//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (192)
//--------------------------------------------------------------------------------
pub const INVALID_CONNECTION_ID = @as(u32, 0);
pub const INVALID_TASK_ID = @as(u32, 0);
pub const MAX_CONNECTION_NAME = @as(u32, 260);
pub const MAIN_CLR_MODULE_NAME_W = "coreclr";
pub const MAIN_CLR_MODULE_NAME_A = "coreclr";
pub const MSCOREE_SHIM_W = "mscoree.dll";
pub const MSCOREE_SHIM_A = "mscoree.dll";
pub const COR_NATIVE_LINK_CUSTOM_VALUE = "COMPLUS_NativeLink";
pub const COR_NATIVE_LINK_CUSTOM_VALUE_ANSI = "COMPLUS_NativeLink";
pub const COR_NATIVE_LINK_CUSTOM_VALUE_CC = @as(u32, 18);
pub const COR_BASE_SECURITY_ATTRIBUTE_CLASS = "System.Security.Permissions.SecurityAttribute";
pub const COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI = "System.Security.Permissions.SecurityAttribute";
pub const COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE = "System.Security.SuppressUnmanagedCodeSecurityAttribute";
pub const COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI = "System.Security.SuppressUnmanagedCodeSecurityAttribute";
pub const COR_UNVER_CODE_ATTRIBUTE = "System.Security.UnverifiableCodeAttribute";
pub const COR_UNVER_CODE_ATTRIBUTE_ANSI = "System.Security.UnverifiableCodeAttribute";
pub const COR_REQUIRES_SECOBJ_ATTRIBUTE = "System.Security.DynamicSecurityMethodAttribute";
pub const COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI = "System.Security.DynamicSecurityMethodAttribute";
pub const COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE = "System.Runtime.CompilerServices.DiscardableAttribute";
pub const COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI = "System.Runtime.CompilerServices.DiscardableAttribute";
pub const COR_E_UNAUTHORIZEDACCESS = @as(i32, -2147024891);
pub const COR_E_ARGUMENT = @as(i32, -2147024809);
pub const COR_E_INVALIDCAST = @as(i32, -2147467262);
pub const COR_E_OUTOFMEMORY = @as(i32, -2147024882);
pub const COR_E_NULLREFERENCE = @as(i32, -2147467261);
pub const COR_E_AMBIGUOUSMATCH = @import("../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147475171));
pub const COR_E_TARGETPARAMCOUNT = @import("../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147352562));
pub const COR_E_DIVIDEBYZERO = @import("../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147352558));
pub const COR_E_BADIMAGEFORMAT = @import("../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147024885));
pub const FRAMEWORK_REGISTRY_KEY = "Software\\Microsoft\\.NETFramework";
pub const FRAMEWORK_REGISTRY_KEY_W = "Software\\Microsoft\\.NETFramework";
pub const USER_FRAMEWORK_REGISTRY_KEY = "Software\\Microsoft\\.NETFramework64";
pub const USER_FRAMEWORK_REGISTRY_KEY_W = "Software\\Microsoft\\.NETFramework64";
pub const COR_CTOR_METHOD_NAME = ".ctor";
pub const COR_CTOR_METHOD_NAME_W = ".ctor";
pub const COR_CCTOR_METHOD_NAME = ".cctor";
pub const COR_CCTOR_METHOD_NAME_W = ".cctor";
pub const COR_ENUM_FIELD_NAME = "value__";
pub const COR_ENUM_FIELD_NAME_W = "value__";
pub const COR_DELETED_NAME_A = "_Deleted";
pub const COR_DELETED_NAME_W = "_Deleted";
pub const COR_VTABLEGAP_NAME_A = "_VtblGap";
pub const COR_VTABLEGAP_NAME_W = "_VtblGap";
pub const INTEROP_DISPID_TYPE_W = "System.Runtime.InteropServices.DispIdAttribute";
pub const INTEROP_DISPID_TYPE = "System.Runtime.InteropServices.DispIdAttribute";
pub const INTEROP_INTERFACETYPE_TYPE_W = "System.Runtime.InteropServices.InterfaceTypeAttribute";
pub const INTEROP_INTERFACETYPE_TYPE = "System.Runtime.InteropServices.InterfaceTypeAttribute";
pub const INTEROP_CLASSINTERFACE_TYPE_W = "System.Runtime.InteropServices.ClassInterfaceAttribute";
pub const INTEROP_CLASSINTERFACE_TYPE = "System.Runtime.InteropServices.ClassInterfaceAttribute";
pub const INTEROP_COMVISIBLE_TYPE_W = "System.Runtime.InteropServices.ComVisibleAttribute";
pub const INTEROP_COMVISIBLE_TYPE = "System.Runtime.InteropServices.ComVisibleAttribute";
pub const INTEROP_COMREGISTERFUNCTION_TYPE_W = "System.Runtime.InteropServices.ComRegisterFunctionAttribute";
pub const INTEROP_COMREGISTERFUNCTION_TYPE = "System.Runtime.InteropServices.ComRegisterFunctionAttribute";
pub const INTEROP_COMUNREGISTERFUNCTION_TYPE_W = "System.Runtime.InteropServices.ComUnregisterFunctionAttribute";
pub const INTEROP_COMUNREGISTERFUNCTION_TYPE = "System.Runtime.InteropServices.ComUnregisterFunctionAttribute";
pub const INTEROP_IMPORTEDFROMTYPELIB_TYPE_W = "System.Runtime.InteropServices.ImportedFromTypeLibAttribute";
pub const INTEROP_IMPORTEDFROMTYPELIB_TYPE = "System.Runtime.InteropServices.ImportedFromTypeLibAttribute";
pub const INTEROP_PRIMARYINTEROPASSEMBLY_TYPE_W = "System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute";
pub const INTEROP_PRIMARYINTEROPASSEMBLY_TYPE = "System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute";
pub const INTEROP_IDISPATCHIMPL_TYPE_W = "System.Runtime.InteropServices.IDispatchImplAttribute";
pub const INTEROP_IDISPATCHIMPL_TYPE = "System.Runtime.InteropServices.IDispatchImplAttribute";
pub const INTEROP_COMSOURCEINTERFACES_TYPE_W = "System.Runtime.InteropServices.ComSourceInterfacesAttribute";
pub const INTEROP_COMSOURCEINTERFACES_TYPE = "System.Runtime.InteropServices.ComSourceInterfacesAttribute";
pub const INTEROP_COMDEFAULTINTERFACE_TYPE_W = "System.Runtime.InteropServices.ComDefaultInterfaceAttribute";
pub const INTEROP_COMDEFAULTINTERFACE_TYPE = "System.Runtime.InteropServices.ComDefaultInterfaceAttribute";
pub const INTEROP_COMCONVERSIONLOSS_TYPE_W = "System.Runtime.InteropServices.ComConversionLossAttribute";
pub const INTEROP_COMCONVERSIONLOSS_TYPE = "System.Runtime.InteropServices.ComConversionLossAttribute";
pub const INTEROP_BESTFITMAPPING_TYPE_W = "System.Runtime.InteropServices.BestFitMappingAttribute";
pub const INTEROP_BESTFITMAPPING_TYPE = "System.Runtime.InteropServices.BestFitMappingAttribute";
pub const INTEROP_TYPELIBTYPE_TYPE_W = "System.Runtime.InteropServices.TypeLibTypeAttribute";
pub const INTEROP_TYPELIBTYPE_TYPE = "System.Runtime.InteropServices.TypeLibTypeAttribute";
pub const INTEROP_TYPELIBFUNC_TYPE_W = "System.Runtime.InteropServices.TypeLibFuncAttribute";
pub const INTEROP_TYPELIBFUNC_TYPE = "System.Runtime.InteropServices.TypeLibFuncAttribute";
pub const INTEROP_TYPELIBVAR_TYPE_W = "System.Runtime.InteropServices.TypeLibVarAttribute";
pub const INTEROP_TYPELIBVAR_TYPE = "System.Runtime.InteropServices.TypeLibVarAttribute";
pub const INTEROP_MARSHALAS_TYPE_W = "System.Runtime.InteropServices.MarshalAsAttribute";
pub const INTEROP_MARSHALAS_TYPE = "System.Runtime.InteropServices.MarshalAsAttribute";
pub const INTEROP_COMIMPORT_TYPE_W = "System.Runtime.InteropServices.ComImportAttribute";
pub const INTEROP_COMIMPORT_TYPE = "System.Runtime.InteropServices.ComImportAttribute";
pub const INTEROP_GUID_TYPE_W = "System.Runtime.InteropServices.GuidAttribute";
pub const INTEROP_GUID_TYPE = "System.Runtime.InteropServices.GuidAttribute";
pub const INTEROP_DEFAULTMEMBER_TYPE_W = "System.Reflection.DefaultMemberAttribute";
pub const INTEROP_DEFAULTMEMBER_TYPE = "System.Reflection.DefaultMemberAttribute";
pub const INTEROP_COMEMULATE_TYPE_W = "System.Runtime.InteropServices.ComEmulateAttribute";
pub const INTEROP_COMEMULATE_TYPE = "System.Runtime.InteropServices.ComEmulateAttribute";
pub const INTEROP_PRESERVESIG_TYPE_W = "System.Runtime.InteropServices.PreserveSigAttribure";
pub const INTEROP_PRESERVESIG_TYPE = "System.Runtime.InteropServices.PreserveSigAttribure";
pub const INTEROP_IN_TYPE_W = "System.Runtime.InteropServices.InAttribute";
pub const INTEROP_IN_TYPE = "System.Runtime.InteropServices.InAttribute";
pub const INTEROP_OUT_TYPE_W = "System.Runtime.InteropServices.OutAttribute";
pub const INTEROP_OUT_TYPE = "System.Runtime.InteropServices.OutAttribute";
pub const INTEROP_COMALIASNAME_TYPE_W = "System.Runtime.InteropServices.ComAliasNameAttribute";
pub const INTEROP_COMALIASNAME_TYPE = "System.Runtime.InteropServices.ComAliasNameAttribute";
pub const INTEROP_PARAMARRAY_TYPE_W = "System.ParamArrayAttribute";
pub const INTEROP_PARAMARRAY_TYPE = "System.ParamArrayAttribute";
pub const INTEROP_LCIDCONVERSION_TYPE_W = "System.Runtime.InteropServices.LCIDConversionAttribute";
pub const INTEROP_LCIDCONVERSION_TYPE = "System.Runtime.InteropServices.LCIDConversionAttribute";
pub const INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE_W = "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute";
pub const INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE = "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute";
pub const INTEROP_DECIMALVALUE_TYPE_W = "System.Runtime.CompilerServices.DecimalConstantAttribute";
pub const INTEROP_DECIMALVALUE_TYPE = "System.Runtime.CompilerServices.DecimalConstantAttribute";
pub const INTEROP_DATETIMEVALUE_TYPE_W = "System.Runtime.CompilerServices.DateTimeConstantAttribute";
pub const INTEROP_DATETIMEVALUE_TYPE = "System.Runtime.CompilerServices.DateTimeConstantAttribute";
pub const INTEROP_IUNKNOWNVALUE_TYPE_W = "System.Runtime.CompilerServices.IUnknownConstantAttribute";
pub const INTEROP_IUNKNOWNVALUE_TYPE = "System.Runtime.CompilerServices.IUnknownConstantAttribute";
pub const INTEROP_IDISPATCHVALUE_TYPE_W = "System.Runtime.CompilerServices.IDispatchConstantAttribute";
pub const INTEROP_IDISPATCHVALUE_TYPE = "System.Runtime.CompilerServices.IDispatchConstantAttribute";
pub const INTEROP_AUTOPROXY_TYPE_W = "System.Runtime.InteropServices.AutomationProxyAttribute";
pub const INTEROP_AUTOPROXY_TYPE = "System.Runtime.InteropServices.AutomationProxyAttribute";
pub const INTEROP_TYPELIBIMPORTCLASS_TYPE_W = "System.Runtime.InteropServices.TypeLibImportClassAttribute";
pub const INTEROP_TYPELIBIMPORTCLASS_TYPE = "System.Runtime.InteropServices.TypeLibImportClassAttribute";
pub const INTEROP_TYPELIBVERSION_TYPE_W = "System.Runtime.InteropServices.TypeLibVersionAttribute";
pub const INTEROP_TYPELIBVERSION_TYPE = "System.Runtime.InteropServices.TypeLibVersionAttribute";
pub const INTEROP_COMCOMPATIBLEVERSION_TYPE_W = "System.Runtime.InteropServices.ComCompatibleVersionAttribute";
pub const INTEROP_COMCOMPATIBLEVERSION_TYPE = "System.Runtime.InteropServices.ComCompatibleVersionAttribute";
pub const INTEROP_COMEVENTINTERFACE_TYPE_W = "System.Runtime.InteropServices.ComEventInterfaceAttribute";
pub const INTEROP_COMEVENTINTERFACE_TYPE = "System.Runtime.InteropServices.ComEventInterfaceAttribute";
pub const INTEROP_COCLASS_TYPE_W = "System.Runtime.InteropServices.CoClassAttribute";
pub const INTEROP_COCLASS_TYPE = "System.Runtime.InteropServices.CoClassAttribute";
pub const INTEROP_SERIALIZABLE_TYPE_W = "System.SerializableAttribute";
pub const INTEROP_SERIALIZABLE_TYPE = "System.SerializableAttribute";
pub const INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE_W = "System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute";
pub const INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE = "System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute";
pub const FORWARD_INTEROP_STUB_METHOD_TYPE_W = "System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute";
pub const FORWARD_INTEROP_STUB_METHOD_TYPE = "System.Runtime.InteropServices.ManagedToNativeComInteropStubAttribute";
pub const FRIEND_ASSEMBLY_TYPE_W = "System.Runtime.CompilerServices.InternalsVisibleToAttribute";
pub const FRIEND_ASSEMBLY_TYPE = "System.Runtime.CompilerServices.InternalsVisibleToAttribute";
pub const FRIEND_ACCESS_ALLOWED_ATTRIBUTE_TYPE_W = "System.Runtime.CompilerServices.FriendAccessAllowedAttribute";
pub const FRIEND_ACCESS_ALLOWED_ATTRIBUTE_TYPE = "System.Runtime.CompilerServices.FriendAccessAllowedAttribute";
pub const SUBJECT_ASSEMBLY_TYPE_W = "System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute";
pub const SUBJECT_ASSEMBLY_TYPE = "System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute";
pub const DISABLED_PRIVATE_REFLECTION_TYPE_W = "System.Runtime.CompilerServices.DisablePrivateReflectionAttribute";
pub const DISABLED_PRIVATE_REFLECTION_TYPE = "System.Runtime.CompilerServices.DisablePrivateReflectionAttribute";
pub const DEFAULTDOMAIN_STA_TYPE_W = "System.STAThreadAttribute";
pub const DEFAULTDOMAIN_STA_TYPE = "System.STAThreadAttribute";
pub const DEFAULTDOMAIN_MTA_TYPE_W = "System.MTAThreadAttribute";
pub const DEFAULTDOMAIN_MTA_TYPE = "System.MTAThreadAttribute";
pub const DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W = "System.LoaderOptimizationAttribute";
pub const DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE = "System.LoaderOptimizationAttribute";
pub const NONVERSIONABLE_TYPE_W = "System.Runtime.Versioning.NonVersionableAttribute";
pub const NONVERSIONABLE_TYPE = "System.Runtime.Versioning.NonVersionableAttribute";
pub const COMPILATIONRELAXATIONS_TYPE_W = "System.Runtime.CompilerServices.CompilationRelaxationsAttribute";
pub const COMPILATIONRELAXATIONS_TYPE = "System.Runtime.CompilerServices.CompilationRelaxationsAttribute";
pub const RUNTIMECOMPATIBILITY_TYPE_W = "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute";
pub const RUNTIMECOMPATIBILITY_TYPE = "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute";
pub const DEFAULTDEPENDENCY_TYPE_W = "System.Runtime.CompilerServices.DefaultDependencyAttribute";
pub const DEFAULTDEPENDENCY_TYPE = "System.Runtime.CompilerServices.DefaultDependencyAttribute";
pub const DEPENDENCY_TYPE_W = "System.Runtime.CompilerServices.DependencyAttribute";
pub const DEPENDENCY_TYPE = "System.Runtime.CompilerServices.DependencyAttribute";
pub const TARGET_FRAMEWORK_TYPE_W = "System.Runtime.Versioning.TargetFrameworkAttribute";
pub const TARGET_FRAMEWORK_TYPE = "System.Runtime.Versioning.TargetFrameworkAttribute";
pub const ASSEMBLY_METADATA_TYPE_W = "System.Reflection.AssemblyMetadataAttribute";
pub const ASSEMBLY_METADATA_TYPE = "System.Reflection.AssemblyMetadataAttribute";
pub const CMOD_CALLCONV_NAMESPACE_OLD = "System.Runtime.InteropServices";
pub const CMOD_CALLCONV_NAMESPACE = "System.Runtime.CompilerServices";
pub const CMOD_CALLCONV_NAME_CDECL = "CallConvCdecl";
pub const CMOD_CALLCONV_NAME_STDCALL = "CallConvStdcall";
pub const CMOD_CALLCONV_NAME_THISCALL = "CallConvThiscall";
pub const CMOD_CALLCONV_NAME_FASTCALL = "CallConvFastcall";
pub const LIBID_ComPlusRuntime = Guid.initString("bed7f4ea-1a96-11d2-8f08-00a0c9a6186d");
pub const GUID_ExportedFromComPlus = Guid.initString("90883f05-3d28-11d2-8f17-00a0c9a6186d");
pub const GUID_ManagedName = Guid.initString("0f21f359-ab84-41e8-9a78-36d110e6d2f9");
pub const GUID_Function2Getter = Guid.initString("54fc8f55-38de-4703-9c4e-250351302b1c");
pub const CLSID_CorMetaDataDispenserRuntime = Guid.initString("1ec2de53-75cc-11d2-9775-00a0c9b4d50c");
pub const GUID_DispIdOverride = Guid.initString("cd2bc5c9-f452-4326-b714-f9c539d4da58");
pub const GUID_ForceIEnumerable = Guid.initString("b64784eb-d8d4-4d9b-9acd-0e30806426f7");
pub const GUID_PropGetCA = Guid.initString("2941ff83-88d8-4f73-b6a9-bdf8712d000d");
pub const GUID_PropPutCA = Guid.initString("29533527-3683-4364-abc0-db1add822fa2");
pub const CLSID_CLR_v1_MetaData = Guid.initString("005023ca-72b1-11d3-9fc4-00c04f79a0a3");
pub const CLSID_CLR_v2_MetaData = Guid.initString("efea471a-44fd-4862-9292-0c58d46e1f3a");
pub const MetaDataCheckDuplicatesFor = Guid.initString("30fe7be8-d7d9-11d2-9f80-00c04f79a0a3");
pub const MetaDataRefToDefCheck = Guid.initString("de3856f8-d7d9-11d2-9f80-00c04f79a0a3");
pub const MetaDataNotificationForTokenMovement = Guid.initString("e5d71a4c-d7da-11d2-9f80-00c04f79a0a3");
pub const MetaDataSetUpdate = Guid.initString("2eee315c-d7db-11d2-9f80-00c04f79a0a3");
pub const MetaDataImportOption = Guid.initString("79700f36-4aac-11d3-84c3-009027868cb1");
pub const MetaDataThreadSafetyOptions = Guid.initString("f7559806-f266-42ea-8c63-0adb45e8b234");
pub const MetaDataErrorIfEmitOutOfOrder = Guid.initString("1547872d-dc03-11d2-9420-0000f8083460");
pub const MetaDataGenerateTCEAdapters = Guid.initString("dcc9de90-4151-11d3-88d6-00902754c43a");
pub const MetaDataTypeLibImportNamespace = Guid.initString("f17ff889-5a63-11d3-9ff2-00c04ff7431a");
pub const MetaDataLinkerOptions = Guid.initString("47e099b6-ae7c-4797-8317-b48aa645b8f9");
pub const MetaDataRuntimeVersion = Guid.initString("47e099b7-ae7c-4797-8317-b48aa645b8f9");
pub const MetaDataMergerOptions = Guid.initString("132d3a6e-b35d-464e-951a-42efb9fb6601");
pub const MetaDataPreserveLocalRefs = Guid.initString("a55c0354-e91b-468b-8648-7cc31035d533");
pub const DESCR_GROUP_METHODDEF = @as(i32, 0);
pub const DESCR_GROUP_METHODIMPL = @as(i32, 1);
pub const CLSID_Cor = Guid.initString("bee00010-ee77-11d0-a015-00c04fbbb884");
pub const CLSID_CorMetaDataDispenser = Guid.initString("e5cb7a31-7512-11d2-89ce-0080c792e5d8");
pub const CLSID_CorMetaDataDispenserReg = Guid.initString("435755ff-7397-11d2-9771-00a0c9b4d50c");
pub const CLSID_CorMetaDataReg = Guid.initString("87f3a1f5-7397-11d2-9771-00a0c9b4d50c");
pub const SIGN_MASK_ONEBYTE = @as(i32, -64);
pub const SIGN_MASK_TWOBYTE = @as(i32, -8192);
pub const SIGN_MASK_FOURBYTE = @as(i32, -268435456);

//--------------------------------------------------------------------------------
// Section: Types (92)
//--------------------------------------------------------------------------------

pub const COINITICOR = enum(i32) {
    T = 0,
};
pub const COINITCOR_DEFAULT = COINITICOR.T;

pub const COINITIEE = enum(i32) {
    DEFAULT = 0,
    DLL = 1,
    MAIN = 2,
};
pub const COINITEE_DEFAULT = COINITIEE.DEFAULT;
pub const COINITEE_DLL = COINITIEE.DLL;
pub const COINITEE_MAIN = COINITIEE.MAIN;

pub const COUNINITIEE = enum(i32) {
    EFAULT = 0,
    LL = 1,
};
pub const COUNINITEE_DEFAULT = COUNINITIEE.EFAULT;
pub const COUNINITEE_DLL = COUNINITIEE.LL;

pub const ReplacesGeneralNumericDefines = enum(i32) {
    R = 14,
};
pub const IMAGE_DIRECTORY_ENTRY_COMHEADER = ReplacesGeneralNumericDefines.R;

pub const CorTypeAttr = enum(i32) {
    VisibilityMask = 7,
    NotPublic = 0,
    Public = 1,
    NestedPublic = 2,
    NestedPrivate = 3,
    NestedFamily = 4,
    NestedAssembly = 5,
    NestedFamANDAssem = 6,
    // NestedFamORAssem = 7, this enum value conflicts with VisibilityMask
    LayoutMask = 24,
    // AutoLayout = 0, this enum value conflicts with NotPublic
    SequentialLayout = 8,
    ExplicitLayout = 16,
    ClassSemanticsMask = 32,
    // Class = 0, this enum value conflicts with NotPublic
    // Interface = 32, this enum value conflicts with ClassSemanticsMask
    Abstract = 128,
    Sealed = 256,
    SpecialName = 1024,
    Import = 4096,
    Serializable = 8192,
    WindowsRuntime = 16384,
    StringFormatMask = 196608,
    // AnsiClass = 0, this enum value conflicts with NotPublic
    UnicodeClass = 65536,
    AutoClass = 131072,
    // CustomFormatClass = 196608, this enum value conflicts with StringFormatMask
    CustomFormatMask = 12582912,
    BeforeFieldInit = 1048576,
    Forwarder = 2097152,
    ReservedMask = 264192,
    RTSpecialName = 2048,
    HasSecurity = 262144,
};
pub const tdVisibilityMask = CorTypeAttr.VisibilityMask;
pub const tdNotPublic = CorTypeAttr.NotPublic;
pub const tdPublic = CorTypeAttr.Public;
pub const tdNestedPublic = CorTypeAttr.NestedPublic;
pub const tdNestedPrivate = CorTypeAttr.NestedPrivate;
pub const tdNestedFamily = CorTypeAttr.NestedFamily;
pub const tdNestedAssembly = CorTypeAttr.NestedAssembly;
pub const tdNestedFamANDAssem = CorTypeAttr.NestedFamANDAssem;
pub const tdNestedFamORAssem = CorTypeAttr.VisibilityMask;
pub const tdLayoutMask = CorTypeAttr.LayoutMask;
pub const tdAutoLayout = CorTypeAttr.NotPublic;
pub const tdSequentialLayout = CorTypeAttr.SequentialLayout;
pub const tdExplicitLayout = CorTypeAttr.ExplicitLayout;
pub const tdClassSemanticsMask = CorTypeAttr.ClassSemanticsMask;
pub const tdClass = CorTypeAttr.NotPublic;
pub const tdInterface = CorTypeAttr.ClassSemanticsMask;
pub const tdAbstract = CorTypeAttr.Abstract;
pub const tdSealed = CorTypeAttr.Sealed;
pub const tdSpecialName = CorTypeAttr.SpecialName;
pub const tdImport = CorTypeAttr.Import;
pub const tdSerializable = CorTypeAttr.Serializable;
pub const tdWindowsRuntime = CorTypeAttr.WindowsRuntime;
pub const tdStringFormatMask = CorTypeAttr.StringFormatMask;
pub const tdAnsiClass = CorTypeAttr.NotPublic;
pub const tdUnicodeClass = CorTypeAttr.UnicodeClass;
pub const tdAutoClass = CorTypeAttr.AutoClass;
pub const tdCustomFormatClass = CorTypeAttr.StringFormatMask;
pub const tdCustomFormatMask = CorTypeAttr.CustomFormatMask;
pub const tdBeforeFieldInit = CorTypeAttr.BeforeFieldInit;
pub const tdForwarder = CorTypeAttr.Forwarder;
pub const tdReservedMask = CorTypeAttr.ReservedMask;
pub const tdRTSpecialName = CorTypeAttr.RTSpecialName;
pub const tdHasSecurity = CorTypeAttr.HasSecurity;

pub const CorMethodAttr = enum(i32) {
    MemberAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assem = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    Final = 32,
    Virtual = 64,
    HideBySig = 128,
    VtableLayoutMask = 256,
    // ReuseSlot = 0, this enum value conflicts with PrivateScope
    // NewSlot = 256, this enum value conflicts with VtableLayoutMask
    CheckAccessOnOverride = 512,
    Abstract = 1024,
    SpecialName = 2048,
    PinvokeImpl = 8192,
    UnmanagedExport = 8,
    ReservedMask = 53248,
    RTSpecialName = 4096,
    HasSecurity = 16384,
    RequireSecObject = 32768,
};
pub const mdMemberAccessMask = CorMethodAttr.MemberAccessMask;
pub const mdPrivateScope = CorMethodAttr.PrivateScope;
pub const mdPrivate = CorMethodAttr.Private;
pub const mdFamANDAssem = CorMethodAttr.FamANDAssem;
pub const mdAssem = CorMethodAttr.Assem;
pub const mdFamily = CorMethodAttr.Family;
pub const mdFamORAssem = CorMethodAttr.FamORAssem;
pub const mdPublic = CorMethodAttr.Public;
pub const mdStatic = CorMethodAttr.Static;
pub const mdFinal = CorMethodAttr.Final;
pub const mdVirtual = CorMethodAttr.Virtual;
pub const mdHideBySig = CorMethodAttr.HideBySig;
pub const mdVtableLayoutMask = CorMethodAttr.VtableLayoutMask;
pub const mdReuseSlot = CorMethodAttr.PrivateScope;
pub const mdNewSlot = CorMethodAttr.VtableLayoutMask;
pub const mdCheckAccessOnOverride = CorMethodAttr.CheckAccessOnOverride;
pub const mdAbstract = CorMethodAttr.Abstract;
pub const mdSpecialName = CorMethodAttr.SpecialName;
pub const mdPinvokeImpl = CorMethodAttr.PinvokeImpl;
pub const mdUnmanagedExport = CorMethodAttr.UnmanagedExport;
pub const mdReservedMask = CorMethodAttr.ReservedMask;
pub const mdRTSpecialName = CorMethodAttr.RTSpecialName;
pub const mdHasSecurity = CorMethodAttr.HasSecurity;
pub const mdRequireSecObject = CorMethodAttr.RequireSecObject;

pub const CorFieldAttr = enum(i32) {
    FieldAccessMask = 7,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    Static = 16,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    SpecialName = 512,
    PinvokeImpl = 8192,
    ReservedMask = 38144,
    RTSpecialName = 1024,
    HasFieldMarshal = 4096,
    HasDefault = 32768,
    HasFieldRVA = 256,
};
pub const fdFieldAccessMask = CorFieldAttr.FieldAccessMask;
pub const fdPrivateScope = CorFieldAttr.PrivateScope;
pub const fdPrivate = CorFieldAttr.Private;
pub const fdFamANDAssem = CorFieldAttr.FamANDAssem;
pub const fdAssembly = CorFieldAttr.Assembly;
pub const fdFamily = CorFieldAttr.Family;
pub const fdFamORAssem = CorFieldAttr.FamORAssem;
pub const fdPublic = CorFieldAttr.Public;
pub const fdStatic = CorFieldAttr.Static;
pub const fdInitOnly = CorFieldAttr.InitOnly;
pub const fdLiteral = CorFieldAttr.Literal;
pub const fdNotSerialized = CorFieldAttr.NotSerialized;
pub const fdSpecialName = CorFieldAttr.SpecialName;
pub const fdPinvokeImpl = CorFieldAttr.PinvokeImpl;
pub const fdReservedMask = CorFieldAttr.ReservedMask;
pub const fdRTSpecialName = CorFieldAttr.RTSpecialName;
pub const fdHasFieldMarshal = CorFieldAttr.HasFieldMarshal;
pub const fdHasDefault = CorFieldAttr.HasDefault;
pub const fdHasFieldRVA = CorFieldAttr.HasFieldRVA;

pub const CorParamAttr = enum(i32) {
    In = 1,
    Out = 2,
    Optional = 16,
    ReservedMask = 61440,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Unused = 53216,
};
pub const pdIn = CorParamAttr.In;
pub const pdOut = CorParamAttr.Out;
pub const pdOptional = CorParamAttr.Optional;
pub const pdReservedMask = CorParamAttr.ReservedMask;
pub const pdHasDefault = CorParamAttr.HasDefault;
pub const pdHasFieldMarshal = CorParamAttr.HasFieldMarshal;
pub const pdUnused = CorParamAttr.Unused;

pub const CorPropertyAttr = enum(i32) {
    SpecialName = 512,
    ReservedMask = 62464,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Unused = 59903,
};
pub const prSpecialName = CorPropertyAttr.SpecialName;
pub const prReservedMask = CorPropertyAttr.ReservedMask;
pub const prRTSpecialName = CorPropertyAttr.RTSpecialName;
pub const prHasDefault = CorPropertyAttr.HasDefault;
pub const prUnused = CorPropertyAttr.Unused;

pub const CorEventAttr = enum(i32) {
    SpecialName = 512,
    ReservedMask = 1024,
    // RTSpecialName = 1024, this enum value conflicts with ReservedMask
};
pub const evSpecialName = CorEventAttr.SpecialName;
pub const evReservedMask = CorEventAttr.ReservedMask;
pub const evRTSpecialName = CorEventAttr.ReservedMask;

pub const CorMethodSemanticsAttr = enum(i32) {
    Setter = 1,
    Getter = 2,
    Other = 4,
    AddOn = 8,
    RemoveOn = 16,
    Fire = 32,
};
pub const msSetter = CorMethodSemanticsAttr.Setter;
pub const msGetter = CorMethodSemanticsAttr.Getter;
pub const msOther = CorMethodSemanticsAttr.Other;
pub const msAddOn = CorMethodSemanticsAttr.AddOn;
pub const msRemoveOn = CorMethodSemanticsAttr.RemoveOn;
pub const msFire = CorMethodSemanticsAttr.Fire;

pub const CorDeclSecurity = enum(i32) {
    ActionMask = 31,
    ActionNil = 0,
    Request = 1,
    Demand = 2,
    Assert = 3,
    Deny = 4,
    PermitOnly = 5,
    LinktimeCheck = 6,
    InheritanceCheck = 7,
    RequestMinimum = 8,
    RequestOptional = 9,
    RequestRefuse = 10,
    PrejitGrant = 11,
    PrejitDenied = 12,
    NonCasDemand = 13,
    NonCasLinkDemand = 14,
    NonCasInheritance = 15,
    // MaximumValue = 15, this enum value conflicts with NonCasInheritance
};
pub const dclActionMask = CorDeclSecurity.ActionMask;
pub const dclActionNil = CorDeclSecurity.ActionNil;
pub const dclRequest = CorDeclSecurity.Request;
pub const dclDemand = CorDeclSecurity.Demand;
pub const dclAssert = CorDeclSecurity.Assert;
pub const dclDeny = CorDeclSecurity.Deny;
pub const dclPermitOnly = CorDeclSecurity.PermitOnly;
pub const dclLinktimeCheck = CorDeclSecurity.LinktimeCheck;
pub const dclInheritanceCheck = CorDeclSecurity.InheritanceCheck;
pub const dclRequestMinimum = CorDeclSecurity.RequestMinimum;
pub const dclRequestOptional = CorDeclSecurity.RequestOptional;
pub const dclRequestRefuse = CorDeclSecurity.RequestRefuse;
pub const dclPrejitGrant = CorDeclSecurity.PrejitGrant;
pub const dclPrejitDenied = CorDeclSecurity.PrejitDenied;
pub const dclNonCasDemand = CorDeclSecurity.NonCasDemand;
pub const dclNonCasLinkDemand = CorDeclSecurity.NonCasLinkDemand;
pub const dclNonCasInheritance = CorDeclSecurity.NonCasInheritance;
pub const dclMaximumValue = CorDeclSecurity.NonCasInheritance;

pub const CorMethodImpl = enum(i32) {
    CodeTypeMask = 3,
    IL = 0,
    Native = 1,
    OPTIL = 2,
    // Runtime = 3, this enum value conflicts with CodeTypeMask
    ManagedMask = 4,
    // Unmanaged = 4, this enum value conflicts with ManagedMask
    // Managed = 0, this enum value conflicts with IL
    ForwardRef = 16,
    PreserveSig = 128,
    InternalCall = 4096,
    Synchronized = 32,
    NoInlining = 8,
    AggressiveInlining = 256,
    NoOptimization = 64,
    SecurityMitigations = 1024,
    UserMask = 5628,
    MaxMethodImplVal = 65535,
};
pub const miCodeTypeMask = CorMethodImpl.CodeTypeMask;
pub const miIL = CorMethodImpl.IL;
pub const miNative = CorMethodImpl.Native;
pub const miOPTIL = CorMethodImpl.OPTIL;
pub const miRuntime = CorMethodImpl.CodeTypeMask;
pub const miManagedMask = CorMethodImpl.ManagedMask;
pub const miUnmanaged = CorMethodImpl.ManagedMask;
pub const miManaged = CorMethodImpl.IL;
pub const miForwardRef = CorMethodImpl.ForwardRef;
pub const miPreserveSig = CorMethodImpl.PreserveSig;
pub const miInternalCall = CorMethodImpl.InternalCall;
pub const miSynchronized = CorMethodImpl.Synchronized;
pub const miNoInlining = CorMethodImpl.NoInlining;
pub const miAggressiveInlining = CorMethodImpl.AggressiveInlining;
pub const miNoOptimization = CorMethodImpl.NoOptimization;
pub const miSecurityMitigations = CorMethodImpl.SecurityMitigations;
pub const miUserMask = CorMethodImpl.UserMask;
pub const miMaxMethodImplVal = CorMethodImpl.MaxMethodImplVal;

pub const CorPinvokeMap = enum(i32) {
    NoMangle = 1,
    CharSetMask = 6,
    CharSetNotSpec = 0,
    CharSetAnsi = 2,
    CharSetUnicode = 4,
    // CharSetAuto = 6, this enum value conflicts with CharSetMask
    // BestFitUseAssem = 0, this enum value conflicts with CharSetNotSpec
    BestFitEnabled = 16,
    BestFitDisabled = 32,
    BestFitMask = 48,
    // ThrowOnUnmappableCharUseAssem = 0, this enum value conflicts with CharSetNotSpec
    ThrowOnUnmappableCharEnabled = 4096,
    ThrowOnUnmappableCharDisabled = 8192,
    ThrowOnUnmappableCharMask = 12288,
    SupportsLastError = 64,
    CallConvMask = 1792,
    CallConvWinapi = 256,
    CallConvCdecl = 512,
    CallConvStdcall = 768,
    CallConvThiscall = 1024,
    CallConvFastcall = 1280,
    MaxValue = 65535,
};
pub const pmNoMangle = CorPinvokeMap.NoMangle;
pub const pmCharSetMask = CorPinvokeMap.CharSetMask;
pub const pmCharSetNotSpec = CorPinvokeMap.CharSetNotSpec;
pub const pmCharSetAnsi = CorPinvokeMap.CharSetAnsi;
pub const pmCharSetUnicode = CorPinvokeMap.CharSetUnicode;
pub const pmCharSetAuto = CorPinvokeMap.CharSetMask;
pub const pmBestFitUseAssem = CorPinvokeMap.CharSetNotSpec;
pub const pmBestFitEnabled = CorPinvokeMap.BestFitEnabled;
pub const pmBestFitDisabled = CorPinvokeMap.BestFitDisabled;
pub const pmBestFitMask = CorPinvokeMap.BestFitMask;
pub const pmThrowOnUnmappableCharUseAssem = CorPinvokeMap.CharSetNotSpec;
pub const pmThrowOnUnmappableCharEnabled = CorPinvokeMap.ThrowOnUnmappableCharEnabled;
pub const pmThrowOnUnmappableCharDisabled = CorPinvokeMap.ThrowOnUnmappableCharDisabled;
pub const pmThrowOnUnmappableCharMask = CorPinvokeMap.ThrowOnUnmappableCharMask;
pub const pmSupportsLastError = CorPinvokeMap.SupportsLastError;
pub const pmCallConvMask = CorPinvokeMap.CallConvMask;
pub const pmCallConvWinapi = CorPinvokeMap.CallConvWinapi;
pub const pmCallConvCdecl = CorPinvokeMap.CallConvCdecl;
pub const pmCallConvStdcall = CorPinvokeMap.CallConvStdcall;
pub const pmCallConvThiscall = CorPinvokeMap.CallConvThiscall;
pub const pmCallConvFastcall = CorPinvokeMap.CallConvFastcall;
pub const pmMaxValue = CorPinvokeMap.MaxValue;

pub const CorAssemblyFlags = enum(i32) {
    PublicKey = 1,
    PA_None = 0,
    PA_MSIL = 16,
    PA_x86 = 32,
    PA_IA64 = 48,
    PA_AMD64 = 64,
    PA_ARM = 80,
    PA_NoPlatform = 112,
    PA_Specified = 128,
    // PA_Mask = 112, this enum value conflicts with PA_NoPlatform
    PA_FullMask = 240,
    PA_Shift = 4,
    EnableJITcompileTracking = 32768,
    DisableJITcompileOptimizer = 16384,
    Retargetable = 256,
    // ContentType_Default = 0, this enum value conflicts with PA_None
    ContentType_WindowsRuntime = 512,
    ContentType_Mask = 3584,
};
pub const afPublicKey = CorAssemblyFlags.PublicKey;
pub const afPA_None = CorAssemblyFlags.PA_None;
pub const afPA_MSIL = CorAssemblyFlags.PA_MSIL;
pub const afPA_x86 = CorAssemblyFlags.PA_x86;
pub const afPA_IA64 = CorAssemblyFlags.PA_IA64;
pub const afPA_AMD64 = CorAssemblyFlags.PA_AMD64;
pub const afPA_ARM = CorAssemblyFlags.PA_ARM;
pub const afPA_NoPlatform = CorAssemblyFlags.PA_NoPlatform;
pub const afPA_Specified = CorAssemblyFlags.PA_Specified;
pub const afPA_Mask = CorAssemblyFlags.PA_NoPlatform;
pub const afPA_FullMask = CorAssemblyFlags.PA_FullMask;
pub const afPA_Shift = CorAssemblyFlags.PA_Shift;
pub const afEnableJITcompileTracking = CorAssemblyFlags.EnableJITcompileTracking;
pub const afDisableJITcompileOptimizer = CorAssemblyFlags.DisableJITcompileOptimizer;
pub const afRetargetable = CorAssemblyFlags.Retargetable;
pub const afContentType_Default = CorAssemblyFlags.PA_None;
pub const afContentType_WindowsRuntime = CorAssemblyFlags.ContentType_WindowsRuntime;
pub const afContentType_Mask = CorAssemblyFlags.ContentType_Mask;

pub const CorManifestResourceFlags = enum(i32) {
    VisibilityMask = 7,
    Public = 1,
    Private = 2,
};
pub const mrVisibilityMask = CorManifestResourceFlags.VisibilityMask;
pub const mrPublic = CorManifestResourceFlags.Public;
pub const mrPrivate = CorManifestResourceFlags.Private;

pub const CorFileFlags = enum(i32) {
    MetaData = 0,
    NoMetaData = 1,
};
pub const ffContainsMetaData = CorFileFlags.MetaData;
pub const ffContainsNoMetaData = CorFileFlags.NoMetaData;

pub const CorPEKind = enum(i32) {
    Not = 0,
    ILonly = 1,
    @"32BitRequired" = 2,
    @"32Plus" = 4,
    @"32Unmanaged" = 8,
    @"32BitPreferred" = 16,
};
pub const peNot = CorPEKind.Not;
pub const peILonly = CorPEKind.ILonly;
pub const pe32BitRequired = CorPEKind.@"32BitRequired";
pub const pe32Plus = CorPEKind.@"32Plus";
pub const pe32Unmanaged = CorPEKind.@"32Unmanaged";
pub const pe32BitPreferred = CorPEKind.@"32BitPreferred";

pub const CorGenericParamAttr = enum(i32) {
    VarianceMask = 3,
    NonVariant = 0,
    Covariant = 1,
    Contravariant = 2,
    SpecialConstraintMask = 28,
    // NoSpecialConstraint = 0, this enum value conflicts with NonVariant
    ReferenceTypeConstraint = 4,
    NotNullableValueTypeConstraint = 8,
    DefaultConstructorConstraint = 16,
};
pub const gpVarianceMask = CorGenericParamAttr.VarianceMask;
pub const gpNonVariant = CorGenericParamAttr.NonVariant;
pub const gpCovariant = CorGenericParamAttr.Covariant;
pub const gpContravariant = CorGenericParamAttr.Contravariant;
pub const gpSpecialConstraintMask = CorGenericParamAttr.SpecialConstraintMask;
pub const gpNoSpecialConstraint = CorGenericParamAttr.NonVariant;
pub const gpReferenceTypeConstraint = CorGenericParamAttr.ReferenceTypeConstraint;
pub const gpNotNullableValueTypeConstraint = CorGenericParamAttr.NotNullableValueTypeConstraint;
pub const gpDefaultConstructorConstraint = CorGenericParamAttr.DefaultConstructorConstraint;

pub const CorElementType = enum(u8) {
    END = 0,
    VOID = 1,
    BOOLEAN = 2,
    CHAR = 3,
    I1 = 4,
    U1 = 5,
    I2 = 6,
    U2 = 7,
    I4 = 8,
    U4 = 9,
    I8 = 10,
    U8 = 11,
    R4 = 12,
    R8 = 13,
    STRING = 14,
    PTR = 15,
    BYREF = 16,
    VALUETYPE = 17,
    CLASS = 18,
    VAR = 19,
    ARRAY = 20,
    GENERICINST = 21,
    TYPEDBYREF = 22,
    I = 24,
    U = 25,
    FNPTR = 27,
    OBJECT = 28,
    SZARRAY = 29,
    MVAR = 30,
    CMOD_REQD = 31,
    CMOD_OPT = 32,
    INTERNAL = 33,
    MAX = 34,
    MODIFIER = 64,
    SENTINEL = 65,
    PINNED = 69,
};
pub const ELEMENT_TYPE_END = CorElementType.END;
pub const ELEMENT_TYPE_VOID = CorElementType.VOID;
pub const ELEMENT_TYPE_BOOLEAN = CorElementType.BOOLEAN;
pub const ELEMENT_TYPE_CHAR = CorElementType.CHAR;
pub const ELEMENT_TYPE_I1 = CorElementType.I1;
pub const ELEMENT_TYPE_U1 = CorElementType.U1;
pub const ELEMENT_TYPE_I2 = CorElementType.I2;
pub const ELEMENT_TYPE_U2 = CorElementType.U2;
pub const ELEMENT_TYPE_I4 = CorElementType.I4;
pub const ELEMENT_TYPE_U4 = CorElementType.U4;
pub const ELEMENT_TYPE_I8 = CorElementType.I8;
pub const ELEMENT_TYPE_U8 = CorElementType.U8;
pub const ELEMENT_TYPE_R4 = CorElementType.R4;
pub const ELEMENT_TYPE_R8 = CorElementType.R8;
pub const ELEMENT_TYPE_STRING = CorElementType.STRING;
pub const ELEMENT_TYPE_PTR = CorElementType.PTR;
pub const ELEMENT_TYPE_BYREF = CorElementType.BYREF;
pub const ELEMENT_TYPE_VALUETYPE = CorElementType.VALUETYPE;
pub const ELEMENT_TYPE_CLASS = CorElementType.CLASS;
pub const ELEMENT_TYPE_VAR = CorElementType.VAR;
pub const ELEMENT_TYPE_ARRAY = CorElementType.ARRAY;
pub const ELEMENT_TYPE_GENERICINST = CorElementType.GENERICINST;
pub const ELEMENT_TYPE_TYPEDBYREF = CorElementType.TYPEDBYREF;
pub const ELEMENT_TYPE_I = CorElementType.I;
pub const ELEMENT_TYPE_U = CorElementType.U;
pub const ELEMENT_TYPE_FNPTR = CorElementType.FNPTR;
pub const ELEMENT_TYPE_OBJECT = CorElementType.OBJECT;
pub const ELEMENT_TYPE_SZARRAY = CorElementType.SZARRAY;
pub const ELEMENT_TYPE_MVAR = CorElementType.MVAR;
pub const ELEMENT_TYPE_CMOD_REQD = CorElementType.CMOD_REQD;
pub const ELEMENT_TYPE_CMOD_OPT = CorElementType.CMOD_OPT;
pub const ELEMENT_TYPE_INTERNAL = CorElementType.INTERNAL;
pub const ELEMENT_TYPE_MAX = CorElementType.MAX;
pub const ELEMENT_TYPE_MODIFIER = CorElementType.MODIFIER;
pub const ELEMENT_TYPE_SENTINEL = CorElementType.SENTINEL;
pub const ELEMENT_TYPE_PINNED = CorElementType.PINNED;

pub const CorSerializationType = enum(i32) {
    UNDEFINED = 0,
    BOOLEAN = 2,
    CHAR = 3,
    I1 = 4,
    U1 = 5,
    I2 = 6,
    U2 = 7,
    I4 = 8,
    U4 = 9,
    I8 = 10,
    U8 = 11,
    R4 = 12,
    R8 = 13,
    STRING = 14,
    SZARRAY = 29,
    TYPE = 80,
    TAGGED_OBJECT = 81,
    FIELD = 83,
    PROPERTY = 84,
    ENUM = 85,
};
pub const SERIALIZATION_TYPE_UNDEFINED = CorSerializationType.UNDEFINED;
pub const SERIALIZATION_TYPE_BOOLEAN = CorSerializationType.BOOLEAN;
pub const SERIALIZATION_TYPE_CHAR = CorSerializationType.CHAR;
pub const SERIALIZATION_TYPE_I1 = CorSerializationType.I1;
pub const SERIALIZATION_TYPE_U1 = CorSerializationType.U1;
pub const SERIALIZATION_TYPE_I2 = CorSerializationType.I2;
pub const SERIALIZATION_TYPE_U2 = CorSerializationType.U2;
pub const SERIALIZATION_TYPE_I4 = CorSerializationType.I4;
pub const SERIALIZATION_TYPE_U4 = CorSerializationType.U4;
pub const SERIALIZATION_TYPE_I8 = CorSerializationType.I8;
pub const SERIALIZATION_TYPE_U8 = CorSerializationType.U8;
pub const SERIALIZATION_TYPE_R4 = CorSerializationType.R4;
pub const SERIALIZATION_TYPE_R8 = CorSerializationType.R8;
pub const SERIALIZATION_TYPE_STRING = CorSerializationType.STRING;
pub const SERIALIZATION_TYPE_SZARRAY = CorSerializationType.SZARRAY;
pub const SERIALIZATION_TYPE_TYPE = CorSerializationType.TYPE;
pub const SERIALIZATION_TYPE_TAGGED_OBJECT = CorSerializationType.TAGGED_OBJECT;
pub const SERIALIZATION_TYPE_FIELD = CorSerializationType.FIELD;
pub const SERIALIZATION_TYPE_PROPERTY = CorSerializationType.PROPERTY;
pub const SERIALIZATION_TYPE_ENUM = CorSerializationType.ENUM;

pub const CorCallingConvention = enum(i32) {
    DEFAULT = 0,
    VARARG = 5,
    FIELD = 6,
    LOCAL_SIG = 7,
    PROPERTY = 8,
    UNMGD = 9,
    GENERICINST = 10,
    NATIVEVARARG = 11,
    MAX = 12,
    MASK = 15,
    HASTHIS = 32,
    EXPLICITTHIS = 64,
    GENERIC = 16,
};
pub const IMAGE_CEE_CS_CALLCONV_DEFAULT = CorCallingConvention.DEFAULT;
pub const IMAGE_CEE_CS_CALLCONV_VARARG = CorCallingConvention.VARARG;
pub const IMAGE_CEE_CS_CALLCONV_FIELD = CorCallingConvention.FIELD;
pub const IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = CorCallingConvention.LOCAL_SIG;
pub const IMAGE_CEE_CS_CALLCONV_PROPERTY = CorCallingConvention.PROPERTY;
pub const IMAGE_CEE_CS_CALLCONV_UNMGD = CorCallingConvention.UNMGD;
pub const IMAGE_CEE_CS_CALLCONV_GENERICINST = CorCallingConvention.GENERICINST;
pub const IMAGE_CEE_CS_CALLCONV_NATIVEVARARG = CorCallingConvention.NATIVEVARARG;
pub const IMAGE_CEE_CS_CALLCONV_MAX = CorCallingConvention.MAX;
pub const IMAGE_CEE_CS_CALLCONV_MASK = CorCallingConvention.MASK;
pub const IMAGE_CEE_CS_CALLCONV_HASTHIS = CorCallingConvention.HASTHIS;
pub const IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = CorCallingConvention.EXPLICITTHIS;
pub const IMAGE_CEE_CS_CALLCONV_GENERIC = CorCallingConvention.GENERIC;

pub const CorUnmanagedCallingConvention = enum(i32) {
    UNMANAGED_CALLCONV_C = 1,
    UNMANAGED_CALLCONV_STDCALL = 2,
    UNMANAGED_CALLCONV_THISCALL = 3,
    UNMANAGED_CALLCONV_FASTCALL = 4,
    // CS_CALLCONV_C = 1, this enum value conflicts with UNMANAGED_CALLCONV_C
    // CS_CALLCONV_STDCALL = 2, this enum value conflicts with UNMANAGED_CALLCONV_STDCALL
    // CS_CALLCONV_THISCALL = 3, this enum value conflicts with UNMANAGED_CALLCONV_THISCALL
    // CS_CALLCONV_FASTCALL = 4, this enum value conflicts with UNMANAGED_CALLCONV_FASTCALL
};
pub const IMAGE_CEE_UNMANAGED_CALLCONV_C = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_C;
pub const IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_STDCALL;
pub const IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_THISCALL;
pub const IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_FASTCALL;
pub const IMAGE_CEE_CS_CALLCONV_C = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_C;
pub const IMAGE_CEE_CS_CALLCONV_STDCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_STDCALL;
pub const IMAGE_CEE_CS_CALLCONV_THISCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_THISCALL;
pub const IMAGE_CEE_CS_CALLCONV_FASTCALL = CorUnmanagedCallingConvention.UNMANAGED_CALLCONV_FASTCALL;

pub const CorArgType = enum(i32) {
    END = 0,
    VOID = 1,
    I4 = 2,
    I8 = 3,
    R4 = 4,
    R8 = 5,
    PTR = 6,
    OBJECT = 7,
    STRUCT4 = 8,
    STRUCT32 = 9,
    BYVALUE = 10,
};
pub const IMAGE_CEE_CS_END = CorArgType.END;
pub const IMAGE_CEE_CS_VOID = CorArgType.VOID;
pub const IMAGE_CEE_CS_I4 = CorArgType.I4;
pub const IMAGE_CEE_CS_I8 = CorArgType.I8;
pub const IMAGE_CEE_CS_R4 = CorArgType.R4;
pub const IMAGE_CEE_CS_R8 = CorArgType.R8;
pub const IMAGE_CEE_CS_PTR = CorArgType.PTR;
pub const IMAGE_CEE_CS_OBJECT = CorArgType.OBJECT;
pub const IMAGE_CEE_CS_STRUCT4 = CorArgType.STRUCT4;
pub const IMAGE_CEE_CS_STRUCT32 = CorArgType.STRUCT32;
pub const IMAGE_CEE_CS_BYVALUE = CorArgType.BYVALUE;

pub const CorNativeType = enum(i32) {
    END = 0,
    VOID = 1,
    BOOLEAN = 2,
    I1 = 3,
    U1 = 4,
    I2 = 5,
    U2 = 6,
    I4 = 7,
    U4 = 8,
    I8 = 9,
    U8 = 10,
    R4 = 11,
    R8 = 12,
    SYSCHAR = 13,
    VARIANT = 14,
    CURRENCY = 15,
    PTR = 16,
    DECIMAL = 17,
    DATE = 18,
    BSTR = 19,
    LPSTR = 20,
    LPWSTR = 21,
    LPTSTR = 22,
    FIXEDSYSSTRING = 23,
    OBJECTREF = 24,
    IUNKNOWN = 25,
    IDISPATCH = 26,
    STRUCT = 27,
    INTF = 28,
    SAFEARRAY = 29,
    FIXEDARRAY = 30,
    INT = 31,
    UINT = 32,
    NESTEDSTRUCT = 33,
    BYVALSTR = 34,
    ANSIBSTR = 35,
    TBSTR = 36,
    VARIANTBOOL = 37,
    FUNC = 38,
    ASANY = 40,
    ARRAY = 42,
    LPSTRUCT = 43,
    CUSTOMMARSHALER = 44,
    ERROR = 45,
    IINSPECTABLE = 46,
    HSTRING = 47,
    LPUTF8STR = 48,
    MAX = 80,
};
pub const NATIVE_TYPE_END = CorNativeType.END;
pub const NATIVE_TYPE_VOID = CorNativeType.VOID;
pub const NATIVE_TYPE_BOOLEAN = CorNativeType.BOOLEAN;
pub const NATIVE_TYPE_I1 = CorNativeType.I1;
pub const NATIVE_TYPE_U1 = CorNativeType.U1;
pub const NATIVE_TYPE_I2 = CorNativeType.I2;
pub const NATIVE_TYPE_U2 = CorNativeType.U2;
pub const NATIVE_TYPE_I4 = CorNativeType.I4;
pub const NATIVE_TYPE_U4 = CorNativeType.U4;
pub const NATIVE_TYPE_I8 = CorNativeType.I8;
pub const NATIVE_TYPE_U8 = CorNativeType.U8;
pub const NATIVE_TYPE_R4 = CorNativeType.R4;
pub const NATIVE_TYPE_R8 = CorNativeType.R8;
pub const NATIVE_TYPE_SYSCHAR = CorNativeType.SYSCHAR;
pub const NATIVE_TYPE_VARIANT = CorNativeType.VARIANT;
pub const NATIVE_TYPE_CURRENCY = CorNativeType.CURRENCY;
pub const NATIVE_TYPE_PTR = CorNativeType.PTR;
pub const NATIVE_TYPE_DECIMAL = CorNativeType.DECIMAL;
pub const NATIVE_TYPE_DATE = CorNativeType.DATE;
pub const NATIVE_TYPE_BSTR = CorNativeType.BSTR;
pub const NATIVE_TYPE_LPSTR = CorNativeType.LPSTR;
pub const NATIVE_TYPE_LPWSTR = CorNativeType.LPWSTR;
pub const NATIVE_TYPE_LPTSTR = CorNativeType.LPTSTR;
pub const NATIVE_TYPE_FIXEDSYSSTRING = CorNativeType.FIXEDSYSSTRING;
pub const NATIVE_TYPE_OBJECTREF = CorNativeType.OBJECTREF;
pub const NATIVE_TYPE_IUNKNOWN = CorNativeType.IUNKNOWN;
pub const NATIVE_TYPE_IDISPATCH = CorNativeType.IDISPATCH;
pub const NATIVE_TYPE_STRUCT = CorNativeType.STRUCT;
pub const NATIVE_TYPE_INTF = CorNativeType.INTF;
pub const NATIVE_TYPE_SAFEARRAY = CorNativeType.SAFEARRAY;
pub const NATIVE_TYPE_FIXEDARRAY = CorNativeType.FIXEDARRAY;
pub const NATIVE_TYPE_INT = CorNativeType.INT;
pub const NATIVE_TYPE_UINT = CorNativeType.UINT;
pub const NATIVE_TYPE_NESTEDSTRUCT = CorNativeType.NESTEDSTRUCT;
pub const NATIVE_TYPE_BYVALSTR = CorNativeType.BYVALSTR;
pub const NATIVE_TYPE_ANSIBSTR = CorNativeType.ANSIBSTR;
pub const NATIVE_TYPE_TBSTR = CorNativeType.TBSTR;
pub const NATIVE_TYPE_VARIANTBOOL = CorNativeType.VARIANTBOOL;
pub const NATIVE_TYPE_FUNC = CorNativeType.FUNC;
pub const NATIVE_TYPE_ASANY = CorNativeType.ASANY;
pub const NATIVE_TYPE_ARRAY = CorNativeType.ARRAY;
pub const NATIVE_TYPE_LPSTRUCT = CorNativeType.LPSTRUCT;
pub const NATIVE_TYPE_CUSTOMMARSHALER = CorNativeType.CUSTOMMARSHALER;
pub const NATIVE_TYPE_ERROR = CorNativeType.ERROR;
pub const NATIVE_TYPE_IINSPECTABLE = CorNativeType.IINSPECTABLE;
pub const NATIVE_TYPE_HSTRING = CorNativeType.HSTRING;
pub const NATIVE_TYPE_LPUTF8STR = CorNativeType.LPUTF8STR;
pub const NATIVE_TYPE_MAX = CorNativeType.MAX;

pub const CorILMethodSect = enum(i32) {
    Reserved = 0,
    EHTable = 1,
    OptILTable = 2,
    KindMask = 63,
    FatFormat = 64,
    MoreSects = 128,
};
pub const CorILMethod_Sect_Reserved = CorILMethodSect.Reserved;
pub const CorILMethod_Sect_EHTable = CorILMethodSect.EHTable;
pub const CorILMethod_Sect_OptILTable = CorILMethodSect.OptILTable;
pub const CorILMethod_Sect_KindMask = CorILMethodSect.KindMask;
pub const CorILMethod_Sect_FatFormat = CorILMethodSect.FatFormat;
pub const CorILMethod_Sect_MoreSects = CorILMethodSect.MoreSects;

pub const IMAGE_COR_ILMETHOD_SECT_SMALL = extern struct {
    Kind: u8,
    DataSize: u8,
};

pub const IMAGE_COR_ILMETHOD_SECT_FAT = extern struct {
    _bitfield: u32,
};

pub const CorExceptionFlag = enum(i32) {
    NONE = 0,
    // OFFSETLEN = 0, this enum value conflicts with NONE
    // DEPRECATED = 0, this enum value conflicts with NONE
    FILTER = 1,
    FINALLY = 2,
    FAULT = 4,
    DUPLICATED = 8,
};
pub const COR_ILEXCEPTION_CLAUSE_NONE = CorExceptionFlag.NONE;
pub const COR_ILEXCEPTION_CLAUSE_OFFSETLEN = CorExceptionFlag.NONE;
pub const COR_ILEXCEPTION_CLAUSE_DEPRECATED = CorExceptionFlag.NONE;
pub const COR_ILEXCEPTION_CLAUSE_FILTER = CorExceptionFlag.FILTER;
pub const COR_ILEXCEPTION_CLAUSE_FINALLY = CorExceptionFlag.FINALLY;
pub const COR_ILEXCEPTION_CLAUSE_FAULT = CorExceptionFlag.FAULT;
pub const COR_ILEXCEPTION_CLAUSE_DUPLICATED = CorExceptionFlag.DUPLICATED;

pub const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT = extern struct {
    Flags: CorExceptionFlag,
    TryOffset: u32,
    TryLength: u32,
    HandlerOffset: u32,
    HandlerLength: u32,
    Anonymous: extern union {
        ClassToken: u32,
        FilterOffset: u32,
    },
};

pub const IMAGE_COR_ILMETHOD_SECT_EH_FAT = extern struct {
    SectFat: IMAGE_COR_ILMETHOD_SECT_FAT,
    Clauses: [1]IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT,
};


pub const IMAGE_COR_ILMETHOD_SECT_EH_SMALL = extern struct {
    SectSmall: IMAGE_COR_ILMETHOD_SECT_SMALL,
    Reserved: u16,
    Clauses: [1]IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL,
};

pub const IMAGE_COR_ILMETHOD_SECT_EH = extern union {
    Small: IMAGE_COR_ILMETHOD_SECT_EH_SMALL,
    Fat: IMAGE_COR_ILMETHOD_SECT_EH_FAT,
};

pub const CorILMethodFlags = enum(i32) {
    InitLocals = 16,
    MoreSects = 8,
    CompressedIL = 64,
    FormatShift = 3,
    FormatMask = 7,
    TinyFormat = 2,
    SmallFormat = 0,
    // FatFormat = 3, this enum value conflicts with FormatShift
    TinyFormat1 = 6,
};
pub const CorILMethod_InitLocals = CorILMethodFlags.InitLocals;
pub const CorILMethod_MoreSects = CorILMethodFlags.MoreSects;
pub const CorILMethod_CompressedIL = CorILMethodFlags.CompressedIL;
pub const CorILMethod_FormatShift = CorILMethodFlags.FormatShift;
pub const CorILMethod_FormatMask = CorILMethodFlags.FormatMask;
pub const CorILMethod_TinyFormat = CorILMethodFlags.TinyFormat;
pub const CorILMethod_SmallFormat = CorILMethodFlags.SmallFormat;
pub const CorILMethod_FatFormat = CorILMethodFlags.FormatShift;
pub const CorILMethod_TinyFormat1 = CorILMethodFlags.TinyFormat1;

pub const IMAGE_COR_ILMETHOD_TINY = extern struct {
    Flags_CodeSize: u8,
};

pub const IMAGE_COR_ILMETHOD_FAT = extern struct {
    _bitfield: u32,
    CodeSize: u32,
    LocalVarSigTok: u32,
};

pub const IMAGE_COR_ILMETHOD = extern union {
    Tiny: IMAGE_COR_ILMETHOD_TINY,
    Fat: IMAGE_COR_ILMETHOD_FAT,
};

pub const IMAGE_COR_VTABLEFIXUP = extern struct {
    RVA: u32,
    Count: u16,
    Type: u16,
};

pub const CorCheckDuplicatesFor = enum(i32) {
    DupAll = -1,
    // DupENC = -1, this enum value conflicts with DupAll
    NoDupChecks = 0,
    DupTypeDef = 1,
    DupInterfaceImpl = 2,
    DupMethodDef = 4,
    DupTypeRef = 8,
    DupMemberRef = 16,
    DupCustomAttribute = 32,
    DupParamDef = 64,
    DupPermission = 128,
    DupProperty = 256,
    DupEvent = 512,
    DupFieldDef = 1024,
    DupSignature = 2048,
    DupModuleRef = 4096,
    DupTypeSpec = 8192,
    DupImplMap = 16384,
    DupAssemblyRef = 32768,
    DupFile = 65536,
    DupExportedType = 131072,
    DupManifestResource = 262144,
    DupGenericParam = 524288,
    DupMethodSpec = 1048576,
    DupGenericParamConstraint = 2097152,
    DupAssembly = 268435456,
    DupDefault = 1058840,
};
pub const MDDupAll = CorCheckDuplicatesFor.DupAll;
pub const MDDupENC = CorCheckDuplicatesFor.DupAll;
pub const MDNoDupChecks = CorCheckDuplicatesFor.NoDupChecks;
pub const MDDupTypeDef = CorCheckDuplicatesFor.DupTypeDef;
pub const MDDupInterfaceImpl = CorCheckDuplicatesFor.DupInterfaceImpl;
pub const MDDupMethodDef = CorCheckDuplicatesFor.DupMethodDef;
pub const MDDupTypeRef = CorCheckDuplicatesFor.DupTypeRef;
pub const MDDupMemberRef = CorCheckDuplicatesFor.DupMemberRef;
pub const MDDupCustomAttribute = CorCheckDuplicatesFor.DupCustomAttribute;
pub const MDDupParamDef = CorCheckDuplicatesFor.DupParamDef;
pub const MDDupPermission = CorCheckDuplicatesFor.DupPermission;
pub const MDDupProperty = CorCheckDuplicatesFor.DupProperty;
pub const MDDupEvent = CorCheckDuplicatesFor.DupEvent;
pub const MDDupFieldDef = CorCheckDuplicatesFor.DupFieldDef;
pub const MDDupSignature = CorCheckDuplicatesFor.DupSignature;
pub const MDDupModuleRef = CorCheckDuplicatesFor.DupModuleRef;
pub const MDDupTypeSpec = CorCheckDuplicatesFor.DupTypeSpec;
pub const MDDupImplMap = CorCheckDuplicatesFor.DupImplMap;
pub const MDDupAssemblyRef = CorCheckDuplicatesFor.DupAssemblyRef;
pub const MDDupFile = CorCheckDuplicatesFor.DupFile;
pub const MDDupExportedType = CorCheckDuplicatesFor.DupExportedType;
pub const MDDupManifestResource = CorCheckDuplicatesFor.DupManifestResource;
pub const MDDupGenericParam = CorCheckDuplicatesFor.DupGenericParam;
pub const MDDupMethodSpec = CorCheckDuplicatesFor.DupMethodSpec;
pub const MDDupGenericParamConstraint = CorCheckDuplicatesFor.DupGenericParamConstraint;
pub const MDDupAssembly = CorCheckDuplicatesFor.DupAssembly;
pub const MDDupDefault = CorCheckDuplicatesFor.DupDefault;

pub const CorRefToDefCheck = enum(i32) {
    RefToDefDefault = 3,
    RefToDefAll = -1,
    RefToDefNone = 0,
    TypeRefToDef = 1,
    MemberRefToDef = 2,
};
pub const MDRefToDefDefault = CorRefToDefCheck.RefToDefDefault;
pub const MDRefToDefAll = CorRefToDefCheck.RefToDefAll;
pub const MDRefToDefNone = CorRefToDefCheck.RefToDefNone;
pub const MDTypeRefToDef = CorRefToDefCheck.TypeRefToDef;
pub const MDMemberRefToDef = CorRefToDefCheck.MemberRefToDef;

pub const CorNotificationForTokenMovement = enum(i32) {
    Default = 15,
    All = -1,
    None = 0,
    MethodDef = 1,
    MemberRef = 2,
    FieldDef = 4,
    TypeRef = 8,
    TypeDef = 16,
    ParamDef = 32,
    InterfaceImpl = 64,
    Property = 128,
    Event = 256,
    Signature = 512,
    TypeSpec = 1024,
    CustomAttribute = 2048,
    SecurityValue = 4096,
    Permission = 8192,
    ModuleRef = 16384,
    NameSpace = 32768,
    AssemblyRef = 16777216,
    File = 33554432,
    ExportedType = 67108864,
    Resource = 134217728,
};
pub const MDNotifyDefault = CorNotificationForTokenMovement.Default;
pub const MDNotifyAll = CorNotificationForTokenMovement.All;
pub const MDNotifyNone = CorNotificationForTokenMovement.None;
pub const MDNotifyMethodDef = CorNotificationForTokenMovement.MethodDef;
pub const MDNotifyMemberRef = CorNotificationForTokenMovement.MemberRef;
pub const MDNotifyFieldDef = CorNotificationForTokenMovement.FieldDef;
pub const MDNotifyTypeRef = CorNotificationForTokenMovement.TypeRef;
pub const MDNotifyTypeDef = CorNotificationForTokenMovement.TypeDef;
pub const MDNotifyParamDef = CorNotificationForTokenMovement.ParamDef;
pub const MDNotifyInterfaceImpl = CorNotificationForTokenMovement.InterfaceImpl;
pub const MDNotifyProperty = CorNotificationForTokenMovement.Property;
pub const MDNotifyEvent = CorNotificationForTokenMovement.Event;
pub const MDNotifySignature = CorNotificationForTokenMovement.Signature;
pub const MDNotifyTypeSpec = CorNotificationForTokenMovement.TypeSpec;
pub const MDNotifyCustomAttribute = CorNotificationForTokenMovement.CustomAttribute;
pub const MDNotifySecurityValue = CorNotificationForTokenMovement.SecurityValue;
pub const MDNotifyPermission = CorNotificationForTokenMovement.Permission;
pub const MDNotifyModuleRef = CorNotificationForTokenMovement.ModuleRef;
pub const MDNotifyNameSpace = CorNotificationForTokenMovement.NameSpace;
pub const MDNotifyAssemblyRef = CorNotificationForTokenMovement.AssemblyRef;
pub const MDNotifyFile = CorNotificationForTokenMovement.File;
pub const MDNotifyExportedType = CorNotificationForTokenMovement.ExportedType;
pub const MDNotifyResource = CorNotificationForTokenMovement.Resource;

pub const CorSetENC = enum(i32) {
    SetENCOn = 1,
    SetENCOff = 2,
    // UpdateENC = 1, this enum value conflicts with SetENCOn
    // UpdateFull = 2, this enum value conflicts with SetENCOff
    UpdateExtension = 3,
    UpdateIncremental = 4,
    UpdateDelta = 5,
    UpdateMask = 7,
};
pub const MDSetENCOn = CorSetENC.SetENCOn;
pub const MDSetENCOff = CorSetENC.SetENCOff;
pub const MDUpdateENC = CorSetENC.SetENCOn;
pub const MDUpdateFull = CorSetENC.SetENCOff;
pub const MDUpdateExtension = CorSetENC.UpdateExtension;
pub const MDUpdateIncremental = CorSetENC.UpdateIncremental;
pub const MDUpdateDelta = CorSetENC.UpdateDelta;
pub const MDUpdateMask = CorSetENC.UpdateMask;

pub const CorErrorIfEmitOutOfOrder = enum(i32) {
    ErrorOutOfOrderDefault = 0,
    // ErrorOutOfOrderNone = 0, this enum value conflicts with ErrorOutOfOrderDefault
    ErrorOutOfOrderAll = -1,
    MethodOutOfOrder = 1,
    FieldOutOfOrder = 2,
    ParamOutOfOrder = 4,
    PropertyOutOfOrder = 8,
    EventOutOfOrder = 16,
};
pub const MDErrorOutOfOrderDefault = CorErrorIfEmitOutOfOrder.ErrorOutOfOrderDefault;
pub const MDErrorOutOfOrderNone = CorErrorIfEmitOutOfOrder.ErrorOutOfOrderDefault;
pub const MDErrorOutOfOrderAll = CorErrorIfEmitOutOfOrder.ErrorOutOfOrderAll;
pub const MDMethodOutOfOrder = CorErrorIfEmitOutOfOrder.MethodOutOfOrder;
pub const MDFieldOutOfOrder = CorErrorIfEmitOutOfOrder.FieldOutOfOrder;
pub const MDParamOutOfOrder = CorErrorIfEmitOutOfOrder.ParamOutOfOrder;
pub const MDPropertyOutOfOrder = CorErrorIfEmitOutOfOrder.PropertyOutOfOrder;
pub const MDEventOutOfOrder = CorErrorIfEmitOutOfOrder.EventOutOfOrder;

pub const CorImportOptions = enum(i32) {
    Default = 0,
    All = -1,
    AllTypeDefs = 1,
    AllMethodDefs = 2,
    AllFieldDefs = 4,
    AllProperties = 8,
    AllEvents = 16,
    AllCustomAttributes = 32,
    AllExportedTypes = 64,
};
pub const MDImportOptionDefault = CorImportOptions.Default;
pub const MDImportOptionAll = CorImportOptions.All;
pub const MDImportOptionAllTypeDefs = CorImportOptions.AllTypeDefs;
pub const MDImportOptionAllMethodDefs = CorImportOptions.AllMethodDefs;
pub const MDImportOptionAllFieldDefs = CorImportOptions.AllFieldDefs;
pub const MDImportOptionAllProperties = CorImportOptions.AllProperties;
pub const MDImportOptionAllEvents = CorImportOptions.AllEvents;
pub const MDImportOptionAllCustomAttributes = CorImportOptions.AllCustomAttributes;
pub const MDImportOptionAllExportedTypes = CorImportOptions.AllExportedTypes;

pub const CorThreadSafetyOptions = enum(i32) {
    Default = 0,
    // Off = 0, this enum value conflicts with Default
    On = 1,
};
pub const MDThreadSafetyDefault = CorThreadSafetyOptions.Default;
pub const MDThreadSafetyOff = CorThreadSafetyOptions.Default;
pub const MDThreadSafetyOn = CorThreadSafetyOptions.On;

pub const CorLinkerOptions = enum(i32) {
    Assembly = 0,
    NetModule = 1,
};
pub const MDAssembly = CorLinkerOptions.Assembly;
pub const MDNetModule = CorLinkerOptions.NetModule;

pub const MergeFlags = enum(i32) {
    MergeFlagsNone = 0,
    MergeManifest = 1,
    DropMemberRefCAs = 2,
    NoDupCheck = 4,
    MergeExportedTypes = 8,
};
pub const MergeFlagsNone = MergeFlags.MergeFlagsNone;
pub const MergeManifest = MergeFlags.MergeManifest;
pub const DropMemberRefCAs = MergeFlags.DropMemberRefCAs;
pub const NoDupCheck = MergeFlags.NoDupCheck;
pub const MergeExportedTypes = MergeFlags.MergeExportedTypes;

pub const CorLocalRefPreservation = enum(i32) {
    RefsNone = 0,
    TypeRef = 1,
    MemberRef = 2,
};
pub const MDPreserveLocalRefsNone = CorLocalRefPreservation.RefsNone;
pub const MDPreserveLocalTypeRef = CorLocalRefPreservation.TypeRef;
pub const MDPreserveLocalMemberRef = CorLocalRefPreservation.MemberRef;

pub const COR_FIELD_OFFSET = extern struct {
    ridOfField: u32,
    ulOffset: u32,
};

pub const CorTokenType = enum(i32) {
    Module = 0,
    TypeRef = 16777216,
    TypeDef = 33554432,
    FieldDef = 67108864,
    MethodDef = 100663296,
    ParamDef = 134217728,
    InterfaceImpl = 150994944,
    MemberRef = 167772160,
    CustomAttribute = 201326592,
    Permission = 234881024,
    Signature = 285212672,
    Event = 335544320,
    Property = 385875968,
    MethodImpl = 419430400,
    ModuleRef = 436207616,
    TypeSpec = 452984832,
    Assembly = 536870912,
    AssemblyRef = 587202560,
    File = 637534208,
    ExportedType = 654311424,
    ManifestResource = 671088640,
    GenericParam = 704643072,
    MethodSpec = 721420288,
    GenericParamConstraint = 738197504,
    String = 1879048192,
    Name = 1895825408,
    BaseType = 1912602624,
};
pub const mdtModule = CorTokenType.Module;
pub const mdtTypeRef = CorTokenType.TypeRef;
pub const mdtTypeDef = CorTokenType.TypeDef;
pub const mdtFieldDef = CorTokenType.FieldDef;
pub const mdtMethodDef = CorTokenType.MethodDef;
pub const mdtParamDef = CorTokenType.ParamDef;
pub const mdtInterfaceImpl = CorTokenType.InterfaceImpl;
pub const mdtMemberRef = CorTokenType.MemberRef;
pub const mdtCustomAttribute = CorTokenType.CustomAttribute;
pub const mdtPermission = CorTokenType.Permission;
pub const mdtSignature = CorTokenType.Signature;
pub const mdtEvent = CorTokenType.Event;
pub const mdtProperty = CorTokenType.Property;
pub const mdtMethodImpl = CorTokenType.MethodImpl;
pub const mdtModuleRef = CorTokenType.ModuleRef;
pub const mdtTypeSpec = CorTokenType.TypeSpec;
pub const mdtAssembly = CorTokenType.Assembly;
pub const mdtAssemblyRef = CorTokenType.AssemblyRef;
pub const mdtFile = CorTokenType.File;
pub const mdtExportedType = CorTokenType.ExportedType;
pub const mdtManifestResource = CorTokenType.ManifestResource;
pub const mdtGenericParam = CorTokenType.GenericParam;
pub const mdtMethodSpec = CorTokenType.MethodSpec;
pub const mdtGenericParamConstraint = CorTokenType.GenericParamConstraint;
pub const mdtString = CorTokenType.String;
pub const mdtName = CorTokenType.Name;
pub const mdtBaseType = CorTokenType.BaseType;

pub const CorOpenFlags = enum(i32) {
    Read = 0,
    Write = 1,
    // ReadWriteMask = 1, this enum value conflicts with Write
    CopyMemory = 2,
    ReadOnly = 16,
    TakeOwnership = 32,
    NoTypeLib = 128,
    NoTransform = 4096,
    CheckIntegrity = 2048,
    Reserved1 = 256,
    Reserved2 = 512,
    Reserved3 = 1024,
    Reserved = -6336,
};
pub const ofRead = CorOpenFlags.Read;
pub const ofWrite = CorOpenFlags.Write;
pub const ofReadWriteMask = CorOpenFlags.Write;
pub const ofCopyMemory = CorOpenFlags.CopyMemory;
pub const ofReadOnly = CorOpenFlags.ReadOnly;
pub const ofTakeOwnership = CorOpenFlags.TakeOwnership;
pub const ofNoTypeLib = CorOpenFlags.NoTypeLib;
pub const ofNoTransform = CorOpenFlags.NoTransform;
pub const ofCheckIntegrity = CorOpenFlags.CheckIntegrity;
pub const ofReserved1 = CorOpenFlags.Reserved1;
pub const ofReserved2 = CorOpenFlags.Reserved2;
pub const ofReserved3 = CorOpenFlags.Reserved3;
pub const ofReserved = CorOpenFlags.Reserved;

pub const CorFileMapping = enum(i32) {
    Flat = 0,
    ExecutableImage = 1,
};
pub const fmFlat = CorFileMapping.Flat;
pub const fmExecutableImage = CorFileMapping.ExecutableImage;

pub const CorAttributeTargets = enum(i32) {
    Assembly = 1,
    Module = 2,
    Class = 4,
    Struct = 8,
    Enum = 16,
    Constructor = 32,
    Method = 64,
    Property = 128,
    Field = 256,
    Event = 512,
    Interface = 1024,
    Parameter = 2048,
    Delegate = 4096,
    GenericParameter = 16384,
    All = 24575,
    ClassMembers = 6140,
};
pub const catAssembly = CorAttributeTargets.Assembly;
pub const catModule = CorAttributeTargets.Module;
pub const catClass = CorAttributeTargets.Class;
pub const catStruct = CorAttributeTargets.Struct;
pub const catEnum = CorAttributeTargets.Enum;
pub const catConstructor = CorAttributeTargets.Constructor;
pub const catMethod = CorAttributeTargets.Method;
pub const catProperty = CorAttributeTargets.Property;
pub const catField = CorAttributeTargets.Field;
pub const catEvent = CorAttributeTargets.Event;
pub const catInterface = CorAttributeTargets.Interface;
pub const catParameter = CorAttributeTargets.Parameter;
pub const catDelegate = CorAttributeTargets.Delegate;
pub const catGenericParameter = CorAttributeTargets.GenericParameter;
pub const catAll = CorAttributeTargets.All;
pub const catClassMembers = CorAttributeTargets.ClassMembers;

pub const CompilationRelaxationsEnum = enum(i32) {
    g = 8,
};
pub const CompilationRelaxations_NoStringInterning = CompilationRelaxationsEnum.g;

pub const NGenHintEnum = enum(i32) {
    Default = 0,
    Eager = 1,
    Lazy = 2,
    Never = 3,
};
pub const NGenDefault = NGenHintEnum.Default;
pub const NGenEager = NGenHintEnum.Eager;
pub const NGenLazy = NGenHintEnum.Lazy;
pub const NGenNever = NGenHintEnum.Never;

pub const LoadHintEnum = enum(i32) {
    Default = 0,
    Always = 1,
    Sometimes = 2,
    Never = 3,
};
pub const LoadDefault = LoadHintEnum.Default;
pub const LoadAlways = LoadHintEnum.Always;
pub const LoadSometimes = LoadHintEnum.Sometimes;
pub const LoadNever = LoadHintEnum.Never;

pub const CorSaveSize = enum(i32) {
    Accurate = 0,
    Quick = 1,
    DiscardTransientCAs = 2,
};
pub const cssAccurate = CorSaveSize.Accurate;
pub const cssQuick = CorSaveSize.Quick;
pub const cssDiscardTransientCAs = CorSaveSize.DiscardTransientCAs;

pub const NativeTypeArrayFlags = enum(i32) {
    SizeParamIndexSpecified = 1,
    Reserved = 65534,
};
pub const ntaSizeParamIndexSpecified = NativeTypeArrayFlags.SizeParamIndexSpecified;
pub const ntaReserved = NativeTypeArrayFlags.Reserved;

pub const COR_SECATTR = extern struct {
    tkCtor: u32,
    pCustomAttribute: ?*const anyopaque,
    cbCustomAttribute: u32,
};

const IID_IMetaDataError_Value = Guid.initString("b81ff171-20f3-11d2-8dcc-00a0c9b09c19");
pub const IID_IMetaDataError = &IID_IMetaDataError_Value;
pub const IMetaDataError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataError,
                hrError: HRESULT,
                token: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataError,
                hrError: HRESULT,
                token: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataError_OnError(self: *const T, hrError: HRESULT, token: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataError.VTable, @ptrCast(self.vtable)).OnError(@as(*const IMetaDataError, @ptrCast(self)), hrError, token);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMapToken_Value = Guid.initString("06a3ea8b-0225-11d1-bf72-00c04fc31e12");
pub const IID_IMapToken = &IID_IMapToken_Value;
pub const IMapToken = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Map: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMapToken,
                tkImp: u32,
                tkEmit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMapToken,
                tkImp: u32,
                tkEmit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMapToken_Map(self: *const T, tkImp: u32, tkEmit: u32) callconv(.Inline) HRESULT {
            return @as(*const IMapToken.VTable, @ptrCast(self.vtable)).Map(@as(*const IMapToken, @ptrCast(self)), tkImp, tkEmit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataDispenser_Value = Guid.initString("809c652e-7396-11d2-9771-00a0c9b4d50c");
pub const IID_IMetaDataDispenser = &IID_IMetaDataDispenser_Value;
pub const IMetaDataDispenser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DefineScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenser,
                rclsid: ?*const Guid,
                dwCreateFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenser,
                rclsid: ?*const Guid,
                dwCreateFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenser,
                szScope: ?[*:0]align(1) const u16,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenser,
                szScope: ?[*:0]align(1) const u16,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenScopeOnMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenser,
                pData: ?*const anyopaque,
                cbData: u32,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenser,
                pData: ?*const anyopaque,
                cbData: u32,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenser_DefineScope(self: *const T, rclsid: ?*const Guid, dwCreateFlags: u32, riid: ?*const Guid, ppIUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenser.VTable, @ptrCast(self.vtable)).DefineScope(@as(*const IMetaDataDispenser, @ptrCast(self)), rclsid, dwCreateFlags, riid, ppIUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenser_OpenScope(self: *const T, szScope: ?[*:0]align(1) const u16, dwOpenFlags: u32, riid: ?*const Guid, ppIUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenser.VTable, @ptrCast(self.vtable)).OpenScope(@as(*const IMetaDataDispenser, @ptrCast(self)), szScope, dwOpenFlags, riid, ppIUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenser_OpenScopeOnMemory(self: *const T, pData: ?*const anyopaque, cbData: u32, dwOpenFlags: u32, riid: ?*const Guid, ppIUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenser.VTable, @ptrCast(self.vtable)).OpenScopeOnMemory(@as(*const IMetaDataDispenser, @ptrCast(self)), pData, cbData, dwOpenFlags, riid, ppIUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataEmit_Value = Guid.initString("ba3fee4c-ecb9-4e41-83b7-183fa41cd859");
pub const IID_IMetaDataEmit = &IID_IMetaDataEmit_Value;
pub const IMetaDataEmit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetModuleProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szFile: ?[*:0]align(1) const u16,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szFile: ?[*:0]align(1) const u16,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pIStream: ?*IStream,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pIStream: ?*IStream,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSaveSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                fSave: CorSaveSize,
                pdwSaveSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                fSave: CorSaveSize,
                pdwSaveSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineTypeDef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szTypeDef: ?[*:0]align(1) const u16,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szTypeDef: ?[*:0]align(1) const u16,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineNestedType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szTypeDef: ?[*:0]align(1) const u16,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
                tdEncloser: u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szTypeDef: ?[*:0]align(1) const u16,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
                tdEncloser: u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                dwMethodFlags: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                ulCodeRVA: u32,
                dwImplFlags: u32,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                dwMethodFlags: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                ulCodeRVA: u32,
                dwImplFlags: u32,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineMethodImpl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                tkBody: u32,
                tkDecl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                tkBody: u32,
                tkDecl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineTypeRefByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tkResolutionScope: u32,
                szName: ?[*:0]align(1) const u16,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tkResolutionScope: u32,
                szName: ?[*:0]align(1) const u16,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineImportType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                pImport: ?*IMetaDataImport,
                tdImport: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                pImport: ?*IMetaDataImport,
                tdImport: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineMemberRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tkImport: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tkImport: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineImportMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                pImport: ?*IMetaDataImport,
                mbMember: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                tkParent: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                pImport: ?*IMetaDataImport,
                mbMember: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                tkParent: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                szEvent: ?[*:0]align(1) const u16,
                dwEventFlags: u32,
                tkEventType: u32,
                mdAddOn: u32,
                mdRemoveOn: u32,
                mdFire: u32,
                rmdOtherMethods: ?*u32,
                pmdEvent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                szEvent: ?[*:0]align(1) const u16,
                dwEventFlags: u32,
                tkEventType: u32,
                mdAddOn: u32,
                mdRemoveOn: u32,
                mdFire: u32,
                rmdOtherMethods: ?*u32,
                pmdEvent: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClassLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                dwPackSize: u32,
                rFieldOffsets: ?*COR_FIELD_OFFSET,
                ulClassSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                dwPackSize: u32,
                rFieldOffsets: ?*COR_FIELD_OFFSET,
                ulClassSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteClassLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldMarshal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
                pvNativeType: ?*u8,
                cbNativeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
                pvNativeType: ?*u8,
                cbNativeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteFieldMarshal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefinePermissionSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwAction: u32,
                pvPermission: ?*const anyopaque,
                cbPermission: u32,
                ppm: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwAction: u32,
                pvPermission: ?*const anyopaque,
                cbPermission: u32,
                ppm: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                md: u32,
                ulRVA: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                md: u32,
                ulRVA: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTokenFromSig: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pvSig: ?*u8,
                cbSig: u32,
                pmsig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pvSig: ?*u8,
                cbSig: u32,
                pmsig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineModuleRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szName: ?[*:0]align(1) const u16,
                pmur: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szName: ?[*:0]align(1) const u16,
                pmur: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                mr: u32,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                mr: u32,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTokenFromTypeSpec: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pvSig: ?*u8,
                cbSig: u32,
                ptypespec: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pvSig: ?*u8,
                cbSig: u32,
                ptypespec: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveToMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pbData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pbData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineUserString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                szString: ?[*:0]align(1) const u16,
                cchString: u32,
                pstk: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                szString: ?[*:0]align(1) const u16,
                cchString: u32,
                pstk: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tkObj: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tkObj: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMethodProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                md: u32,
                dwMethodFlags: u32,
                ulCodeRVA: u32,
                dwImplFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                md: u32,
                dwMethodFlags: u32,
                ulCodeRVA: u32,
                dwImplFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeDefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                dwTypeDefFlags: u32,
                tkExtends: u32,
                rtkImplements: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                ev: u32,
                dwEventFlags: u32,
                tkEventType: u32,
                mdAddOn: u32,
                mdRemoveOn: u32,
                mdFire: u32,
                rmdOtherMethods: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                ev: u32,
                dwEventFlags: u32,
                tkEventType: u32,
                mdAddOn: u32,
                mdRemoveOn: u32,
                mdFire: u32,
                rmdOtherMethods: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPermissionSetProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwAction: u32,
                pvPermission: ?*const anyopaque,
                cbPermission: u32,
                ppm: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwAction: u32,
                pvPermission: ?*const anyopaque,
                cbPermission: u32,
                ppm: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefinePinvokeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwMappingFlags: u32,
                szImportName: ?[*:0]align(1) const u16,
                mrImportDLL: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwMappingFlags: u32,
                szImportName: ?[*:0]align(1) const u16,
                mrImportDLL: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPinvokeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwMappingFlags: u32,
                szImportName: ?[*:0]align(1) const u16,
                mrImportDLL: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
                dwMappingFlags: u32,
                szImportName: ?[*:0]align(1) const u16,
                mrImportDLL: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePinvokeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineCustomAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tkOwner: u32,
                tkCtor: u32,
                pCustomAttribute: ?*const anyopaque,
                cbCustomAttribute: u32,
                pcv: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tkOwner: u32,
                tkCtor: u32,
                pCustomAttribute: ?*const anyopaque,
                cbCustomAttribute: u32,
                pcv: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCustomAttributeValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pcv: u32,
                pCustomAttribute: ?*const anyopaque,
                cbCustomAttribute: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pcv: u32,
                pCustomAttribute: ?*const anyopaque,
                cbCustomAttribute: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineField: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                dwFieldFlags: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                dwFieldFlags: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                td: u32,
                szProperty: ?[*:0]align(1) const u16,
                dwPropFlags: u32,
                pvSig: ?*u8,
                cbSig: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                mdSetter: u32,
                mdGetter: u32,
                rmdOtherMethods: ?*u32,
                pmdProp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                td: u32,
                szProperty: ?[*:0]align(1) const u16,
                dwPropFlags: u32,
                pvSig: ?*u8,
                cbSig: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                mdSetter: u32,
                mdGetter: u32,
                rmdOtherMethods: ?*u32,
                pmdProp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                md: u32,
                ulParamSeq: u32,
                szName: ?[*:0]align(1) const u16,
                dwParamFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                ppd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                md: u32,
                ulParamSeq: u32,
                szName: ?[*:0]align(1) const u16,
                dwParamFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                ppd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                fd: u32,
                dwFieldFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                fd: u32,
                dwFieldFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertyProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pr: u32,
                dwPropFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                mdSetter: u32,
                mdGetter: u32,
                rmdOtherMethods: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pr: u32,
                dwPropFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
                mdSetter: u32,
                mdGetter: u32,
                rmdOtherMethods: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParamProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pd: u32,
                szName: ?[*:0]align(1) const u16,
                dwParamFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pd: u32,
                szName: ?[*:0]align(1) const u16,
                dwParamFlags: u32,
                dwCPlusTypeFlag: u32,
                pValue: ?*const anyopaque,
                cchValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineSecurityAttributeSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                tkObj: u32,
                rSecAttrs: ?*COR_SECATTR,
                cSecAttrs: u32,
                pulErrorAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                tkObj: u32,
                rSecAttrs: ?*COR_SECATTR,
                cSecAttrs: u32,
                pulErrorAttr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ApplyEditAndContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pImport: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pImport: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TranslateSigWithScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                import: ?*IMetaDataImport,
                pbSigBlob: ?*u8,
                cbSigBlob: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                emit: ?*IMetaDataEmit,
                pvTranslatedSig: ?*u8,
                cbTranslatedSigMax: u32,
                pcbTranslatedSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pAssemImport: ?*IMetaDataAssemblyImport,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                import: ?*IMetaDataImport,
                pbSigBlob: ?*u8,
                cbSigBlob: u32,
                pAssemEmit: ?*IMetaDataAssemblyEmit,
                emit: ?*IMetaDataEmit,
                pvTranslatedSig: ?*u8,
                cbTranslatedSigMax: u32,
                pcbTranslatedSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMethodImplFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                md: u32,
                dwImplFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                md: u32,
                dwImplFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFieldRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                fd: u32,
                ulRVA: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                fd: u32,
                ulRVA: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Merge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
                pImport: ?*IMetaDataImport,
                pHostMapToken: ?*IMapToken,
                pHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
                pImport: ?*IMetaDataImport,
                pHostMapToken: ?*IMapToken,
                pHandler: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MergeEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetModuleProps(self: *const T, szName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetModuleProps(@as(*const IMetaDataEmit, @ptrCast(self)), szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_Save(self: *const T, szFile: ?[*:0]align(1) const u16, dwSaveFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).Save(@as(*const IMetaDataEmit, @ptrCast(self)), szFile, dwSaveFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SaveToStream(self: *const T, pIStream: ?*IStream, dwSaveFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SaveToStream(@as(*const IMetaDataEmit, @ptrCast(self)), pIStream, dwSaveFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_GetSaveSize(self: *const T, fSave: CorSaveSize, pdwSaveSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).GetSaveSize(@as(*const IMetaDataEmit, @ptrCast(self)), fSave, pdwSaveSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineTypeDef(self: *const T, szTypeDef: ?[*:0]align(1) const u16, dwTypeDefFlags: u32, tkExtends: u32, rtkImplements: ?*u32, ptd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineTypeDef(@as(*const IMetaDataEmit, @ptrCast(self)), szTypeDef, dwTypeDefFlags, tkExtends, rtkImplements, ptd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineNestedType(self: *const T, szTypeDef: ?[*:0]align(1) const u16, dwTypeDefFlags: u32, tkExtends: u32, rtkImplements: ?*u32, tdEncloser: u32, ptd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineNestedType(@as(*const IMetaDataEmit, @ptrCast(self)), szTypeDef, dwTypeDefFlags, tkExtends, rtkImplements, tdEncloser, ptd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetHandler(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetHandler(@as(*const IMetaDataEmit, @ptrCast(self)), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineMethod(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, dwMethodFlags: u32, pvSigBlob: ?*u8, cbSigBlob: u32, ulCodeRVA: u32, dwImplFlags: u32, pmd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineMethod(@as(*const IMetaDataEmit, @ptrCast(self)), td, szName, dwMethodFlags, pvSigBlob, cbSigBlob, ulCodeRVA, dwImplFlags, pmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineMethodImpl(self: *const T, td: u32, tkBody: u32, tkDecl: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineMethodImpl(@as(*const IMetaDataEmit, @ptrCast(self)), td, tkBody, tkDecl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineTypeRefByName(self: *const T, tkResolutionScope: u32, szName: ?[*:0]align(1) const u16, ptr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineTypeRefByName(@as(*const IMetaDataEmit, @ptrCast(self)), tkResolutionScope, szName, ptr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineImportType(self: *const T, pAssemImport: ?*IMetaDataAssemblyImport, pbHashValue: ?*const anyopaque, cbHashValue: u32, pImport: ?*IMetaDataImport, _param_tdImport: u32, pAssemEmit: ?*IMetaDataAssemblyEmit, ptr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineImportType(@as(*const IMetaDataEmit, @ptrCast(self)), pAssemImport, pbHashValue, cbHashValue, pImport, _param_tdImport, pAssemEmit, ptr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineMemberRef(self: *const T, tkImport: u32, szName: ?[*:0]align(1) const u16, pvSigBlob: ?*u8, cbSigBlob: u32, pmr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineMemberRef(@as(*const IMetaDataEmit, @ptrCast(self)), tkImport, szName, pvSigBlob, cbSigBlob, pmr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineImportMember(self: *const T, pAssemImport: ?*IMetaDataAssemblyImport, pbHashValue: ?*const anyopaque, cbHashValue: u32, pImport: ?*IMetaDataImport, mbMember: u32, pAssemEmit: ?*IMetaDataAssemblyEmit, tkParent: u32, pmr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineImportMember(@as(*const IMetaDataEmit, @ptrCast(self)), pAssemImport, pbHashValue, cbHashValue, pImport, mbMember, pAssemEmit, tkParent, pmr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineEvent(self: *const T, td: u32, szEvent: ?[*:0]align(1) const u16, dwEventFlags: u32, tkEventType: u32, mdAddOn: u32, mdRemoveOn: u32, mdFire: u32, rmdOtherMethods: ?*u32, pmdEvent: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineEvent(@as(*const IMetaDataEmit, @ptrCast(self)), td, szEvent, dwEventFlags, tkEventType, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods, pmdEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetClassLayout(self: *const T, td: u32, dwPackSize: u32, rFieldOffsets: ?*COR_FIELD_OFFSET, ulClassSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetClassLayout(@as(*const IMetaDataEmit, @ptrCast(self)), td, dwPackSize, rFieldOffsets, ulClassSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DeleteClassLayout(self: *const T, td: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DeleteClassLayout(@as(*const IMetaDataEmit, @ptrCast(self)), td);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetFieldMarshal(self: *const T, tk: u32, pvNativeType: ?*u8, cbNativeType: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetFieldMarshal(@as(*const IMetaDataEmit, @ptrCast(self)), tk, pvNativeType, cbNativeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DeleteFieldMarshal(self: *const T, tk: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DeleteFieldMarshal(@as(*const IMetaDataEmit, @ptrCast(self)), tk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefinePermissionSet(self: *const T, tk: u32, dwAction: u32, pvPermission: ?*const anyopaque, cbPermission: u32, ppm: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefinePermissionSet(@as(*const IMetaDataEmit, @ptrCast(self)), tk, dwAction, pvPermission, cbPermission, ppm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetRVA(self: *const T, md: u32, ulRVA: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetRVA(@as(*const IMetaDataEmit, @ptrCast(self)), md, ulRVA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_GetTokenFromSig(self: *const T, pvSig: ?*u8, cbSig: u32, pmsig: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).GetTokenFromSig(@as(*const IMetaDataEmit, @ptrCast(self)), pvSig, cbSig, pmsig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineModuleRef(self: *const T, szName: ?[*:0]align(1) const u16, pmur: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineModuleRef(@as(*const IMetaDataEmit, @ptrCast(self)), szName, pmur);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetParent(self: *const T, mr: u32, tk: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetParent(@as(*const IMetaDataEmit, @ptrCast(self)), mr, tk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_GetTokenFromTypeSpec(self: *const T, pvSig: ?*u8, cbSig: u32, ptypespec: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).GetTokenFromTypeSpec(@as(*const IMetaDataEmit, @ptrCast(self)), pvSig, cbSig, ptypespec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SaveToMemory(self: *const T, pbData: ?*anyopaque, cbData: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SaveToMemory(@as(*const IMetaDataEmit, @ptrCast(self)), pbData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineUserString(self: *const T, szString: ?[*:0]align(1) const u16, cchString: u32, pstk: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineUserString(@as(*const IMetaDataEmit, @ptrCast(self)), szString, cchString, pstk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DeleteToken(self: *const T, tkObj: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DeleteToken(@as(*const IMetaDataEmit, @ptrCast(self)), tkObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetMethodProps(self: *const T, md: u32, dwMethodFlags: u32, ulCodeRVA: u32, dwImplFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetMethodProps(@as(*const IMetaDataEmit, @ptrCast(self)), md, dwMethodFlags, ulCodeRVA, dwImplFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetTypeDefProps(self: *const T, td: u32, dwTypeDefFlags: u32, tkExtends: u32, rtkImplements: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetTypeDefProps(@as(*const IMetaDataEmit, @ptrCast(self)), td, dwTypeDefFlags, tkExtends, rtkImplements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetEventProps(self: *const T, ev: u32, dwEventFlags: u32, tkEventType: u32, mdAddOn: u32, mdRemoveOn: u32, mdFire: u32, rmdOtherMethods: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetEventProps(@as(*const IMetaDataEmit, @ptrCast(self)), ev, dwEventFlags, tkEventType, mdAddOn, mdRemoveOn, mdFire, rmdOtherMethods);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetPermissionSetProps(self: *const T, tk: u32, dwAction: u32, pvPermission: ?*const anyopaque, cbPermission: u32, ppm: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetPermissionSetProps(@as(*const IMetaDataEmit, @ptrCast(self)), tk, dwAction, pvPermission, cbPermission, ppm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefinePinvokeMap(self: *const T, tk: u32, dwMappingFlags: u32, szImportName: ?[*:0]align(1) const u16, mrImportDLL: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefinePinvokeMap(@as(*const IMetaDataEmit, @ptrCast(self)), tk, dwMappingFlags, szImportName, mrImportDLL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetPinvokeMap(self: *const T, tk: u32, dwMappingFlags: u32, szImportName: ?[*:0]align(1) const u16, mrImportDLL: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetPinvokeMap(@as(*const IMetaDataEmit, @ptrCast(self)), tk, dwMappingFlags, szImportName, mrImportDLL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DeletePinvokeMap(self: *const T, tk: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DeletePinvokeMap(@as(*const IMetaDataEmit, @ptrCast(self)), tk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineCustomAttribute(self: *const T, tkOwner: u32, tkCtor: u32, pCustomAttribute: ?*const anyopaque, cbCustomAttribute: u32, pcv: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineCustomAttribute(@as(*const IMetaDataEmit, @ptrCast(self)), tkOwner, tkCtor, pCustomAttribute, cbCustomAttribute, pcv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetCustomAttributeValue(self: *const T, pcv: u32, pCustomAttribute: ?*const anyopaque, cbCustomAttribute: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetCustomAttributeValue(@as(*const IMetaDataEmit, @ptrCast(self)), pcv, pCustomAttribute, cbCustomAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineField(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, dwFieldFlags: u32, pvSigBlob: ?*u8, cbSigBlob: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32, pmd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineField(@as(*const IMetaDataEmit, @ptrCast(self)), td, szName, dwFieldFlags, pvSigBlob, cbSigBlob, dwCPlusTypeFlag, pValue, cchValue, pmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineProperty(self: *const T, td: u32, szProperty: ?[*:0]align(1) const u16, dwPropFlags: u32, pvSig: ?*u8, cbSig: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32, mdSetter: u32, mdGetter: u32, rmdOtherMethods: ?*u32, pmdProp: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineProperty(@as(*const IMetaDataEmit, @ptrCast(self)), td, szProperty, dwPropFlags, pvSig, cbSig, dwCPlusTypeFlag, pValue, cchValue, mdSetter, mdGetter, rmdOtherMethods, pmdProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineParam(self: *const T, md: u32, ulParamSeq: u32, szName: ?[*:0]align(1) const u16, dwParamFlags: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32, ppd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineParam(@as(*const IMetaDataEmit, @ptrCast(self)), md, ulParamSeq, szName, dwParamFlags, dwCPlusTypeFlag, pValue, cchValue, ppd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetFieldProps(self: *const T, fd: u32, dwFieldFlags: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetFieldProps(@as(*const IMetaDataEmit, @ptrCast(self)), fd, dwFieldFlags, dwCPlusTypeFlag, pValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetPropertyProps(self: *const T, pr: u32, dwPropFlags: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32, mdSetter: u32, mdGetter: u32, rmdOtherMethods: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetPropertyProps(@as(*const IMetaDataEmit, @ptrCast(self)), pr, dwPropFlags, dwCPlusTypeFlag, pValue, cchValue, mdSetter, mdGetter, rmdOtherMethods);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetParamProps(self: *const T, pd: u32, szName: ?[*:0]align(1) const u16, dwParamFlags: u32, dwCPlusTypeFlag: u32, pValue: ?*const anyopaque, cchValue: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetParamProps(@as(*const IMetaDataEmit, @ptrCast(self)), pd, szName, dwParamFlags, dwCPlusTypeFlag, pValue, cchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_DefineSecurityAttributeSet(self: *const T, tkObj: u32, rSecAttrs: ?*COR_SECATTR, cSecAttrs: u32, pulErrorAttr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).DefineSecurityAttributeSet(@as(*const IMetaDataEmit, @ptrCast(self)), tkObj, rSecAttrs, cSecAttrs, pulErrorAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_ApplyEditAndContinue(self: *const T, pImport: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).ApplyEditAndContinue(@as(*const IMetaDataEmit, @ptrCast(self)), pImport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_TranslateSigWithScope(self: *const T, pAssemImport: ?*IMetaDataAssemblyImport, pbHashValue: ?*const anyopaque, cbHashValue: u32, import: ?*IMetaDataImport, pbSigBlob: ?*u8, cbSigBlob: u32, pAssemEmit: ?*IMetaDataAssemblyEmit, emit: ?*IMetaDataEmit, pvTranslatedSig: ?*u8, cbTranslatedSigMax: u32, pcbTranslatedSig: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).TranslateSigWithScope(@as(*const IMetaDataEmit, @ptrCast(self)), pAssemImport, pbHashValue, cbHashValue, import, pbSigBlob, cbSigBlob, pAssemEmit, emit, pvTranslatedSig, cbTranslatedSigMax, pcbTranslatedSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetMethodImplFlags(self: *const T, md: u32, dwImplFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetMethodImplFlags(@as(*const IMetaDataEmit, @ptrCast(self)), md, dwImplFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_SetFieldRVA(self: *const T, fd: u32, ulRVA: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).SetFieldRVA(@as(*const IMetaDataEmit, @ptrCast(self)), fd, ulRVA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_Merge(self: *const T, pImport: ?*IMetaDataImport, pHostMapToken: ?*IMapToken, pHandler: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).Merge(@as(*const IMetaDataEmit, @ptrCast(self)), pImport, pHostMapToken, pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit_MergeEnd(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit.VTable, @ptrCast(self.vtable)).MergeEnd(@as(*const IMetaDataEmit, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataEmit2_Value = Guid.initString("f5dd9950-f693-42e6-830e-7b833e8146a9");
pub const IID_IMetaDataEmit2 = &IID_IMetaDataEmit2_Value;
pub const IMetaDataEmit2 = extern struct {
    pub const VTable = extern struct {
        base: IMetaDataEmit.VTable,
        DefineMethodSpec: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                tkParent: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmi: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                tkParent: u32,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmi: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeltaSaveSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                fSave: CorSaveSize,
                pdwSaveSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                fSave: CorSaveSize,
                pdwSaveSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveDelta: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                szFile: ?[*:0]align(1) const u16,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                szFile: ?[*:0]align(1) const u16,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveDeltaToStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                pIStream: ?*IStream,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                pIStream: ?*IStream,
                dwSaveFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveDeltaToMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                pbData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                pbData: ?*anyopaque,
                cbData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineGenericParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                tk: u32,
                ulParamSeq: u32,
                dwParamFlags: u32,
                szname: ?[*:0]align(1) const u16,
                reserved: u32,
                rtkConstraints: ?*u32,
                pgp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                tk: u32,
                ulParamSeq: u32,
                dwParamFlags: u32,
                szname: ?[*:0]align(1) const u16,
                reserved: u32,
                rtkConstraints: ?*u32,
                pgp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGenericParamProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
                gp: u32,
                dwParamFlags: u32,
                szName: ?[*:0]align(1) const u16,
                reserved: u32,
                rtkConstraints: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
                gp: u32,
                dwParamFlags: u32,
                szName: ?[*:0]align(1) const u16,
                reserved: u32,
                rtkConstraints: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetENCLog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataEmit2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataEmit2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMetaDataEmit.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_DefineMethodSpec(self: *const T, tkParent: u32, pvSigBlob: ?*u8, cbSigBlob: u32, pmi: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).DefineMethodSpec(@as(*const IMetaDataEmit2, @ptrCast(self)), tkParent, pvSigBlob, cbSigBlob, pmi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_GetDeltaSaveSize(self: *const T, fSave: CorSaveSize, pdwSaveSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).GetDeltaSaveSize(@as(*const IMetaDataEmit2, @ptrCast(self)), fSave, pdwSaveSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_SaveDelta(self: *const T, szFile: ?[*:0]align(1) const u16, dwSaveFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).SaveDelta(@as(*const IMetaDataEmit2, @ptrCast(self)), szFile, dwSaveFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_SaveDeltaToStream(self: *const T, pIStream: ?*IStream, dwSaveFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).SaveDeltaToStream(@as(*const IMetaDataEmit2, @ptrCast(self)), pIStream, dwSaveFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_SaveDeltaToMemory(self: *const T, pbData: ?*anyopaque, cbData: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).SaveDeltaToMemory(@as(*const IMetaDataEmit2, @ptrCast(self)), pbData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_DefineGenericParam(self: *const T, tk: u32, ulParamSeq: u32, dwParamFlags: u32, szname: ?[*:0]align(1) const u16, reserved: u32, rtkConstraints: ?*u32, pgp: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).DefineGenericParam(@as(*const IMetaDataEmit2, @ptrCast(self)), tk, ulParamSeq, dwParamFlags, szname, reserved, rtkConstraints, pgp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_SetGenericParamProps(self: *const T, gp: u32, dwParamFlags: u32, szName: ?[*:0]align(1) const u16, reserved: u32, rtkConstraints: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).SetGenericParamProps(@as(*const IMetaDataEmit2, @ptrCast(self)), gp, dwParamFlags, szName, reserved, rtkConstraints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataEmit2_ResetENCLog(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataEmit2.VTable, @ptrCast(self.vtable)).ResetENCLog(@as(*const IMetaDataEmit2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataImport_Value = Guid.initString("7dac8207-d3ae-4c75-9b67-92801a497d44");
pub const IID_IMetaDataImport = &IID_IMetaDataImport_Value;
pub const IMetaDataImport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CountEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
                ulPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                hEnum: ?*anyopaque,
                ulPos: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTypeDefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeDefs: ?*u32,
                cMax: u32,
                pcTypeDefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeDefs: ?*u32,
                cMax: u32,
                pcTypeDefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumInterfaceImpls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rImpls: ?*u32,
                cMax: u32,
                pcImpls: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rImpls: ?*u32,
                cMax: u32,
                pcImpls: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTypeRefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeRefs: ?*u32,
                cMax: u32,
                pcTypeRefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeRefs: ?*u32,
                cMax: u32,
                pcTypeRefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTypeDefByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                szTypeDef: ?[*:0]align(1) const u16,
                tkEnclosingClass: u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                szTypeDef: ?[*:0]align(1) const u16,
                tkEnclosingClass: u32,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pmvid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pmvid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleFromScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                pmd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeDefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                szTypeDef: ?[*:0]u16,
                cchTypeDef: u32,
                pchTypeDef: ?*u32,
                pdwTypeDefFlags: ?*u32,
                ptkExtends: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                szTypeDef: ?[*:0]u16,
                cchTypeDef: u32,
                pchTypeDef: ?*u32,
                pdwTypeDefFlags: ?*u32,
                ptkExtends: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterfaceImplProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                iiImpl: u32,
                pClass: ?*u32,
                ptkIface: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                iiImpl: u32,
                pClass: ?*u32,
                ptkIface: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tr: u32,
                ptkResolutionScope: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tr: u32,
                ptkResolutionScope: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResolveTypeRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tr: u32,
                riid: ?*const Guid,
                ppIScope: ?*?*IUnknown,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tr: u32,
                riid: ?*const Guid,
                ppIScope: ?*?*IUnknown,
                ptd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rMembers: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rMembers: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMembersWithName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rMembers: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rMembers: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMethods: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMethodsWithName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFields: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rFields: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                rFields: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFieldsWithName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rFields: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                cl: u32,
                szName: ?[*:0]align(1) const u16,
                rFields: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                mb: u32,
                rParams: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                mb: u32,
                rParams: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMemberRefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tkParent: u32,
                rMemberRefs: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tkParent: u32,
                rMemberRefs: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMethodImpls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rMethodBody: ?*u32,
                rMethodDecl: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rMethodBody: ?*u32,
                rMethodDecl: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPermissionSets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tk: u32,
                dwActions: u32,
                rPermission: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tk: u32,
                dwActions: u32,
                rPermission: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindMember: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindField: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindMemberRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                szName: ?[*:0]align(1) const u16,
                pvSigBlob: ?*u8,
                cbSigBlob: u32,
                pmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMethodProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szMethod: ?[*:0]u16,
                cchMethod: u32,
                pchMethod: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szMethod: ?[*:0]u16,
                cchMethod: u32,
                pchMethod: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mr: u32,
                ptk: ?*u32,
                szMember: ?[*:0]u16,
                cchMember: u32,
                pchMember: ?*u32,
                ppvSigBlob: ?*?*u8,
                pbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mr: u32,
                ptk: ?*u32,
                szMember: ?[*:0]u16,
                cchMember: u32,
                pchMember: ?*u32,
                ppvSigBlob: ?*?*u8,
                pbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rProperties: ?*u32,
                cMax: u32,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rProperties: ?*u32,
                cMax: u32,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rEvents: ?*u32,
                cMax: u32,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                td: u32,
                rEvents: ?*u32,
                cMax: u32,
                pcEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                ev: u32,
                pClass: ?*u32,
                szEvent: ?[*:0]align(1) const u16,
                cchEvent: u32,
                pchEvent: ?*u32,
                pdwEventFlags: ?*u32,
                ptkEventType: ?*u32,
                pmdAddOn: ?*u32,
                pmdRemoveOn: ?*u32,
                pmdFire: ?*u32,
                rmdOtherMethod: ?*u32,
                cMax: u32,
                pcOtherMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                ev: u32,
                pClass: ?*u32,
                szEvent: ?[*:0]align(1) const u16,
                cchEvent: u32,
                pchEvent: ?*u32,
                pdwEventFlags: ?*u32,
                ptkEventType: ?*u32,
                pmdAddOn: ?*u32,
                pmdRemoveOn: ?*u32,
                pmdFire: ?*u32,
                rmdOtherMethod: ?*u32,
                cMax: u32,
                pcOtherMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMethodSemantics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                mb: u32,
                rEventProp: ?*u32,
                cMax: u32,
                pcEventProp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                mb: u32,
                rEventProp: ?*u32,
                cMax: u32,
                pcEventProp: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMethodSemantics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mb: u32,
                tkEventProp: u32,
                pdwSemanticsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mb: u32,
                tkEventProp: u32,
                pdwSemanticsFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                td: u32,
                pdwPackSize: ?*u32,
                rFieldOffset: ?*COR_FIELD_OFFSET,
                cMax: u32,
                pcFieldOffset: ?*u32,
                pulClassSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                td: u32,
                pdwPackSize: ?*u32,
                rFieldOffset: ?*COR_FIELD_OFFSET,
                cMax: u32,
                pcFieldOffset: ?*u32,
                pulClassSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldMarshal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
                ppvNativeType: ?*?*u8,
                pcbNativeType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
                ppvNativeType: ?*?*u8,
                pcbNativeType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPermissionSetProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                pm: u32,
                pdwAction: ?*u32,
                ppvPermission: ?*const ?*anyopaque,
                pcbPermission: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                pm: u32,
                pdwAction: ?*u32,
                ppvPermission: ?*const ?*anyopaque,
                pcbPermission: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSigFromToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mdSig: u32,
                ppvSig: ?*?*u8,
                pcbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mdSig: u32,
                ppvSig: ?*?*u8,
                pcbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mur: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mur: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumModuleRefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rModuleRefs: ?*u32,
                cmax: u32,
                pcModuleRefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rModuleRefs: ?*u32,
                cmax: u32,
                pcModuleRefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSpecFromToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                typespec: u32,
                ppvSig: ?*?*u8,
                pcbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                typespec: u32,
                ppvSig: ?*?*u8,
                pcbSig: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameFromToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
                pszUtf8NamePtr: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
                pszUtf8NamePtr: ?*?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumUnresolvedMethods: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rMethods: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                stk: u32,
                szString: ?[*:0]u16,
                cchString: u32,
                pchString: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                stk: u32,
                szString: ?[*:0]u16,
                cchString: u32,
                pchString: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPinvokeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
                pdwMappingFlags: ?*u32,
                szImportName: ?[*:0]u16,
                cchImportName: u32,
                pchImportName: ?*u32,
                pmrImportDLL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
                pdwMappingFlags: ?*u32,
                szImportName: ?[*:0]u16,
                cchImportName: u32,
                pchImportName: ?*u32,
                pmrImportDLL: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumSignatures: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rSignatures: ?*u32,
                cmax: u32,
                pcSignatures: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rSignatures: ?*u32,
                cmax: u32,
                pcSignatures: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTypeSpecs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeSpecs: ?*u32,
                cmax: u32,
                pcTypeSpecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rTypeSpecs: ?*u32,
                cmax: u32,
                pcTypeSpecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumUserStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rStrings: ?*u32,
                cmax: u32,
                pcStrings: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                rStrings: ?*u32,
                cmax: u32,
                pcStrings: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParamForMethodIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                md: u32,
                ulParamSeq: u32,
                ppd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                md: u32,
                ulParamSeq: u32,
                ppd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCustomAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tk: u32,
                tkType: u32,
                rCustomAttributes: ?*u32,
                cMax: u32,
                pcCustomAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                phEnum: ?*?*anyopaque,
                tk: u32,
                tkType: u32,
                rCustomAttributes: ?*u32,
                cMax: u32,
                pcCustomAttributes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustomAttributeProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                cv: u32,
                ptkObj: ?*u32,
                ptkType: ?*u32,
                ppBlob: ?*const ?*anyopaque,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                cv: u32,
                ptkObj: ?*u32,
                ptkType: ?*u32,
                ppBlob: ?*const ?*anyopaque,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTypeRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tkResolutionScope: u32,
                szName: ?[*:0]align(1) const u16,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tkResolutionScope: u32,
                szName: ?[*:0]align(1) const u16,
                ptr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szMember: ?[*:0]u16,
                cchMember: u32,
                pchMember: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szMember: ?[*:0]u16,
                cchMember: u32,
                pchMember: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pulCodeRVA: ?*u32,
                pdwImplFlags: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szField: ?[*:0]u16,
                cchField: u32,
                pchField: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                mb: u32,
                pClass: ?*u32,
                szField: ?[*:0]u16,
                cchField: u32,
                pchField: ?*u32,
                pdwAttr: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                prop: u32,
                pClass: ?*u32,
                szProperty: ?[*:0]align(1) const u16,
                cchProperty: u32,
                pchProperty: ?*u32,
                pdwPropFlags: ?*u32,
                ppvSig: ?*?*u8,
                pbSig: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppDefaultValue: ?*?*anyopaque,
                pcchDefaultValue: ?*u32,
                pmdSetter: ?*u32,
                pmdGetter: ?*u32,
                rmdOtherMethod: ?*u32,
                cMax: u32,
                pcOtherMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                prop: u32,
                pClass: ?*u32,
                szProperty: ?[*:0]align(1) const u16,
                cchProperty: u32,
                pchProperty: ?*u32,
                pdwPropFlags: ?*u32,
                ppvSig: ?*?*u8,
                pbSig: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppDefaultValue: ?*?*anyopaque,
                pcchDefaultValue: ?*u32,
                pmdSetter: ?*u32,
                pmdGetter: ?*u32,
                rmdOtherMethod: ?*u32,
                cMax: u32,
                pcOtherMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParamProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
                pmd: ?*u32,
                pulSequence: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pdwAttr: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
                pmd: ?*u32,
                pulSequence: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pdwAttr: ?*u32,
                pdwCPlusTypeFlag: ?*u32,
                ppValue: ?*?*anyopaque,
                pcchValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCustomAttributeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tkObj: u32,
                szName: ?[*:0]align(1) const u16,
                ppData: ?*const ?*anyopaque,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tkObj: u32,
                szName: ?[*:0]align(1) const u16,
                ppData: ?*const ?*anyopaque,
                pcbData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsValidToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IMetaDataImport,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        GetNestedClassProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                tdNestedClass: u32,
                ptdEnclosingClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                tdNestedClass: u32,
                ptdEnclosingClass: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNativeCallConvFromSig: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                pvSig: ?*const anyopaque,
                cbSig: u32,
                pCallConv: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                pvSig: ?*const anyopaque,
                cbSig: u32,
                pCallConv: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsGlobal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport,
                pd: u32,
                pbGlobal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport,
                pd: u32,
                pbGlobal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_CloseEnum(self: *const T, hEnum: ?*anyopaque) callconv(.Inline) void {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).CloseEnum(@as(*const IMetaDataImport, @ptrCast(self)), hEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_CountEnum(self: *const T, hEnum: ?*anyopaque, pulCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).CountEnum(@as(*const IMetaDataImport, @ptrCast(self)), hEnum, pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_ResetEnum(self: *const T, hEnum: ?*anyopaque, ulPos: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).ResetEnum(@as(*const IMetaDataImport, @ptrCast(self)), hEnum, ulPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumTypeDefs(self: *const T, phEnum: ?*?*anyopaque, rTypeDefs: ?*u32, cMax: u32, pcTypeDefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumTypeDefs(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rTypeDefs, cMax, pcTypeDefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumInterfaceImpls(self: *const T, phEnum: ?*?*anyopaque, td: u32, rImpls: ?*u32, cMax: u32, pcImpls: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumInterfaceImpls(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, td, rImpls, cMax, pcImpls);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumTypeRefs(self: *const T, phEnum: ?*?*anyopaque, rTypeRefs: ?*u32, cMax: u32, pcTypeRefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumTypeRefs(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rTypeRefs, cMax, pcTypeRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindTypeDefByName(self: *const T, szTypeDef: ?[*:0]align(1) const u16, tkEnclosingClass: u32, ptd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindTypeDefByName(@as(*const IMetaDataImport, @ptrCast(self)), szTypeDef, tkEnclosingClass, ptd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetScopeProps(self: *const T, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, pmvid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetScopeProps(@as(*const IMetaDataImport, @ptrCast(self)), szName, cchName, pchName, pmvid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetModuleFromScope(self: *const T, pmd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetModuleFromScope(@as(*const IMetaDataImport, @ptrCast(self)), pmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetTypeDefProps(self: *const T, td: u32, szTypeDef: ?[*:0]u16, cchTypeDef: u32, pchTypeDef: ?*u32, pdwTypeDefFlags: ?*u32, ptkExtends: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetTypeDefProps(@as(*const IMetaDataImport, @ptrCast(self)), td, szTypeDef, cchTypeDef, pchTypeDef, pdwTypeDefFlags, ptkExtends);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetInterfaceImplProps(self: *const T, iiImpl: u32, pClass: ?*u32, ptkIface: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetInterfaceImplProps(@as(*const IMetaDataImport, @ptrCast(self)), iiImpl, pClass, ptkIface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetTypeRefProps(self: *const T, tr: u32, ptkResolutionScope: ?*u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetTypeRefProps(@as(*const IMetaDataImport, @ptrCast(self)), tr, ptkResolutionScope, szName, cchName, pchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_ResolveTypeRef(self: *const T, tr: u32, riid: ?*const Guid, ppIScope: ?*?*IUnknown, ptd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).ResolveTypeRef(@as(*const IMetaDataImport, @ptrCast(self)), tr, riid, ppIScope, ptd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMembers(self: *const T, phEnum: ?*?*anyopaque, cl: u32, rMembers: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMembers(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, rMembers, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMembersWithName(self: *const T, phEnum: ?*?*anyopaque, cl: u32, szName: ?[*:0]align(1) const u16, rMembers: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMembersWithName(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, szName, rMembers, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMethods(self: *const T, phEnum: ?*?*anyopaque, cl: u32, rMethods: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMethods(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, rMethods, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMethodsWithName(self: *const T, phEnum: ?*?*anyopaque, cl: u32, szName: ?[*:0]align(1) const u16, rMethods: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMethodsWithName(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, szName, rMethods, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumFields(self: *const T, phEnum: ?*?*anyopaque, cl: u32, rFields: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumFields(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, rFields, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumFieldsWithName(self: *const T, phEnum: ?*?*anyopaque, cl: u32, szName: ?[*:0]align(1) const u16, rFields: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumFieldsWithName(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, cl, szName, rFields, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumParams(self: *const T, phEnum: ?*?*anyopaque, mb: u32, rParams: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumParams(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, mb, rParams, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMemberRefs(self: *const T, phEnum: ?*?*anyopaque, tkParent: u32, rMemberRefs: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMemberRefs(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, tkParent, rMemberRefs, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMethodImpls(self: *const T, phEnum: ?*?*anyopaque, td: u32, rMethodBody: ?*u32, rMethodDecl: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMethodImpls(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, td, rMethodBody, rMethodDecl, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumPermissionSets(self: *const T, phEnum: ?*?*anyopaque, tk: u32, dwActions: u32, rPermission: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumPermissionSets(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, tk, dwActions, rPermission, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindMember(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, pvSigBlob: ?*u8, cbSigBlob: u32, pmb: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindMember(@as(*const IMetaDataImport, @ptrCast(self)), td, szName, pvSigBlob, cbSigBlob, pmb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindMethod(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, pvSigBlob: ?*u8, cbSigBlob: u32, pmb: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindMethod(@as(*const IMetaDataImport, @ptrCast(self)), td, szName, pvSigBlob, cbSigBlob, pmb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindField(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, pvSigBlob: ?*u8, cbSigBlob: u32, pmb: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindField(@as(*const IMetaDataImport, @ptrCast(self)), td, szName, pvSigBlob, cbSigBlob, pmb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindMemberRef(self: *const T, td: u32, szName: ?[*:0]align(1) const u16, pvSigBlob: ?*u8, cbSigBlob: u32, pmr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindMemberRef(@as(*const IMetaDataImport, @ptrCast(self)), td, szName, pvSigBlob, cbSigBlob, pmr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetMethodProps(self: *const T, mb: u32, pClass: ?*u32, szMethod: ?[*:0]u16, cchMethod: u32, pchMethod: ?*u32, pdwAttr: ?*u32, ppvSigBlob: ?*?*u8, pcbSigBlob: ?*u32, pulCodeRVA: ?*u32, pdwImplFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetMethodProps(@as(*const IMetaDataImport, @ptrCast(self)), mb, pClass, szMethod, cchMethod, pchMethod, pdwAttr, ppvSigBlob, pcbSigBlob, pulCodeRVA, pdwImplFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetMemberRefProps(self: *const T, mr: u32, ptk: ?*u32, szMember: ?[*:0]u16, cchMember: u32, pchMember: ?*u32, ppvSigBlob: ?*?*u8, pbSig: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetMemberRefProps(@as(*const IMetaDataImport, @ptrCast(self)), mr, ptk, szMember, cchMember, pchMember, ppvSigBlob, pbSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumProperties(self: *const T, phEnum: ?*?*anyopaque, td: u32, rProperties: ?*u32, cMax: u32, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumProperties(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, td, rProperties, cMax, pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumEvents(self: *const T, phEnum: ?*?*anyopaque, td: u32, rEvents: ?*u32, cMax: u32, pcEvents: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumEvents(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, td, rEvents, cMax, pcEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetEventProps(self: *const T, ev: u32, pClass: ?*u32, szEvent: ?[*:0]align(1) const u16, cchEvent: u32, pchEvent: ?*u32, pdwEventFlags: ?*u32, ptkEventType: ?*u32, pmdAddOn: ?*u32, pmdRemoveOn: ?*u32, pmdFire: ?*u32, rmdOtherMethod: ?*u32, cMax: u32, pcOtherMethod: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetEventProps(@as(*const IMetaDataImport, @ptrCast(self)), ev, pClass, szEvent, cchEvent, pchEvent, pdwEventFlags, ptkEventType, pmdAddOn, pmdRemoveOn, pmdFire, rmdOtherMethod, cMax, pcOtherMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumMethodSemantics(self: *const T, phEnum: ?*?*anyopaque, mb: u32, rEventProp: ?*u32, cMax: u32, pcEventProp: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumMethodSemantics(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, mb, rEventProp, cMax, pcEventProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetMethodSemantics(self: *const T, mb: u32, tkEventProp: u32, pdwSemanticsFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetMethodSemantics(@as(*const IMetaDataImport, @ptrCast(self)), mb, tkEventProp, pdwSemanticsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetClassLayout(self: *const T, td: u32, pdwPackSize: ?*u32, rFieldOffset: ?*COR_FIELD_OFFSET, cMax: u32, pcFieldOffset: ?*u32, pulClassSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetClassLayout(@as(*const IMetaDataImport, @ptrCast(self)), td, pdwPackSize, rFieldOffset, cMax, pcFieldOffset, pulClassSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetFieldMarshal(self: *const T, tk: u32, ppvNativeType: ?*?*u8, pcbNativeType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetFieldMarshal(@as(*const IMetaDataImport, @ptrCast(self)), tk, ppvNativeType, pcbNativeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetRVA(self: *const T, tk: u32, pulCodeRVA: ?*u32, pdwImplFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetRVA(@as(*const IMetaDataImport, @ptrCast(self)), tk, pulCodeRVA, pdwImplFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetPermissionSetProps(self: *const T, pm: u32, pdwAction: ?*u32, ppvPermission: ?*const ?*anyopaque, pcbPermission: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetPermissionSetProps(@as(*const IMetaDataImport, @ptrCast(self)), pm, pdwAction, ppvPermission, pcbPermission);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetSigFromToken(self: *const T, mdSig: u32, ppvSig: ?*?*u8, pcbSig: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetSigFromToken(@as(*const IMetaDataImport, @ptrCast(self)), mdSig, ppvSig, pcbSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetModuleRefProps(self: *const T, mur: u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetModuleRefProps(@as(*const IMetaDataImport, @ptrCast(self)), mur, szName, cchName, pchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumModuleRefs(self: *const T, phEnum: ?*?*anyopaque, rModuleRefs: ?*u32, cmax: u32, pcModuleRefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumModuleRefs(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rModuleRefs, cmax, pcModuleRefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetTypeSpecFromToken(self: *const T, typespec: u32, ppvSig: ?*?*u8, pcbSig: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetTypeSpecFromToken(@as(*const IMetaDataImport, @ptrCast(self)), typespec, ppvSig, pcbSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetNameFromToken(self: *const T, tk: u32, pszUtf8NamePtr: ?*?*i8) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetNameFromToken(@as(*const IMetaDataImport, @ptrCast(self)), tk, pszUtf8NamePtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumUnresolvedMethods(self: *const T, phEnum: ?*?*anyopaque, rMethods: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumUnresolvedMethods(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rMethods, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetUserString(self: *const T, stk: u32, szString: ?[*:0]u16, cchString: u32, pchString: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetUserString(@as(*const IMetaDataImport, @ptrCast(self)), stk, szString, cchString, pchString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetPinvokeMap(self: *const T, tk: u32, pdwMappingFlags: ?*u32, szImportName: ?[*:0]u16, cchImportName: u32, pchImportName: ?*u32, pmrImportDLL: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetPinvokeMap(@as(*const IMetaDataImport, @ptrCast(self)), tk, pdwMappingFlags, szImportName, cchImportName, pchImportName, pmrImportDLL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumSignatures(self: *const T, phEnum: ?*?*anyopaque, rSignatures: ?*u32, cmax: u32, pcSignatures: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumSignatures(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rSignatures, cmax, pcSignatures);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumTypeSpecs(self: *const T, phEnum: ?*?*anyopaque, rTypeSpecs: ?*u32, cmax: u32, pcTypeSpecs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumTypeSpecs(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rTypeSpecs, cmax, pcTypeSpecs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumUserStrings(self: *const T, phEnum: ?*?*anyopaque, rStrings: ?*u32, cmax: u32, pcStrings: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumUserStrings(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, rStrings, cmax, pcStrings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetParamForMethodIndex(self: *const T, md: u32, ulParamSeq: u32, ppd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetParamForMethodIndex(@as(*const IMetaDataImport, @ptrCast(self)), md, ulParamSeq, ppd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_EnumCustomAttributes(self: *const T, phEnum: ?*?*anyopaque, tk: u32, tkType: u32, rCustomAttributes: ?*u32, cMax: u32, pcCustomAttributes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).EnumCustomAttributes(@as(*const IMetaDataImport, @ptrCast(self)), phEnum, tk, tkType, rCustomAttributes, cMax, pcCustomAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetCustomAttributeProps(self: *const T, cv: u32, ptkObj: ?*u32, ptkType: ?*u32, ppBlob: ?*const ?*anyopaque, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetCustomAttributeProps(@as(*const IMetaDataImport, @ptrCast(self)), cv, ptkObj, ptkType, ppBlob, pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_FindTypeRef(self: *const T, tkResolutionScope: u32, szName: ?[*:0]align(1) const u16, ptr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).FindTypeRef(@as(*const IMetaDataImport, @ptrCast(self)), tkResolutionScope, szName, ptr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetMemberProps(self: *const T, mb: u32, pClass: ?*u32, szMember: ?[*:0]u16, cchMember: u32, pchMember: ?*u32, pdwAttr: ?*u32, ppvSigBlob: ?*?*u8, pcbSigBlob: ?*u32, pulCodeRVA: ?*u32, pdwImplFlags: ?*u32, pdwCPlusTypeFlag: ?*u32, ppValue: ?*?*anyopaque, pcchValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetMemberProps(@as(*const IMetaDataImport, @ptrCast(self)), mb, pClass, szMember, cchMember, pchMember, pdwAttr, ppvSigBlob, pcbSigBlob, pulCodeRVA, pdwImplFlags, pdwCPlusTypeFlag, ppValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetFieldProps(self: *const T, mb: u32, pClass: ?*u32, szField: ?[*:0]u16, cchField: u32, pchField: ?*u32, pdwAttr: ?*u32, ppvSigBlob: ?*?*u8, pcbSigBlob: ?*u32, pdwCPlusTypeFlag: ?*u32, ppValue: ?*?*anyopaque, pcchValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetFieldProps(@as(*const IMetaDataImport, @ptrCast(self)), mb, pClass, szField, cchField, pchField, pdwAttr, ppvSigBlob, pcbSigBlob, pdwCPlusTypeFlag, ppValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetPropertyProps(self: *const T, prop: u32, pClass: ?*u32, szProperty: ?[*:0]align(1) const u16, cchProperty: u32, pchProperty: ?*u32, pdwPropFlags: ?*u32, ppvSig: ?*?*u8, pbSig: ?*u32, pdwCPlusTypeFlag: ?*u32, ppDefaultValue: ?*?*anyopaque, pcchDefaultValue: ?*u32, pmdSetter: ?*u32, pmdGetter: ?*u32, rmdOtherMethod: ?*u32, cMax: u32, pcOtherMethod: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetPropertyProps(@as(*const IMetaDataImport, @ptrCast(self)), prop, pClass, szProperty, cchProperty, pchProperty, pdwPropFlags, ppvSig, pbSig, pdwCPlusTypeFlag, ppDefaultValue, pcchDefaultValue, pmdSetter, pmdGetter, rmdOtherMethod, cMax, pcOtherMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetParamProps(self: *const T, tk: u32, pmd: ?*u32, pulSequence: ?*u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, pdwAttr: ?*u32, pdwCPlusTypeFlag: ?*u32, ppValue: ?*?*anyopaque, pcchValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetParamProps(@as(*const IMetaDataImport, @ptrCast(self)), tk, pmd, pulSequence, szName, cchName, pchName, pdwAttr, pdwCPlusTypeFlag, ppValue, pcchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetCustomAttributeByName(self: *const T, tkObj: u32, szName: ?[*:0]align(1) const u16, ppData: ?*const ?*anyopaque, pcbData: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetCustomAttributeByName(@as(*const IMetaDataImport, @ptrCast(self)), tkObj, szName, ppData, pcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_IsValidToken(self: *const T, tk: u32) callconv(.Inline) BOOL {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).IsValidToken(@as(*const IMetaDataImport, @ptrCast(self)), tk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetNestedClassProps(self: *const T, tdNestedClass: u32, ptdEnclosingClass: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetNestedClassProps(@as(*const IMetaDataImport, @ptrCast(self)), tdNestedClass, ptdEnclosingClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_GetNativeCallConvFromSig(self: *const T, pvSig: ?*const anyopaque, cbSig: u32, pCallConv: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).GetNativeCallConvFromSig(@as(*const IMetaDataImport, @ptrCast(self)), pvSig, cbSig, pCallConv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport_IsGlobal(self: *const T, pd: u32, pbGlobal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport.VTable, @ptrCast(self.vtable)).IsGlobal(@as(*const IMetaDataImport, @ptrCast(self)), pd, pbGlobal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataImport2_Value = Guid.initString("fce5efa0-8bba-4f8e-a036-8f2022b08466");
pub const IID_IMetaDataImport2 = &IID_IMetaDataImport2_Value;
pub const IMetaDataImport2 = extern struct {
    pub const VTable = extern struct {
        base: IMetaDataImport.VTable,
        EnumGenericParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rGenericParams: ?*u32,
                cMax: u32,
                pcGenericParams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rGenericParams: ?*u32,
                cMax: u32,
                pcGenericParams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericParamProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                gp: u32,
                pulParamSeq: ?*u32,
                pdwParamFlags: ?*u32,
                ptOwner: ?*u32,
                reserved: ?*u32,
                wzname: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                gp: u32,
                pulParamSeq: ?*u32,
                pdwParamFlags: ?*u32,
                ptOwner: ?*u32,
                reserved: ?*u32,
                wzname: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMethodSpecProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                mi: u32,
                tkParent: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                mi: u32,
                tkParent: ?*u32,
                ppvSigBlob: ?*?*u8,
                pcbSigBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumGenericParamConstraints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rGenericParamConstraints: ?*u32,
                cMax: u32,
                pcGenericParamConstraints: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rGenericParamConstraints: ?*u32,
                cMax: u32,
                pcGenericParamConstraints: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericParamConstraintProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                gpc: u32,
                ptGenericParam: ?*u32,
                ptkConstraintType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                gpc: u32,
                ptGenericParam: ?*u32,
                ptkConstraintType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPEKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                pdwPEKind: ?*u32,
                pdwMAchine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                pdwPEKind: ?*u32,
                pdwMAchine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                pwzBuf: ?[*:0]u16,
                ccBufSize: u32,
                pccBufSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                pwzBuf: ?[*:0]u16,
                ccBufSize: u32,
                pccBufSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMethodSpecs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rMethodSpecs: ?*u32,
                cMax: u32,
                pcMethodSpecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataImport2,
                phEnum: ?*?*anyopaque,
                tk: u32,
                rMethodSpecs: ?*u32,
                cMax: u32,
                pcMethodSpecs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMetaDataImport.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_EnumGenericParams(self: *const T, phEnum: ?*?*anyopaque, tk: u32, rGenericParams: ?*u32, cMax: u32, pcGenericParams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).EnumGenericParams(@as(*const IMetaDataImport2, @ptrCast(self)), phEnum, tk, rGenericParams, cMax, pcGenericParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_GetGenericParamProps(self: *const T, gp: u32, pulParamSeq: ?*u32, pdwParamFlags: ?*u32, ptOwner: ?*u32, reserved: ?*u32, wzname: ?[*:0]u16, cchName: u32, pchName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).GetGenericParamProps(@as(*const IMetaDataImport2, @ptrCast(self)), gp, pulParamSeq, pdwParamFlags, ptOwner, reserved, wzname, cchName, pchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_GetMethodSpecProps(self: *const T, mi: u32, tkParent: ?*u32, ppvSigBlob: ?*?*u8, pcbSigBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).GetMethodSpecProps(@as(*const IMetaDataImport2, @ptrCast(self)), mi, tkParent, ppvSigBlob, pcbSigBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_EnumGenericParamConstraints(self: *const T, phEnum: ?*?*anyopaque, tk: u32, rGenericParamConstraints: ?*u32, cMax: u32, pcGenericParamConstraints: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).EnumGenericParamConstraints(@as(*const IMetaDataImport2, @ptrCast(self)), phEnum, tk, rGenericParamConstraints, cMax, pcGenericParamConstraints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_GetGenericParamConstraintProps(self: *const T, gpc: u32, ptGenericParam: ?*u32, ptkConstraintType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).GetGenericParamConstraintProps(@as(*const IMetaDataImport2, @ptrCast(self)), gpc, ptGenericParam, ptkConstraintType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_GetPEKind(self: *const T, pdwPEKind: ?*u32, pdwMAchine: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).GetPEKind(@as(*const IMetaDataImport2, @ptrCast(self)), pdwPEKind, pdwMAchine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_GetVersionString(self: *const T, pwzBuf: ?[*:0]u16, ccBufSize: u32, pccBufSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).GetVersionString(@as(*const IMetaDataImport2, @ptrCast(self)), pwzBuf, ccBufSize, pccBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataImport2_EnumMethodSpecs(self: *const T, phEnum: ?*?*anyopaque, tk: u32, rMethodSpecs: ?*u32, cMax: u32, pcMethodSpecs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataImport2.VTable, @ptrCast(self.vtable)).EnumMethodSpecs(@as(*const IMetaDataImport2, @ptrCast(self)), phEnum, tk, rMethodSpecs, cMax, pcMethodSpecs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataFilter_Value = Guid.initString("d0e80dd1-12d4-11d3-b39d-00c04ff81795");
pub const IID_IMetaDataFilter = &IID_IMetaDataFilter_Value;
pub const IMetaDataFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UnmarkAll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MarkToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataFilter,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataFilter,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTokenMarked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataFilter,
                tk: u32,
                pIsMarked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataFilter,
                tk: u32,
                pIsMarked: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataFilter_UnmarkAll(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataFilter.VTable, @ptrCast(self.vtable)).UnmarkAll(@as(*const IMetaDataFilter, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataFilter_MarkToken(self: *const T, tk: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataFilter.VTable, @ptrCast(self.vtable)).MarkToken(@as(*const IMetaDataFilter, @ptrCast(self)), tk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataFilter_IsTokenMarked(self: *const T, tk: u32, pIsMarked: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataFilter.VTable, @ptrCast(self.vtable)).IsTokenMarked(@as(*const IMetaDataFilter, @ptrCast(self)), tk, pIsMarked);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostFilter_Value = Guid.initString("d0e80dd3-12d4-11d3-b39d-00c04ff81795");
pub const IID_IHostFilter = &IID_IHostFilter_Value;
pub const IHostFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MarkToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostFilter,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostFilter,
                tk: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostFilter_MarkToken(self: *const T, tk: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostFilter.VTable, @ptrCast(self.vtable)).MarkToken(@as(*const IHostFilter, @ptrCast(self)), tk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OSINFO = extern struct {
    dwOSPlatformId: u32,
    dwOSMajorVersion: u32,
    dwOSMinorVersion: u32,
};

pub const ASSEMBLYMETADATA = extern struct {
    usMajorVersion: u16,
    usMinorVersion: u16,
    usBuildNumber: u16,
    usRevisionNumber: u16,
    szLocale: ?PWSTR,
    cbLocale: u32,
    rProcessor: ?*u32,
    ulProcessor: u32,
    rOS: ?*OSINFO,
    ulOS: u32,
};

const IID_IMetaDataAssemblyEmit_Value = Guid.initString("211ef15b-5317-4438-b196-dec87b887693");
pub const IID_IMetaDataAssemblyEmit = &IID_IMetaDataAssemblyEmit_Value;
pub const IMetaDataAssemblyEmit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DefineAssembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                pbPublicKey: ?*const anyopaque,
                cbPublicKey: u32,
                ulHashAlgId: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                dwAssemblyFlags: u32,
                pma: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                pbPublicKey: ?*const anyopaque,
                cbPublicKey: u32,
                ulHashAlgId: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                dwAssemblyFlags: u32,
                pma: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineAssemblyRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                pbPublicKeyOrToken: ?*const anyopaque,
                cbPublicKeyOrToken: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwAssemblyRefFlags: u32,
                pmdar: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                pbPublicKeyOrToken: ?*const anyopaque,
                cbPublicKeyOrToken: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwAssemblyRefFlags: u32,
                pmdar: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwFileFlags: u32,
                pmdf: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwFileFlags: u32,
                pmdf: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineExportedType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                tkImplementation: u32,
                tkTypeDef: u32,
                dwExportedTypeFlags: u32,
                pmdct: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                tkImplementation: u32,
                tkTypeDef: u32,
                dwExportedTypeFlags: u32,
                pmdct: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineManifestResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                tkImplementation: u32,
                dwOffset: u32,
                dwResourceFlags: u32,
                pmdmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                szName: ?[*:0]align(1) const u16,
                tkImplementation: u32,
                dwOffset: u32,
                dwResourceFlags: u32,
                pmdmr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                pma: u32,
                pbPublicKey: ?*const anyopaque,
                cbPublicKey: u32,
                ulHashAlgId: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                dwAssemblyFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                pma: u32,
                pbPublicKey: ?*const anyopaque,
                cbPublicKey: u32,
                ulHashAlgId: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                dwAssemblyFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                ar: u32,
                pbPublicKeyOrToken: ?*const anyopaque,
                cbPublicKeyOrToken: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwAssemblyRefFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                ar: u32,
                pbPublicKeyOrToken: ?*const anyopaque,
                cbPublicKeyOrToken: u32,
                szName: ?[*:0]align(1) const u16,
                pMetaData: ?*const ASSEMBLYMETADATA,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwAssemblyRefFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFileProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                file: u32,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwFileFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                file: u32,
                pbHashValue: ?*const anyopaque,
                cbHashValue: u32,
                dwFileFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExportedTypeProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                ct: u32,
                tkImplementation: u32,
                tkTypeDef: u32,
                dwExportedTypeFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                ct: u32,
                tkImplementation: u32,
                tkTypeDef: u32,
                dwExportedTypeFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetManifestResourceProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyEmit,
                mr: u32,
                tkImplementation: u32,
                dwOffset: u32,
                dwResourceFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyEmit,
                mr: u32,
                tkImplementation: u32,
                dwOffset: u32,
                dwResourceFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_DefineAssembly(self: *const T, pbPublicKey: ?*const anyopaque, cbPublicKey: u32, ulHashAlgId: u32, szName: ?[*:0]align(1) const u16, pMetaData: ?*const ASSEMBLYMETADATA, dwAssemblyFlags: u32, pma: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).DefineAssembly(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), pbPublicKey, cbPublicKey, ulHashAlgId, szName, pMetaData, dwAssemblyFlags, pma);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_DefineAssemblyRef(self: *const T, pbPublicKeyOrToken: ?*const anyopaque, cbPublicKeyOrToken: u32, szName: ?[*:0]align(1) const u16, pMetaData: ?*const ASSEMBLYMETADATA, pbHashValue: ?*const anyopaque, cbHashValue: u32, dwAssemblyRefFlags: u32, pmdar: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).DefineAssemblyRef(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), pbPublicKeyOrToken, cbPublicKeyOrToken, szName, pMetaData, pbHashValue, cbHashValue, dwAssemblyRefFlags, pmdar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_DefineFile(self: *const T, szName: ?[*:0]align(1) const u16, pbHashValue: ?*const anyopaque, cbHashValue: u32, dwFileFlags: u32, pmdf: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).DefineFile(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), szName, pbHashValue, cbHashValue, dwFileFlags, pmdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_DefineExportedType(self: *const T, szName: ?[*:0]align(1) const u16, tkImplementation: u32, tkTypeDef: u32, dwExportedTypeFlags: u32, pmdct: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).DefineExportedType(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), szName, tkImplementation, tkTypeDef, dwExportedTypeFlags, pmdct);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_DefineManifestResource(self: *const T, szName: ?[*:0]align(1) const u16, tkImplementation: u32, dwOffset: u32, dwResourceFlags: u32, pmdmr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).DefineManifestResource(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), szName, tkImplementation, dwOffset, dwResourceFlags, pmdmr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_SetAssemblyProps(self: *const T, pma: u32, pbPublicKey: ?*const anyopaque, cbPublicKey: u32, ulHashAlgId: u32, szName: ?[*:0]align(1) const u16, pMetaData: ?*const ASSEMBLYMETADATA, dwAssemblyFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).SetAssemblyProps(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), pma, pbPublicKey, cbPublicKey, ulHashAlgId, szName, pMetaData, dwAssemblyFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_SetAssemblyRefProps(self: *const T, ar: u32, pbPublicKeyOrToken: ?*const anyopaque, cbPublicKeyOrToken: u32, szName: ?[*:0]align(1) const u16, pMetaData: ?*const ASSEMBLYMETADATA, pbHashValue: ?*const anyopaque, cbHashValue: u32, dwAssemblyRefFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).SetAssemblyRefProps(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), ar, pbPublicKeyOrToken, cbPublicKeyOrToken, szName, pMetaData, pbHashValue, cbHashValue, dwAssemblyRefFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_SetFileProps(self: *const T, file: u32, pbHashValue: ?*const anyopaque, cbHashValue: u32, dwFileFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).SetFileProps(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), file, pbHashValue, cbHashValue, dwFileFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_SetExportedTypeProps(self: *const T, ct: u32, tkImplementation: u32, tkTypeDef: u32, dwExportedTypeFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).SetExportedTypeProps(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), ct, tkImplementation, tkTypeDef, dwExportedTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyEmit_SetManifestResourceProps(self: *const T, mr: u32, tkImplementation: u32, dwOffset: u32, dwResourceFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyEmit.VTable, @ptrCast(self.vtable)).SetManifestResourceProps(@as(*const IMetaDataAssemblyEmit, @ptrCast(self)), mr, tkImplementation, dwOffset, dwResourceFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataAssemblyImport_Value = Guid.initString("ee62470b-e94b-424e-9b7c-2f00c9249f93");
pub const IID_IMetaDataAssemblyImport = &IID_IMetaDataAssemblyImport_Value;
pub const IMetaDataAssemblyImport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAssemblyProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                mda: u32,
                ppbPublicKey: ?*const ?*anyopaque,
                pcbPublicKey: ?*u32,
                pulHashAlgId: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pMetaData: ?*ASSEMBLYMETADATA,
                pdwAssemblyFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                mda: u32,
                ppbPublicKey: ?*const ?*anyopaque,
                pcbPublicKey: ?*u32,
                pulHashAlgId: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pMetaData: ?*ASSEMBLYMETADATA,
                pdwAssemblyFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                mdar: u32,
                ppbPublicKeyOrToken: ?*const ?*anyopaque,
                pcbPublicKeyOrToken: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pMetaData: ?*ASSEMBLYMETADATA,
                ppbHashValue: ?*const ?*anyopaque,
                pcbHashValue: ?*u32,
                pdwAssemblyRefFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                mdar: u32,
                ppbPublicKeyOrToken: ?*const ?*anyopaque,
                pcbPublicKeyOrToken: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                pMetaData: ?*ASSEMBLYMETADATA,
                ppbHashValue: ?*const ?*anyopaque,
                pcbHashValue: ?*u32,
                pdwAssemblyRefFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                mdf: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ppbHashValue: ?*const ?*anyopaque,
                pcbHashValue: ?*u32,
                pdwFileFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                mdf: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ppbHashValue: ?*const ?*anyopaque,
                pcbHashValue: ?*u32,
                pdwFileFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExportedTypeProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                mdct: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ptkImplementation: ?*u32,
                ptkTypeDef: ?*u32,
                pdwExportedTypeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                mdct: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ptkImplementation: ?*u32,
                ptkTypeDef: ?*u32,
                pdwExportedTypeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManifestResourceProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                mdmr: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ptkImplementation: ?*u32,
                pdwOffset: ?*u32,
                pdwResourceFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                mdmr: u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
                ptkImplementation: ?*u32,
                pdwOffset: ?*u32,
                pdwResourceFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAssemblyRefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rAssemblyRefs: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rAssemblyRefs: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rFiles: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rFiles: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumExportedTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rExportedTypes: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rExportedTypes: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumManifestResources: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rManifestResources: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                phEnum: ?*?*anyopaque,
                rManifestResources: ?*u32,
                cMax: u32,
                pcTokens: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyFromScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                ptkAssembly: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                ptkAssembly: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindExportedTypeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                szName: ?[*:0]align(1) const u16,
                mdtExportedType: u32,
                ptkExportedType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                szName: ?[*:0]align(1) const u16,
                mdtExportedType: u32,
                ptkExportedType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindManifestResourceByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                szName: ?[*:0]align(1) const u16,
                ptkManifestResource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                szName: ?[*:0]align(1) const u16,
                ptkManifestResource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        FindAssembliesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataAssemblyImport,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                ppIUnk: ?*?*IUnknown,
                cMax: u32,
                pcAssemblies: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataAssemblyImport,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                ppIUnk: ?*?*IUnknown,
                cMax: u32,
                pcAssemblies: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetAssemblyProps(self: *const T, mda: u32, ppbPublicKey: ?*const ?*anyopaque, pcbPublicKey: ?*u32, pulHashAlgId: ?*u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, pMetaData: ?*ASSEMBLYMETADATA, pdwAssemblyFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetAssemblyProps(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), mda, ppbPublicKey, pcbPublicKey, pulHashAlgId, szName, cchName, pchName, pMetaData, pdwAssemblyFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetAssemblyRefProps(self: *const T, mdar: u32, ppbPublicKeyOrToken: ?*const ?*anyopaque, pcbPublicKeyOrToken: ?*u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, pMetaData: ?*ASSEMBLYMETADATA, ppbHashValue: ?*const ?*anyopaque, pcbHashValue: ?*u32, pdwAssemblyRefFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetAssemblyRefProps(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), mdar, ppbPublicKeyOrToken, pcbPublicKeyOrToken, szName, cchName, pchName, pMetaData, ppbHashValue, pcbHashValue, pdwAssemblyRefFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetFileProps(self: *const T, mdf: u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, ppbHashValue: ?*const ?*anyopaque, pcbHashValue: ?*u32, pdwFileFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetFileProps(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), mdf, szName, cchName, pchName, ppbHashValue, pcbHashValue, pdwFileFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetExportedTypeProps(self: *const T, mdct: u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, ptkImplementation: ?*u32, ptkTypeDef: ?*u32, pdwExportedTypeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetExportedTypeProps(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), mdct, szName, cchName, pchName, ptkImplementation, ptkTypeDef, pdwExportedTypeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetManifestResourceProps(self: *const T, mdmr: u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32, ptkImplementation: ?*u32, pdwOffset: ?*u32, pdwResourceFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetManifestResourceProps(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), mdmr, szName, cchName, pchName, ptkImplementation, pdwOffset, pdwResourceFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_EnumAssemblyRefs(self: *const T, phEnum: ?*?*anyopaque, rAssemblyRefs: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).EnumAssemblyRefs(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), phEnum, rAssemblyRefs, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_EnumFiles(self: *const T, phEnum: ?*?*anyopaque, rFiles: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).EnumFiles(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), phEnum, rFiles, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_EnumExportedTypes(self: *const T, phEnum: ?*?*anyopaque, rExportedTypes: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).EnumExportedTypes(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), phEnum, rExportedTypes, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_EnumManifestResources(self: *const T, phEnum: ?*?*anyopaque, rManifestResources: ?*u32, cMax: u32, pcTokens: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).EnumManifestResources(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), phEnum, rManifestResources, cMax, pcTokens);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_GetAssemblyFromScope(self: *const T, ptkAssembly: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).GetAssemblyFromScope(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), ptkAssembly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_FindExportedTypeByName(self: *const T, szName: ?[*:0]align(1) const u16, _param_mdtExportedType: u32, ptkExportedType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).FindExportedTypeByName(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), szName, _param_mdtExportedType, ptkExportedType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_FindManifestResourceByName(self: *const T, szName: ?[*:0]align(1) const u16, ptkManifestResource: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).FindManifestResourceByName(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), szName, ptkManifestResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_CloseEnum(self: *const T, hEnum: ?*anyopaque) callconv(.Inline) void {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).CloseEnum(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), hEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataAssemblyImport_FindAssembliesByName(self: *const T, szAppBase: ?[*:0]align(1) const u16, szPrivateBin: ?[*:0]align(1) const u16, szAssemblyName: ?[*:0]align(1) const u16, ppIUnk: ?*?*IUnknown, cMax: u32, pcAssemblies: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataAssemblyImport.VTable, @ptrCast(self.vtable)).FindAssembliesByName(@as(*const IMetaDataAssemblyImport, @ptrCast(self)), szAppBase, szPrivateBin, szAssemblyName, ppIUnk, cMax, pcAssemblies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CorValidatorModuleType = enum(i32) {
    Invalid = 0,
    Min = 1,
    // PE = 1, this enum value conflicts with Min
    Obj = 2,
    Enc = 3,
    Incr = 4,
    // Max = 4, this enum value conflicts with Incr
};
pub const ValidatorModuleTypeInvalid = CorValidatorModuleType.Invalid;
pub const ValidatorModuleTypeMin = CorValidatorModuleType.Min;
pub const ValidatorModuleTypePE = CorValidatorModuleType.Min;
pub const ValidatorModuleTypeObj = CorValidatorModuleType.Obj;
pub const ValidatorModuleTypeEnc = CorValidatorModuleType.Enc;
pub const ValidatorModuleTypeIncr = CorValidatorModuleType.Incr;
pub const ValidatorModuleTypeMax = CorValidatorModuleType.Incr;

const IID_IMetaDataValidate_Value = Guid.initString("4709c9c6-81ff-11d3-9fc7-00c04f79a0a3");
pub const IID_IMetaDataValidate = &IID_IMetaDataValidate_Value;
pub const IMetaDataValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidatorInit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataValidate,
                dwModuleType: u32,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataValidate,
                dwModuleType: u32,
                pUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ValidateMetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataValidate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataValidate_ValidatorInit(self: *const T, dwModuleType: u32, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataValidate.VTable, @ptrCast(self.vtable)).ValidatorInit(@as(*const IMetaDataValidate, @ptrCast(self)), dwModuleType, pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataValidate_ValidateMetaData(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataValidate.VTable, @ptrCast(self.vtable)).ValidateMetaData(@as(*const IMetaDataValidate, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataDispenserEx_Value = Guid.initString("31bcfce2-dafb-11d2-9f81-00c04f79a0a3");
pub const IID_IMetaDataDispenserEx = &IID_IMetaDataDispenserEx_Value;
pub const IMetaDataDispenserEx = extern struct {
    pub const VTable = extern struct {
        base: IMetaDataDispenser.VTable,
        SetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                optionid: ?*const Guid,
                value: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                optionid: ?*const Guid,
                value: ?*const VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                optionid: ?*const Guid,
                pvalue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                optionid: ?*const Guid,
                pvalue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenScopeOnITypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                pITI: ?*ITypeInfo,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                pITI: ?*ITypeInfo,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppIUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCORSystemDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                szBuffer: ?[*:0]u16,
                cchBuffer: u32,
                pchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                szBuffer: ?[*:0]u16,
                cchBuffer: u32,
                pchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAssembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szGlobalBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                szName: ?[*:0]align(1) const u16,
                cchName: u32,
                pcName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szGlobalBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                szName: ?[*:0]align(1) const u16,
                cchName: u32,
                pcName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindAssemblyModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataDispenserEx,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szGlobalBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                szModuleName: ?[*:0]align(1) const u16,
                szName: ?[*:0]u16,
                cchName: u32,
                pcName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataDispenserEx,
                szAppBase: ?[*:0]align(1) const u16,
                szPrivateBin: ?[*:0]align(1) const u16,
                szGlobalBin: ?[*:0]align(1) const u16,
                szAssemblyName: ?[*:0]align(1) const u16,
                szModuleName: ?[*:0]align(1) const u16,
                szName: ?[*:0]u16,
                cchName: u32,
                pcName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMetaDataDispenser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_SetOption(self: *const T, optionid: ?*const Guid, value: ?*const VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IMetaDataDispenserEx, @ptrCast(self)), optionid, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_GetOption(self: *const T, optionid: ?*const Guid, pvalue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).GetOption(@as(*const IMetaDataDispenserEx, @ptrCast(self)), optionid, pvalue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_OpenScopeOnITypeInfo(self: *const T, pITI: ?*ITypeInfo, dwOpenFlags: u32, riid: ?*const Guid, ppIUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).OpenScopeOnITypeInfo(@as(*const IMetaDataDispenserEx, @ptrCast(self)), pITI, dwOpenFlags, riid, ppIUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_GetCORSystemDirectory(self: *const T, szBuffer: ?[*:0]u16, cchBuffer: u32, pchBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).GetCORSystemDirectory(@as(*const IMetaDataDispenserEx, @ptrCast(self)), szBuffer, cchBuffer, pchBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_FindAssembly(self: *const T, szAppBase: ?[*:0]align(1) const u16, szPrivateBin: ?[*:0]align(1) const u16, szGlobalBin: ?[*:0]align(1) const u16, szAssemblyName: ?[*:0]align(1) const u16, szName: ?[*:0]align(1) const u16, cchName: u32, pcName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).FindAssembly(@as(*const IMetaDataDispenserEx, @ptrCast(self)), szAppBase, szPrivateBin, szGlobalBin, szAssemblyName, szName, cchName, pcName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataDispenserEx_FindAssemblyModule(self: *const T, szAppBase: ?[*:0]align(1) const u16, szPrivateBin: ?[*:0]align(1) const u16, szGlobalBin: ?[*:0]align(1) const u16, szAssemblyName: ?[*:0]align(1) const u16, szModuleName: ?[*:0]align(1) const u16, szName: ?[*:0]u16, cchName: u32, pcName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataDispenserEx.VTable, @ptrCast(self.vtable)).FindAssemblyModule(@as(*const IMetaDataDispenserEx, @ptrCast(self)), szAppBase, szPrivateBin, szGlobalBin, szAssemblyName, szModuleName, szName, cchName, pcName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CorRegFlags = enum(i32) {
    NoCopy = 1,
    Config = 2,
    HasRefs = 4,
};
pub const regNoCopy = CorRegFlags.NoCopy;
pub const regConfig = CorRegFlags.Config;
pub const regHasRefs = CorRegFlags.HasRefs;

pub const CVStruct = extern struct {
    Major: i16,
    Minor: i16,
    Sub: i16,
    Build: i16,
};

pub const CeeSectionAttr = enum(i64) {
    None = 0,
    ReadOnly = 1073741888,
    ReadWrite = 3221225536,
    Execute = 1610612768,
};
pub const sdNone = CeeSectionAttr.None;
pub const sdReadOnly = CeeSectionAttr.ReadOnly;
pub const sdReadWrite = CeeSectionAttr.ReadWrite;
pub const sdExecute = CeeSectionAttr.Execute;

pub const CeeSectionRelocType = enum(i32) {
    RelocAbsolute = 0,
    RelocHighLow = 3,
    RelocHighAdj = 4,
    RelocMapToken = 5,
    RelocRelative = 6,
    RelocFilePos = 7,
    RelocCodeRelative = 8,
    RelocIA64Imm64 = 9,
    RelocDir64 = 10,
    RelocIA64PcRel25 = 11,
    RelocIA64PcRel64 = 12,
    RelocAbsoluteTagged = 13,
    RelocSentinel = 14,
    NoBaseReloc = 16384,
    RelocPtr = 32768,
    // RelocAbsolutePtr = 32768, this enum value conflicts with RelocPtr
    RelocHighLowPtr = 32771,
    RelocRelativePtr = 32774,
    RelocIA64Imm64Ptr = 32777,
    RelocDir64Ptr = 32778,
};
pub const srRelocAbsolute = CeeSectionRelocType.RelocAbsolute;
pub const srRelocHighLow = CeeSectionRelocType.RelocHighLow;
pub const srRelocHighAdj = CeeSectionRelocType.RelocHighAdj;
pub const srRelocMapToken = CeeSectionRelocType.RelocMapToken;
pub const srRelocRelative = CeeSectionRelocType.RelocRelative;
pub const srRelocFilePos = CeeSectionRelocType.RelocFilePos;
pub const srRelocCodeRelative = CeeSectionRelocType.RelocCodeRelative;
pub const srRelocIA64Imm64 = CeeSectionRelocType.RelocIA64Imm64;
pub const srRelocDir64 = CeeSectionRelocType.RelocDir64;
pub const srRelocIA64PcRel25 = CeeSectionRelocType.RelocIA64PcRel25;
pub const srRelocIA64PcRel64 = CeeSectionRelocType.RelocIA64PcRel64;
pub const srRelocAbsoluteTagged = CeeSectionRelocType.RelocAbsoluteTagged;
pub const srRelocSentinel = CeeSectionRelocType.RelocSentinel;
pub const srNoBaseReloc = CeeSectionRelocType.NoBaseReloc;
pub const srRelocPtr = CeeSectionRelocType.RelocPtr;
pub const srRelocAbsolutePtr = CeeSectionRelocType.RelocPtr;
pub const srRelocHighLowPtr = CeeSectionRelocType.RelocHighLowPtr;
pub const srRelocRelativePtr = CeeSectionRelocType.RelocRelativePtr;
pub const srRelocIA64Imm64Ptr = CeeSectionRelocType.RelocIA64Imm64Ptr;
pub const srRelocDir64Ptr = CeeSectionRelocType.RelocDir64Ptr;

pub const CeeSectionRelocExtra = extern union {
    highAdj: u16,
};

const IID_ICeeGen_Value = Guid.initString("7ed1bdff-8e36-11d2-9c56-00a0c9b7cc45");
pub const IID_ICeeGen = &IID_ICeeGen_Value;
pub const ICeeGen = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EmitString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                lpString: ?PWSTR,
                RVA: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                lpString: ?PWSTR,
                RVA: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                RVA: u32,
                lpString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                RVA: u32,
                lpString: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateMethodBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                cchBuffer: u32,
                lpBuffer: ?*?*u8,
                RVA: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                cchBuffer: u32,
                lpBuffer: ?*?*u8,
                RVA: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMethodBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                RVA: u32,
                lpBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                RVA: u32,
                lpBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIMapTokenIface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                pIMapToken: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                pIMapToken: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateCeeFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIlSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSectionReloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                offset: u32,
                relativeTo: ?*anyopaque,
                relocType: CeeSectionRelocType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                offset: u32,
                relativeTo: ?*anyopaque,
                relocType: CeeSectionRelocType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSectionCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                name: ?[*:0]align(1) const u8,
                flags: u32,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                name: ?[*:0]align(1) const u8,
                flags: u32,
                section: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSectionDataLen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                dataLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                dataLen: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSectionBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                len: u32,
                @"align": u32,
                ppBytes: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                len: u32,
                @"align": u32,
                ppBytes: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TruncateSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                len: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                len: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GenerateCeeMemoryImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                ppImage: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                ppImage: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ComputePointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                RVA: u32,
                lpBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICeeGen,
                section: ?*anyopaque,
                RVA: u32,
                lpBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_EmitString(self: *const T, lpString: ?PWSTR, RVA: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).EmitString(@as(*const ICeeGen, @ptrCast(self)), lpString, RVA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetString(self: *const T, RVA: u32, lpString: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetString(@as(*const ICeeGen, @ptrCast(self)), RVA, lpString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_AllocateMethodBuffer(self: *const T, cchBuffer: u32, lpBuffer: ?*?*u8, RVA: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).AllocateMethodBuffer(@as(*const ICeeGen, @ptrCast(self)), cchBuffer, lpBuffer, RVA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetMethodBuffer(self: *const T, RVA: u32, lpBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetMethodBuffer(@as(*const ICeeGen, @ptrCast(self)), RVA, lpBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetIMapTokenIface(self: *const T, pIMapToken: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetIMapTokenIface(@as(*const ICeeGen, @ptrCast(self)), pIMapToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GenerateCeeFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GenerateCeeFile(@as(*const ICeeGen, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetIlSection(self: *const T, section: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetIlSection(@as(*const ICeeGen, @ptrCast(self)), section);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetStringSection(self: *const T, section: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetStringSection(@as(*const ICeeGen, @ptrCast(self)), section);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_AddSectionReloc(self: *const T, section: ?*anyopaque, offset: u32, relativeTo: ?*anyopaque, relocType: CeeSectionRelocType) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).AddSectionReloc(@as(*const ICeeGen, @ptrCast(self)), section, offset, relativeTo, relocType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetSectionCreate(self: *const T, name: ?[*:0]align(1) const u8, flags: u32, section: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetSectionCreate(@as(*const ICeeGen, @ptrCast(self)), name, flags, section);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetSectionDataLen(self: *const T, section: ?*anyopaque, dataLen: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetSectionDataLen(@as(*const ICeeGen, @ptrCast(self)), section, dataLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GetSectionBlock(self: *const T, section: ?*anyopaque, len: u32, @"align": u32, ppBytes: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GetSectionBlock(@as(*const ICeeGen, @ptrCast(self)), section, len, @"align", ppBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_TruncateSection(self: *const T, section: ?*anyopaque, len: u32) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).TruncateSection(@as(*const ICeeGen, @ptrCast(self)), section, len);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_GenerateCeeMemoryImage(self: *const T, ppImage: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).GenerateCeeMemoryImage(@as(*const ICeeGen, @ptrCast(self)), ppImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICeeGen_ComputePointer(self: *const T, section: ?*anyopaque, RVA: u32, lpBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICeeGen.VTable, @ptrCast(self.vtable)).ComputePointer(@as(*const ICeeGen, @ptrCast(self)), section, RVA, lpBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataTables_Value = Guid.initString("d8f579ab-402d-4b8e-82d9-5d63b1065c68");
pub const IID_IMetaDataTables = &IID_IMetaDataTables_Value;
pub const IMetaDataTables = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringHeapSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                pcbStrings: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                pcbStrings: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBlobHeapSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                pcbBlobs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                pcbBlobs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuidHeapSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                pcbGuids: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                pcbGuids: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserStringHeapSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                pcbBlobs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                pcbBlobs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumTables: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                pcTables: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                pcTables: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                token: u32,
                pixTbl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                token: u32,
                pixTbl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                pcbRow: ?*u32,
                pcRows: ?*u32,
                pcCols: ?*u32,
                piKey: ?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                pcbRow: ?*u32,
                pcRows: ?*u32,
                pcCols: ?*u32,
                piKey: ?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumnInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                ixCol: u32,
                poCol: ?*u32,
                pcbCol: ?*u32,
                pType: ?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                ixCol: u32,
                poCol: ?*u32,
                pcbCol: ?*u32,
                pType: ?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodedTokenInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixCdTkn: u32,
                pcTokens: ?*u32,
                ppTokens: ?*?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixCdTkn: u32,
                pcTokens: ?*u32,
                ppTokens: ?*?*u32,
                ppName: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                rid: u32,
                ppRow: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                rid: u32,
                ppRow: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColumn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                ixCol: u32,
                rid: u32,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixTbl: u32,
                ixCol: u32,
                rid: u32,
                pVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixString: u32,
                ppString: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixString: u32,
                ppString: ?*const ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixBlob: u32,
                pcbData: ?*u32,
                ppData: ?*const ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixBlob: u32,
                pcbData: ?*u32,
                ppData: ?*const ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixGuid: u32,
                ppGUID: ?*const ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixGuid: u32,
                ppGUID: ?*const ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixUserString: u32,
                pcbData: ?*u32,
                ppData: ?*const ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixUserString: u32,
                pcbData: ?*u32,
                ppData: ?*const ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixString: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixString: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixBlob: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixBlob: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixGuid: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixGuid: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextUserString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables,
                ixUserString: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables,
                ixUserString: u32,
                pNext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetStringHeapSize(self: *const T, pcbStrings: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetStringHeapSize(@as(*const IMetaDataTables, @ptrCast(self)), pcbStrings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetBlobHeapSize(self: *const T, pcbBlobs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetBlobHeapSize(@as(*const IMetaDataTables, @ptrCast(self)), pcbBlobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetGuidHeapSize(self: *const T, pcbGuids: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetGuidHeapSize(@as(*const IMetaDataTables, @ptrCast(self)), pcbGuids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetUserStringHeapSize(self: *const T, pcbBlobs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetUserStringHeapSize(@as(*const IMetaDataTables, @ptrCast(self)), pcbBlobs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetNumTables(self: *const T, pcTables: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetNumTables(@as(*const IMetaDataTables, @ptrCast(self)), pcTables);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetTableIndex(self: *const T, token: u32, pixTbl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetTableIndex(@as(*const IMetaDataTables, @ptrCast(self)), token, pixTbl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetTableInfo(self: *const T, ixTbl: u32, pcbRow: ?*u32, pcRows: ?*u32, pcCols: ?*u32, piKey: ?*u32, ppName: ?*const ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetTableInfo(@as(*const IMetaDataTables, @ptrCast(self)), ixTbl, pcbRow, pcRows, pcCols, piKey, ppName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetColumnInfo(self: *const T, ixTbl: u32, ixCol: u32, poCol: ?*u32, pcbCol: ?*u32, pType: ?*u32, ppName: ?*const ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetColumnInfo(@as(*const IMetaDataTables, @ptrCast(self)), ixTbl, ixCol, poCol, pcbCol, pType, ppName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetCodedTokenInfo(self: *const T, ixCdTkn: u32, pcTokens: ?*u32, ppTokens: ?*?*u32, ppName: ?*const ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetCodedTokenInfo(@as(*const IMetaDataTables, @ptrCast(self)), ixCdTkn, pcTokens, ppTokens, ppName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetRow(self: *const T, ixTbl: u32, rid: u32, ppRow: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetRow(@as(*const IMetaDataTables, @ptrCast(self)), ixTbl, rid, ppRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetColumn(self: *const T, ixTbl: u32, ixCol: u32, rid: u32, pVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetColumn(@as(*const IMetaDataTables, @ptrCast(self)), ixTbl, ixCol, rid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetString(self: *const T, ixString: u32, ppString: ?*const ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetString(@as(*const IMetaDataTables, @ptrCast(self)), ixString, ppString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetBlob(self: *const T, ixBlob: u32, pcbData: ?*u32, ppData: ?*const ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetBlob(@as(*const IMetaDataTables, @ptrCast(self)), ixBlob, pcbData, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetGuid(self: *const T, ixGuid: u32, ppGUID: ?*const ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const IMetaDataTables, @ptrCast(self)), ixGuid, ppGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetUserString(self: *const T, ixUserString: u32, pcbData: ?*u32, ppData: ?*const ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetUserString(@as(*const IMetaDataTables, @ptrCast(self)), ixUserString, pcbData, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetNextString(self: *const T, ixString: u32, pNext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetNextString(@as(*const IMetaDataTables, @ptrCast(self)), ixString, pNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetNextBlob(self: *const T, ixBlob: u32, pNext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetNextBlob(@as(*const IMetaDataTables, @ptrCast(self)), ixBlob, pNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetNextGuid(self: *const T, ixGuid: u32, pNext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetNextGuid(@as(*const IMetaDataTables, @ptrCast(self)), ixGuid, pNext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables_GetNextUserString(self: *const T, ixUserString: u32, pNext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables.VTable, @ptrCast(self.vtable)).GetNextUserString(@as(*const IMetaDataTables, @ptrCast(self)), ixUserString, pNext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataTables2_Value = Guid.initString("badb5f70-58da-43a9-a1c6-d74819f19b15");
pub const IID_IMetaDataTables2 = &IID_IMetaDataTables2_Value;
pub const IMetaDataTables2 = extern struct {
    pub const VTable = extern struct {
        base: IMetaDataTables.VTable,
        GetMetaDataStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables2,
                ppvMd: ?*const ?*anyopaque,
                pcbMd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables2,
                ppvMd: ?*const ?*anyopaque,
                pcbMd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMetaDataStreamInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataTables2,
                ix: u32,
                ppchName: ?*const ?*i8,
                ppv: ?*const ?*anyopaque,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataTables2,
                ix: u32,
                ppchName: ?*const ?*i8,
                ppv: ?*const ?*anyopaque,
                pcb: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMetaDataTables.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables2_GetMetaDataStorage(self: *const T, ppvMd: ?*const ?*anyopaque, pcbMd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables2.VTable, @ptrCast(self.vtable)).GetMetaDataStorage(@as(*const IMetaDataTables2, @ptrCast(self)), ppvMd, pcbMd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataTables2_GetMetaDataStreamInfo(self: *const T, ix: u32, ppchName: ?*const ?*i8, ppv: ?*const ?*anyopaque, pcb: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataTables2.VTable, @ptrCast(self.vtable)).GetMetaDataStreamInfo(@as(*const IMetaDataTables2, @ptrCast(self)), ix, ppchName, ppv, pcb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataInfo_Value = Guid.initString("7998ea64-7f95-48b8-86fc-17caf48bf5cb");
pub const IID_IMetaDataInfo = &IID_IMetaDataInfo_Value;
pub const IMetaDataInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFileMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataInfo,
                ppvData: ?*const ?*anyopaque,
                pcbData: ?*u64,
                pdwMappingType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataInfo,
                ppvData: ?*const ?*anyopaque,
                pcbData: ?*u64,
                pdwMappingType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataInfo_GetFileMapping(self: *const T, ppvData: ?*const ?*anyopaque, pcbData: ?*u64, pdwMappingType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataInfo.VTable, @ptrCast(self.vtable)).GetFileMapping(@as(*const IMetaDataInfo, @ptrCast(self)), ppvData, pcbData, pdwMappingType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaDataWinMDImport_Value = Guid.initString("969ea0c5-964e-411b-a807-b0f3c2dfcbd4");
pub const IID_IMetaDataWinMDImport = &IID_IMetaDataWinMDImport_Value;
pub const IMetaDataWinMDImport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUntransformedTypeRefProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMetaDataWinMDImport,
                tr: u32,
                ptkResolutionScope: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMetaDataWinMDImport,
                tr: u32,
                ptkResolutionScope: ?*u32,
                szName: ?[*:0]u16,
                cchName: u32,
                pchName: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaDataWinMDImport_GetUntransformedTypeRefProps(self: *const T, tr: u32, ptkResolutionScope: ?*u32, szName: ?[*:0]u16, cchName: u32, pchName: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMetaDataWinMDImport.VTable, @ptrCast(self.vtable)).GetUntransformedTypeRefProps(@as(*const IMetaDataWinMDImport, @ptrCast(self)), tr, ptkResolutionScope, szName, cchName, pchName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COR_NATIVE_LINK = extern struct {
    m_linkType: u8 align(1),
    m_flags: u8 align(1),
    m_entryPoint: u32 align(1),
};

pub const CorNativeLinkType = enum(i32) {
    None = 1,
    Ansi = 2,
    Unicode = 3,
    Auto = 4,
    Ole = 5,
    MaxValue = 7,
};
pub const nltNone = CorNativeLinkType.None;
pub const nltAnsi = CorNativeLinkType.Ansi;
pub const nltUnicode = CorNativeLinkType.Unicode;
pub const nltAuto = CorNativeLinkType.Auto;
pub const nltOle = CorNativeLinkType.Ole;
pub const nltMaxValue = CorNativeLinkType.MaxValue;

pub const CorNativeLinkFlags = enum(i32) {
    None = 0,
    LastError = 1,
    NoMangle = 2,
    MaxValue = 3,
};
pub const nlfNone = CorNativeLinkFlags.None;
pub const nlfLastError = CorNativeLinkFlags.LastError;
pub const nlfNoMangle = CorNativeLinkFlags.NoMangle;
pub const nlfMaxValue = CorNativeLinkFlags.MaxValue;

pub const IRoSimpleMetaDataBuilder = extern struct {
    pub const VTable = extern struct {
        SetWinRtInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDelegate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                iid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceGroupSimpleDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                defaultInterfaceName: ?[*:0]align(1) const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                defaultInterfaceName: ?[*:0]align(1) const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceGroupParameterizedDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuntimeClassSimpleDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                defaultInterfaceName: ?[*:0]align(1) const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                defaultInterfaceName: ?[*:0]align(1) const u16,
                defaultInterfaceIID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRuntimeClassParameterizedDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                elementCount: u32,
                defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStruct: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                numFields: u32,
                fieldTypeNames: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                numFields: u32,
                fieldTypeNames: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                baseType: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                name: ?[*:0]align(1) const u16,
                baseType: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameterizedInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameterizedDelegate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoSimpleMetaDataBuilder,
                piid: Guid,
                numArgs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetWinRtInterface(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetWinRtInterface(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetDelegate(self: *const T, iid: Guid) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetDelegate(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), iid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupSimpleDefault(self: *const T, name: ?[*:0]align(1) const u16, defaultInterfaceName: ?[*:0]align(1) const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetInterfaceGroupSimpleDefault(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetInterfaceGroupParameterizedDefault(self: *const T, name: ?[*:0]align(1) const u16, elementCount: u32, defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetInterfaceGroupParameterizedDefault(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassSimpleDefault(self: *const T, name: ?[*:0]align(1) const u16, defaultInterfaceName: ?[*:0]align(1) const u16, defaultInterfaceIID: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetRuntimeClassSimpleDefault(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, defaultInterfaceName, defaultInterfaceIID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetRuntimeClassParameterizedDefault(self: *const T, name: ?[*:0]align(1) const u16, elementCount: u32, defaultInterfaceNameElements: [*]const ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetRuntimeClassParameterizedDefault(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, elementCount, defaultInterfaceNameElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetStruct(self: *const T, name: ?[*:0]align(1) const u16, numFields: u32, fieldTypeNames: [*]const ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetStruct(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, numFields, fieldTypeNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetEnum(self: *const T, name: ?[*:0]align(1) const u16, baseType: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetEnum(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), name, baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedInterface(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetParameterizedInterface(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), piid, numArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoSimpleMetaDataBuilder_SetParameterizedDelegate(self: *const T, piid: Guid, numArgs: u32) callconv(.Inline) HRESULT {
            return @as(*const IRoSimpleMetaDataBuilder.VTable, @ptrCast(self.vtable)).SetParameterizedDelegate(@as(*const IRoSimpleMetaDataBuilder, @ptrCast(self)), piid, numArgs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRoMetaDataLocator = extern struct {
    pub const VTable = extern struct {
        Locate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRoMetaDataLocator,
                nameElement: ?[*:0]align(1) const u16,
                metaDataDestination: ?*IRoSimpleMetaDataBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRoMetaDataLocator,
                nameElement: ?[*:0]align(1) const u16,
                metaDataDestination: ?*IRoSimpleMetaDataBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRoMetaDataLocator_Locate(self: *const T, nameElement: ?[*:0]align(1) const u16, metaDataDestination: ?*IRoSimpleMetaDataBuilder) callconv(.Inline) HRESULT {
            return @as(*const IRoMetaDataLocator.VTable, @ptrCast(self.vtable)).Locate(@as(*const IRoMetaDataLocator, @ptrCast(self)), nameElement, metaDataDestination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        _bitfield1: u32,
        _bitfield2: u32,
        Anonymous: extern union {
            ClassToken: u32,
            FilterOffset: u32,
        },
    },
    .X86 => extern struct {
        _bitfield1: i32,
        _bitfield2: u32,
        Anonymous: extern union {
            ClassToken: u32,
            FilterOffset: u32,
        },
    },
};

//--------------------------------------------------------------------------------
// Section: Functions (11)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows8.0'
pub extern "rometadata" fn MetaDataGetDispenser(
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-ro-typeresolution-l1-1-0" fn RoGetMetaDataFile(
    name: ?HSTRING,
    metaDataDispenser: ?*IMetaDataDispenserEx,
    metaDataFilePath: ?*?HSTRING,
    metaDataImport: ?*?*IMetaDataImport2,
    typeDefToken: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-ro-typeresolution-l1-1-0" fn RoParseTypeName(
    typeName: ?HSTRING,
    partsCount: ?*u32,
    typeNameParts: [*]?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-ro-typeresolution-l1-1-0" fn RoResolveNamespace(
    name: ?HSTRING,
    windowsMetaDataDir: ?HSTRING,
    packageGraphDirsCount: u32,
    packageGraphDirs: ?[*]const ?HSTRING,
    metaDataFilePathsCount: ?*u32,
    metaDataFilePaths: ?*?*?HSTRING,
    subNamespacesCount: ?*u32,
    subNamespaces: ?*?*?HSTRING,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-ro-typeresolution-l1-1-1" fn RoIsApiContractPresent(
    name: ?[*:0]align(1) const u16,
    majorVersion: u16,
    minorVersion: u16,
    present: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "api-ms-win-ro-typeresolution-l1-1-1" fn RoIsApiContractMajorVersionPresent(
    name: ?[*:0]align(1) const u16,
    majorVersion: u16,
    present: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-ro-typeresolution-l1-1-1" fn RoCreateNonAgilePropertySet(
    ppPropertySet: ?**struct{comment: []const u8 = "MissingClrType IPropertySet.Windows.Foundation.Collections"},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-ro-typeresolution-l1-1-1" fn RoCreatePropertySetSerializer(
    ppPropertySetSerializer: ?**struct{comment: []const u8 = "MissingClrType IPropertySetSerializer.Windows.Storage.Streams"},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoGetParameterizedTypeInstanceIID(
    nameElementCount: u32,
    nameElements: [*]const ?[*:0]align(1) const u16,
    metaDataLocator: ?*IRoMetaDataLocator,
    iid: ?*Guid,
    pExtra: ?*ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoFreeParameterizedTypeExtra(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows8.0'
pub extern "api-ms-win-core-winrt-roparameterizediid-l1-1-0" fn RoParameterizedTypeExtraGetTypeSignature(
    extra: ROPARAMIIDHANDLE,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../zig.zig").Guid;
const BOOL = @import("../../../../windows/win32/foundation.zig").BOOL;
const HRESULT = @import("../../../../windows/win32/foundation.zig").HRESULT;
const HSTRING = @import("../../../../windows/win32/system/win_rt.zig").HSTRING;
const IStream = @import("../../../../windows/win32/system/com.zig").IStream;
const ITypeInfo = @import("../../../../windows/win32/system/com.zig").ITypeInfo;
const IUnknown = @import("../../../../windows/win32/system/com.zig").IUnknown;
const PSTR = @import("../../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../../windows/win32/foundation.zig").PWSTR;
const ROPARAMIIDHANDLE = @import("../../../../windows/win32/system/win_rt.zig").ROPARAMIIDHANDLE;
const VARIANT = @import("../../../../windows/win32/system/variant.zig").VARIANT;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
