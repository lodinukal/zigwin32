//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (449)
//--------------------------------------------------------------------------------
pub const DISPID_AMBIENT_OFFLINEIFNOTCONNECTED = @as(i32, -5501);
pub const DISPID_AMBIENT_SILENT = @as(i32, -5502);
pub const DISPID_BEFORENAVIGATE = @as(u32, 100);
pub const DISPID_NAVIGATECOMPLETE = @as(u32, 101);
pub const DISPID_STATUSTEXTCHANGE = @as(u32, 102);
pub const DISPID_QUIT = @as(u32, 103);
pub const DISPID_DOWNLOADCOMPLETE = @as(u32, 104);
pub const DISPID_COMMANDSTATECHANGE = @as(u32, 105);
pub const DISPID_DOWNLOADBEGIN = @as(u32, 106);
pub const DISPID_NEWWINDOW = @as(u32, 107);
pub const DISPID_PROGRESSCHANGE = @as(u32, 108);
pub const DISPID_WINDOWMOVE = @as(u32, 109);
pub const DISPID_WINDOWRESIZE = @as(u32, 110);
pub const DISPID_WINDOWACTIVATE = @as(u32, 111);
pub const DISPID_PROPERTYCHANGE = @as(u32, 112);
pub const DISPID_TITLECHANGE = @as(u32, 113);
pub const DISPID_TITLEICONCHANGE = @as(u32, 114);
pub const DISPID_FRAMEBEFORENAVIGATE = @as(u32, 200);
pub const DISPID_FRAMENAVIGATECOMPLETE = @as(u32, 201);
pub const DISPID_FRAMENEWWINDOW = @as(u32, 204);
pub const DISPID_BEFORENAVIGATE2 = @as(u32, 250);
pub const DISPID_NEWWINDOW2 = @as(u32, 251);
pub const DISPID_NAVIGATECOMPLETE2 = @as(u32, 252);
pub const DISPID_ONQUIT = @as(u32, 253);
pub const DISPID_ONVISIBLE = @as(u32, 254);
pub const DISPID_ONTOOLBAR = @as(u32, 255);
pub const DISPID_ONMENUBAR = @as(u32, 256);
pub const DISPID_ONSTATUSBAR = @as(u32, 257);
pub const DISPID_ONFULLSCREEN = @as(u32, 258);
pub const DISPID_DOCUMENTCOMPLETE = @as(u32, 259);
pub const DISPID_ONTHEATERMODE = @as(u32, 260);
pub const DISPID_ONADDRESSBAR = @as(u32, 261);
pub const DISPID_WINDOWSETRESIZABLE = @as(u32, 262);
pub const DISPID_WINDOWCLOSING = @as(u32, 263);
pub const DISPID_WINDOWSETLEFT = @as(u32, 264);
pub const DISPID_WINDOWSETTOP = @as(u32, 265);
pub const DISPID_WINDOWSETWIDTH = @as(u32, 266);
pub const DISPID_WINDOWSETHEIGHT = @as(u32, 267);
pub const DISPID_CLIENTTOHOSTWINDOW = @as(u32, 268);
pub const DISPID_SETSECURELOCKICON = @as(u32, 269);
pub const DISPID_FILEDOWNLOAD = @as(u32, 270);
pub const DISPID_NAVIGATEERROR = @as(u32, 271);
pub const DISPID_PRIVACYIMPACTEDSTATECHANGE = @as(u32, 272);
pub const DISPID_NEWWINDOW3 = @as(u32, 273);
pub const DISPID_VIEWUPDATE = @as(u32, 281);
pub const DISPID_SETPHISHINGFILTERSTATUS = @as(u32, 282);
pub const DISPID_WINDOWSTATECHANGED = @as(u32, 283);
pub const DISPID_NEWPROCESS = @as(u32, 284);
pub const DISPID_THIRDPARTYURLBLOCKED = @as(u32, 285);
pub const DISPID_REDIRECTXDOMAINBLOCKED = @as(u32, 286);
pub const DISPID_WEBWORKERSTARTED = @as(u32, 288);
pub const DISPID_WEBWORKERFINISHED = @as(u32, 289);
pub const DISPID_BEFORESCRIPTEXECUTE = @as(u32, 290);
pub const DISPID_PRINTTEMPLATEINSTANTIATION = @as(u32, 225);
pub const DISPID_PRINTTEMPLATETEARDOWN = @as(u32, 226);
pub const DISPID_UPDATEPAGESTATUS = @as(u32, 227);
pub const DISPID_WINDOWREGISTERED = @as(u32, 200);
pub const DISPID_WINDOWREVOKED = @as(u32, 201);
pub const DISPID_RESETFIRSTBOOTMODE = @as(u32, 1);
pub const DISPID_RESETSAFEMODE = @as(u32, 2);
pub const DISPID_REFRESHOFFLINEDESKTOP = @as(u32, 3);
pub const DISPID_ADDFAVORITE = @as(u32, 4);
pub const DISPID_ADDCHANNEL = @as(u32, 5);
pub const DISPID_ADDDESKTOPCOMPONENT = @as(u32, 6);
pub const DISPID_ISSUBSCRIBED = @as(u32, 7);
pub const DISPID_NAVIGATEANDFIND = @as(u32, 8);
pub const DISPID_IMPORTEXPORTFAVORITES = @as(u32, 9);
pub const DISPID_AUTOCOMPLETESAVEFORM = @as(u32, 10);
pub const DISPID_AUTOSCAN = @as(u32, 11);
pub const DISPID_AUTOCOMPLETEATTACH = @as(u32, 12);
pub const DISPID_SHOWBROWSERUI = @as(u32, 13);
pub const DISPID_ADDSEARCHPROVIDER = @as(u32, 14);
pub const DISPID_RUNONCESHOWN = @as(u32, 15);
pub const DISPID_SKIPRUNONCE = @as(u32, 16);
pub const DISPID_CUSTOMIZESETTINGS = @as(u32, 17);
pub const DISPID_SQMENABLED = @as(u32, 18);
pub const DISPID_PHISHINGENABLED = @as(u32, 19);
pub const DISPID_BRANDIMAGEURI = @as(u32, 20);
pub const DISPID_SKIPTABSWELCOME = @as(u32, 21);
pub const DISPID_DIAGNOSECONNECTION = @as(u32, 22);
pub const DISPID_CUSTOMIZECLEARTYPE = @as(u32, 23);
pub const DISPID_ISSEARCHPROVIDERINSTALLED = @as(u32, 24);
pub const DISPID_ISSEARCHMIGRATED = @as(u32, 25);
pub const DISPID_DEFAULTSEARCHPROVIDER = @as(u32, 26);
pub const DISPID_RUNONCEREQUIREDSETTINGSCOMPLETE = @as(u32, 27);
pub const DISPID_RUNONCEHASSHOWN = @as(u32, 28);
pub const DISPID_SEARCHGUIDEURL = @as(u32, 29);
pub const DISPID_ADDSERVICE = @as(u32, 30);
pub const DISPID_ISSERVICEINSTALLED = @as(u32, 31);
pub const DISPID_ADDTOFAVORITESBAR = @as(u32, 32);
pub const DISPID_BUILDNEWTABPAGE = @as(u32, 33);
pub const DISPID_SETRECENTLYCLOSEDVISIBLE = @as(u32, 34);
pub const DISPID_SETACTIVITIESVISIBLE = @as(u32, 35);
pub const DISPID_CONTENTDISCOVERYRESET = @as(u32, 36);
pub const DISPID_INPRIVATEFILTERINGENABLED = @as(u32, 37);
pub const DISPID_SUGGESTEDSITESENABLED = @as(u32, 38);
pub const DISPID_ENABLESUGGESTEDSITES = @as(u32, 39);
pub const DISPID_NAVIGATETOSUGGESTEDSITES = @as(u32, 40);
pub const DISPID_SHOWTABSHELP = @as(u32, 41);
pub const DISPID_SHOWINPRIVATEHELP = @as(u32, 42);
pub const DISPID_ISSITEMODE = @as(u32, 43);
pub const DISPID_SETSITEMODEICONOVERLAY = @as(u32, 44);
pub const DISPID_CLEARSITEMODEICONOVERLAY = @as(u32, 45);
pub const DISPID_UPDATETHUMBNAILBUTTON = @as(u32, 46);
pub const DISPID_SETTHUMBNAILBUTTONS = @as(u32, 47);
pub const DISPID_ADDTHUMBNAILBUTTONS = @as(u32, 48);
pub const DISPID_ADDSITEMODE = @as(u32, 49);
pub const DISPID_SETSITEMODEPROPERTIES = @as(u32, 50);
pub const DISPID_SITEMODECREATEJUMPLIST = @as(u32, 51);
pub const DISPID_SITEMODEADDJUMPLISTITEM = @as(u32, 52);
pub const DISPID_SITEMODECLEARJUMPLIST = @as(u32, 53);
pub const DISPID_SITEMODEADDBUTTONSTYLE = @as(u32, 54);
pub const DISPID_SITEMODESHOWBUTTONSTYLE = @as(u32, 55);
pub const DISPID_SITEMODESHOWJUMPLIST = @as(u32, 56);
pub const DISPID_ADDTRACKINGPROTECTIONLIST = @as(u32, 57);
pub const DISPID_SITEMODEACTIVATE = @as(u32, 58);
pub const DISPID_ISSITEMODEFIRSTRUN = @as(u32, 59);
pub const DISPID_TRACKINGPROTECTIONENABLED = @as(u32, 60);
pub const DISPID_ACTIVEXFILTERINGENABLED = @as(u32, 61);
pub const DISPID_PROVISIONNETWORKS = @as(u32, 62);
pub const DISPID_REPORTSAFEURL = @as(u32, 63);
pub const DISPID_SITEMODEREFRESHBADGE = @as(u32, 64);
pub const DISPID_SITEMODECLEARBADGE = @as(u32, 65);
pub const DISPID_DIAGNOSECONNECTIONUILESS = @as(u32, 66);
pub const DISPID_LAUNCHNETWORKCLIENTHELP = @as(u32, 67);
pub const DISPID_CHANGEDEFAULTBROWSER = @as(u32, 68);
pub const DISPID_STOPPERIODICUPDATE = @as(u32, 69);
pub const DISPID_STARTPERIODICUPDATE = @as(u32, 70);
pub const DISPID_CLEARNOTIFICATION = @as(u32, 71);
pub const DISPID_ENABLENOTIFICATIONQUEUE = @as(u32, 72);
pub const DISPID_PINNEDSITESTATE = @as(u32, 73);
pub const DISPID_LAUNCHINTERNETOPTIONS = @as(u32, 74);
pub const DISPID_STARTPERIODICUPDATEBATCH = @as(u32, 75);
pub const DISPID_ENABLENOTIFICATIONQUEUESQUARE = @as(u32, 76);
pub const DISPID_ENABLENOTIFICATIONQUEUEWIDE = @as(u32, 77);
pub const DISPID_ENABLENOTIFICATIONQUEUELARGE = @as(u32, 78);
pub const DISPID_SCHEDULEDTILENOTIFICATION = @as(u32, 79);
pub const DISPID_REMOVESCHEDULEDTILENOTIFICATION = @as(u32, 80);
pub const DISPID_STARTBADGEUPDATE = @as(u32, 81);
pub const DISPID_STOPBADGEUPDATE = @as(u32, 82);
pub const DISPID_ISMETAREFERRERAVAILABLE = @as(u32, 83);
pub const DISPID_SETEXPERIMENTALFLAG = @as(u32, 84);
pub const DISPID_GETEXPERIMENTALFLAG = @as(u32, 85);
pub const DISPID_SETEXPERIMENTALVALUE = @as(u32, 86);
pub const DISPID_GETEXPERIMENTALVALUE = @as(u32, 87);
pub const DISPID_HASNEEDIEAUTOLAUNCHFLAG = @as(u32, 88);
pub const DISPID_GETNEEDIEAUTOLAUNCHFLAG = @as(u32, 89);
pub const DISPID_SETNEEDIEAUTOLAUNCHFLAG = @as(u32, 90);
pub const DISPID_LAUNCHIE = @as(u32, 91);
pub const DISPID_RESETEXPERIMENTALFLAGS = @as(u32, 92);
pub const DISPID_GETCVLISTDATA = @as(u32, 93);
pub const DISPID_GETCVLISTLOCALDATA = @as(u32, 94);
pub const DISPID_GETEMIELISTDATA = @as(u32, 95);
pub const DISPID_GETEMIELISTLOCALDATA = @as(u32, 96);
pub const DISPID_OPENFAVORITESPANE = @as(u32, 97);
pub const DISPID_OPENFAVORITESSETTINGS = @as(u32, 98);
pub const DISPID_LAUNCHINHVSI = @as(u32, 99);
pub const DISPID_GETNEEDHVSIAUTOLAUNCHFLAG = @as(u32, 100);
pub const DISPID_SETNEEDHVSIAUTOLAUNCHFLAG = @as(u32, 101);
pub const DISPID_HASNEEDHVSIAUTOLAUNCHFLAG = @as(u32, 102);
pub const DISPID_GETOSSKU = @as(u32, 103);
pub const DISPID_SETMSDEFAULTS = @as(u32, 104);
pub const DISPID_SHELLUIHELPERLAST = @as(u32, 105);
pub const DISPID_ADVANCEERROR = @as(u32, 10);
pub const DISPID_RETREATERROR = @as(u32, 11);
pub const DISPID_CANADVANCEERROR = @as(u32, 12);
pub const DISPID_CANRETREATERROR = @as(u32, 13);
pub const DISPID_GETERRORLINE = @as(u32, 14);
pub const DISPID_GETERRORCHAR = @as(u32, 15);
pub const DISPID_GETERRORCODE = @as(u32, 16);
pub const DISPID_GETERRORMSG = @as(u32, 17);
pub const DISPID_GETERRORURL = @as(u32, 18);
pub const DISPID_GETDETAILSSTATE = @as(u32, 19);
pub const DISPID_SETDETAILSSTATE = @as(u32, 20);
pub const DISPID_GETPERERRSTATE = @as(u32, 21);
pub const DISPID_SETPERERRSTATE = @as(u32, 22);
pub const DISPID_GETALWAYSSHOWLOCKSTATE = @as(u32, 23);
pub const DISPID_FAVSELECTIONCHANGE = @as(u32, 1);
pub const DISPID_SELECTIONCHANGE = @as(u32, 2);
pub const DISPID_DOUBLECLICK = @as(u32, 3);
pub const DISPID_INITIALIZED = @as(u32, 4);
pub const DISPID_MOVESELECTIONUP = @as(u32, 1);
pub const DISPID_MOVESELECTIONDOWN = @as(u32, 2);
pub const DISPID_RESETSORT = @as(u32, 3);
pub const DISPID_NEWFOLDER = @as(u32, 4);
pub const DISPID_SYNCHRONIZE = @as(u32, 5);
pub const DISPID_IMPORT = @as(u32, 6);
pub const DISPID_EXPORT = @as(u32, 7);
pub const DISPID_INVOKECONTEXTMENU = @as(u32, 8);
pub const DISPID_MOVESELECTIONTO = @as(u32, 9);
pub const DISPID_SUBSCRIPTIONSENABLED = @as(u32, 10);
pub const DISPID_CREATESUBSCRIPTION = @as(u32, 11);
pub const DISPID_DELETESUBSCRIPTION = @as(u32, 12);
pub const DISPID_SETROOT = @as(u32, 13);
pub const DISPID_ENUMOPTIONS = @as(u32, 14);
pub const DISPID_SELECTEDITEM = @as(u32, 15);
pub const DISPID_ROOT = @as(u32, 16);
pub const DISPID_DEPTH = @as(u32, 17);
pub const DISPID_MODE = @as(u32, 18);
pub const DISPID_FLAGS = @as(u32, 19);
pub const DISPID_TVFLAGS = @as(u32, 20);
pub const DISPID_NSCOLUMNS = @as(u32, 21);
pub const DISPID_COUNTVIEWTYPES = @as(u32, 22);
pub const DISPID_SETVIEWTYPE = @as(u32, 23);
pub const DISPID_SELECTEDITEMS = @as(u32, 24);
pub const DISPID_EXPAND = @as(u32, 25);
pub const DISPID_UNSELECTALL = @as(u32, 26);
pub const TF_NAVIGATE = @as(u32, 2142153644);
pub const TARGET_NOTIFY_OBJECT_NAME = "863a99a0-21bc-11d0-82b4-00a0c90c29c5";
pub const IEPROCESS_MODULE_NAME = "IERtUtil.dll";
pub const IEGetProcessModule_PROC_NAME = "IEGetProcessModule";
pub const IEGetTabWindowExports_PROC_NAME = "IEGetTabWindowExports";
pub const TSZMICROSOFTPATH = "Software\\Microsoft";
pub const SZ_IE_MAIN = "Main";
pub const REGSTR_VAL_SMOOTHSCROLL = "SmoothScroll";
pub const REGSTR_VAL_SMOOTHSCROLL_DEF = @as(u32, 1);
pub const REGSTR_VAL_SHOWTOOLBAR = "Show_ToolBar";
pub const REGSTR_VAL_SHOWADDRESSBAR = "Show_URLToolBar";
pub const REGSTR_VAL_STARTPAGE = "Start Page";
pub const REGSTRA_VAL_STARTPAGE = "Start Page";
pub const REGSTR_VAL_SEARCHPAGE = "Search Page";
pub const REGSTR_VAL_LOCALPAGE = "Local Page";
pub const REGSTR_VAL_USESTYLESHEETS = "Use Stylesheets";
pub const REGSTR_VAL_USESTYLESHEETS_DEF = "yes";
pub const REGSTR_VAL_USEICM = "UseICM";
pub const REGSTR_VAL_USEICM_DEF = @as(u32, 0);
pub const REGSTR_VAL_SHOWFOCUS = "Tabstop - MouseDown";
pub const REGSTR_VAL_SHOWFOCUS_DEF = "no";
pub const REGSTR_VAL_LOADIMAGES = "Display Inline Images";
pub const REGSTR_VAL_PLAYSOUNDS = "Play_Background_Sounds";
pub const REGSTR_VAL_PLAYVIDEOS = "Display Inline Videos";
pub const REGSTR_VAL_ANCHORUNDERLINE = "Anchor Underline";
pub const REGSTR_VAL_USEDLGCOLORS = "Use_DlgBox_Colors";
pub const REGSTR_VAL_CHECKASSOC = "Check_Associations";
pub const REGSTR_VAL_SHOWFULLURLS = "Show_FullURL";
pub const REGSTR_VAL_AUTOSEARCH = "Do404Search";
pub const REGSTR_VAL_AUTONAVIGATE = "SearchForExtensions";
pub const REGSTR_VAL_HTTP_ERRORS = "Friendly http errors";
pub const REGSTR_VAL_USEIBAR = "UseBar";
pub const SZ_IE_SETTINGS = "Settings";
pub const REGSTR_VAL_IE_CUSTOMCOLORS = "Custom Colors";
pub const REGSTR_VAL_ANCHORCOLOR = "Anchor Color";
pub const REGSTR_VAL_ANCHORCOLORVISITED = "Anchor Color Visited";
pub const REGSTR_VAL_BACKGROUNDCOLOR = "Background Color";
pub const REGSTR_VAL_TEXTCOLOR = "Text Color";
pub const REGSTR_VAL_ANCHORCOLORHOVER = "Anchor Color Hover";
pub const REGSTR_VAL_USEHOVERCOLOR = "Use Anchor Hover Color";
pub const SZ_IE_SECURITY = "Security";
pub const REGSTR_VAL_SAFETYWARNINGLEVEL = "Safety Warning Level";
pub const SZ_IE_DEFAULT_HTML_EDITOR = "Default HTML Editor";
pub const REGSTR_VAL_USEAUTOAPPEND = "Append Completion";
pub const REGSTR_VAL_USEAUTOSUGGEST = "AutoSuggest";
pub const REGSTR_VAL_USEAUTOCOMPLETE = "Use AutoComplete";
pub const SZ_IE_IBAR = "Bar";
pub const SZ_IE_IBAR_BANDS = "Bands";
pub const REGSTR_VAL_USERAGENT = "User Agent";
pub const REGSTR_VAL_INTERNETENTRY = "InternetProfile";
pub const REGSTR_VAL_INTERNETPROFILE = "InternetProfile";
pub const REGSTR_VAL_INTERNETENTRYBKUP = "BackupInternetProfile";
pub const REGSTR_VAL_CODEDOWNLOAD = "Code Download";
pub const REGSTR_VAL_CODEDOWNLOAD_DEF = "yes";
pub const REGSTR_PATH_INETCPL_RESTRICTIONS = "Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel";
pub const REGSTR_VAL_INETCPL_GENERALTAB = "GeneralTab";
pub const REGSTR_VAL_INETCPL_SECURITYTAB = "SecurityTab";
pub const REGSTR_VAL_INETCPL_CONTENTTAB = "ContentTab";
pub const REGSTR_VAL_INETCPL_CONNECTIONSTAB = "ConnectionsTab";
pub const REGSTR_VAL_INETCPL_PROGRAMSTAB = "ProgramsTab";
pub const REGSTR_VAL_INETCPL_ADVANCEDTAB = "AdvancedTab";
pub const REGSTR_VAL_INETCPL_PRIVACYTAB = "PrivacyTab";
pub const REGSTR_VAL_INETCPL_IEAK = "IEAKContext";
pub const REGSTR_VAL_DIRECTORY = "Directory";
pub const REGSTR_VAL_NEWDIRECTORY = "NewDirectory";
pub const REGSTR_VAL_CACHEPREFIX = "CachePrefix";
pub const SZ_IE_SEARCHSTRINGS = "UrlTemplate";
pub const MAX_SEARCH_FORMAT_STRING = @as(u32, 255);
pub const SZ_IE_THRESHOLDS = "ErrorThresholds";
pub const REGSTR_VAL_ACCESSMEDIUM = "AccessMedium";
pub const REGSTR_VAL_ACCESSTYPE = "AccessType";
pub const REGSTR_VAL_AUTODIALDLLNAME = "AutodialDllName";
pub const REGSTR_VAL_AUTODIALFCNNAME = "AutodialFcnName";
pub const REGSTR_VAL_AUTODIAL_MONITORCLASSNAME = "MS_AutodialMonitor";
pub const REGSTR_VAL_AUTODIAL_TRYONLYONCE = "TryAutodialOnce";
pub const REGSTR_PATH_REMOTEACCESS = "RemoteAccess";
pub const REGSTR_PATH_REMOTEACESS = "RemoteAccess";
pub const REGSTR_VAL_RNAINSTALLED = "Installed";
pub const REGSTR_VAL_ENABLEAUTODIAL = "EnableAutodial";
pub const REGSTR_VAL_ENABLEUNATTENDED = "EnableUnattended";
pub const REGSTR_VAL_NONETAUTODIAL = "NoNetAutodial";
pub const REGSTR_VAL_REDIALATTEMPTS = "RedialAttempts";
pub const REGSTR_VAL_REDIALINTERVAL = "RedialWait";
pub const REGSTR_VAL_ENABLEAUTODIALDISCONNECT = "EnableAutodisconnect";
pub const REGSTR_VAL_ENABLEAUTODISCONNECT = "EnableAutodisconnect";
pub const REGSTR_VAL_ENABLEEXITDISCONNECT = "EnableExitDisconnect";
pub const REGSTR_VAL_ENABLESECURITYCHECK = "EnableSecurityCheck";
pub const REGSTR_VAL_COVEREXCLUDE = "CoverExclude";
pub const REGSTR_VAL_DISCONNECTIDLETIME = "DisconnectIdleTime";
pub const REGSTR_VAL_MOSDISCONNECT = "DisconnectTimeout";
pub const REGSTR_VAL_PROXYENABLE = "ProxyEnable";
pub const REGSTR_VAL_PROXYSERVER = "ProxyServer";
pub const REGSTR_VAL_PROXYOVERRIDE = "ProxyOverride";
pub const REGSTR_VAL_BYPASSAUTOCONFIG = "BypassAutoconfig";
pub const SZTRUSTWARNLEVEL = "Trust Warning Level";
pub const REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH = "High";
pub const REGSTR_VAL_TRUSTWARNINGLEVEL_MED = "Medium";
pub const REGSTR_VAL_TRUSTWARNINGLEVEL_LOW = "No Security";
pub const REGSTR_VAL_SECURITYWARNONSEND = "WarnOnPost";
pub const REGSTR_VAL_SECURITYWARNONSEND_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYWARNONSENDALWAYS = "WarnAlwaysOnPost";
pub const REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYWARNONVIEW = "WarnOnView";
pub const REGSTR_VAL_SECURITYWARNONVIEW_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYALLOWCOOKIES = "AllowCookies";
pub const REGSTR_VAL_SECURITYALLOWCOOKIES_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYWARNONZONECROSSING = "WarnOnZoneCrossing";
pub const REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYWARNONBADCERTVIEWING = "WarnOnBadCertRecving";
pub const REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYWARNONBADCERTSENDING = "WarnOnBadCertSending";
pub const REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES = "DisableCachingOfSSLPages";
pub const REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF = @as(u32, 0);
pub const REGSTR_VAL_SECURITYACTIVEX = "Security_RunActiveXControls";
pub const REGSTR_VAL_SECURITYACTIVEX_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYACTICEXSCRIPTS = "Security_RunScripts";
pub const REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF = @as(u32, 1);
pub const REGSTR_VAL_SECURITYJAVA = "Security_RunJavaApplets";
pub const REGSTR_VAL_SECURITYJAVA_DEF = @as(u32, 1);
pub const SZJAVAVMPATH = "\\Java VM";
pub const REGSTR_VAL_JAVAJIT = "EnableJIT";
pub const REGSTR_VAL_JAVAJIT_DEF = @as(u32, 0);
pub const REGSTR_VAL_JAVALOGGING = "EnableLogging";
pub const REGSTR_VAL_JAVALOGGING_DEF = @as(u32, 0);
pub const SZTOOLBAR = "\\Toolbar";
pub const REGSTR_VAL_DAYSTOKEEP = "DaysToKeep";
pub const SZNOTEXT = "NoText";
pub const SZVISIBLE = "VisibleBands";
pub const REGSTR_VAL_VISIBLEBANDS = "VisibleBands";
pub const REGSTR_VAL_VISIBLEBANDS_DEF = @as(u32, 7);
pub const TOOLSBAND = @as(u32, 1);
pub const ADDRESSBAND = @as(u32, 2);
pub const LINKSBAND = @as(u32, 4);
pub const SZBACKBITMAP = "BackBitmap";
pub const REGSTR_VAL_BACKBITMAP = "BackBitmap";
pub const REGSTR_SHIFTQUICKSUFFIX = "ShiftQuickCompleteSuffix";
pub const TSZSCHANNELPATH = "SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL";
pub const REGSTR_VAL_SCHANNELENABLEPROTOCOL = "Enabled";
pub const REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF = @as(u32, 1);
pub const TSZINTERNETCLIENTSPATH = "Software\\Microsoft\\Internet Explorer\\Unix";
pub const REGSTR_PATH_DEFAULT = "default";
pub const REGSTR_PATH_CURRENT = "current";
pub const IE_USE_OE_PRESENT_HKEY = @as(i32, -2147483646);
pub const IE_USE_OE_PRESENT_KEY = "Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe";
pub const IE_USE_OE_MAIL_HKEY = @as(i32, -2147483647);
pub const IE_USE_OE_MAIL_KEY = "Software\\Microsoft\\Internet Explorer\\Mail";
pub const IE_USE_OE_MAIL_VALUE = "Use Outlook Express";
pub const IE_USE_OE_NEWS_HKEY = @as(i32, -2147483647);
pub const IE_USE_OE_NEWS_KEY = "Software\\Microsoft\\Internet Explorer\\News";
pub const IE_USE_OE_NEWS_VALUE = "Use Outlook Express";
pub const TSZPROTOCOLSPATH = "Protocols\\";
pub const TSZMAILTOPROTOCOL = "mailto";
pub const TSZNEWSPROTOCOL = "news";
pub const TSZCALLTOPROTOCOL = "callto";
pub const TSZLDAPPROTOCOL = "ldap";
pub const TSZCALENDARPROTOCOL = "unk";
pub const TSZVSOURCEPROTOCOL = "view source";
pub const REGSTR_VAL_DEFAULT_CODEPAGE = "Default_CodePage";
pub const REGSTR_VAL_DEFAULT_SCRIPT = "Default_Script";
pub const REGSTR_VAL_ACCEPT_LANGUAGE = "AcceptLanguage";
pub const REGSTR_VAL_FONT_SCRIPTS = "Scripts";
pub const REGSTR_VAL_FONT_SCRIPT = "Script";
pub const REGSTR_VAL_FONT_SCRIPT_NAME = "Script";
pub const REGSTR_VAL_DEF_ENCODING = "Default_Encoding";
pub const REGSTR_VAL_DEF_INETENCODING = "Default_InternetEncoding";
pub const REGSTR_VAL_FIXED_FONT = "IEFixedFontName";
pub const REGSTR_VAL_SCRIPT_FIXED_FONT = "IEFixedFontName";
pub const REGSTR_VAL_PROP_FONT = "IEPropFontName";
pub const REGSTR_VAL_SCRIPT_PROP_FONT = "IEPropFontName";
pub const REGSTR_VAL_FONT_SIZE = "IEFontSize";
pub const REGSTR_VAL_FONT_SIZE_DEF = @as(u32, 2);
pub const REGSTR_VAL_AUTODETECT = "AutoDetect";
pub const REGSTR_PATH_MIME_DATABASE = "MIME\\Database";
pub const REGSTR_VAL_CODEPAGE = "CodePage";
pub const REGSTR_VAL_INETENCODING = "InternetEncoding";
pub const REGSTR_VAL_FAMILY = "Family";
pub const REGSTR_VAL_LEVEL = "Level";
pub const REGSTR_VAL_ALIASTO = "AliasForCharset";
pub const REGSTR_VAL_ENCODENAME = "EncodingName";
pub const REGSTR_VAL_DESCRIPTION = "Description";
pub const REGSTR_VAL_WEBCHARSET = "WebCharset";
pub const REGSTR_VAL_BODYCHARSET = "BodyCharset";
pub const REGSTR_VAL_HEADERCHARSET = "HeaderCharset";
pub const REGSTR_VAL_FIXEDWIDTHFONT = "FixedWidthFont";
pub const REGSTR_VAL_PROPORTIONALFONT = "ProportionalFont";
pub const REGSTR_VAL_PRIVCONVERTER = "PrivConverter";
pub const IECMDID_CLEAR_AUTOCOMPLETE_FOR_FORMS = @as(u32, 0);
pub const IECMDID_SETID_AUTOCOMPLETE_FOR_FORMS = @as(u32, 1);
pub const IECMDID_BEFORENAVIGATE_GETSHELLBROWSE = @as(u32, 2);
pub const IECMDID_BEFORENAVIGATE_DOEXTERNALBROWSE = @as(u32, 3);
pub const IECMDID_BEFORENAVIGATE_GETIDLIST = @as(u32, 4);
pub const IECMDID_SET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW = @as(u32, 5);
pub const IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW = @as(u32, 6);
pub const IECMDID_ARG_CLEAR_FORMS_ALL = @as(u32, 0);
pub const IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS = @as(u32, 1);
pub const IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY = @as(u32, 2);
pub const CATID_MSOfficeAntiVirus = Guid.initString("56ffcc30-d398-11d0-b2ae-00a0c908fa49");
pub const msoedmEnable = @as(u32, 1);
pub const msoedmDisable = @as(u32, 2);
pub const msoedmDontOpen = @as(u32, 3);
pub const msoslUndefined = @as(u32, 0);
pub const msoslNone = @as(u32, 1);
pub const msoslMedium = @as(u32, 2);
pub const msoslHigh = @as(u32, 3);
pub const msodsvNoMacros = @as(u32, 0);
pub const msodsvUnsigned = @as(u32, 1);
pub const msodsvPassedTrusted = @as(u32, 2);
pub const msodsvFailed = @as(u32, 3);
pub const msodsvLowSecurityLevel = @as(u32, 4);
pub const msodsvPassedTrustedCert = @as(u32, 5);
pub const STATURL_QUERYFLAG_ISCACHED = @as(u32, 65536);
pub const STATURL_QUERYFLAG_NOURL = @as(u32, 131072);
pub const STATURL_QUERYFLAG_NOTITLE = @as(u32, 262144);
pub const STATURL_QUERYFLAG_TOPLEVEL = @as(u32, 524288);
pub const STATURLFLAG_ISCACHED = @as(u32, 1);
pub const STATURLFLAG_ISTOPLEVEL = @as(u32, 2);
pub const SURFACE_LOCK_EXCLUSIVE = @as(u32, 1);
pub const SURFACE_LOCK_ALLOW_DISCARD = @as(u32, 2);
pub const SURFACE_LOCK_WAIT = @as(u32, 4);
pub const E_SURFACE_NOSURFACE = @as(i32, -2147434496);
pub const E_SURFACE_UNKNOWN_FORMAT = @as(i32, -2147434495);
pub const E_SURFACE_NOTMYPOINTER = @as(i32, -2147434494);
pub const E_SURFACE_DISCARDED = @as(i32, -2147434493);
pub const E_SURFACE_NODC = @as(i32, -2147434492);
pub const E_SURFACE_NOTMYDC = @as(i32, -2147434491);
pub const S_SURFACE_DISCARDED = @as(i32, 49155);
pub const COLOR_NO_TRANSPARENT = @as(u32, 4294967295);
pub const IMGDECODE_EVENT_PROGRESS = @as(u32, 1);
pub const IMGDECODE_EVENT_PALETTE = @as(u32, 2);
pub const IMGDECODE_EVENT_BEGINBITS = @as(u32, 4);
pub const IMGDECODE_EVENT_BITSCOMPLETE = @as(u32, 8);
pub const IMGDECODE_EVENT_USEDDRAW = @as(u32, 16);
pub const IMGDECODE_HINT_TOPDOWN = @as(u32, 1);
pub const IMGDECODE_HINT_BOTTOMUP = @as(u32, 2);
pub const IMGDECODE_HINT_FULLWIDTH = @as(u32, 4);
pub const MAPMIME_DEFAULT = @as(u32, 0);
pub const MAPMIME_CLSID = @as(u32, 1);
pub const MAPMIME_DISABLE = @as(u32, 2);
pub const MAPMIME_DEFAULT_ALWAYS = @as(u32, 3);
pub const TIMERMODE_NORMAL = @as(u32, 0);
pub const TIMERMODE_VISIBILITYAWARE = @as(u32, 1);

//--------------------------------------------------------------------------------
// Section: Types (112)
//--------------------------------------------------------------------------------
const IID_IDocObjectService_Value = Guid.initString("3050f801-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDocObjectService = &IID_IDocObjectService_Value;
pub const IDocObjectService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireBeforeNavigate2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pDispatch: ?*IDispatch,
                lpszUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
                lpszFrameName: ?[*:0]align(1) const u16,
                pPostData: ?*u8,
                cbPostData: u32,
                lpszHeaders: ?[*:0]align(1) const u16,
                fPlayNavSound: BOOL,
                pfCancel: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pDispatch: ?*IDispatch,
                lpszUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
                lpszFrameName: ?[*:0]align(1) const u16,
                pPostData: ?*u8,
                cbPostData: u32,
                lpszHeaders: ?[*:0]align(1) const u16,
                fPlayNavSound: BOOL,
                pfCancel: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireNavigateComplete2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pHTMLWindow2: ?*IHTMLWindow2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pHTMLWindow2: ?*IHTMLWindow2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDownloadBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDownloadComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDocumentComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pHTMLWindow: ?*IHTMLWindow2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pHTMLWindow: ?*IHTMLWindow2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateDesktopComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pHTMLWindow: ?*IHTMLWindow2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pHTMLWindow: ?*IHTMLWindow2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPendingUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pbstrPendingUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pbstrPendingUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActiveElementChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pHTMLElement: ?*IHTMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pHTMLElement: ?*IHTMLElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUrlSearchComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                pbstrSearch: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                pbstrSearch: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsErrorUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDocObjectService,
                lpszUrl: ?[*:0]align(1) const u16,
                pfIsError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDocObjectService,
                lpszUrl: ?[*:0]align(1) const u16,
                pfIsError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_FireBeforeNavigate2(self: *const T, pDispatch: ?*IDispatch, lpszUrl: ?[*:0]align(1) const u16, dwFlags: u32, lpszFrameName: ?[*:0]align(1) const u16, pPostData: ?*u8, cbPostData: u32, lpszHeaders: ?[*:0]align(1) const u16, fPlayNavSound: BOOL, pfCancel: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).FireBeforeNavigate2(@as(*const IDocObjectService, @ptrCast(self)), pDispatch, lpszUrl, dwFlags, lpszFrameName, pPostData, cbPostData, lpszHeaders, fPlayNavSound, pfCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_FireNavigateComplete2(self: *const T, pHTMLWindow2: ?*IHTMLWindow2, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).FireNavigateComplete2(@as(*const IDocObjectService, @ptrCast(self)), pHTMLWindow2, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_FireDownloadBegin(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).FireDownloadBegin(@as(*const IDocObjectService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_FireDownloadComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).FireDownloadComplete(@as(*const IDocObjectService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_FireDocumentComplete(self: *const T, pHTMLWindow: ?*IHTMLWindow2, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).FireDocumentComplete(@as(*const IDocObjectService, @ptrCast(self)), pHTMLWindow, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_UpdateDesktopComponent(self: *const T, pHTMLWindow: ?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).UpdateDesktopComponent(@as(*const IDocObjectService, @ptrCast(self)), pHTMLWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_GetPendingUrl(self: *const T, pbstrPendingUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).GetPendingUrl(@as(*const IDocObjectService, @ptrCast(self)), pbstrPendingUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_ActiveElementChanged(self: *const T, pHTMLElement: ?*IHTMLElement) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).ActiveElementChanged(@as(*const IDocObjectService, @ptrCast(self)), pHTMLElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_GetUrlSearchComponent(self: *const T, pbstrSearch: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).GetUrlSearchComponent(@as(*const IDocObjectService, @ptrCast(self)), pbstrSearch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocObjectService_IsErrorUrl(self: *const T, lpszUrl: ?[*:0]align(1) const u16, pfIsError: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDocObjectService.VTable, @ptrCast(self.vtable)).IsErrorUrl(@as(*const IDocObjectService, @ptrCast(self)), lpszUrl, pfIsError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDownloadManager_Value = Guid.initString("988934a4-064b-11d3-bb80-00104b35e7f9");
pub const IID_IDownloadManager = &IID_IDownloadManager_Value;
pub const IDownloadManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Download: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadManager,
                pmk: ?*IMoniker,
                pbc: ?*IBindCtx,
                dwBindVerb: u32,
                grfBINDF: i32,
                pBindInfo: ?*BINDINFO,
                pszHeaders: ?[*:0]align(1) const u16,
                pszRedir: ?[*:0]align(1) const u16,
                uiCP: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadManager,
                pmk: ?*IMoniker,
                pbc: ?*IBindCtx,
                dwBindVerb: u32,
                grfBINDF: i32,
                pBindInfo: ?*BINDINFO,
                pszHeaders: ?[*:0]align(1) const u16,
                pszRedir: ?[*:0]align(1) const u16,
                uiCP: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadManager_Download(self: *const T, pmk: ?*IMoniker, pbc: ?*IBindCtx, dwBindVerb: u32, grfBINDF: i32, pBindInfo: ?*BINDINFO, pszHeaders: ?[*:0]align(1) const u16, pszRedir: ?[*:0]align(1) const u16, uiCP: u32) callconv(.Inline) HRESULT {
            return @as(*const IDownloadManager.VTable, @ptrCast(self.vtable)).Download(@as(*const IDownloadManager, @ptrCast(self)), pmk, pbc, dwBindVerb, grfBINDF, pBindInfo, pszHeaders, pszRedir, uiCP);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ExtensionValidationContexts = enum(i32) {
    None = 0,
    Dynamic = 1,
    Parsed = 2,
};
pub const ExtensionValidationContextNone = ExtensionValidationContexts.None;
pub const ExtensionValidationContextDynamic = ExtensionValidationContexts.Dynamic;
pub const ExtensionValidationContextParsed = ExtensionValidationContexts.Parsed;

pub const ExtensionValidationResults = enum(i32) {
    None = 0,
    DoNotInstantiate = 1,
    ArrestPageLoad = 2,
};
pub const ExtensionValidationResultNone = ExtensionValidationResults.None;
pub const ExtensionValidationResultDoNotInstantiate = ExtensionValidationResults.DoNotInstantiate;
pub const ExtensionValidationResultArrestPageLoad = ExtensionValidationResults.ArrestPageLoad;

const IID_IExtensionValidation_Value = Guid.initString("7d33f73d-8525-4e0f-87db-830288baff44");
pub const IID_IExtensionValidation = &IID_IExtensionValidation_Value;
pub const IExtensionValidation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtensionValidation,
                extensionGuid: ?*const Guid,
                extensionModulePath: ?PWSTR,
                extensionFileVersionMS: u32,
                extensionFileVersionLS: u32,
                htmlDocumentTop: ?*IHTMLDocument2,
                htmlDocumentSubframe: ?*IHTMLDocument2,
                htmlElement: ?*IHTMLElement,
                contexts: ExtensionValidationContexts,
                results: ?*ExtensionValidationResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtensionValidation,
                extensionGuid: ?*const Guid,
                extensionModulePath: ?PWSTR,
                extensionFileVersionMS: u32,
                extensionFileVersionLS: u32,
                htmlDocumentTop: ?*IHTMLDocument2,
                htmlDocumentSubframe: ?*IHTMLDocument2,
                htmlElement: ?*IHTMLElement,
                contexts: ExtensionValidationContexts,
                results: ?*ExtensionValidationResults,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IExtensionValidation,
                displayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IExtensionValidation,
                displayName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtensionValidation_Validate(self: *const T, extensionGuid: ?*const Guid, extensionModulePath: ?PWSTR, extensionFileVersionMS: u32, extensionFileVersionLS: u32, htmlDocumentTop: ?*IHTMLDocument2, htmlDocumentSubframe: ?*IHTMLDocument2, htmlElement: ?*IHTMLElement, contexts: ExtensionValidationContexts, results: ?*ExtensionValidationResults) callconv(.Inline) HRESULT {
            return @as(*const IExtensionValidation.VTable, @ptrCast(self.vtable)).Validate(@as(*const IExtensionValidation, @ptrCast(self)), extensionGuid, extensionModulePath, extensionFileVersionMS, extensionFileVersionLS, htmlDocumentTop, htmlDocumentSubframe, htmlElement, contexts, results);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExtensionValidation_DisplayName(self: *const T, displayName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IExtensionValidation.VTable, @ptrCast(self.vtable)).DisplayName(@as(*const IExtensionValidation, @ptrCast(self)), displayName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHomePageSetting_Value = Guid.initString("fdfc244f-18fa-4ff2-b08e-1d618f3ffbe4");
pub const IID_IHomePageSetting = &IID_IHomePageSetting_Value;
pub const IHomePageSetting = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHomePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePageSetting,
                hwnd: ?HWND,
                homePageUri: ?[*:0]align(1) const u16,
                brandingMessage: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePageSetting,
                hwnd: ?HWND,
                homePageUri: ?[*:0]align(1) const u16,
                brandingMessage: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsHomePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePageSetting,
                uri: ?[*:0]align(1) const u16,
                isDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePageSetting,
                uri: ?[*:0]align(1) const u16,
                isDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHomePageToBrowserDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePageSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePageSetting,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePageSetting_SetHomePage(self: *const T, hwnd: ?HWND, homePageUri: ?[*:0]align(1) const u16, brandingMessage: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IHomePageSetting.VTable, @ptrCast(self.vtable)).SetHomePage(@as(*const IHomePageSetting, @ptrCast(self)), hwnd, homePageUri, brandingMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePageSetting_IsHomePage(self: *const T, uri: ?[*:0]align(1) const u16, isDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHomePageSetting.VTable, @ptrCast(self.vtable)).IsHomePage(@as(*const IHomePageSetting, @ptrCast(self)), uri, isDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePageSetting_SetHomePageToBrowserDefault(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHomePageSetting.VTable, @ptrCast(self.vtable)).SetHomePageToBrowserDefault(@as(*const IHomePageSetting, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_HomePageSetting_Value = Guid.initString("374cede0-873a-4c4f-bc86-bcc8cf5116a3");
pub const CLSID_HomePageSetting = &CLSID_HomePageSetting_Value;

const IID_ITargetNotify_Value = Guid.initString("863a99a0-21bc-11d0-82b4-00a0c90c29c5");
pub const IID_ITargetNotify = &IID_ITargetNotify_Value;
pub const ITargetNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCreate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetNotify,
                pUnkDestination: ?*IUnknown,
                cbCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetNotify,
                pUnkDestination: ?*IUnknown,
                cbCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnReuse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetNotify,
                pUnkDestination: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetNotify,
                pUnkDestination: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetNotify_OnCreate(self: *const T, pUnkDestination: ?*IUnknown, cbCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetNotify.VTable, @ptrCast(self.vtable)).OnCreate(@as(*const ITargetNotify, @ptrCast(self)), pUnkDestination, cbCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetNotify_OnReuse(self: *const T, pUnkDestination: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetNotify.VTable, @ptrCast(self.vtable)).OnReuse(@as(*const ITargetNotify, @ptrCast(self)), pUnkDestination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITargetNotify2_Value = Guid.initString("3050f6b1-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITargetNotify2 = &IID_ITargetNotify2_Value;
pub const ITargetNotify2 = extern struct {
    pub const VTable = extern struct {
        base: ITargetNotify.VTable,
        GetOptionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetNotify2,
                pbstrOptions: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetNotify2,
                pbstrOptions: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITargetNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetNotify2_GetOptionString(self: *const T, pbstrOptions: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetNotify2.VTable, @ptrCast(self.vtable)).GetOptionString(@as(*const ITargetNotify2, @ptrCast(self)), pbstrOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FINDFRAME_FLAGS = enum(i32) {
    NONE = 0,
    JUSTTESTEXISTENCE = 1,
    INTERNAL = -2147483648,
};
pub const FINDFRAME_NONE = FINDFRAME_FLAGS.NONE;
pub const FINDFRAME_JUSTTESTEXISTENCE = FINDFRAME_FLAGS.JUSTTESTEXISTENCE;
pub const FINDFRAME_INTERNAL = FINDFRAME_FLAGS.INTERNAL;

pub const FRAMEOPTIONS_FLAGS = enum(i32) {
    SCROLL_YES = 1,
    SCROLL_NO = 2,
    SCROLL_AUTO = 4,
    NORESIZE = 8,
    NO3DBORDER = 16,
    DESKTOP = 32,
    BROWSERBAND = 64,
};
pub const FRAMEOPTIONS_SCROLL_YES = FRAMEOPTIONS_FLAGS.SCROLL_YES;
pub const FRAMEOPTIONS_SCROLL_NO = FRAMEOPTIONS_FLAGS.SCROLL_NO;
pub const FRAMEOPTIONS_SCROLL_AUTO = FRAMEOPTIONS_FLAGS.SCROLL_AUTO;
pub const FRAMEOPTIONS_NORESIZE = FRAMEOPTIONS_FLAGS.NORESIZE;
pub const FRAMEOPTIONS_NO3DBORDER = FRAMEOPTIONS_FLAGS.NO3DBORDER;
pub const FRAMEOPTIONS_DESKTOP = FRAMEOPTIONS_FLAGS.DESKTOP;
pub const FRAMEOPTIONS_BROWSERBAND = FRAMEOPTIONS_FLAGS.BROWSERBAND;

const IID_ITargetFrame2_Value = Guid.initString("86d52e11-94a8-11d0-82af-00c04fd5ae38");
pub const IID_ITargetFrame2 = &IID_ITargetFrame2_Value;
pub const ITargetFrame2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pszFrameName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pszFrameName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                ppszFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                ppszFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                ppunkParent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                ppunkParent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameSrc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pszFrameSrc: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pszFrameSrc: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameSrc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFramesContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameMargins: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                dwWidth: u32,
                dwHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                dwWidth: u32,
                dwHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameMargins: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pszTargetName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pszTargetName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTargetAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame2,
                pszTargetName: ?[*:0]align(1) const u16,
                ppszTargetAlias: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame2,
                pszTargetName: ?[*:0]align(1) const u16,
                ppszTargetAlias: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_SetFrameName(self: *const T, pszFrameName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).SetFrameName(@as(*const ITargetFrame2, @ptrCast(self)), pszFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetFrameName(self: *const T, ppszFrameName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetFrameName(@as(*const ITargetFrame2, @ptrCast(self)), ppszFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetParentFrame(self: *const T, ppunkParent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetParentFrame(@as(*const ITargetFrame2, @ptrCast(self)), ppunkParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_SetFrameSrc(self: *const T, pszFrameSrc: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).SetFrameSrc(@as(*const ITargetFrame2, @ptrCast(self)), pszFrameSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetFrameSrc(self: *const T, ppszFrameSrc: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetFrameSrc(@as(*const ITargetFrame2, @ptrCast(self)), ppszFrameSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetFramesContainer(self: *const T, ppContainer: ?*?*IOleContainer) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetFramesContainer(@as(*const ITargetFrame2, @ptrCast(self)), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_SetFrameOptions(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).SetFrameOptions(@as(*const ITargetFrame2, @ptrCast(self)), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetFrameOptions(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetFrameOptions(@as(*const ITargetFrame2, @ptrCast(self)), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_SetFrameMargins(self: *const T, dwWidth: u32, dwHeight: u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).SetFrameMargins(@as(*const ITargetFrame2, @ptrCast(self)), dwWidth, dwHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetFrameMargins(self: *const T, pdwWidth: ?*u32, pdwHeight: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetFrameMargins(@as(*const ITargetFrame2, @ptrCast(self)), pdwWidth, pdwHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_FindFrame(self: *const T, pszTargetName: ?[*:0]align(1) const u16, dwFlags: u32, ppunkTargetFrame: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).FindFrame(@as(*const ITargetFrame2, @ptrCast(self)), pszTargetName, dwFlags, ppunkTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame2_GetTargetAlias(self: *const T, pszTargetName: ?[*:0]align(1) const u16, ppszTargetAlias: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame2.VTable, @ptrCast(self.vtable)).GetTargetAlias(@as(*const ITargetFrame2, @ptrCast(self)), pszTargetName, ppszTargetAlias);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITargetContainer_Value = Guid.initString("7847ec01-2bec-11d0-82b4-00a0c90c29c5");
pub const IID_ITargetContainer = &IID_ITargetContainer_Value;
pub const ITargetContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetContainer,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetContainer,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFramesContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetContainer,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetContainer,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetContainer_GetFrameUrl(self: *const T, ppszFrameSrc: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetContainer.VTable, @ptrCast(self.vtable)).GetFrameUrl(@as(*const ITargetContainer, @ptrCast(self)), ppszFrameSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetContainer_GetFramesContainer(self: *const T, ppContainer: ?*?*IOleContainer) callconv(.Inline) HRESULT {
            return @as(*const ITargetContainer.VTable, @ptrCast(self.vtable)).GetFramesContainer(@as(*const ITargetContainer, @ptrCast(self)), ppContainer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NAVIGATEFRAME_FLAGS = enum(i32) {
    RECORD = 1,
    POST = 2,
    NO_DOC_CACHE = 4,
    NO_IMAGE_CACHE = 8,
    AUTH_FAIL_CACHE_OK = 16,
    SENDING_FROM_FORM = 32,
    REALLY_SENDING_FROM_FORM = 64,
};
pub const NAVIGATEFRAME_FL_RECORD = NAVIGATEFRAME_FLAGS.RECORD;
pub const NAVIGATEFRAME_FL_POST = NAVIGATEFRAME_FLAGS.POST;
pub const NAVIGATEFRAME_FL_NO_DOC_CACHE = NAVIGATEFRAME_FLAGS.NO_DOC_CACHE;
pub const NAVIGATEFRAME_FL_NO_IMAGE_CACHE = NAVIGATEFRAME_FLAGS.NO_IMAGE_CACHE;
pub const NAVIGATEFRAME_FL_AUTH_FAIL_CACHE_OK = NAVIGATEFRAME_FLAGS.AUTH_FAIL_CACHE_OK;
pub const NAVIGATEFRAME_FL_SENDING_FROM_FORM = NAVIGATEFRAME_FLAGS.SENDING_FROM_FORM;
pub const NAVIGATEFRAME_FL_REALLY_SENDING_FROM_FORM = NAVIGATEFRAME_FLAGS.REALLY_SENDING_FROM_FORM;

pub const NAVIGATEDATA = extern struct {
    ulTarget: u32,
    ulURL: u32,
    ulRefURL: u32,
    ulPostData: u32,
    dwFlags: u32,
};

const IID_ITargetFrame_Value = Guid.initString("d5f78c80-5252-11cf-90fa-00aa0042106e");
pub const IID_ITargetFrame = &IID_ITargetFrame_Value;
pub const ITargetFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pszFrameName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pszFrameName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                ppszFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                ppszFrameName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                ppunkParent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                ppunkParent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pszTargetName: ?[*:0]align(1) const u16,
                ppunkContextFrame: ?*IUnknown,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pszTargetName: ?[*:0]align(1) const u16,
                ppunkContextFrame: ?*IUnknown,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameSrc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pszFrameSrc: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pszFrameSrc: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameSrc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                ppszFrameSrc: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFramesContainer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                ppContainer: ?*?*IOleContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFrameMargins: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                dwWidth: u32,
                dwHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                dwWidth: u32,
                dwHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameMargins: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pdwWidth: ?*u32,
                pdwHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoteNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                cLength: u32,
                pulData: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                cLength: u32,
                pulData: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChildFrameActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChildFrameDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFrame,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFrame,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_SetFrameName(self: *const T, pszFrameName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).SetFrameName(@as(*const ITargetFrame, @ptrCast(self)), pszFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetFrameName(self: *const T, ppszFrameName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetFrameName(@as(*const ITargetFrame, @ptrCast(self)), ppszFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetParentFrame(self: *const T, ppunkParent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetParentFrame(@as(*const ITargetFrame, @ptrCast(self)), ppunkParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_FindFrame(self: *const T, pszTargetName: ?[*:0]align(1) const u16, ppunkContextFrame: ?*IUnknown, dwFlags: u32, ppunkTargetFrame: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).FindFrame(@as(*const ITargetFrame, @ptrCast(self)), pszTargetName, ppunkContextFrame, dwFlags, ppunkTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_SetFrameSrc(self: *const T, pszFrameSrc: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).SetFrameSrc(@as(*const ITargetFrame, @ptrCast(self)), pszFrameSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetFrameSrc(self: *const T, ppszFrameSrc: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetFrameSrc(@as(*const ITargetFrame, @ptrCast(self)), ppszFrameSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetFramesContainer(self: *const T, ppContainer: ?*?*IOleContainer) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetFramesContainer(@as(*const ITargetFrame, @ptrCast(self)), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_SetFrameOptions(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).SetFrameOptions(@as(*const ITargetFrame, @ptrCast(self)), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetFrameOptions(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetFrameOptions(@as(*const ITargetFrame, @ptrCast(self)), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_SetFrameMargins(self: *const T, dwWidth: u32, dwHeight: u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).SetFrameMargins(@as(*const ITargetFrame, @ptrCast(self)), dwWidth, dwHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_GetFrameMargins(self: *const T, pdwWidth: ?*u32, pdwHeight: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).GetFrameMargins(@as(*const ITargetFrame, @ptrCast(self)), pdwWidth, pdwHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_RemoteNavigate(self: *const T, cLength: u32, pulData: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).RemoteNavigate(@as(*const ITargetFrame, @ptrCast(self)), cLength, pulData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_OnChildFrameActivate(self: *const T, pUnkChildFrame: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).OnChildFrameActivate(@as(*const ITargetFrame, @ptrCast(self)), pUnkChildFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFrame_OnChildFrameDeactivate(self: *const T, pUnkChildFrame: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFrame.VTable, @ptrCast(self.vtable)).OnChildFrameDeactivate(@as(*const ITargetFrame, @ptrCast(self)), pUnkChildFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITargetEmbedding_Value = Guid.initString("548793c0-9e74-11cf-9655-00a0c9034923");
pub const IID_ITargetEmbedding = &IID_ITargetEmbedding_Value;
pub const ITargetEmbedding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetEmbedding,
                ppTargetFrame: ?*?*ITargetFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetEmbedding,
                ppTargetFrame: ?*?*ITargetFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetEmbedding_GetTargetFrame(self: *const T, ppTargetFrame: ?*?*ITargetFrame) callconv(.Inline) HRESULT {
            return @as(*const ITargetEmbedding.VTable, @ptrCast(self.vtable)).GetTargetFrame(@as(*const ITargetEmbedding, @ptrCast(self)), ppTargetFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITargetFramePriv_Value = Guid.initString("9216e421-2bf5-11d0-82b4-00a0c90c29c5");
pub const IID_ITargetFramePriv = &IID_ITargetFramePriv_Value;
pub const ITargetFramePriv = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindFrameDownwards: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                pszTargetName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                pszTargetName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFrameInContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                pszTargetName: ?[*:0]align(1) const u16,
                punkContextFrame: ?*IUnknown,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                pszTargetName: ?[*:0]align(1) const u16,
                punkContextFrame: ?*IUnknown,
                dwFlags: u32,
                ppunkTargetFrame: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChildFrameActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnChildFrameDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                pUnkChildFrame: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NavigateHack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pszTargetName: ?[*:0]align(1) const u16,
                pszUrl: ?[*:0]align(1) const u16,
                pszLocation: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pszTargetName: ?[*:0]align(1) const u16,
                pszUrl: ?[*:0]align(1) const u16,
                pszLocation: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindBrowserByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv,
                dwID: u32,
                ppunkBrowser: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv,
                dwID: u32,
                ppunkBrowser: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_FindFrameDownwards(self: *const T, pszTargetName: ?[*:0]align(1) const u16, dwFlags: u32, ppunkTargetFrame: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).FindFrameDownwards(@as(*const ITargetFramePriv, @ptrCast(self)), pszTargetName, dwFlags, ppunkTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_FindFrameInContext(self: *const T, pszTargetName: ?[*:0]align(1) const u16, punkContextFrame: ?*IUnknown, dwFlags: u32, ppunkTargetFrame: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).FindFrameInContext(@as(*const ITargetFramePriv, @ptrCast(self)), pszTargetName, punkContextFrame, dwFlags, ppunkTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_OnChildFrameActivate(self: *const T, pUnkChildFrame: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).OnChildFrameActivate(@as(*const ITargetFramePriv, @ptrCast(self)), pUnkChildFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_OnChildFrameDeactivate(self: *const T, pUnkChildFrame: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).OnChildFrameDeactivate(@as(*const ITargetFramePriv, @ptrCast(self)), pUnkChildFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_NavigateHack(self: *const T, grfHLNF: u32, pbc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pszTargetName: ?[*:0]align(1) const u16, pszUrl: ?[*:0]align(1) const u16, pszLocation: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).NavigateHack(@as(*const ITargetFramePriv, @ptrCast(self)), grfHLNF, pbc, pibsc, pszTargetName, pszUrl, pszLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv_FindBrowserByIndex(self: *const T, dwID: u32, ppunkBrowser: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv.VTable, @ptrCast(self.vtable)).FindBrowserByIndex(@as(*const ITargetFramePriv, @ptrCast(self)), dwID, ppunkBrowser);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITargetFramePriv2_Value = Guid.initString("b2c867e6-69d6-46f2-a611-ded9a4bd7fef");
pub const IID_ITargetFramePriv2 = &IID_ITargetFramePriv2_Value;
pub const ITargetFramePriv2 = extern struct {
    pub const VTable = extern struct {
        base: ITargetFramePriv.VTable,
        AggregatedNavigation2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITargetFramePriv2,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pszTargetName: ?[*:0]align(1) const u16,
                pUri: ?*IUri,
                pszLocation: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITargetFramePriv2,
                grfHLNF: u32,
                pbc: ?*IBindCtx,
                pibsc: ?*IBindStatusCallback,
                pszTargetName: ?[*:0]align(1) const u16,
                pUri: ?*IUri,
                pszLocation: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITargetFramePriv.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITargetFramePriv2_AggregatedNavigation2(self: *const T, grfHLNF: u32, pbc: ?*IBindCtx, pibsc: ?*IBindStatusCallback, pszTargetName: ?[*:0]align(1) const u16, pUri: ?*IUri, pszLocation: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITargetFramePriv2.VTable, @ptrCast(self.vtable)).AggregatedNavigation2(@as(*const ITargetFramePriv2, @ptrCast(self)), grfHLNF, pbc, pibsc, pszTargetName, pUri, pszLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfacePresenterFlipBuffer_Value = Guid.initString("e43f4a08-8bbc-4665-ac92-c55ce61fd7e7");
pub const IID_ISurfacePresenterFlipBuffer = &IID_ISurfacePresenterFlipBuffer_Value;
pub const ISurfacePresenterFlipBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISurfacePresenterFlipBuffer,
                riid: ?*const Guid,
                ppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISurfacePresenterFlipBuffer,
                riid: ?*const Guid,
                ppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISurfacePresenterFlipBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISurfacePresenterFlipBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenterFlipBuffer_BeginDraw(self: *const T, riid: ?*const Guid, ppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ISurfacePresenterFlipBuffer.VTable, @ptrCast(self.vtable)).BeginDraw(@as(*const ISurfacePresenterFlipBuffer, @ptrCast(self)), riid, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenterFlipBuffer_EndDraw(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISurfacePresenterFlipBuffer.VTable, @ptrCast(self.vtable)).EndDraw(@as(*const ISurfacePresenterFlipBuffer, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfacePresenterFlip_Value = Guid.initString("30510848-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISurfacePresenterFlip = &IID_ISurfacePresenterFlip_Value;
pub const ISurfacePresenterFlip = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Present: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISurfacePresenterFlip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISurfacePresenterFlip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISurfacePresenterFlip,
                backBufferIndex: u32,
                riid: ?*const Guid,
                ppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISurfacePresenterFlip,
                backBufferIndex: u32,
                riid: ?*const Guid,
                ppBuffer: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenterFlip_Present(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISurfacePresenterFlip.VTable, @ptrCast(self.vtable)).Present(@as(*const ISurfacePresenterFlip, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenterFlip_GetBuffer(self: *const T, backBufferIndex: u32, riid: ?*const Guid, ppBuffer: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ISurfacePresenterFlip.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const ISurfacePresenterFlip, @ptrCast(self)), backBufferIndex, riid, ppBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfacePresenterFlip2_Value = Guid.initString("30510865-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ISurfacePresenterFlip2 = &IID_ISurfacePresenterFlip2_Value;
pub const ISurfacePresenterFlip2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRotation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISurfacePresenterFlip2,
                dxgiRotation: DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISurfacePresenterFlip2,
                dxgiRotation: DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenterFlip2_SetRotation(self: *const T, dxgiRotation: DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @as(*const ISurfacePresenterFlip2.VTable, @ptrCast(self.vtable)).SetRotation(@as(*const ISurfacePresenterFlip2, @ptrCast(self)), dxgiRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentFlipSite_Value = Guid.initString("30510846-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentFlipSite = &IID_IViewObjectPresentFlipSite_Value;
pub const IViewObjectPresentFlipSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSurfacePresenterFlip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pDevice: ?*IUnknown,
                width: u32,
                height: u32,
                backBufferCount: u32,
                format: DXGI_FORMAT,
                mode: VIEW_OBJECT_ALPHA_MODE,
                ppSPFlip: ?*?*ISurfacePresenterFlip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pDevice: ?*IUnknown,
                width: u32,
                height: u32,
                backBufferCount: u32,
                format: DXGI_FORMAT,
                mode: VIEW_OBJECT_ALPHA_MODE,
                ppSPFlip: ?*?*ISurfacePresenterFlip,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeviceLuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pLuid: ?*LUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pLuid: ?*LUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnterFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pfFullScreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pfFullScreen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoundingRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMetrics: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pPos: ?*POINT,
                pSize: ?*SIZE,
                pScaleX: ?*f32,
                pScaleY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pPos: ?*POINT,
                pSize: ?*SIZE,
                pScaleX: ?*f32,
                pScaleY: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFullScreenSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite,
                pSize: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_CreateSurfacePresenterFlip(self: *const T, pDevice: ?*IUnknown, width: u32, height: u32, backBufferCount: u32, format: DXGI_FORMAT, mode: VIEW_OBJECT_ALPHA_MODE, ppSPFlip: ?*?*ISurfacePresenterFlip) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).CreateSurfacePresenterFlip(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pDevice, width, height, backBufferCount, format, mode, ppSPFlip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_GetDeviceLuid(self: *const T, pLuid: ?*LUID) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).GetDeviceLuid(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pLuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_EnterFullScreen(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).EnterFullScreen(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_ExitFullScreen(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).ExitFullScreen(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_IsFullScreen(self: *const T, pfFullScreen: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).IsFullScreen(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pfFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_GetBoundingRect(self: *const T, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).GetBoundingRect(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_GetMetrics(self: *const T, pPos: ?*POINT, pSize: ?*SIZE, pScaleX: ?*f32, pScaleY: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).GetMetrics(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pPos, pSize, pScaleX, pScaleY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite_GetFullScreenSize(self: *const T, pSize: ?*SIZE) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite.VTable, @ptrCast(self.vtable)).GetFullScreenSize(@as(*const IViewObjectPresentFlipSite, @ptrCast(self)), pSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentFlipSite2_Value = Guid.initString("aad0cbf1-e7fd-4f12-8902-c78132a8e01d");
pub const IID_IViewObjectPresentFlipSite2 = &IID_IViewObjectPresentFlipSite2_Value;
pub const IViewObjectPresentFlipSite2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRotationForCurrentOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlipSite2,
                pDxgiRotation: ?*DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlipSite2,
                pDxgiRotation: ?*DXGI_MODE_ROTATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlipSite2_GetRotationForCurrentOutput(self: *const T, pDxgiRotation: ?*DXGI_MODE_ROTATION) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlipSite2.VTable, @ptrCast(self.vtable)).GetRotationForCurrentOutput(@as(*const IViewObjectPresentFlipSite2, @ptrCast(self)), pDxgiRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentFlip_Value = Guid.initString("30510847-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentFlip = &IID_IViewObjectPresentFlip_Value;
pub const IViewObjectPresentFlip = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRender: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlip,
                fRecreatePresenter: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlip,
                fRecreatePresenter: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderObjectToBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlip,
                pBitmap: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlip,
                pBitmap: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderObjectToSharedBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlip,
                pBuffer: ?*ISurfacePresenterFlipBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlip,
                pBuffer: ?*ISurfacePresenterFlipBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlip_NotifyRender(self: *const T, fRecreatePresenter: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlip.VTable, @ptrCast(self.vtable)).NotifyRender(@as(*const IViewObjectPresentFlip, @ptrCast(self)), fRecreatePresenter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlip_RenderObjectToBitmap(self: *const T, pBitmap: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlip.VTable, @ptrCast(self.vtable)).RenderObjectToBitmap(@as(*const IViewObjectPresentFlip, @ptrCast(self)), pBitmap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlip_RenderObjectToSharedBuffer(self: *const T, pBuffer: ?*ISurfacePresenterFlipBuffer) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlip.VTable, @ptrCast(self.vtable)).RenderObjectToSharedBuffer(@as(*const IViewObjectPresentFlip, @ptrCast(self)), pBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentFlip2_Value = Guid.initString("30510856-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IViewObjectPresentFlip2 = &IID_IViewObjectPresentFlip2_Value;
pub const IViewObjectPresentFlip2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyLeavingView: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IViewObjectPresentFlip2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IViewObjectPresentFlip2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentFlip2_NotifyLeavingView(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IViewObjectPresentFlip2.VTable, @ptrCast(self.vtable)).NotifyLeavingView(@as(*const IViewObjectPresentFlip2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveXUIHandlerSite2_Value = Guid.initString("7e3707b2-d087-4542-ac1f-a0d2fcd080fd");
pub const IID_IActiveXUIHandlerSite2 = &IID_IActiveXUIHandlerSite2_Value;
pub const IActiveXUIHandlerSite2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSuspensionExemption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveXUIHandlerSite2,
                pullCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveXUIHandlerSite2,
                pullCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSuspensionExemption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveXUIHandlerSite2,
                ullCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveXUIHandlerSite2,
                ullCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveXUIHandlerSite2_AddSuspensionExemption(self: *const T, pullCookie: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IActiveXUIHandlerSite2.VTable, @ptrCast(self.vtable)).AddSuspensionExemption(@as(*const IActiveXUIHandlerSite2, @ptrCast(self)), pullCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveXUIHandlerSite2_RemoveSuspensionExemption(self: *const T, ullCookie: u64) callconv(.Inline) HRESULT {
            return @as(*const IActiveXUIHandlerSite2.VTable, @ptrCast(self.vtable)).RemoveSuspensionExemption(@as(*const IActiveXUIHandlerSite2, @ptrCast(self)), ullCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaretPositionProvider_Value = Guid.initString("58da43a2-108e-4d5b-9f75-e5f74f93fff5");
pub const IID_ICaretPositionProvider = &IID_ICaretPositionProvider_Value;
pub const ICaretPositionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaretPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaretPositionProvider,
                pptCaret: ?*POINT,
                pflHeight: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaretPositionProvider,
                pptCaret: ?*POINT,
                pflHeight: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaretPositionProvider_GetCaretPosition(self: *const T, pptCaret: ?*POINT, pflHeight: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const ICaretPositionProvider.VTable, @ptrCast(self.vtable)).GetCaretPosition(@as(*const ICaretPositionProvider, @ptrCast(self)), pptCaret, pflHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentTouchInput_Value = Guid.initString("30510850-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITridentTouchInput = &IID_ITridentTouchInput_Value;
pub const ITridentTouchInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPointerMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITridentTouchInput,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                pfAllowManipulations: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITridentTouchInput,
                msg: u32,
                wParam: WPARAM,
                lParam: LPARAM,
                pfAllowManipulations: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentTouchInput_OnPointerMessage(self: *const T, msg: u32, wParam: WPARAM, lParam: LPARAM, pfAllowManipulations: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITridentTouchInput.VTable, @ptrCast(self.vtable)).OnPointerMessage(@as(*const ITridentTouchInput, @ptrCast(self)), msg, wParam, lParam, pfAllowManipulations);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentTouchInputSite_Value = Guid.initString("30510849-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITridentTouchInputSite = &IID_ITridentTouchInputSite_Value;
pub const ITridentTouchInputSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetManipulationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITridentTouchInputSite,
                msTouchAction: styleMsTouchAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITridentTouchInputSite,
                msTouchAction: styleMsTouchAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ZoomToPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITridentTouchInputSite,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITridentTouchInputSite,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentTouchInputSite_SetManipulationMode(self: *const T, msTouchAction: styleMsTouchAction) callconv(.Inline) HRESULT {
            return @as(*const ITridentTouchInputSite.VTable, @ptrCast(self.vtable)).SetManipulationMode(@as(*const ITridentTouchInputSite, @ptrCast(self)), msTouchAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentTouchInputSite_ZoomToPoint(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @as(*const ITridentTouchInputSite.VTable, @ptrCast(self.vtable)).ZoomToPoint(@as(*const ITridentTouchInputSite, @ptrCast(self)), x, y);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MEDIA_ACTIVITY_NOTIFY_TYPE = enum(i32) {
    Playback = 0,
    Recording = 1,
    Casting = 2,
};
pub const MediaPlayback = MEDIA_ACTIVITY_NOTIFY_TYPE.Playback;
pub const MediaRecording = MEDIA_ACTIVITY_NOTIFY_TYPE.Recording;
pub const MediaCasting = MEDIA_ACTIVITY_NOTIFY_TYPE.Casting;

const IID_IMediaActivityNotifySite_Value = Guid.initString("8165cfef-179d-46c2-bc71-3fa726dc1f8d");
pub const IID_IMediaActivityNotifySite = &IID_IMediaActivityNotifySite_Value;
pub const IMediaActivityNotifySite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMediaActivityStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaActivityNotifySite,
                mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaActivityNotifySite,
                mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnMediaActivityStopped: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaActivityNotifySite,
                mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaActivityNotifySite,
                mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaActivityNotifySite_OnMediaActivityStarted(self: *const T, mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMediaActivityNotifySite.VTable, @ptrCast(self.vtable)).OnMediaActivityStarted(@as(*const IMediaActivityNotifySite, @ptrCast(self)), mediaActivityType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaActivityNotifySite_OnMediaActivityStopped(self: *const T, mediaActivityType: MEDIA_ACTIVITY_NOTIFY_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMediaActivityNotifySite.VTable, @ptrCast(self.vtable)).OnMediaActivityStopped(@as(*const IMediaActivityNotifySite, @ptrCast(self)), mediaActivityType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSessionSite_Value = Guid.initString("d7d8b684-d02d-4517-b6b7-19e3dfe29c45");
pub const IID_IAudioSessionSite = &IID_IAudioSessionSite_Value;
pub const IAudioSessionSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAudioSessionGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSessionSite,
                audioSessionGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSessionSite,
                audioSessionGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAudioStreamCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSessionSite,
                endpointID: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSessionSite,
                endpointID: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnAudioStreamDestroyed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioSessionSite,
                endpointID: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioSessionSite,
                endpointID: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionSite_GetAudioSessionGuid(self: *const T, audioSessionGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IAudioSessionSite.VTable, @ptrCast(self.vtable)).GetAudioSessionGuid(@as(*const IAudioSessionSite, @ptrCast(self)), audioSessionGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionSite_OnAudioStreamCreated(self: *const T, endpointID: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IAudioSessionSite.VTable, @ptrCast(self.vtable)).OnAudioStreamCreated(@as(*const IAudioSessionSite, @ptrCast(self)), endpointID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSessionSite_OnAudioStreamDestroyed(self: *const T, endpointID: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IAudioSessionSite.VTable, @ptrCast(self.vtable)).OnAudioStreamDestroyed(@as(*const IAudioSessionSite, @ptrCast(self)), endpointID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintTaskRequestHandler_Value = Guid.initString("191cd340-cf36-44ff-bd53-d1b701799d9b");
pub const IID_IPrintTaskRequestHandler = &IID_IPrintTaskRequestHandler_Value;
pub const IPrintTaskRequestHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandlePrintTaskRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPrintTaskRequestHandler,
                pPrintTaskRequest: ?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPrintTaskRequestHandler,
                pPrintTaskRequest: ?*IInspectable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintTaskRequestHandler_HandlePrintTaskRequest(self: *const T, pPrintTaskRequest: ?*IInspectable) callconv(.Inline) HRESULT {
            return @as(*const IPrintTaskRequestHandler.VTable, @ptrCast(self.vtable)).HandlePrintTaskRequest(@as(*const IPrintTaskRequestHandler, @ptrCast(self)), pPrintTaskRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintTaskRequestFactory_Value = Guid.initString("bb516745-8c34-4f8b-9605-684dcb144be5");
pub const IID_IPrintTaskRequestFactory = &IID_IPrintTaskRequestFactory_Value;
pub const IPrintTaskRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePrintTaskRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPrintTaskRequestFactory,
                pPrintTaskRequestHandler: ?*IPrintTaskRequestHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPrintTaskRequestFactory,
                pPrintTaskRequestHandler: ?*IPrintTaskRequestHandler,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintTaskRequestFactory_CreatePrintTaskRequest(self: *const T, pPrintTaskRequestHandler: ?*IPrintTaskRequestHandler) callconv(.Inline) HRESULT {
            return @as(*const IPrintTaskRequestFactory.VTable, @ptrCast(self.vtable)).CreatePrintTaskRequest(@as(*const IPrintTaskRequestFactory, @ptrCast(self)), pPrintTaskRequestHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScrollableContextMenu_Value = Guid.initString("30510854-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IScrollableContextMenu = &IID_IScrollableContextMenu_Value;
pub const IScrollableContextMenu = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollableContextMenu,
                itemText: ?[*:0]align(1) const u16,
                cmdID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollableContextMenu,
                itemText: ?[*:0]align(1) const u16,
                cmdID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowModal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollableContextMenu,
                x: i32,
                y: i32,
                cmdID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollableContextMenu,
                x: i32,
                y: i32,
                cmdID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollableContextMenu_AddItem(self: *const T, itemText: ?[*:0]align(1) const u16, cmdID: u32) callconv(.Inline) HRESULT {
            return @as(*const IScrollableContextMenu.VTable, @ptrCast(self.vtable)).AddItem(@as(*const IScrollableContextMenu, @ptrCast(self)), itemText, cmdID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollableContextMenu_ShowModal(self: *const T, x: i32, y: i32, cmdID: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScrollableContextMenu.VTable, @ptrCast(self.vtable)).ShowModal(@as(*const IScrollableContextMenu, @ptrCast(self)), x, y, cmdID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCROLLABLECONTEXTMENU_PLACEMENT = enum(i32) {
    TOP = 0,
    BOTTOM = 1,
    LEFT = 2,
    RIGHT = 3,
    FULL = 4,
};
pub const SCMP_TOP = SCROLLABLECONTEXTMENU_PLACEMENT.TOP;
pub const SCMP_BOTTOM = SCROLLABLECONTEXTMENU_PLACEMENT.BOTTOM;
pub const SCMP_LEFT = SCROLLABLECONTEXTMENU_PLACEMENT.LEFT;
pub const SCMP_RIGHT = SCROLLABLECONTEXTMENU_PLACEMENT.RIGHT;
pub const SCMP_FULL = SCROLLABLECONTEXTMENU_PLACEMENT.FULL;

const IID_IScrollableContextMenu2_Value = Guid.initString("f77e9056-8674-4936-924c-0e4a06fa634a");
pub const IID_IScrollableContextMenu2 = &IID_IScrollableContextMenu2_Value;
pub const IScrollableContextMenu2 = extern struct {
    pub const VTable = extern struct {
        base: IScrollableContextMenu.VTable,
        AddSeparator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollableContextMenu2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollableContextMenu2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScrollableContextMenu2,
                scmp: SCROLLABLECONTEXTMENU_PLACEMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScrollableContextMenu2,
                scmp: SCROLLABLECONTEXTMENU_PLACEMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScrollableContextMenu.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollableContextMenu2_AddSeparator(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScrollableContextMenu2.VTable, @ptrCast(self.vtable)).AddSeparator(@as(*const IScrollableContextMenu2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollableContextMenu2_SetPlacement(self: *const T, scmp: SCROLLABLECONTEXTMENU_PLACEMENT) callconv(.Inline) HRESULT {
            return @as(*const IScrollableContextMenu2.VTable, @ptrCast(self.vtable)).SetPlacement(@as(*const IScrollableContextMenu2, @ptrCast(self)), scmp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveXUIHandlerSite_Value = Guid.initString("30510853-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IActiveXUIHandlerSite = &IID_IActiveXUIHandlerSite_Value;
pub const IActiveXUIHandlerSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateScrollableContextMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveXUIHandlerSite,
                scrollableContextMenu: ?*?*IScrollableContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveXUIHandlerSite,
                scrollableContextMenu: ?*?*IScrollableContextMenu,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PickFileAndGetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveXUIHandlerSite,
                filePicker: ?*IUnknown,
                allowMultipleSelections: BOOL,
                result: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveXUIHandlerSite,
                filePicker: ?*IUnknown,
                allowMultipleSelections: BOOL,
                result: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveXUIHandlerSite_CreateScrollableContextMenu(self: *const T, scrollableContextMenu: ?*?*IScrollableContextMenu) callconv(.Inline) HRESULT {
            return @as(*const IActiveXUIHandlerSite.VTable, @ptrCast(self.vtable)).CreateScrollableContextMenu(@as(*const IActiveXUIHandlerSite, @ptrCast(self)), scrollableContextMenu);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveXUIHandlerSite_PickFileAndGetResult(self: *const T, filePicker: ?*IUnknown, allowMultipleSelections: BOOL, result: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IActiveXUIHandlerSite.VTable, @ptrCast(self.vtable)).PickFileAndGetResult(@as(*const IActiveXUIHandlerSite, @ptrCast(self)), filePicker, allowMultipleSelections, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveXUIHandlerSite3_Value = Guid.initString("7904009a-1238-47f4-901c-871375c34608");
pub const IID_IActiveXUIHandlerSite3 = &IID_IActiveXUIHandlerSite3_Value;
pub const IActiveXUIHandlerSite3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MessageBoxW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveXUIHandlerSite3,
                hwnd: ?HWND,
                text: ?[*:0]align(1) const u16,
                caption: ?[*:0]align(1) const u16,
                type: u32,
                result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveXUIHandlerSite3,
                hwnd: ?HWND,
                text: ?[*:0]align(1) const u16,
                caption: ?[*:0]align(1) const u16,
                type: u32,
                result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveXUIHandlerSite3_MessageBoxW(self: *const T, hwnd: ?HWND, text: ?[*:0]align(1) const u16, caption: ?[*:0]align(1) const u16, type_: u32, result: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveXUIHandlerSite3.VTable, @ptrCast(self.vtable)).MessageBoxW(@as(*const IActiveXUIHandlerSite3, @ptrCast(self)), hwnd, text, caption, type_, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const INTERNETEXPLORERCONFIGURATION = enum(i32) {
    HOST = 1,
    WEB_DRIVER = 2,
    WEB_DRIVER_EDGE = 4,
};
pub const INTERNETEXPLORERCONFIGURATION_HOST = INTERNETEXPLORERCONFIGURATION.HOST;
pub const INTERNETEXPLORERCONFIGURATION_WEB_DRIVER = INTERNETEXPLORERCONFIGURATION.WEB_DRIVER;
pub const INTERNETEXPLORERCONFIGURATION_WEB_DRIVER_EDGE = INTERNETEXPLORERCONFIGURATION.WEB_DRIVER_EDGE;

const IID_IEnumManagerFrames_Value = Guid.initString("3caa826a-9b1f-4a79-bc81-f0430ded1648");
pub const IID_IEnumManagerFrames = &IID_IEnumManagerFrames_Value;
pub const IEnumManagerFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumManagerFrames,
                celt: u32,
                ppWindows: [*]?*?HWND,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumManagerFrames,
                celt: u32,
                ppWindows: [*]?*?HWND,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Count: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumManagerFrames,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumManagerFrames,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumManagerFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumManagerFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumManagerFrames,
                ppEnum: ?*?*IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumManagerFrames,
                ppEnum: ?*?*IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumManagerFrames_Next(self: *const T, celt: u32, ppWindows: [*]?*?HWND, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumManagerFrames.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumManagerFrames, @ptrCast(self)), celt, ppWindows, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumManagerFrames_Count(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumManagerFrames.VTable, @ptrCast(self.vtable)).Count(@as(*const IEnumManagerFrames, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumManagerFrames_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumManagerFrames.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumManagerFrames, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumManagerFrames_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumManagerFrames.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumManagerFrames, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumManagerFrames_Clone(self: *const T, ppEnum: ?*?*IEnumManagerFrames) callconv(.Inline) HRESULT {
            return @as(*const IEnumManagerFrames.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumManagerFrames, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetExplorerManager_Value = Guid.initString("acc84351-04ff-44f9-b23f-655ed168c6d5");
pub const IID_IInternetExplorerManager = &IID_IInternetExplorerManager_Value;
pub const IInternetExplorerManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetExplorerManager,
                dwConfig: u32,
                pszURL: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetExplorerManager,
                dwConfig: u32,
                pszURL: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppv: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetExplorerManager_CreateObject(self: *const T, dwConfig: u32, pszURL: ?[*:0]align(1) const u16, riid: ?*const Guid, ppv: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IInternetExplorerManager.VTable, @ptrCast(self.vtable)).CreateObject(@as(*const IInternetExplorerManager, @ptrCast(self)), dwConfig, pszURL, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInternetExplorerManager2_Value = Guid.initString("dfbb5136-9259-4895-b4a7-c1934429919a");
pub const IID_IInternetExplorerManager2 = &IID_IInternetExplorerManager2_Value;
pub const IInternetExplorerManager2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumFrameWindows: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IInternetExplorerManager2,
                ppEnum: ?*?*IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IInternetExplorerManager2,
                ppEnum: ?*?*IEnumManagerFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternetExplorerManager2_EnumFrameWindows(self: *const T, ppEnum: ?*?*IEnumManagerFrames) callconv(.Inline) HRESULT {
            return @as(*const IInternetExplorerManager2.VTable, @ptrCast(self.vtable)).EnumFrameWindows(@as(*const IInternetExplorerManager2, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_InternetExplorerManager_Value = Guid.initString("df4fcc34-067a-4e0a-8352-4a1a5095346e");
pub const CLSID_InternetExplorerManager = &CLSID_InternetExplorerManager_Value;

pub const IELAUNCHOPTION_FLAGS = enum(i32) {
    SCRIPTDEBUG = 1,
    FORCE_COMPAT = 2,
    FORCE_EDGE = 4,
    LOCK_ENGINE = 8,
};
pub const IELAUNCHOPTION_SCRIPTDEBUG = IELAUNCHOPTION_FLAGS.SCRIPTDEBUG;
pub const IELAUNCHOPTION_FORCE_COMPAT = IELAUNCHOPTION_FLAGS.FORCE_COMPAT;
pub const IELAUNCHOPTION_FORCE_EDGE = IELAUNCHOPTION_FLAGS.FORCE_EDGE;
pub const IELAUNCHOPTION_LOCK_ENGINE = IELAUNCHOPTION_FLAGS.LOCK_ENGINE;

pub const IELAUNCHURLINFO = extern struct {
    cbSize: u32,
    dwCreationFlags: u32,
    dwLaunchOptionFlags: u32,
};

const IID_IIEWebDriverSite_Value = Guid.initString("ffb84444-453d-4fbc-9f9d-8db5c471ec75");
pub const IID_IIEWebDriverSite = &IID_IIEWebDriverSite_Value;
pub const IIEWebDriverSite = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        WindowOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIEWebDriverSite,
                operationCode: u32,
                hWnd: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIEWebDriverSite,
                operationCode: u32,
                hWnd: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachWebdriver: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIEWebDriverSite,
                pUnkWD: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIEWebDriverSite,
                pUnkWD: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilityValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIEWebDriverSite,
                pUnkWD: ?*IUnknown,
                capName: ?PWSTR,
                capValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIEWebDriverSite,
                pUnkWD: ?*IUnknown,
                capName: ?PWSTR,
                capValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIEWebDriverSite_WindowOperation(self: *const T, operationCode: u32, hWnd: u32) callconv(.Inline) HRESULT {
            return @as(*const IIEWebDriverSite.VTable, @ptrCast(self.vtable)).WindowOperation(@as(*const IIEWebDriverSite, @ptrCast(self)), operationCode, hWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIEWebDriverSite_DetachWebdriver(self: *const T, pUnkWD: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IIEWebDriverSite.VTable, @ptrCast(self.vtable)).DetachWebdriver(@as(*const IIEWebDriverSite, @ptrCast(self)), pUnkWD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIEWebDriverSite_GetCapabilityValue(self: *const T, pUnkWD: ?*IUnknown, capName: ?PWSTR, capValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IIEWebDriverSite.VTable, @ptrCast(self.vtable)).GetCapabilityValue(@as(*const IIEWebDriverSite, @ptrCast(self)), pUnkWD, capName, capValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIEWebDriverManager_Value = Guid.initString("bd1dc630-6590-4ca2-a293-6bc72b2438d8");
pub const IID_IIEWebDriverManager = &IID_IIEWebDriverManager_Value;
pub const IIEWebDriverManager = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ExecuteCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIEWebDriverManager,
                command: ?PWSTR,
                response: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIEWebDriverManager,
                command: ?PWSTR,
                response: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIEWebDriverManager_ExecuteCommand(self: *const T, command: ?PWSTR, response: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IIEWebDriverManager.VTable, @ptrCast(self.vtable)).ExecuteCommand(@as(*const IIEWebDriverManager, @ptrCast(self)), command, response);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_IEWebDriverManager_Value = Guid.initString("90314af2-5250-47b3-89d8-6295fc23bc22");
pub const CLSID_IEWebDriverManager = &CLSID_IEWebDriverManager_Value;

const IID_IPeerFactory_Value = Guid.initString("6663f9d3-b482-11d1-89c6-00c04fb6bfc4");
pub const IID_IPeerFactory = &IID_IPeerFactory_Value;
pub const IPeerFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHomePage_Value = Guid.initString("766bf2af-d650-11d1-9811-00c04fc31d2e");
pub const IID_IHomePage = &IID_IHomePage_Value;
pub const IHomePage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        navigateHomePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setHomePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePage,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePage,
                bstrURL: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        isHomePage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHomePage,
                bstrURL: ?BSTR,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHomePage,
                bstrURL: ?BSTR,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePage_navigateHomePage(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHomePage.VTable, @ptrCast(self.vtable)).navigateHomePage(@as(*const IHomePage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePage_setHomePage(self: *const T, bstrURL: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHomePage.VTable, @ptrCast(self.vtable)).setHomePage(@as(*const IHomePage, @ptrCast(self)), bstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHomePage_isHomePage(self: *const T, bstrURL: ?BSTR, p: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHomePage.VTable, @ptrCast(self.vtable)).isHomePage(@as(*const IHomePage, @ptrCast(self)), bstrURL, p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIntelliForms_Value = Guid.initString("9b9f68e6-1aaa-11d2-bca5-00c04fd929db");
pub const IID_IIntelliForms = &IID_IIntelliForms_Value;
pub const IIntelliForms = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIntelliForms,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIntelliForms,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIntelliForms,
                bVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIntelliForms,
                bVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIntelliForms_get_enabled(self: *const T, pVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IIntelliForms.VTable, @ptrCast(self.vtable)).get_enabled(@as(*const IIntelliForms, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIntelliForms_put_enabled(self: *const T, bVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IIntelliForms.VTable, @ptrCast(self.vtable)).put_enabled(@as(*const IIntelliForms, @ptrCast(self)), bVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_Iwfolders_Value = Guid.initString("bae31f98-1b81-11d2-a97a-00c04f8ecb02");
pub const IID_Iwfolders = &IID_Iwfolders_Value;
pub const Iwfolders = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                pbstrRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                pbstrRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        navigateFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                bstrTargetFrame: ?BSTR,
                pbstrRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                bstrTargetFrame: ?BSTR,
                pbstrRetVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        navigateNoSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                bstrTargetFrame: ?BSTR,
                dwhwnd: u32,
                pwb: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const Iwfolders,
                bstrUrl: ?BSTR,
                bstrTargetFrame: ?BSTR,
                dwhwnd: u32,
                pwb: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Iwfolders_navigate(self: *const T, bstrUrl: ?BSTR, pbstrRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const Iwfolders.VTable, @ptrCast(self.vtable)).navigate(@as(*const Iwfolders, @ptrCast(self)), bstrUrl, pbstrRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Iwfolders_navigateFrame(self: *const T, bstrUrl: ?BSTR, bstrTargetFrame: ?BSTR, pbstrRetVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const Iwfolders.VTable, @ptrCast(self.vtable)).navigateFrame(@as(*const Iwfolders, @ptrCast(self)), bstrUrl, bstrTargetFrame, pbstrRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn Iwfolders_navigateNoSite(self: *const T, bstrUrl: ?BSTR, bstrTargetFrame: ?BSTR, dwhwnd: u32, pwb: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const Iwfolders.VTable, @ptrCast(self.vtable)).navigateNoSite(@as(*const Iwfolders, @ptrCast(self)), bstrUrl, bstrTargetFrame, dwhwnd, pwb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAnchorClick_Value = Guid.initString("13d5413b-33b9-11d2-95a7-00c04f8ecb02");
pub const IID_IAnchorClick = &IID_IAnchorClick_Value;
pub const IAnchorClick = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ProcOnClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAnchorClick,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAnchorClick,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnchorClick_ProcOnClick(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAnchorClick.VTable, @ptrCast(self.vtable)).ProcOnClick(@as(*const IAnchorClick, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUserDataOM_Value = Guid.initString("3050f48f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLUserDataOM = &IID_IHTMLUserDataOM_Value;
pub const IHTMLUserDataOM = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                p: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHTMLUserDataOM,
                p: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                strName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLUserDataOM,
                strName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                strName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLUserDataOM,
                strName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLUserDataOM,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_expires: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHTMLUserDataOM,
                bstr: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_expires: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHTMLUserDataOM,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHTMLUserDataOM,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_get_XMLDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).get_XMLDocument(@as(*const IHTMLUserDataOM, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_save(self: *const T, strName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).save(@as(*const IHTMLUserDataOM, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_load(self: *const T, strName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).load(@as(*const IHTMLUserDataOM, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_getAttribute(self: *const T, name: ?BSTR, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).getAttribute(@as(*const IHTMLUserDataOM, @ptrCast(self)), name, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_setAttribute(self: *const T, name: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IHTMLUserDataOM, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_removeAttribute(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IHTMLUserDataOM, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_put_expires(self: *const T, bstr: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).put_expires(@as(*const IHTMLUserDataOM, @ptrCast(self)), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUserDataOM_get_expires(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLUserDataOM.VTable, @ptrCast(self.vtable)).get_expires(@as(*const IHTMLUserDataOM, @ptrCast(self)), pbstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPersistDataOM_Value = Guid.initString("3050f4c0-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPersistDataOM = &IID_IHTMLPersistDataOM_Value;
pub const IHTMLPersistDataOM = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XMLDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHTMLPersistDataOM,
                p: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHTMLPersistDataOM,
                p: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        setAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
                value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        removeAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistDataOM,
                name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistDataOM_get_XMLDocument(self: *const T, p: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistDataOM.VTable, @ptrCast(self.vtable)).get_XMLDocument(@as(*const IHTMLPersistDataOM, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistDataOM_getAttribute(self: *const T, name: ?BSTR, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistDataOM.VTable, @ptrCast(self.vtable)).getAttribute(@as(*const IHTMLPersistDataOM, @ptrCast(self)), name, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistDataOM_setAttribute(self: *const T, name: ?BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistDataOM.VTable, @ptrCast(self.vtable)).setAttribute(@as(*const IHTMLPersistDataOM, @ptrCast(self)), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistDataOM_removeAttribute(self: *const T, name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistDataOM.VTable, @ptrCast(self.vtable)).removeAttribute(@as(*const IHTMLPersistDataOM, @ptrCast(self)), name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPersistData_Value = Guid.initString("3050f4c5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHTMLPersistData = &IID_IHTMLPersistData_Value;
pub const IHTMLPersistData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistData,
                pUnk: ?*IUnknown,
                lType: i32,
                fContinueBroacast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistData,
                pUnk: ?*IUnknown,
                lType: i32,
                fContinueBroacast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistData,
                pUnk: ?*IUnknown,
                lType: i32,
                fDoDefault: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistData,
                pUnk: ?*IUnknown,
                lType: i32,
                fDoDefault: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        queryType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHTMLPersistData,
                lType: i32,
                pfSupportsType: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHTMLPersistData,
                lType: i32,
                pfSupportsType: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistData_save(self: *const T, pUnk: ?*IUnknown, lType: i32, fContinueBroacast: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistData.VTable, @ptrCast(self.vtable)).save(@as(*const IHTMLPersistData, @ptrCast(self)), pUnk, lType, fContinueBroacast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistData_load(self: *const T, pUnk: ?*IUnknown, lType: i32, fDoDefault: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistData.VTable, @ptrCast(self.vtable)).load(@as(*const IHTMLPersistData, @ptrCast(self)), pUnk, lType, fDoDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPersistData_queryType(self: *const T, lType: i32, pfSupportsType: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHTMLPersistData.VTable, @ptrCast(self.vtable)).queryType(@as(*const IHTMLPersistData, @ptrCast(self)), lType, pfSupportsType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDownloadBehavior_Value = Guid.initString("3050f5bd-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDownloadBehavior = &IID_IDownloadBehavior_Value;
pub const IDownloadBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDownload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDownloadBehavior,
                bstrUrl: ?BSTR,
                pdispCallback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDownloadBehavior,
                bstrUrl: ?BSTR,
                pdispCallback: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDownloadBehavior_startDownload(self: *const T, bstrUrl: ?BSTR, pdispCallback: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IDownloadBehavior.VTable, @ptrCast(self.vtable)).startDownload(@as(*const IDownloadBehavior, @ptrCast(self)), bstrUrl, pdispCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILayoutRect_Value = Guid.initString("3050f665-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ILayoutRect = &IID_ILayoutRect_Value;
pub const ILayoutRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nextRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                bstrElementId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                bstrElementId: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                pbstrElementId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                pbstrElementId: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_contentSrc: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                varContentSrc: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                varContentSrc: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentSrc: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                pvarContentSrc: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                pvarContentSrc: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_honorPageBreaks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                v: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                v: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_honorPageBreaks: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_honorPageRules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                v: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                v: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_honorPageRules: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                p: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_nextRectElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                pElem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                pElem: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_nextRectElement: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                ppElem: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                ppElem: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_contentDocument: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILayoutRect,
                pDoc: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILayoutRect,
                pDoc: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_put_nextRect(self: *const T, bstrElementId: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).put_nextRect(@as(*const ILayoutRect, @ptrCast(self)), bstrElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_nextRect(self: *const T, pbstrElementId: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_nextRect(@as(*const ILayoutRect, @ptrCast(self)), pbstrElementId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_put_contentSrc(self: *const T, varContentSrc: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).put_contentSrc(@as(*const ILayoutRect, @ptrCast(self)), varContentSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_contentSrc(self: *const T, pvarContentSrc: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_contentSrc(@as(*const ILayoutRect, @ptrCast(self)), pvarContentSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_put_honorPageBreaks(self: *const T, v: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).put_honorPageBreaks(@as(*const ILayoutRect, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_honorPageBreaks(self: *const T, p: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_honorPageBreaks(@as(*const ILayoutRect, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_put_honorPageRules(self: *const T, v: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).put_honorPageRules(@as(*const ILayoutRect, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_honorPageRules(self: *const T, p: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_honorPageRules(@as(*const ILayoutRect, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_put_nextRectElement(self: *const T, pElem: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).put_nextRectElement(@as(*const ILayoutRect, @ptrCast(self)), pElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_nextRectElement(self: *const T, ppElem: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_nextRectElement(@as(*const ILayoutRect, @ptrCast(self)), ppElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutRect_get_contentDocument(self: *const T, pDoc: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const ILayoutRect.VTable, @ptrCast(self.vtable)).get_contentDocument(@as(*const ILayoutRect, @ptrCast(self)), pDoc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDeviceRect_Value = Guid.initString("3050f6d5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IDeviceRect = &IID_IDeviceRect_Value;
pub const IDeviceRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHeaderFooter_Value = Guid.initString("3050f6ce-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHeaderFooter = &IID_IHeaderFooter_Value;
pub const IHeaderFooter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_htmlHead: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_htmlFoot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textHead: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textHead: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_textFoot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_textFoot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_page: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_page: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_pageTotal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_pageTotal: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dateShort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dateShort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_dateLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_dateLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_timeShort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timeShort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_timeLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_timeLong: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_htmlHead(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_htmlHead(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_htmlFoot(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_htmlFoot(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_textHead(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_textHead(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_textHead(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_textHead(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_textFoot(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_textFoot(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_textFoot(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_textFoot(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_page(self: *const T, v: u32) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_page(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_page(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_page(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_pageTotal(self: *const T, v: u32) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_pageTotal(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_pageTotal(self: *const T, p: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_pageTotal(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_URL(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_URL(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_URL(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_title(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_title(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_title(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_title(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_dateShort(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_dateShort(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_dateShort(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_dateShort(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_dateLong(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_dateLong(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_dateLong(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_dateLong(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_timeShort(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_timeShort(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_timeShort(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_timeShort(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_put_timeLong(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).put_timeLong(@as(*const IHeaderFooter, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter_get_timeLong(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter.VTable, @ptrCast(self.vtable)).get_timeLong(@as(*const IHeaderFooter, @ptrCast(self)), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHeaderFooter2_Value = Guid.initString("305104a5-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_IHeaderFooter2 = &IID_IHeaderFooter2_Value;
pub const IHeaderFooter2 = extern struct {
    pub const VTable = extern struct {
        base: IHeaderFooter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_font: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter2,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter2,
                v: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_font: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IHeaderFooter2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IHeaderFooter2,
                p: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHeaderFooter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter2_put_font(self: *const T, v: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter2.VTable, @ptrCast(self.vtable)).put_font(@as(*const IHeaderFooter2, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHeaderFooter2_get_font(self: *const T, p: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IHeaderFooter2.VTable, @ptrCast(self.vtable)).get_font(@as(*const IHeaderFooter2, @ptrCast(self)), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_PeerFactory_Value = Guid.initString("3050f4cf-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_PeerFactory = &CLSID_PeerFactory_Value;

const CLSID_IntelliForms_Value = Guid.initString("613ab92e-16bf-11d2-bca5-00c04fd929db");
pub const CLSID_IntelliForms = &CLSID_IntelliForms_Value;

const CLSID_HomePage_Value = Guid.initString("766bf2ae-d650-11d1-9811-00c04fc31d2e");
pub const CLSID_HomePage = &CLSID_HomePage_Value;

const CLSID_CPersistUserData_Value = Guid.initString("3050f48e-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPersistUserData = &CLSID_CPersistUserData_Value;

const CLSID_CPersistDataPeer_Value = Guid.initString("3050f487-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPersistDataPeer = &CLSID_CPersistDataPeer_Value;

const CLSID_CPersistShortcut_Value = Guid.initString("3050f4c6-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPersistShortcut = &CLSID_CPersistShortcut_Value;

const CLSID_CPersistHistory_Value = Guid.initString("3050f4c8-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPersistHistory = &CLSID_CPersistHistory_Value;

const CLSID_CPersistSnapshot_Value = Guid.initString("3050f4c9-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CPersistSnapshot = &CLSID_CPersistSnapshot_Value;

const CLSID_CDownloadBehavior_Value = Guid.initString("3050f5be-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CDownloadBehavior = &CLSID_CDownloadBehavior_Value;

const CLSID_wfolders_Value = Guid.initString("bae31f9a-1b81-11d2-a97a-00c04f8ecb02");
pub const CLSID_wfolders = &CLSID_wfolders_Value;

const CLSID_AnchorClick_Value = Guid.initString("13d5413c-33b9-11d2-95a7-00c04f8ecb02");
pub const CLSID_AnchorClick = &CLSID_AnchorClick_Value;

const CLSID_CLayoutRect_Value = Guid.initString("3050f664-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CLayoutRect = &CLSID_CLayoutRect_Value;

const CLSID_CDeviceRect_Value = Guid.initString("3050f6d4-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CDeviceRect = &CLSID_CDeviceRect_Value;

const CLSID_CHeaderFooter_Value = Guid.initString("3050f6cd-98b5-11cf-bb82-00aa00bdce0b");
pub const CLSID_CHeaderFooter = &CLSID_CHeaderFooter_Value;

pub const OpenServiceErrors = enum(i32) {
    NOTFOUND = -2147287038,
    NOTSUPPORTED = -2147467231,
    CANCELLED = -2147471631,
    GPDISABLED = -1072886820,
};
pub const OS_E_NOTFOUND = OpenServiceErrors.NOTFOUND;
pub const OS_E_NOTSUPPORTED = OpenServiceErrors.NOTSUPPORTED;
pub const OS_E_CANCELLED = OpenServiceErrors.CANCELLED;
pub const OS_E_GPDISABLED = OpenServiceErrors.GPDISABLED;

pub const OpenServiceActivityContentType = enum(i32) {
    None = -1,
    Document = 0,
    Selection = 1,
    Link = 2,
    Count = 3,
};
pub const ActivityContentNone = OpenServiceActivityContentType.None;
pub const ActivityContentDocument = OpenServiceActivityContentType.Document;
pub const ActivityContentSelection = OpenServiceActivityContentType.Selection;
pub const ActivityContentLink = OpenServiceActivityContentType.Link;
pub const ActivityContentCount = OpenServiceActivityContentType.Count;

const IID_IOpenServiceActivityInput_Value = Guid.initString("75cb4db9-6da0-4da3-83ce-422b6a433346");
pub const IID_IOpenServiceActivityInput = &IID_IOpenServiceActivityInput_Value;
pub const IOpenServiceActivityInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityInput,
                pwzVariableName: ?[*:0]align(1) const u16,
                pwzVariableType: ?[*:0]align(1) const u16,
                pbstrVariableContent: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityInput,
                pwzVariableName: ?[*:0]align(1) const u16,
                pwzVariableType: ?[*:0]align(1) const u16,
                pbstrVariableContent: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HasVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityInput,
                pwzVariableName: ?[*:0]align(1) const u16,
                pwzVariableType: ?[*:0]align(1) const u16,
                pfHasVariable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityInput,
                pwzVariableName: ?[*:0]align(1) const u16,
                pwzVariableType: ?[*:0]align(1) const u16,
                pfHasVariable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityInput,
                pType: ?*OpenServiceActivityContentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityInput,
                pType: ?*OpenServiceActivityContentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityInput_GetVariable(self: *const T, pwzVariableName: ?[*:0]align(1) const u16, pwzVariableType: ?[*:0]align(1) const u16, pbstrVariableContent: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityInput.VTable, @ptrCast(self.vtable)).GetVariable(@as(*const IOpenServiceActivityInput, @ptrCast(self)), pwzVariableName, pwzVariableType, pbstrVariableContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityInput_HasVariable(self: *const T, pwzVariableName: ?[*:0]align(1) const u16, pwzVariableType: ?[*:0]align(1) const u16, pfHasVariable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityInput.VTable, @ptrCast(self.vtable)).HasVariable(@as(*const IOpenServiceActivityInput, @ptrCast(self)), pwzVariableName, pwzVariableType, pfHasVariable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityInput_GetType(self: *const T, pType: ?*OpenServiceActivityContentType) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityInput.VTable, @ptrCast(self.vtable)).GetType(@as(*const IOpenServiceActivityInput, @ptrCast(self)), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenServiceActivityOutputContext_Value = Guid.initString("e289deab-f709-49a9-b99e-282364074571");
pub const IID_IOpenServiceActivityOutputContext = &IID_IOpenServiceActivityOutputContext_Value;
pub const IOpenServiceActivityOutputContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityOutputContext,
                pwzUri: ?[*:0]align(1) const u16,
                pwzMethod: ?[*:0]align(1) const u16,
                pwzHeaders: ?[*:0]align(1) const u16,
                pPostData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityOutputContext,
                pwzUri: ?[*:0]align(1) const u16,
                pwzMethod: ?[*:0]align(1) const u16,
                pwzHeaders: ?[*:0]align(1) const u16,
                pPostData: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanNavigate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityOutputContext,
                pwzUri: ?[*:0]align(1) const u16,
                pwzMethod: ?[*:0]align(1) const u16,
                pwzHeaders: ?[*:0]align(1) const u16,
                pPostData: ?*IStream,
                pfCanNavigate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityOutputContext,
                pwzUri: ?[*:0]align(1) const u16,
                pwzMethod: ?[*:0]align(1) const u16,
                pwzHeaders: ?[*:0]align(1) const u16,
                pPostData: ?*IStream,
                pfCanNavigate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityOutputContext_Navigate(self: *const T, pwzUri: ?[*:0]align(1) const u16, pwzMethod: ?[*:0]align(1) const u16, pwzHeaders: ?[*:0]align(1) const u16, pPostData: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityOutputContext.VTable, @ptrCast(self.vtable)).Navigate(@as(*const IOpenServiceActivityOutputContext, @ptrCast(self)), pwzUri, pwzMethod, pwzHeaders, pPostData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityOutputContext_CanNavigate(self: *const T, pwzUri: ?[*:0]align(1) const u16, pwzMethod: ?[*:0]align(1) const u16, pwzHeaders: ?[*:0]align(1) const u16, pPostData: ?*IStream, pfCanNavigate: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityOutputContext.VTable, @ptrCast(self.vtable)).CanNavigate(@as(*const IOpenServiceActivityOutputContext, @ptrCast(self)), pwzUri, pwzMethod, pwzHeaders, pPostData, pfCanNavigate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenService_Value = Guid.initString("c2952ed1-6a89-4606-925f-1ed8b4be0630");
pub const IID_IOpenService = &IID_IOpenService_Value;
pub const IOpenService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenService,
                pfIsDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenService,
                pfIsDefault: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenService,
                fDefault: BOOL,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenService,
                fDefault: BOOL,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenService,
                pbstrID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenService,
                pbstrID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenService_IsDefault(self: *const T, pfIsDefault: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenService.VTable, @ptrCast(self.vtable)).IsDefault(@as(*const IOpenService, @ptrCast(self)), pfIsDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenService_SetDefault(self: *const T, fDefault: BOOL, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IOpenService.VTable, @ptrCast(self.vtable)).SetDefault(@as(*const IOpenService, @ptrCast(self)), fDefault, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenService_GetID(self: *const T, pbstrID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenService.VTable, @ptrCast(self.vtable)).GetID(@as(*const IOpenService, @ptrCast(self)), pbstrID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenServiceManager_Value = Guid.initString("5664125f-4e10-4e90-98e4-e4513d955a14");
pub const IID_IOpenServiceManager = &IID_IOpenServiceManager_Value;
pub const IOpenServiceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InstallService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceManager,
                pwzServiceUrl: ?[*:0]align(1) const u16,
                ppService: ?*?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceManager,
                pwzServiceUrl: ?[*:0]align(1) const u16,
                ppService: ?*?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UninstallService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceManager,
                pService: ?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceManager,
                pService: ?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceManager,
                pwzID: ?[*:0]align(1) const u16,
                ppService: ?*?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceManager,
                pwzID: ?[*:0]align(1) const u16,
                ppService: ?*?*IOpenService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceManager_InstallService(self: *const T, pwzServiceUrl: ?[*:0]align(1) const u16, ppService: ?*?*IOpenService) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceManager.VTable, @ptrCast(self.vtable)).InstallService(@as(*const IOpenServiceManager, @ptrCast(self)), pwzServiceUrl, ppService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceManager_UninstallService(self: *const T, pService: ?*IOpenService) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceManager.VTable, @ptrCast(self.vtable)).UninstallService(@as(*const IOpenServiceManager, @ptrCast(self)), pService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceManager_GetServiceByID(self: *const T, pwzID: ?[*:0]align(1) const u16, ppService: ?*?*IOpenService) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceManager.VTable, @ptrCast(self.vtable)).GetServiceByID(@as(*const IOpenServiceManager, @ptrCast(self)), pwzID, ppService);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_OpenServiceManager_Value = Guid.initString("098870b6-39ea-480b-b8b5-dd0167c4db59");
pub const CLSID_OpenServiceManager = &CLSID_OpenServiceManager_Value;

const CLSID_OpenServiceActivityManager_Value = Guid.initString("c5efd803-50f8-43cd-9ab8-aafc1394c9e0");
pub const CLSID_OpenServiceActivityManager = &CLSID_OpenServiceActivityManager_Value;

const IID_IOpenServiceActivity_Value = Guid.initString("13645c88-221a-4905-8ed1-4f5112cfc108");
pub const IID_IOpenServiceActivity = &IID_IOpenServiceActivity_Value;
pub const IOpenServiceActivity = extern struct {
    pub const VTable = extern struct {
        base: IOpenService.VTable,
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanExecute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                pfCanExecute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                pfCanExecute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanExecuteType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                type: OpenServiceActivityContentType,
                pfCanExecute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                type: OpenServiceActivityContentType,
                pfCanExecute: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Preview: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanPreview: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                pfCanPreview: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                pfCanPreview: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanPreviewType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                type: OpenServiceActivityContentType,
                pfCanPreview: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                type: OpenServiceActivityContentType,
                pfCanPreview: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatusText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pInput: ?*IOpenServiceActivityInput,
                pbstrStatusText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHomepageUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrHomepageUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrHomepageUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrDisplayName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCategoryName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrCategoryName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrCategoryName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIconPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrIconPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrIconPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIcon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                fSmallIcon: BOOL,
                phIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                fSmallIcon: BOOL,
                phIcon: ?*?HICON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionFilePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrXmlPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrXmlPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDownloadUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrXmlUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrXmlUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstallUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pbstrInstallUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pbstrInstallUri: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                pfIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                pfIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivity,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivity,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOpenService.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_Execute(self: *const T, pInput: ?*IOpenServiceActivityInput, pOutput: ?*IOpenServiceActivityOutputContext) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).Execute(@as(*const IOpenServiceActivity, @ptrCast(self)), pInput, pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_CanExecute(self: *const T, pInput: ?*IOpenServiceActivityInput, pOutput: ?*IOpenServiceActivityOutputContext, pfCanExecute: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).CanExecute(@as(*const IOpenServiceActivity, @ptrCast(self)), pInput, pOutput, pfCanExecute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_CanExecuteType(self: *const T, type_: OpenServiceActivityContentType, pfCanExecute: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).CanExecuteType(@as(*const IOpenServiceActivity, @ptrCast(self)), type_, pfCanExecute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_Preview(self: *const T, pInput: ?*IOpenServiceActivityInput, pOutput: ?*IOpenServiceActivityOutputContext) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).Preview(@as(*const IOpenServiceActivity, @ptrCast(self)), pInput, pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_CanPreview(self: *const T, pInput: ?*IOpenServiceActivityInput, pOutput: ?*IOpenServiceActivityOutputContext, pfCanPreview: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).CanPreview(@as(*const IOpenServiceActivity, @ptrCast(self)), pInput, pOutput, pfCanPreview);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_CanPreviewType(self: *const T, type_: OpenServiceActivityContentType, pfCanPreview: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).CanPreviewType(@as(*const IOpenServiceActivity, @ptrCast(self)), type_, pfCanPreview);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetStatusText(self: *const T, pInput: ?*IOpenServiceActivityInput, pbstrStatusText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetStatusText(@as(*const IOpenServiceActivity, @ptrCast(self)), pInput, pbstrStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetHomepageUrl(self: *const T, pbstrHomepageUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetHomepageUrl(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrHomepageUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetDisplayName(self: *const T, pbstrDisplayName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetDisplayName(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrDisplayName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetDescription(self: *const T, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetCategoryName(self: *const T, pbstrCategoryName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetCategoryName(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrCategoryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetIconPath(self: *const T, pbstrIconPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetIconPath(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrIconPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetIcon(self: *const T, fSmallIcon: BOOL, phIcon: ?*?HICON) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetIcon(@as(*const IOpenServiceActivity, @ptrCast(self)), fSmallIcon, phIcon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetDescriptionFilePath(self: *const T, pbstrXmlPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetDescriptionFilePath(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrXmlPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetDownloadUrl(self: *const T, pbstrXmlUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetDownloadUrl(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrXmlUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_GetInstallUrl(self: *const T, pbstrInstallUri: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).GetInstallUrl(@as(*const IOpenServiceActivity, @ptrCast(self)), pbstrInstallUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_IsEnabled(self: *const T, pfIsEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IOpenServiceActivity, @ptrCast(self)), pfIsEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivity_SetEnabled(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivity.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IOpenServiceActivity, @ptrCast(self)), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumOpenServiceActivity_Value = Guid.initString("a436d7d2-17c3-4ef4-a1e8-5c86faff26c0");
pub const IID_IEnumOpenServiceActivity = &IID_IEnumOpenServiceActivity_Value;
pub const IEnumOpenServiceActivity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivity,
                celt: u32,
                rgelt: [*]?*IOpenServiceActivity,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivity,
                celt: u32,
                rgelt: [*]?*IOpenServiceActivity,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivity,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivity,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivity,
                ppenum: ?*?*IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivity,
                ppenum: ?*?*IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivity_Next(self: *const T, celt: u32, rgelt: [*]?*IOpenServiceActivity, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivity.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumOpenServiceActivity, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivity_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivity.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumOpenServiceActivity, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivity_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivity.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumOpenServiceActivity, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivity_Clone(self: *const T, ppenum: ?*?*IEnumOpenServiceActivity) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivity.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumOpenServiceActivity, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenServiceActivityCategory_Value = Guid.initString("850af9d6-7309-40b5-bdb8-786c106b2153");
pub const IID_IOpenServiceActivityCategory = &IID_IOpenServiceActivityCategory_Value;
pub const IOpenServiceActivityCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasDefaultActivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityCategory,
                pfHasDefaultActivity: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityCategory,
                pfHasDefaultActivity: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultActivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityCategory,
                ppDefaultActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityCategory,
                ppDefaultActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultActivity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityCategory,
                pActivity: ?*IOpenServiceActivity,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityCategory,
                pActivity: ?*IOpenServiceActivity,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityCategory,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityCategory,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActivityEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityCategory,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                ppEnumActivity: ?*?*IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityCategory,
                pInput: ?*IOpenServiceActivityInput,
                pOutput: ?*IOpenServiceActivityOutputContext,
                ppEnumActivity: ?*?*IEnumOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityCategory_HasDefaultActivity(self: *const T, pfHasDefaultActivity: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).HasDefaultActivity(@as(*const IOpenServiceActivityCategory, @ptrCast(self)), pfHasDefaultActivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityCategory_GetDefaultActivity(self: *const T, ppDefaultActivity: ?*?*IOpenServiceActivity) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).GetDefaultActivity(@as(*const IOpenServiceActivityCategory, @ptrCast(self)), ppDefaultActivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityCategory_SetDefaultActivity(self: *const T, pActivity: ?*IOpenServiceActivity, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).SetDefaultActivity(@as(*const IOpenServiceActivityCategory, @ptrCast(self)), pActivity, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityCategory_GetName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).GetName(@as(*const IOpenServiceActivityCategory, @ptrCast(self)), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityCategory_GetActivityEnumerator(self: *const T, pInput: ?*IOpenServiceActivityInput, pOutput: ?*IOpenServiceActivityOutputContext, ppEnumActivity: ?*?*IEnumOpenServiceActivity) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).GetActivityEnumerator(@as(*const IOpenServiceActivityCategory, @ptrCast(self)), pInput, pOutput, ppEnumActivity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumOpenServiceActivityCategory_Value = Guid.initString("33627a56-8c9a-4430-8fd1-b5f5c771afb6");
pub const IID_IEnumOpenServiceActivityCategory = &IID_IEnumOpenServiceActivityCategory_Value;
pub const IEnumOpenServiceActivityCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivityCategory,
                celt: u32,
                rgelt: [*]?*IOpenServiceActivityCategory,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivityCategory,
                celt: u32,
                rgelt: [*]?*IOpenServiceActivityCategory,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivityCategory,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivityCategory,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumOpenServiceActivityCategory,
                ppenum: ?*?*IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumOpenServiceActivityCategory,
                ppenum: ?*?*IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivityCategory_Next(self: *const T, celt: u32, rgelt: [*]?*IOpenServiceActivityCategory, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumOpenServiceActivityCategory, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivityCategory_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumOpenServiceActivityCategory, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivityCategory_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumOpenServiceActivityCategory, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumOpenServiceActivityCategory_Clone(self: *const T, ppenum: ?*?*IEnumOpenServiceActivityCategory) callconv(.Inline) HRESULT {
            return @as(*const IEnumOpenServiceActivityCategory.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumOpenServiceActivityCategory, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenServiceActivityManager_Value = Guid.initString("8a2d0a9d-e920-4bdc-a291-d30f650bc4f1");
pub const IID_IOpenServiceActivityManager = &IID_IOpenServiceActivityManager_Value;
pub const IOpenServiceActivityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCategoryEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityManager,
                eType: OpenServiceActivityContentType,
                ppEnum: ?*?*IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityManager,
                eType: OpenServiceActivityContentType,
                ppEnum: ?*?*IEnumOpenServiceActivityCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActivityByID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityManager,
                pwzActivityID: ?[*:0]align(1) const u16,
                ppActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityManager,
                pwzActivityID: ?[*:0]align(1) const u16,
                ppActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActivityByHomepageAndCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityManager,
                pwzHomepage: ?[*:0]align(1) const u16,
                pwzCategory: ?[*:0]align(1) const u16,
                ppActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityManager,
                pwzHomepage: ?[*:0]align(1) const u16,
                pwzCategory: ?[*:0]align(1) const u16,
                ppActivity: ?*?*IOpenServiceActivity,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOpenServiceActivityManager,
                pdwVersionCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOpenServiceActivityManager,
                pdwVersionCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityManager_GetCategoryEnumerator(self: *const T, eType: OpenServiceActivityContentType, ppEnum: ?*?*IEnumOpenServiceActivityCategory) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityManager.VTable, @ptrCast(self.vtable)).GetCategoryEnumerator(@as(*const IOpenServiceActivityManager, @ptrCast(self)), eType, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityManager_GetActivityByID(self: *const T, pwzActivityID: ?[*:0]align(1) const u16, ppActivity: ?*?*IOpenServiceActivity) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityManager.VTable, @ptrCast(self.vtable)).GetActivityByID(@as(*const IOpenServiceActivityManager, @ptrCast(self)), pwzActivityID, ppActivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityManager_GetActivityByHomepageAndCategory(self: *const T, pwzHomepage: ?[*:0]align(1) const u16, pwzCategory: ?[*:0]align(1) const u16, ppActivity: ?*?*IOpenServiceActivity) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityManager.VTable, @ptrCast(self.vtable)).GetActivityByHomepageAndCategory(@as(*const IOpenServiceActivityManager, @ptrCast(self)), pwzHomepage, pwzCategory, ppActivity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenServiceActivityManager_GetVersionCookie(self: *const T, pdwVersionCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IOpenServiceActivityManager.VTable, @ptrCast(self.vtable)).GetVersionCookie(@as(*const IOpenServiceActivityManager, @ptrCast(self)), pdwVersionCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPersistHistory_Value = Guid.initString("91a565c1-e38f-11d0-94bf-00a0c9055cbf");
pub const IID_IPersistHistory = &IID_IPersistHistory_Value;
pub const IPersistHistory = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        LoadHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistHistory,
                pStream: ?*IStream,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistHistory,
                pStream: ?*IStream,
                pbc: ?*IBindCtx,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistHistory,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistHistory,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPositionCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistHistory,
                dwPositioncookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistHistory,
                dwPositioncookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistHistory,
                pdwPositioncookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistHistory,
                pdwPositioncookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistHistory_LoadHistory(self: *const T, pStream: ?*IStream, pbc: ?*IBindCtx) callconv(.Inline) HRESULT {
            return @as(*const IPersistHistory.VTable, @ptrCast(self.vtable)).LoadHistory(@as(*const IPersistHistory, @ptrCast(self)), pStream, pbc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistHistory_SaveHistory(self: *const T, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IPersistHistory.VTable, @ptrCast(self.vtable)).SaveHistory(@as(*const IPersistHistory, @ptrCast(self)), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistHistory_SetPositionCookie(self: *const T, dwPositioncookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IPersistHistory.VTable, @ptrCast(self.vtable)).SetPositionCookie(@as(*const IPersistHistory, @ptrCast(self)), dwPositioncookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistHistory_GetPositionCookie(self: *const T, pdwPositioncookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPersistHistory.VTable, @ptrCast(self.vtable)).GetPositionCookie(@as(*const IPersistHistory, @ptrCast(self)), pdwPositioncookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ADDURL_FLAG = enum(i32) {
    FIRST = 0,
    // ADDTOHISTORYANDCACHE = 0, this enum value conflicts with FIRST
    ADDTOCACHE = 1,
    Max = 2147483647,
};
pub const ADDURL_FIRST = ADDURL_FLAG.FIRST;
pub const ADDURL_ADDTOHISTORYANDCACHE = ADDURL_FLAG.FIRST;
pub const ADDURL_ADDTOCACHE = ADDURL_FLAG.ADDTOCACHE;
pub const ADDURL_Max = ADDURL_FLAG.Max;

pub const STATURL = extern struct {
    cbSize: u32,
    pwcsUrl: ?PWSTR,
    pwcsTitle: ?PWSTR,
    ftLastVisited: FILETIME,
    ftLastUpdated: FILETIME,
    ftExpires: FILETIME,
    dwFlags: u32,
};

const IID_IEnumSTATURL_Value = Guid.initString("3c374a42-bae4-11cf-bf7d-00aa006946ee");
pub const IID_IEnumSTATURL = &IID_IEnumSTATURL_Value;
pub const IEnumSTATURL = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATURL,
                celt: u32,
                rgelt: ?*STATURL,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATURL,
                celt: u32,
                rgelt: ?*STATURL,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATURL,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATURL,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATURL,
                ppenum: ?*?*IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATURL,
                ppenum: ?*?*IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATURL,
                poszFilter: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATURL,
                poszFilter: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATURL_Next(self: *const T, celt: u32, rgelt: ?*STATURL, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATURL.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATURL, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATURL_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATURL.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATURL, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATURL_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATURL.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATURL, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATURL_Clone(self: *const T, ppenum: ?*?*IEnumSTATURL) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATURL.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATURL, @ptrCast(self)), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATURL_SetFilter(self: *const T, poszFilter: ?[*:0]align(1) const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATURL.VTable, @ptrCast(self.vtable)).SetFilter(@as(*const IEnumSTATURL, @ptrCast(self)), poszFilter, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlHistoryStg_Value = Guid.initString("3c374a41-bae4-11cf-bf7d-00aa006946ee");
pub const IID_IUrlHistoryStg = &IID_IUrlHistoryStg_Value;
pub const IUrlHistoryStg = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                pocsTitle: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                pocsTitle: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryUrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
                lpSTATURL: ?*STATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                dwFlags: u32,
                lpSTATURL: ?*STATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindToObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg,
                pocsUrl: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppvOut: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumUrls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg,
                ppEnum: ?*?*IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg,
                ppEnum: ?*?*IEnumSTATURL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg_AddUrl(self: *const T, pocsUrl: ?[*:0]align(1) const u16, pocsTitle: ?[*:0]align(1) const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg.VTable, @ptrCast(self.vtable)).AddUrl(@as(*const IUrlHistoryStg, @ptrCast(self)), pocsUrl, pocsTitle, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg_DeleteUrl(self: *const T, pocsUrl: ?[*:0]align(1) const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg.VTable, @ptrCast(self.vtable)).DeleteUrl(@as(*const IUrlHistoryStg, @ptrCast(self)), pocsUrl, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg_QueryUrl(self: *const T, pocsUrl: ?[*:0]align(1) const u16, dwFlags: u32, lpSTATURL: ?*STATURL) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg.VTable, @ptrCast(self.vtable)).QueryUrl(@as(*const IUrlHistoryStg, @ptrCast(self)), pocsUrl, dwFlags, lpSTATURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg_BindToObject(self: *const T, pocsUrl: ?[*:0]align(1) const u16, riid: ?*const Guid, ppvOut: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg.VTable, @ptrCast(self.vtable)).BindToObject(@as(*const IUrlHistoryStg, @ptrCast(self)), pocsUrl, riid, ppvOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg_EnumUrls(self: *const T, ppEnum: ?*?*IEnumSTATURL) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg.VTable, @ptrCast(self.vtable)).EnumUrls(@as(*const IUrlHistoryStg, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlHistoryStg2_Value = Guid.initString("afa0dc11-c313-11d0-831a-00c04fd5ae38");
pub const IID_IUrlHistoryStg2 = &IID_IUrlHistoryStg2_Value;
pub const IUrlHistoryStg2 = extern struct {
    pub const VTable = extern struct {
        base: IUrlHistoryStg.VTable,
        AddUrlAndNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg2,
                pocsUrl: ?[*:0]align(1) const u16,
                pocsTitle: ?[*:0]align(1) const u16,
                dwFlags: u32,
                fWriteHistory: BOOL,
                poctNotify: ?*IOleCommandTarget,
                punkISFolder: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg2,
                pocsUrl: ?[*:0]align(1) const u16,
                pocsTitle: ?[*:0]align(1) const u16,
                dwFlags: u32,
                fWriteHistory: BOOL,
                poctNotify: ?*IOleCommandTarget,
                punkISFolder: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearHistory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IUrlHistoryStg2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IUrlHistoryStg2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUrlHistoryStg.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg2_AddUrlAndNotify(self: *const T, pocsUrl: ?[*:0]align(1) const u16, pocsTitle: ?[*:0]align(1) const u16, dwFlags: u32, fWriteHistory: BOOL, poctNotify: ?*IOleCommandTarget, punkISFolder: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg2.VTable, @ptrCast(self.vtable)).AddUrlAndNotify(@as(*const IUrlHistoryStg2, @ptrCast(self)), pocsUrl, pocsTitle, dwFlags, fWriteHistory, poctNotify, punkISFolder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlHistoryStg2_ClearHistory(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IUrlHistoryStg2.VTable, @ptrCast(self.vtable)).ClearHistory(@as(*const IUrlHistoryStg2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlHistoryNotify_Value = Guid.initString("bc40bec1-c493-11d0-831b-00c04fd5ae38");
pub const IID_IUrlHistoryNotify = &IID_IUrlHistoryNotify_Value;
pub const IUrlHistoryNotify = extern struct {
    pub const VTable = extern struct {
        base: IOleCommandTarget.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOleCommandTarget.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserEventsService_Value = Guid.initString("54a8f188-9ebd-4795-ad16-9b4945119636");
pub const IID_IWebBrowserEventsService = &IID_IWebBrowserEventsService_Value;
pub const IWebBrowserEventsService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireBeforeNavigate2Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsService,
                pfCancel: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsService,
                pfCancel: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireNavigateComplete2Event: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDownloadBeginEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDownloadCompleteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDocumentCompleteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsService_FireBeforeNavigate2Event(self: *const T, pfCancel: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsService.VTable, @ptrCast(self.vtable)).FireBeforeNavigate2Event(@as(*const IWebBrowserEventsService, @ptrCast(self)), pfCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsService_FireNavigateComplete2Event(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsService.VTable, @ptrCast(self.vtable)).FireNavigateComplete2Event(@as(*const IWebBrowserEventsService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsService_FireDownloadBeginEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsService.VTable, @ptrCast(self.vtable)).FireDownloadBeginEvent(@as(*const IWebBrowserEventsService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsService_FireDownloadCompleteEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsService.VTable, @ptrCast(self.vtable)).FireDownloadCompleteEvent(@as(*const IWebBrowserEventsService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsService_FireDocumentCompleteEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsService.VTable, @ptrCast(self.vtable)).FireDocumentCompleteEvent(@as(*const IWebBrowserEventsService, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserEventsUrlService_Value = Guid.initString("87cc5d04-eafa-4833-9820-8f986530cc00");
pub const IID_IWebBrowserEventsUrlService = &IID_IWebBrowserEventsUrlService_Value;
pub const IWebBrowserEventsUrlService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUrlForEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebBrowserEventsUrlService,
                pUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebBrowserEventsUrlService,
                pUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserEventsUrlService_GetUrlForEvents(self: *const T, pUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IWebBrowserEventsUrlService.VTable, @ptrCast(self.vtable)).GetUrlForEvents(@as(*const IWebBrowserEventsUrlService, @ptrCast(self)), pUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimerService_Value = Guid.initString("3050f35f-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITimerService = &IID_ITimerService_Value;
pub const ITimerService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimerService,
                pReferenceTimer: ?*ITimer,
                ppNewTimer: ?*?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimerService,
                pReferenceTimer: ?*ITimer,
                ppNewTimer: ?*?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamedTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimerService,
                rguidName: ?*const Guid,
                ppTimer: ?*?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimerService,
                rguidName: ?*const Guid,
                ppTimer: ?*?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNamedTimerReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimerService,
                rguidName: ?*const Guid,
                pReferenceTimer: ?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimerService,
                rguidName: ?*const Guid,
                pReferenceTimer: ?*ITimer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimerService_CreateTimer(self: *const T, pReferenceTimer: ?*ITimer, ppNewTimer: ?*?*ITimer) callconv(.Inline) HRESULT {
            return @as(*const ITimerService.VTable, @ptrCast(self.vtable)).CreateTimer(@as(*const ITimerService, @ptrCast(self)), pReferenceTimer, ppNewTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimerService_GetNamedTimer(self: *const T, rguidName: ?*const Guid, ppTimer: ?*?*ITimer) callconv(.Inline) HRESULT {
            return @as(*const ITimerService.VTable, @ptrCast(self.vtable)).GetNamedTimer(@as(*const ITimerService, @ptrCast(self)), rguidName, ppTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimerService_SetNamedTimerReference(self: *const T, rguidName: ?*const Guid, pReferenceTimer: ?*ITimer) callconv(.Inline) HRESULT {
            return @as(*const ITimerService.VTable, @ptrCast(self.vtable)).SetNamedTimerReference(@as(*const ITimerService, @ptrCast(self)), rguidName, pReferenceTimer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimer_Value = Guid.initString("3050f360-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITimer = &IID_ITimer_Value;
pub const ITimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimer,
                vtimeMin: VARIANT,
                vtimeMax: VARIANT,
                vtimeInterval: VARIANT,
                dwFlags: u32,
                pTimerSink: ?*ITimerSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimer,
                vtimeMin: VARIANT,
                vtimeMax: VARIANT,
                vtimeInterval: VARIANT,
                dwFlags: u32,
                pTimerSink: ?*ITimerSink,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimer,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimer,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Freeze: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimer,
                fFreeze: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimer,
                fFreeze: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimer,
                pvtime: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimer,
                pvtime: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimer_Advise(self: *const T, vtimeMin: VARIANT, vtimeMax: VARIANT, vtimeInterval: VARIANT, dwFlags: u32, pTimerSink: ?*ITimerSink, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITimer.VTable, @ptrCast(self.vtable)).Advise(@as(*const ITimer, @ptrCast(self)), vtimeMin, vtimeMax, vtimeInterval, dwFlags, pTimerSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimer_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const ITimer.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ITimer, @ptrCast(self)), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimer_Freeze(self: *const T, fFreeze: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITimer.VTable, @ptrCast(self.vtable)).Freeze(@as(*const ITimer, @ptrCast(self)), fFreeze);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimer_GetTime(self: *const T, pvtime: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITimer.VTable, @ptrCast(self.vtable)).GetTime(@as(*const ITimer, @ptrCast(self)), pvtime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimerEx_Value = Guid.initString("30510414-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITimerEx = &IID_ITimerEx_Value;
pub const ITimerEx = extern struct {
    pub const VTable = extern struct {
        base: ITimer.VTable,
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimerEx,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimerEx,
                dwMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITimer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimerEx_SetMode(self: *const T, dwMode: u32) callconv(.Inline) HRESULT {
            return @as(*const ITimerEx.VTable, @ptrCast(self.vtable)).SetMode(@as(*const ITimerEx, @ptrCast(self)), dwMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITimerSink_Value = Guid.initString("3050f361-98b5-11cf-bb82-00aa00bdce0b");
pub const IID_ITimerSink = &IID_ITimerSink_Value;
pub const ITimerSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITimerSink,
                vtimeAdvise: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITimerSink,
                vtimeAdvise: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITimerSink_OnTimer(self: *const T, vtimeAdvise: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITimerSink.VTable, @ptrCast(self.vtable)).OnTimer(@as(*const ITimerSink, @ptrCast(self)), vtimeAdvise);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMapMIMEToCLSID_Value = Guid.initString("d9e89500-30fa-11d0-b724-00aa006c1a01");
pub const IID_IMapMIMEToCLSID = &IID_IMapMIMEToCLSID_Value;
pub const IMapMIMEToCLSID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDefaultMappings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMapMIMEToCLSID,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMapMIMEToCLSID,
                bEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapMIMEToCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMapMIMEToCLSID,
                pszMIMEType: ?[*:0]align(1) const u16,
                pCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMapMIMEToCLSID,
                pszMIMEType: ?[*:0]align(1) const u16,
                pCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMapMIMEToCLSID,
                pszMIMEType: ?[*:0]align(1) const u16,
                dwMapMode: u32,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMapMIMEToCLSID,
                pszMIMEType: ?[*:0]align(1) const u16,
                dwMapMode: u32,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMapMIMEToCLSID_EnableDefaultMappings(self: *const T, bEnable: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMapMIMEToCLSID.VTable, @ptrCast(self.vtable)).EnableDefaultMappings(@as(*const IMapMIMEToCLSID, @ptrCast(self)), bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMapMIMEToCLSID_MapMIMEToCLSID(self: *const T, pszMIMEType: ?[*:0]align(1) const u16, pCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMapMIMEToCLSID.VTable, @ptrCast(self.vtable)).MapMIMEToCLSID(@as(*const IMapMIMEToCLSID, @ptrCast(self)), pszMIMEType, pCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMapMIMEToCLSID_SetMapping(self: *const T, pszMIMEType: ?[*:0]align(1) const u16, dwMapMode: u32, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMapMIMEToCLSID.VTable, @ptrCast(self.vtable)).SetMapping(@as(*const IMapMIMEToCLSID, @ptrCast(self)), pszMIMEType, dwMapMode, clsid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImageDecodeFilter_Value = Guid.initString("a3ccedf3-2de2-11d0-86f4-00a0c913f750");
pub const IID_IImageDecodeFilter = &IID_IImageDecodeFilter_Value;
pub const IImageDecodeFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeFilter,
                pEventSink: ?*IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeFilter,
                pEventSink: ?*IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Process: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeFilter,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeFilter,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeFilter,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeFilter,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeFilter_Initialize(self: *const T, pEventSink: ?*IImageDecodeEventSink) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeFilter.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IImageDecodeFilter, @ptrCast(self)), pEventSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeFilter_Process(self: *const T, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeFilter.VTable, @ptrCast(self.vtable)).Process(@as(*const IImageDecodeFilter, @ptrCast(self)), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeFilter_Terminate(self: *const T, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeFilter.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IImageDecodeFilter, @ptrCast(self)), hrStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImageDecodeEventSink_Value = Guid.initString("baa342a0-2ded-11d0-86f4-00a0c913f750");
pub const IID_IImageDecodeEventSink = &IID_IImageDecodeEventSink_Value;
pub const IImageDecodeEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
                nWidth: i32,
                nHeight: i32,
                bfid: ?*const Guid,
                nPasses: u32,
                dwHints: u32,
                ppSurface: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
                nWidth: i32,
                nHeight: i32,
                bfid: ?*const Guid,
                nPasses: u32,
                dwHints: u32,
                ppSurface: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeginDecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
                pdwEvents: ?*u32,
                pnFormats: ?*u32,
                ppFormats: [*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
                pdwEvents: ?*u32,
                pnFormats: ?*u32,
                ppFormats: [*]?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBitsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDecodeComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPalette: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink,
                pBounds: ?*RECT,
                bComplete: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink,
                pBounds: ?*RECT,
                bComplete: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_GetSurface(self: *const T, nWidth: i32, nHeight: i32, bfid: ?*const Guid, nPasses: u32, dwHints: u32, ppSurface: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IImageDecodeEventSink, @ptrCast(self)), nWidth, nHeight, bfid, nPasses, dwHints, ppSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_OnBeginDecode(self: *const T, pdwEvents: ?*u32, pnFormats: ?*u32, ppFormats: [*]?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).OnBeginDecode(@as(*const IImageDecodeEventSink, @ptrCast(self)), pdwEvents, pnFormats, ppFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_OnBitsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).OnBitsComplete(@as(*const IImageDecodeEventSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_OnDecodeComplete(self: *const T, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).OnDecodeComplete(@as(*const IImageDecodeEventSink, @ptrCast(self)), hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_OnPalette(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).OnPalette(@as(*const IImageDecodeEventSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink_OnProgress(self: *const T, pBounds: ?*RECT, bComplete: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink.VTable, @ptrCast(self.vtable)).OnProgress(@as(*const IImageDecodeEventSink, @ptrCast(self)), pBounds, bComplete);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IImageDecodeEventSink2_Value = Guid.initString("8ebd8a57-8a96-48c9-84a6-962e2db9c931");
pub const IID_IImageDecodeEventSink2 = &IID_IImageDecodeEventSink2_Value;
pub const IImageDecodeEventSink2 = extern struct {
    pub const VTable = extern struct {
        base: IImageDecodeEventSink.VTable,
        IsAlphaPremultRequired: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IImageDecodeEventSink2,
                pfPremultAlpha: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IImageDecodeEventSink2,
                pfPremultAlpha: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IImageDecodeEventSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageDecodeEventSink2_IsAlphaPremultRequired(self: *const T, pfPremultAlpha: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IImageDecodeEventSink2.VTable, @ptrCast(self.vtable)).IsAlphaPremultRequired(@as(*const IImageDecodeEventSink2, @ptrCast(self)), pfPremultAlpha);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISniffStream_Value = Guid.initString("4ef17940-30e0-11d0-b724-00aa006c1a01");
pub const IID_ISniffStream = &IID_ISniffStream_Value;
pub const ISniffStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISniffStream,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISniffStream,
                pStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Peek: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISniffStream,
                pBuffer: ?*anyopaque,
                nBytes: u32,
                pnBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISniffStream,
                pBuffer: ?*anyopaque,
                nBytes: u32,
                pnBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISniffStream_Init(self: *const T, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const ISniffStream.VTable, @ptrCast(self.vtable)).Init(@as(*const ISniffStream, @ptrCast(self)), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISniffStream_Peek(self: *const T, pBuffer: ?*anyopaque, nBytes: u32, pnBytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISniffStream.VTable, @ptrCast(self.vtable)).Peek(@as(*const ISniffStream, @ptrCast(self)), pBuffer, nBytes, pnBytesRead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDithererImpl_Value = Guid.initString("7c48e840-3910-11d0-86fc-00a0c913f750");
pub const IID_IDithererImpl = &IID_IDithererImpl_Value;
pub const IDithererImpl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDestColorTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDithererImpl,
                nColors: u32,
                prgbColors: ?*const RGBQUAD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDithererImpl,
                nColors: u32,
                prgbColors: ?*const RGBQUAD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDithererImpl,
                pEventSink: ?*IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDithererImpl,
                pEventSink: ?*IImageDecodeEventSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDithererImpl_SetDestColorTable(self: *const T, nColors: u32, prgbColors: ?*const RGBQUAD) callconv(.Inline) HRESULT {
            return @as(*const IDithererImpl.VTable, @ptrCast(self.vtable)).SetDestColorTable(@as(*const IDithererImpl, @ptrCast(self)), nColors, prgbColors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDithererImpl_SetEventSink(self: *const T, pEventSink: ?*IImageDecodeEventSink) callconv(.Inline) HRESULT {
            return @as(*const IDithererImpl.VTable, @ptrCast(self.vtable)).SetEventSink(@as(*const IDithererImpl, @ptrCast(self)), pEventSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CoDitherToRGB8_Value = Guid.initString("a860ce50-3910-11d0-86fc-00a0c913f750");
pub const CLSID_CoDitherToRGB8 = &CLSID_CoDitherToRGB8_Value;

const CLSID_CoSniffStream_Value = Guid.initString("6a01fda0-30df-11d0-b724-00aa006c1a01");
pub const CLSID_CoSniffStream = &CLSID_CoSniffStream_Value;

const CLSID_CoMapMIMEToCLSID_Value = Guid.initString("30c3b080-30fb-11d0-b724-00aa006c1a01");
pub const CLSID_CoMapMIMEToCLSID = &CLSID_CoMapMIMEToCLSID_Value;


//--------------------------------------------------------------------------------
// Section: Functions (57)
//--------------------------------------------------------------------------------
pub extern "ieframe" fn IEAssociateThreadWithTab(
    dwTabThreadID: u32,
    dwAssociatedThreadID: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEDisassociateThreadWithTab(
    dwTabThreadID: u32,
    dwAssociatedThreadID: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEIsInPrivateBrowsing(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IEInPrivateFilteringEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IETrackingProtectionEnabled(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IESaveFile(
    hState: ?HANDLE,
    lpwstrSourceFile: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IECancelSaveFile(
    hState: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEShowSaveFileDialog(
    hwnd: ?HWND,
    lpwstrInitialFileName: ?[*:0]align(1) const u16,
    lpwstrInitialDir: ?[*:0]align(1) const u16,
    lpwstrFilter: ?[*:0]align(1) const u16,
    lpwstrDefExt: ?[*:0]align(1) const u16,
    dwFilterIndex: u32,
    dwFlags: u32,
    lppwstrDestinationFilePath: ?*?PWSTR,
    phState: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEShowOpenFileDialog(
    hwnd: ?HWND,
    lpwstrFileName: [*:0]u16,
    cchMaxFileName: u32,
    lpwstrInitialDir: ?[*:0]align(1) const u16,
    lpwstrFilter: ?[*:0]align(1) const u16,
    lpwstrDefExt: ?[*:0]align(1) const u16,
    dwFilterIndex: u32,
    dwFlags: u32,
    phFile: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEGetWriteableLowHKCU(
    pHKey: ?*?HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEGetWriteableFolderPath(
    clsidFolderID: ?*const Guid,
    lppwstrPath: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEIsProtectedModeProcess(
    pbResult: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEIsProtectedModeURL(
    lpwstrUrl: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IELaunchURL(
    lpwstrUrl: ?[*:0]align(1) const u16,
    lpProcInfo: ?*PROCESS_INFORMATION,
    lpInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IERefreshElevationPolicy(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEGetProtectedModeCookie(
    lpszURL: ?[*:0]align(1) const u16,
    lpszCookieName: ?[*:0]align(1) const u16,
    lpszCookieData: [*:0]u16,
    pcchCookieData: ?*u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IESetProtectedModeCookie(
    lpszURL: ?[*:0]align(1) const u16,
    lpszCookieName: ?[*:0]align(1) const u16,
    lpszCookieData: ?[*:0]align(1) const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IERegisterWritableRegistryKey(
    guid: Guid,
    lpSubkey: ?[*:0]align(1) const u16,
    fSubkeyAllowed: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IERegisterWritableRegistryValue(
    guid: Guid,
    lpPath: ?[*:0]align(1) const u16,
    lpValueName: ?[*:0]align(1) const u16,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbMaxData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IEUnregisterWritableRegistry(
    guid: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IERegCreateKeyEx(
    lpSubKey: ?[*:0]align(1) const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: u32,
    samDesired: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    phkResult: ?*?HKEY,
    lpdwDisposition: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IERegSetValueEx(
    lpSubKey: ?[*:0]align(1) const u16,
    lpValueName: ?[*:0]align(1) const u16,
    Reserved: u32,
    dwType: u32,
    // TODO: what to do with BytesParamIndex 5?
    lpData: ?*const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ieframe" fn IECreateFile(
    lpFileName: ?[*:0]align(1) const u16,
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    dwCreationDisposition: u32,
    dwFlagsAndAttributes: u32,
    hTemplateFile: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "ieframe" fn IEDeleteFile(
    lpFileName: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IERemoveDirectory(
    lpPathName: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IEMoveFileEx(
    lpExistingFileName: ?[*:0]align(1) const u16,
    lpNewFileName: ?[*:0]align(1) const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IECreateDirectory(
    lpPathName: ?[*:0]align(1) const u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IEGetFileAttributesEx(
    lpFileName: ?[*:0]align(1) const u16,
    fInfoLevelId: GET_FILEEX_INFO_LEVELS,
    lpFileInformation: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ieframe" fn IEFindFirstFile(
    lpFileName: ?[*:0]align(1) const u16,
    lpFindFileData: ?*WIN32_FIND_DATAA,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "msrating" fn RatingEnable(
    hwndParent: ?HWND,
    pszUsername: ?[*:0]align(1) const u8,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingEnableW(
    hwndParent: ?HWND,
    pszUsername: ?[*:0]align(1) const u16,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingCheckUserAccess(
    pszUsername: ?[*:0]align(1) const u8,
    pszURL: ?[*:0]align(1) const u8,
    pszRatingInfo: ?[*:0]align(1) const u8,
    // TODO: what to do with BytesParamIndex 4?
    pData: ?*u8,
    cbData: u32,
    ppRatingDetails: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingCheckUserAccessW(
    pszUsername: ?[*:0]align(1) const u16,
    pszURL: ?[*:0]align(1) const u16,
    pszRatingInfo: ?[*:0]align(1) const u16,
    // TODO: what to do with BytesParamIndex 4?
    pData: ?*u8,
    cbData: u32,
    ppRatingDetails: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingAccessDeniedDialog(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u8,
    pszContentDescription: ?[*:0]align(1) const u8,
    pRatingDetails: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingAccessDeniedDialogW(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u16,
    pszContentDescription: ?[*:0]align(1) const u16,
    pRatingDetails: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingAccessDeniedDialog2(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u8,
    pRatingDetails: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingAccessDeniedDialog2W(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u16,
    pRatingDetails: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingFreeDetails(
    pRatingDetails: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingObtainCancel(
    hRatingObtainQuery: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingObtainQuery(
    pszTargetUrl: ?[*:0]align(1) const u8,
    dwUserData: u32,
    fCallback: isize,
    phRatingObtainQuery: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingObtainQueryW(
    pszTargetUrl: ?[*:0]align(1) const u16,
    dwUserData: u32,
    fCallback: isize,
    phRatingObtainQuery: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingSetupUI(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingSetupUIW(
    hDlg: ?HWND,
    pszUsername: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingAddToApprovedSites(
    hDlg: ?HWND,
    cbPasswordBlob: u32,
    // TODO: what to do with BytesParamIndex 1?
    pbPasswordBlob: ?*u8,
    lpszUrl: ?[*:0]align(1) const u16,
    fAlwaysNever: BOOL,
    fSitePage: BOOL,
    fApprovedSitesEnforced: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingClickedOnPRFInternal(
    hWndOwner: ?HWND,
    param1: ?HINSTANCE,
    lpszFileName: ?PSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingClickedOnRATInternal(
    hWndOwner: ?HWND,
    param1: ?HINSTANCE,
    lpszFileName: ?PSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingEnabledQuery(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "msrating" fn RatingInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn CreateMIMEMap(
    ppMap: ?*?*IMapMIMEToCLSID,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn DecodeImage(
    pStream: ?*IStream,
    pMap: ?*IMapMIMEToCLSID,
    pEventSink: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn SniffStream(
    pInStream: ?*IStream,
    pnFormat: ?*u32,
    ppOutStream: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn GetMaxMIMEIDBytes(
    pnMaxBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn IdentifyMIMEType(
    pbBytes: ?*const u8,
    nBytes: u32,
    pnFormat: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn ComputeInvCMAP(
    pRGBColors: ?*const RGBQUAD,
    nColors: u32,
    pInvTable: ?*u8,
    cbTable: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn DitherTo8(
    pDestBits: ?*u8,
    nDestPitch: i32,
    pSrcBits: ?*u8,
    nSrcPitch: i32,
    bfidSrc: ?*const Guid,
    prgbDestColors: ?*RGBQUAD,
    prgbSrcColors: ?*RGBQUAD,
    pbDestInvMap: ?*u8,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    lDestTrans: i32,
    lSrcTrans: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn CreateDDrawSurfaceOnDIB(
    hbmDib: ?HBITMAP,
    ppSurface: ?*?*IDirectDrawSurface,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "imgutil" fn DecodeImageEx(
    pStream: ?*IStream,
    pMap: ?*IMapMIMEToCLSID,
    pEventSink: ?*IUnknown,
    pszMIMETypeParam: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (46)
//--------------------------------------------------------------------------------
const Guid = @import("../../../zig.zig").Guid;
const BINDINFO = @import("../../../windows/win32/system/com.zig").BINDINFO;
const BOOL = @import("../../../windows/win32/foundation.zig").BOOL;
const BSTR = @import("../../../windows/win32/foundation.zig").BSTR;
const DXGI_FORMAT = @import("../../../windows/win32/graphics/dxgi/common.zig").DXGI_FORMAT;
const DXGI_MODE_ROTATION = @import("../../../windows/win32/graphics/dxgi/common.zig").DXGI_MODE_ROTATION;
const FILETIME = @import("../../../windows/win32/foundation.zig").FILETIME;
const GET_FILEEX_INFO_LEVELS = @import("../../../windows/win32/storage/file_system.zig").GET_FILEEX_INFO_LEVELS;
const HANDLE = @import("../../../windows/win32/foundation.zig").HANDLE;
const HBITMAP = @import("../../../windows/win32/graphics/gdi.zig").HBITMAP;
const HICON = @import("../../../windows/win32/ui/windows_and_messaging.zig").HICON;
const HINSTANCE = @import("../../../windows/win32/foundation.zig").HINSTANCE;
const HKEY = @import("../../../windows/win32/system/registry.zig").HKEY;
const HRESULT = @import("../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../windows/win32/foundation.zig").HWND;
const IBindCtx = @import("../../../windows/win32/system/com.zig").IBindCtx;
const IBindStatusCallback = @import("../../../windows/win32/system/com.zig").IBindStatusCallback;
const IDirectDrawSurface = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDrawSurface;
const IDispatch = @import("../../../windows/win32/system/com.zig").IDispatch;
const IHTMLDocument2 = @import("../../../windows/win32/web/ms_html.zig").IHTMLDocument2;
const IHTMLElement = @import("../../../windows/win32/web/ms_html.zig").IHTMLElement;
const IHTMLWindow2 = @import("../../../windows/win32/web/ms_html.zig").IHTMLWindow2;
const IInspectable = @import("../../../windows/win32/system/win_rt.zig").IInspectable;
const IMoniker = @import("../../../windows/win32/system/com.zig").IMoniker;
const IOleCommandTarget = @import("../../../windows/win32/system/ole.zig").IOleCommandTarget;
const IOleContainer = @import("../../../windows/win32/system/ole.zig").IOleContainer;
const IPersist = @import("../../../windows/win32/system/com.zig").IPersist;
const IStream = @import("../../../windows/win32/system/com.zig").IStream;
const IUnknown = @import("../../../windows/win32/system/com.zig").IUnknown;
const IUri = @import("../../../windows/win32/system/com.zig").IUri;
const LPARAM = @import("../../../windows/win32/foundation.zig").LPARAM;
const LUID = @import("../../../windows/win32/foundation.zig").LUID;
const POINT = @import("../../../windows/win32/foundation.zig").POINT;
const PROCESS_INFORMATION = @import("../../../windows/win32/system/threading.zig").PROCESS_INFORMATION;
const PSTR = @import("../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../windows/win32/foundation.zig").PWSTR;
const RECT = @import("../../../windows/win32/foundation.zig").RECT;
const RGBQUAD = @import("../../../windows/win32/graphics/gdi.zig").RGBQUAD;
const SECURITY_ATTRIBUTES = @import("../../../windows/win32/security.zig").SECURITY_ATTRIBUTES;
const SIZE = @import("../../../windows/win32/foundation.zig").SIZE;
const styleMsTouchAction = @import("../../../windows/win32/web/ms_html.zig").styleMsTouchAction;
const VARIANT = @import("../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../windows/win32/foundation.zig").VARIANT_BOOL;
const VIEW_OBJECT_ALPHA_MODE = @import("../../../windows/win32/web/ms_html.zig").VIEW_OBJECT_ALPHA_MODE;
const WIN32_FIND_DATAA = @import("../../../windows/win32/storage/file_system.zig").WIN32_FIND_DATAA;
const WPARAM = @import("../../../windows/win32/foundation.zig").WPARAM;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
