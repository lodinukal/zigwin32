//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (122)
//--------------------------------------------------------------------------------
pub const CATID_ActiveScriptAuthor = Guid.initString("0aee2a92-bcbb-11d0-8c72-00c04fc2b085");
pub const APPBREAKFLAG_DEBUGGER_BLOCK = @as(u32, 1);
pub const APPBREAKFLAG_DEBUGGER_HALT = @as(u32, 2);
pub const APPBREAKFLAG_STEP = @as(u32, 65536);
pub const APPBREAKFLAG_NESTED = @as(u32, 131072);
pub const APPBREAKFLAG_STEPTYPE_SOURCE = @as(u32, 0);
pub const APPBREAKFLAG_STEPTYPE_BYTECODE = @as(u32, 1048576);
pub const APPBREAKFLAG_STEPTYPE_MACHINE = @as(u32, 2097152);
pub const APPBREAKFLAG_STEPTYPE_MASK = @as(u32, 15728640);
pub const APPBREAKFLAG_IN_BREAKPOINT = @as(u32, 2147483648);
pub const SOURCETEXT_ATTR_KEYWORD = @as(u32, 1);
pub const SOURCETEXT_ATTR_COMMENT = @as(u32, 2);
pub const SOURCETEXT_ATTR_NONSOURCE = @as(u32, 4);
pub const SOURCETEXT_ATTR_OPERATOR = @as(u32, 8);
pub const SOURCETEXT_ATTR_NUMBER = @as(u32, 16);
pub const SOURCETEXT_ATTR_STRING = @as(u32, 32);
pub const SOURCETEXT_ATTR_FUNCTION_START = @as(u32, 64);
pub const TEXT_DOC_ATTR_READONLY = @as(u32, 1);
pub const TEXT_DOC_ATTR_TYPE_PRIMARY = @as(u32, 2);
pub const TEXT_DOC_ATTR_TYPE_WORKER = @as(u32, 4);
pub const TEXT_DOC_ATTR_TYPE_SCRIPT = @as(u32, 8);
pub const DEBUG_TEXT_ISEXPRESSION = @as(u32, 1);
pub const DEBUG_TEXT_RETURNVALUE = @as(u32, 2);
pub const DEBUG_TEXT_NOSIDEEFFECTS = @as(u32, 4);
pub const DEBUG_TEXT_ALLOWBREAKPOINTS = @as(u32, 8);
pub const DEBUG_TEXT_ALLOWERRORREPORT = @as(u32, 16);
pub const DEBUG_TEXT_EVALUATETOCODECONTEXT = @as(u32, 32);
pub const DEBUG_TEXT_ISNONUSERCODE = @as(u32, 64);
pub const THREAD_STATE_RUNNING = @as(u32, 1);
pub const THREAD_STATE_SUSPENDED = @as(u32, 2);
pub const THREAD_BLOCKED = @as(u32, 4);
pub const THREAD_OUT_OF_CONTEXT = @as(u32, 8);
pub const CATID_ActiveScript = Guid.initString("f0b7a1a1-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptParse = Guid.initString("f0b7a1a2-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptEncode = Guid.initString("f0b7a1a3-9847-11cf-8f20-00805f2cd064");
pub const OID_VBSSIP = Guid.initString("1629f04e-2799-4db5-8fe5-ace10f17ebab");
pub const OID_JSSIP = Guid.initString("06c9e010-38ce-11d4-a2a3-00104bd35090");
pub const OID_WSFSIP = Guid.initString("1a610570-38ce-11d4-a2a3-00104bd35090");
pub const SCRIPTITEM_ISVISIBLE = @as(u32, 2);
pub const SCRIPTITEM_ISSOURCE = @as(u32, 4);
pub const SCRIPTITEM_GLOBALMEMBERS = @as(u32, 8);
pub const SCRIPTITEM_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTITEM_CODEONLY = @as(u32, 512);
pub const SCRIPTITEM_NOCODE = @as(u32, 1024);
pub const SCRIPTTYPELIB_ISCONTROL = @as(u32, 16);
pub const SCRIPTTYPELIB_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_DELAYEXECUTION = @as(u32, 1);
pub const SCRIPTTEXT_ISVISIBLE = @as(u32, 2);
pub const SCRIPTTEXT_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTTEXT_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTTEXT_ISXDOMAIN = @as(u32, 256);
pub const SCRIPTTEXT_ISNONUSERCODE = @as(u32, 512);
pub const SCRIPTPROC_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTPROC_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTPROC_IMPLICIT_THIS = @as(u32, 256);
pub const SCRIPTPROC_IMPLICIT_PARENTS = @as(u32, 512);
pub const SCRIPTPROC_ISXDOMAIN = @as(u32, 1024);
pub const SCRIPTINFO_IUNKNOWN = @as(u32, 1);
pub const SCRIPTINFO_ITYPEINFO = @as(u32, 2);
pub const SCRIPTINTERRUPT_DEBUG = @as(u32, 1);
pub const SCRIPTINTERRUPT_RAISEEXCEPTION = @as(u32, 2);
pub const SCRIPTSTAT_STATEMENT_COUNT = @as(u32, 1);
pub const SCRIPTSTAT_INSTRUCTION_COUNT = @as(u32, 2);
pub const SCRIPTSTAT_INTSTRUCTION_TIME = @as(u32, 3);
pub const SCRIPTSTAT_TOTAL_TIME = @as(u32, 4);
pub const SCRIPT_ENCODE_SECTION = @as(u32, 1);
pub const SCRIPT_ENCODE_DEFAULT_LANGUAGE = @as(u32, 1);
pub const SCRIPT_ENCODE_NO_ASP_LANGUAGE = @as(u32, 2);
pub const SCRIPTPROP_NAME = @as(u32, 0);
pub const SCRIPTPROP_MAJORVERSION = @as(u32, 1);
pub const SCRIPTPROP_MINORVERSION = @as(u32, 2);
pub const SCRIPTPROP_BUILDNUMBER = @as(u32, 3);
pub const SCRIPTPROP_DELAYEDEVENTSINKING = @as(u32, 4096);
pub const SCRIPTPROP_CATCHEXCEPTION = @as(u32, 4097);
pub const SCRIPTPROP_CONVERSIONLCID = @as(u32, 4098);
pub const SCRIPTPROP_HOSTSTACKREQUIRED = @as(u32, 4099);
pub const SCRIPTPROP_SCRIPTSAREFULLYTRUSTED = @as(u32, 4100);
pub const SCRIPTPROP_DEBUGGER = @as(u32, 4352);
pub const SCRIPTPROP_JITDEBUG = @as(u32, 4353);
pub const SCRIPTPROP_GCCONTROLSOFTCLOSE = @as(u32, 8192);
pub const SCRIPTPROP_INTEGERMODE = @as(u32, 12288);
pub const SCRIPTPROP_STRINGCOMPAREINSTANCE = @as(u32, 12289);
pub const SCRIPTPROP_INVOKEVERSIONING = @as(u32, 16384);
pub const SCRIPTPROP_HACK_FIBERSUPPORT = @as(u32, 1879048192);
pub const SCRIPTPROP_HACK_TRIDENTEVENTSINK = @as(u32, 1879048193);
pub const SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION = @as(u32, 1879048194);
pub const SCRIPTPROP_HOSTKEEPALIVE = @as(u32, 1879048196);
pub const SCRIPT_E_RECORDED = @as(i32, -2040119292);
pub const SCRIPT_E_REPORTED = @as(i32, -2147352319);
pub const SCRIPT_E_PROPAGATE = @as(i32, -2147352318);
pub const FACILITY_JsDEBUG = @as(u32, 3527);
pub const E_JsDEBUG_MISMATCHED_RUNTIME = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338175));
pub const E_JsDEBUG_UNKNOWN_THREAD = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338174));
pub const E_JsDEBUG_OUTSIDE_OF_VM = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338172));
pub const E_JsDEBUG_INVALID_MEMORY_ADDRESS = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338171));
pub const E_JsDEBUG_SOURCE_LOCATION_NOT_FOUND = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338170));
pub const E_JsDEBUG_RUNTIME_NOT_IN_DEBUG_MODE = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -1916338169));
pub const ACTIVPROF_E_PROFILER_PRESENT = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const ACTIVPROF_E_PROFILER_ABSENT = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const ACTIVPROF_E_UNABLE_TO_APPLY_ACTION = @import("../../../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const PROFILER_HEAP_OBJECT_NAME_ID_UNAVAILABLE = @as(u32, 4294967295);
pub const fasaPreferInternalHandler = @as(u32, 1);
pub const fasaSupportInternalHandler = @as(u32, 2);
pub const fasaCaseSensitive = @as(u32, 4);
pub const SCRIPT_CMPL_NOLIST = @as(u32, 0);
pub const SCRIPT_CMPL_MEMBERLIST = @as(u32, 1);
pub const SCRIPT_CMPL_ENUMLIST = @as(u32, 2);
pub const SCRIPT_CMPL_PARAMTIP = @as(u32, 4);
pub const SCRIPT_CMPL_GLOBALLIST = @as(u32, 8);
pub const SCRIPT_CMPL_ENUM_TRIGGER = @as(u32, 1);
pub const SCRIPT_CMPL_MEMBER_TRIGGER = @as(u32, 2);
pub const SCRIPT_CMPL_PARAM_TRIGGER = @as(u32, 3);
pub const SCRIPT_CMPL_COMMIT = @as(u32, 4);
pub const GETATTRTYPE_NORMAL = @as(u32, 0);
pub const GETATTRTYPE_DEPSCAN = @as(u32, 1);
pub const GETATTRFLAG_THIS = @as(u32, 256);
pub const GETATTRFLAG_HUMANTEXT = @as(u32, 32768);
pub const SOURCETEXT_ATTR_HUMANTEXT = @as(u32, 32768);
pub const SOURCETEXT_ATTR_IDENTIFIER = @as(u32, 256);
pub const SOURCETEXT_ATTR_MEMBERLOOKUP = @as(u32, 512);
pub const SOURCETEXT_ATTR_THIS = @as(u32, 1024);

//--------------------------------------------------------------------------------
// Section: Types (171)
//--------------------------------------------------------------------------------
pub const SCRIPTLANGUAGEVERSION = enum(i32) {
    DEFAULT = 0,
    @"5_7" = 1,
    @"5_8" = 2,
    MAX = 255,
};
pub const SCRIPTLANGUAGEVERSION_DEFAULT = SCRIPTLANGUAGEVERSION.DEFAULT;
pub const SCRIPTLANGUAGEVERSION_5_7 = SCRIPTLANGUAGEVERSION.@"5_7";
pub const SCRIPTLANGUAGEVERSION_5_8 = SCRIPTLANGUAGEVERSION.@"5_8";
pub const SCRIPTLANGUAGEVERSION_MAX = SCRIPTLANGUAGEVERSION.MAX;

pub const SCRIPTSTATE = enum(i32) {
    UNINITIALIZED = 0,
    INITIALIZED = 5,
    STARTED = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    CLOSED = 4,
};
pub const SCRIPTSTATE_UNINITIALIZED = SCRIPTSTATE.UNINITIALIZED;
pub const SCRIPTSTATE_INITIALIZED = SCRIPTSTATE.INITIALIZED;
pub const SCRIPTSTATE_STARTED = SCRIPTSTATE.STARTED;
pub const SCRIPTSTATE_CONNECTED = SCRIPTSTATE.CONNECTED;
pub const SCRIPTSTATE_DISCONNECTED = SCRIPTSTATE.DISCONNECTED;
pub const SCRIPTSTATE_CLOSED = SCRIPTSTATE.CLOSED;

pub const SCRIPTTRACEINFO = enum(i32) {
    SCRIPTSTART = 0,
    SCRIPTEND = 1,
    COMCALLSTART = 2,
    COMCALLEND = 3,
    CREATEOBJSTART = 4,
    CREATEOBJEND = 5,
    GETOBJSTART = 6,
    GETOBJEND = 7,
};
pub const SCRIPTTRACEINFO_SCRIPTSTART = SCRIPTTRACEINFO.SCRIPTSTART;
pub const SCRIPTTRACEINFO_SCRIPTEND = SCRIPTTRACEINFO.SCRIPTEND;
pub const SCRIPTTRACEINFO_COMCALLSTART = SCRIPTTRACEINFO.COMCALLSTART;
pub const SCRIPTTRACEINFO_COMCALLEND = SCRIPTTRACEINFO.COMCALLEND;
pub const SCRIPTTRACEINFO_CREATEOBJSTART = SCRIPTTRACEINFO.CREATEOBJSTART;
pub const SCRIPTTRACEINFO_CREATEOBJEND = SCRIPTTRACEINFO.CREATEOBJEND;
pub const SCRIPTTRACEINFO_GETOBJSTART = SCRIPTTRACEINFO.GETOBJSTART;
pub const SCRIPTTRACEINFO_GETOBJEND = SCRIPTTRACEINFO.GETOBJEND;

pub const SCRIPTTHREADSTATE = enum(i32) {
    NOTINSCRIPT = 0,
    RUNNING = 1,
};
pub const SCRIPTTHREADSTATE_NOTINSCRIPT = SCRIPTTHREADSTATE.NOTINSCRIPT;
pub const SCRIPTTHREADSTATE_RUNNING = SCRIPTTHREADSTATE.RUNNING;

pub const SCRIPTGCTYPE = enum(i32) {
    NORMAL = 0,
    EXHAUSTIVE = 1,
};
pub const SCRIPTGCTYPE_NORMAL = SCRIPTGCTYPE.NORMAL;
pub const SCRIPTGCTYPE_EXHAUSTIVE = SCRIPTGCTYPE.EXHAUSTIVE;

pub const SCRIPTUICITEM = enum(i32) {
    INPUTBOX = 1,
    MSGBOX = 2,
};
pub const SCRIPTUICITEM_INPUTBOX = SCRIPTUICITEM.INPUTBOX;
pub const SCRIPTUICITEM_MSGBOX = SCRIPTUICITEM.MSGBOX;

pub const SCRIPTUICHANDLING = enum(i32) {
    ALLOW = 0,
    NOUIERROR = 1,
    NOUIDEFAULT = 2,
};
pub const SCRIPTUICHANDLING_ALLOW = SCRIPTUICHANDLING.ALLOW;
pub const SCRIPTUICHANDLING_NOUIERROR = SCRIPTUICHANDLING.NOUIERROR;
pub const SCRIPTUICHANDLING_NOUIDEFAULT = SCRIPTUICHANDLING.NOUIDEFAULT;

const IID_IActiveScriptSite_Value = Guid.initString("db01a1e3-a42b-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSite = &IID_IActiveScriptSite_Value;
pub const IActiveScriptSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                plcid: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                pstrName: ?[*:0]align(1) const u16,
                dwReturnMask: u32,
                ppiunkItem: ?*?*IUnknown,
                ppti: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                pstrName: ?[*:0]align(1) const u16,
                dwReturnMask: u32,
                ppiunkItem: ?*?*IUnknown,
                ppti: ?*?*ITypeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                pbstrVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                pbstrVersion: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptTerminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                pvarResult: ?*const VARIANT,
                pexcepinfo: ?*const EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                pvarResult: ?*const VARIANT,
                pexcepinfo: ?*const EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                ssScriptState: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                ssScriptState: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
                pscripterror: ?*IActiveScriptError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
                pscripterror: ?*IActiveScriptError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEnterScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLeaveScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetLCID(self: *const T, plcid: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetLCID(@as(*const IActiveScriptSite, @ptrCast(self)), plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetItemInfo(self: *const T, pstrName: ?[*:0]align(1) const u16, dwReturnMask: u32, ppiunkItem: ?*?*IUnknown, ppti: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetItemInfo(@as(*const IActiveScriptSite, @ptrCast(self)), pstrName, dwReturnMask, ppiunkItem, ppti);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetDocVersionString(self: *const T, pbstrVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).GetDocVersionString(@as(*const IActiveScriptSite, @ptrCast(self)), pbstrVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptTerminate(self: *const T, pvarResult: ?*const VARIANT, pexcepinfo: ?*const EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnScriptTerminate(@as(*const IActiveScriptSite, @ptrCast(self)), pvarResult, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnStateChange(self: *const T, ssScriptState: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnStateChange(@as(*const IActiveScriptSite, @ptrCast(self)), ssScriptState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptError(self: *const T, pscripterror: ?*IActiveScriptError) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnScriptError(@as(*const IActiveScriptSite, @ptrCast(self)), pscripterror);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnEnterScript(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnEnterScript(@as(*const IActiveScriptSite, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnLeaveScript(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSite.VTable, @ptrCast(self.vtable)).OnLeaveScript(@as(*const IActiveScriptSite, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError_Value = Guid.initString("eae1ba61-a4ed-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptError = &IID_IActiveScriptError_Value;
pub const IActiveScriptError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptError,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptError,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptError,
                pdwSourceContext: ?*u32,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptError,
                pdwSourceContext: ?*u32,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceLineText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptError,
                pbstrSourceLine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptError,
                pbstrSourceLine: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetExceptionInfo(self: *const T, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetExceptionInfo(@as(*const IActiveScriptError, @ptrCast(self)), pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourcePosition(self: *const T, pdwSourceContext: ?*u32, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetSourcePosition(@as(*const IActiveScriptError, @ptrCast(self)), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourceLineText(self: *const T, pbstrSourceLine: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptError.VTable, @ptrCast(self.vtable)).GetSourceLineText(@as(*const IActiveScriptError, @ptrCast(self)), pbstrSourceLine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError64_Value = Guid.initString("b21fb2a1-5b8f-4963-8c21-21450f84ed7f");
pub const IID_IActiveScriptError64 = &IID_IActiveScriptError64_Value;
pub const IActiveScriptError64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetSourcePosition64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptError64,
                pdwSourceContext: ?*u64,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptError64,
                pdwSourceContext: ?*u64,
                pulLineNumber: ?*u32,
                plCharacterPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError64_GetSourcePosition64(self: *const T, pdwSourceContext: ?*u64, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptError64.VTable, @ptrCast(self.vtable)).GetSourcePosition64(@as(*const IActiveScriptError64, @ptrCast(self)), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteWindow_Value = Guid.initString("d10f6761-83e9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSiteWindow = &IID_IActiveScriptSiteWindow_Value;
pub const IActiveScriptSiteWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteWindow,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableModeless: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteWindow,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteWindow,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_GetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteWindow.VTable, @ptrCast(self.vtable)).GetWindow(@as(*const IActiveScriptSiteWindow, @ptrCast(self)), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteWindow.VTable, @ptrCast(self.vtable)).EnableModeless(@as(*const IActiveScriptSiteWindow, @ptrCast(self)), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteUIControl_Value = Guid.initString("aedae97e-d7ee-4796-b960-7f092ae844ab");
pub const IID_IActiveScriptSiteUIControl = &IID_IActiveScriptSiteUIControl_Value;
pub const IActiveScriptSiteUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIBehavior: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteUIControl,
                UicItem: SCRIPTUICITEM,
                pUicHandling: ?*SCRIPTUICHANDLING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteUIControl,
                UicItem: SCRIPTUICITEM,
                pUicHandling: ?*SCRIPTUICHANDLING,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteUIControl_GetUIBehavior(self: *const T, UicItem: SCRIPTUICITEM, pUicHandling: ?*SCRIPTUICHANDLING) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteUIControl.VTable, @ptrCast(self.vtable)).GetUIBehavior(@as(*const IActiveScriptSiteUIControl, @ptrCast(self)), UicItem, pUicHandling);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteInterruptPoll_Value = Guid.initString("539698a0-cdca-11cf-a5eb-00aa0047a063");
pub const IID_IActiveScriptSiteInterruptPoll = &IID_IActiveScriptSiteInterruptPoll_Value;
pub const IActiveScriptSiteInterruptPoll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteInterruptPoll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteInterruptPoll,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteInterruptPoll_QueryContinue(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteInterruptPoll.VTable, @ptrCast(self.vtable)).QueryContinue(@as(*const IActiveScriptSiteInterruptPoll, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScript_Value = Guid.initString("bb1a2ae1-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScript = &IID_IActiveScript_Value;
pub const IActiveScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScriptSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                pass: ?*IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                pass: ?*IActiveScriptSite,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptSite: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                riid: ?*const Guid,
                ppvObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScriptState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                ss: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                ss: SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                pssState: ?*SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                pssState: ?*SCRIPTSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                pstrName: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                pstrName: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                pstrItemName: ?[*:0]align(1) const u16,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                pstrItemName: ?[*:0]align(1) const u16,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScriptThreadID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptThreadID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                dwWin32ThreadId: u32,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                dwWin32ThreadId: u32,
                pstidThread: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                stidThread: u32,
                pstsState: ?*SCRIPTTHREADSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                stidThread: u32,
                pstsState: ?*SCRIPTTHREADSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InterruptScriptThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                stidThread: u32,
                pexcepinfo: ?*const EXCEPINFO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                stidThread: u32,
                pexcepinfo: ?*const EXCEPINFO,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScript,
                ppscript: ?*?*IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScript,
                ppscript: ?*?*IActiveScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptSite(self: *const T, pass: ?*IActiveScriptSite) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).SetScriptSite(@as(*const IActiveScript, @ptrCast(self)), pass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptSite(self: *const T, riid: ?*const Guid, ppvObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptSite(@as(*const IActiveScript, @ptrCast(self)), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptState(self: *const T, ss: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).SetScriptState(@as(*const IActiveScript, @ptrCast(self)), ss);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptState(self: *const T, pssState: ?*SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptState(@as(*const IActiveScript, @ptrCast(self)), pssState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).Close(@as(*const IActiveScript, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddNamedItem(self: *const T, pstrName: ?[*:0]align(1) const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).AddNamedItem(@as(*const IActiveScript, @ptrCast(self)), pstrName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).AddTypeLib(@as(*const IActiveScript, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptDispatch(self: *const T, pstrItemName: ?[*:0]align(1) const u16, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptDispatch(@as(*const IActiveScript, @ptrCast(self)), pstrItemName, ppdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetCurrentScriptThreadID(self: *const T, pstidThread: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetCurrentScriptThreadID(@as(*const IActiveScript, @ptrCast(self)), pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadID(self: *const T, dwWin32ThreadId: u32, pstidThread: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptThreadID(@as(*const IActiveScript, @ptrCast(self)), dwWin32ThreadId, pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadState(self: *const T, stidThread: u32, pstsState: ?*SCRIPTTHREADSTATE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).GetScriptThreadState(@as(*const IActiveScript, @ptrCast(self)), stidThread, pstsState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_InterruptScriptThread(self: *const T, stidThread: u32, pexcepinfo: ?*const EXCEPINFO, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).InterruptScriptThread(@as(*const IActiveScript, @ptrCast(self)), stidThread, pexcepinfo, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Clone(self: *const T, ppscript: ?*?*IActiveScript) callconv(.Inline) HRESULT {
            return @as(*const IActiveScript.VTable, @ptrCast(self.vtable)).Clone(@as(*const IActiveScript, @ptrCast(self)), ppscript);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse32_Value = Guid.initString("bb1a2ae2-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptParse32 = &IID_IActiveScriptParse32_Value;
pub const IActiveScriptParse32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse32,
                pstrDefaultName: ?[*:0]align(1) const u16,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                pstrSubItemName: ?[*:0]align(1) const u16,
                pstrEventName: ?[*:0]align(1) const u16,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse32,
                pstrDefaultName: ?[*:0]align(1) const u16,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                pstrSubItemName: ?[*:0]align(1) const u16,
                pstrEventName: ?[*:0]align(1) const u16,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IActiveScriptParse32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]align(1) const u16, pstrCode: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, pstrSubItemName: ?[*:0]align(1) const u16, pstrEventName: ?[*:0]align(1) const u16, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptParse32, @ptrCast(self)), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_ParseScriptText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse32.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptParse32, @ptrCast(self)), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse64_Value = Guid.initString("c7ef7658-e1ee-480e-97ea-d52cb4d76d17");
pub const IID_IActiveScriptParse64 = &IID_IActiveScriptParse64_Value;
pub const IActiveScriptParse64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse64,
                pstrDefaultName: ?[*:0]align(1) const u16,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                pstrSubItemName: ?[*:0]align(1) const u16,
                pstrEventName: ?[*:0]align(1) const u16,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse64,
                pstrDefaultName: ?[*:0]align(1) const u16,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                pstrSubItemName: ?[*:0]align(1) const u16,
                pstrEventName: ?[*:0]align(1) const u16,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pbstrName: ?*?BSTR,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParse64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParse64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                pvarResult: ?*VARIANT,
                pexcepinfo: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IActiveScriptParse64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]align(1) const u16, pstrCode: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, pstrSubItemName: ?[*:0]align(1) const u16, pstrEventName: ?[*:0]align(1) const u16, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptParse64, @ptrCast(self)), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_ParseScriptText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParse64.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptParse64, @ptrCast(self)), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld32_Value = Guid.initString("1cff0050-6fdd-11d0-9328-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedureOld32 = &IID_IActiveScriptParseProcedureOld32_Value;
pub const IActiveScriptParseProcedureOld32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParseProcedureOld32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParseProcedureOld32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrFormalParams: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParseProcedureOld32.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedureOld32, @ptrCast(self)), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld64_Value = Guid.initString("21f57128-08c9-4638-ba12-22d15d88dc5c");
pub const IID_IActiveScriptParseProcedureOld64 = &IID_IActiveScriptParseProcedureOld64_Value;
pub const IActiveScriptParseProcedureOld64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParseProcedureOld64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParseProcedureOld64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrFormalParams: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParseProcedureOld64.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedureOld64, @ptrCast(self)), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure32_Value = Guid.initString("aa5b6a80-b834-11d0-932f-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedure32 = &IID_IActiveScriptParseProcedure32_Value;
pub const IActiveScriptParseProcedure32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParseProcedure32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrProcedureName: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParseProcedure32,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrProcedureName: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u32,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrFormalParams: ?[*:0]align(1) const u16, pstrProcedureName: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParseProcedure32.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedure32, @ptrCast(self)), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure64_Value = Guid.initString("c64713b6-e029-4cc5-9200-438b72890b6a");
pub const IID_IActiveScriptParseProcedure64 = &IID_IActiveScriptParseProcedure64_Value;
pub const IActiveScriptParseProcedure64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptParseProcedure64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrProcedureName: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptParseProcedure64,
                pstrCode: ?[*:0]align(1) const u16,
                pstrFormalParams: ?[*:0]align(1) const u16,
                pstrProcedureName: ?[*:0]align(1) const u16,
                pstrItemName: ?[*:0]align(1) const u16,
                punkContext: ?*IUnknown,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwSourceContextCookie: u64,
                ulStartingLineNumber: u32,
                dwFlags: u32,
                ppdisp: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]align(1) const u16, pstrFormalParams: ?[*:0]align(1) const u16, pstrProcedureName: ?[*:0]align(1) const u16, pstrItemName: ?[*:0]align(1) const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]align(1) const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptParseProcedure64.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptParseProcedure64, @ptrCast(self)), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_32_Value = Guid.initString("71ee5b20-fb04-11d1-b3a8-00a0c911e8b2");
pub const IID_IActiveScriptParseProcedure2_32 = &IID_IActiveScriptParseProcedure2_32_Value;
pub const IActiveScriptParseProcedure2_32 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure32.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure32.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_64_Value = Guid.initString("fe7c4271-210c-448d-9f54-76dab7047b28");
pub const IID_IActiveScriptParseProcedure2_64 = &IID_IActiveScriptParseProcedure2_64_Value;
pub const IActiveScriptParseProcedure2_64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure64.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure64.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptEncode_Value = Guid.initString("bb1a2ae3-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptEncode = &IID_IActiveScriptEncode_Value;
pub const IActiveScriptEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]align(1) const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]align(1) const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DecodeScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]align(1) const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptEncode,
                pchIn: ?[*:0]align(1) const u16,
                cchIn: u32,
                pchOut: ?PWSTR,
                cchOut: u32,
                pcchRet: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEncodeProgId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptEncode,
                pbstrOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptEncode,
                pbstrOut: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_EncodeSection(self: *const T, pchIn: ?[*:0]align(1) const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).EncodeSection(@as(*const IActiveScriptEncode, @ptrCast(self)), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_DecodeScript(self: *const T, pchIn: ?[*:0]align(1) const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).DecodeScript(@as(*const IActiveScriptEncode, @ptrCast(self)), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_GetEncodeProgId(self: *const T, pbstrOut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptEncode.VTable, @ptrCast(self.vtable)).GetEncodeProgId(@as(*const IActiveScriptEncode, @ptrCast(self)), pbstrOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptHostEncode_Value = Guid.initString("bee9b76e-cfe3-11d1-b747-00c04fc2b085");
pub const IID_IActiveScriptHostEncode = &IID_IActiveScriptHostEncode_Value;
pub const IActiveScriptHostEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeScriptHostFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptHostEncode,
                bstrInFile: ?BSTR,
                pbstrOutFile: ?*?BSTR,
                cFlags: u32,
                bstrDefaultLang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptHostEncode,
                bstrInFile: ?BSTR,
                pbstrOutFile: ?*?BSTR,
                cFlags: u32,
                bstrDefaultLang: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptHostEncode_EncodeScriptHostFile(self: *const T, bstrInFile: ?BSTR, pbstrOutFile: ?*?BSTR, cFlags: u32, bstrDefaultLang: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptHostEncode.VTable, @ptrCast(self.vtable)).EncodeScriptHostFile(@as(*const IActiveScriptHostEncode, @ptrCast(self)), bstrInFile, pbstrOutFile, cFlags, bstrDefaultLang);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindEventHandler_Value = Guid.initString("63cdbcb0-c1b1-11d0-9336-00a0c90dcaa9");
pub const IID_IBindEventHandler = &IID_IBindEventHandler_Value;
pub const IBindEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBindEventHandler,
                pstrEvent: ?[*:0]align(1) const u16,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBindEventHandler,
                pstrEvent: ?[*:0]align(1) const u16,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindEventHandler_BindHandler(self: *const T, pstrEvent: ?[*:0]align(1) const u16, pdisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IBindEventHandler.VTable, @ptrCast(self.vtable)).BindHandler(@as(*const IBindEventHandler, @ptrCast(self)), pstrEvent, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStats_Value = Guid.initString("b8da6310-e19b-11d0-933c-00a0c90dcaa9");
pub const IID_IActiveScriptStats = &IID_IActiveScriptStats_Value;
pub const IActiveScriptStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptStats,
                stid: u32,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptStats,
                stid: u32,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptStats,
                guid: ?*const Guid,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptStats,
                guid: ?*const Guid,
                pluHi: ?*u32,
                pluLo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStat(self: *const T, stid: u32, pluHi: ?*u32, pluLo: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).GetStat(@as(*const IActiveScriptStats, @ptrCast(self)), stid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStatEx(self: *const T, guid: ?*const Guid, pluHi: ?*u32, pluLo: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).GetStatEx(@as(*const IActiveScriptStats, @ptrCast(self)), guid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_ResetStats(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptStats.VTable, @ptrCast(self.vtable)).ResetStats(@as(*const IActiveScriptStats, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProperty_Value = Guid.initString("4954e0d0-fbc7-11d1-8410-006008c3fbfc");
pub const IID_IActiveScriptProperty = &IID_IActiveScriptProperty_Value;
pub const IActiveScriptProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProperty,
                dwProperty: u32,
                pvarIndex: ?*VARIANT,
                pvarValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_GetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProperty.VTable, @ptrCast(self.vtable)).GetProperty(@as(*const IActiveScriptProperty, @ptrCast(self)), dwProperty, pvarIndex, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_SetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProperty.VTable, @ptrCast(self.vtable)).SetProperty(@as(*const IActiveScriptProperty, @ptrCast(self)), dwProperty, pvarIndex, pvarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentEventSink_Value = Guid.initString("1dc9ca50-06ef-11d2-8415-006008c3fbfc");
pub const IID_ITridentEventSink = &IID_ITridentEventSink_Value;
pub const ITridentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITridentEventSink,
                pstrEvent: ?[*:0]align(1) const u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITridentEventSink,
                pstrEvent: ?[*:0]align(1) const u16,
                pdp: ?*DISPPARAMS,
                pvarRes: ?*VARIANT,
                pei: ?*EXCEPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentEventSink_FireEvent(self: *const T, pstrEvent: ?[*:0]align(1) const u16, pdp: ?*DISPPARAMS, pvarRes: ?*VARIANT, pei: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @as(*const ITridentEventSink.VTable, @ptrCast(self.vtable)).FireEvent(@as(*const ITridentEventSink, @ptrCast(self)), pstrEvent, pdp, pvarRes, pei);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptGarbageCollector_Value = Guid.initString("6aa2c4a0-2b53-11d4-a2a0-00104bd35090");
pub const IID_IActiveScriptGarbageCollector = &IID_IActiveScriptGarbageCollector_Value;
pub const IActiveScriptGarbageCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CollectGarbage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptGarbageCollector,
                scriptgctype: SCRIPTGCTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptGarbageCollector,
                scriptgctype: SCRIPTGCTYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptGarbageCollector_CollectGarbage(self: *const T, scriptgctype: SCRIPTGCTYPE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptGarbageCollector.VTable, @ptrCast(self.vtable)).CollectGarbage(@as(*const IActiveScriptGarbageCollector, @ptrCast(self)), scriptgctype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSIPInfo_Value = Guid.initString("764651d0-38de-11d4-a2a3-00104bd35090");
pub const IID_IActiveScriptSIPInfo = &IID_IActiveScriptSIPInfo_Value;
pub const IActiveScriptSIPInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSIPOID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSIPInfo,
                poid_sip: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSIPInfo,
                poid_sip: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSIPInfo_GetSIPOID(self: *const T, poid_sip: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSIPInfo.VTable, @ptrCast(self.vtable)).GetSIPOID(@as(*const IActiveScriptSIPInfo, @ptrCast(self)), poid_sip);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteTraceInfo_Value = Guid.initString("4b7272ae-1955-4bfe-98b0-780621888569");
pub const IID_IActiveScriptSiteTraceInfo = &IID_IActiveScriptSiteTraceInfo_Value;
pub const IActiveScriptSiteTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendScriptTraceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteTraceInfo,
                stiEventType: SCRIPTTRACEINFO,
                guidContextID: Guid,
                dwScriptContextCookie: u32,
                lScriptStatementStart: i32,
                lScriptStatementEnd: i32,
                dwReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteTraceInfo,
                stiEventType: SCRIPTTRACEINFO,
                guidContextID: Guid,
                dwScriptContextCookie: u32,
                lScriptStatementStart: i32,
                lScriptStatementEnd: i32,
                dwReserved: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteTraceInfo_SendScriptTraceInfo(self: *const T, stiEventType: SCRIPTTRACEINFO, guidContextID: Guid, dwScriptContextCookie: u32, lScriptStatementStart: i32, lScriptStatementEnd: i32, dwReserved: u64) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteTraceInfo.VTable, @ptrCast(self.vtable)).SendScriptTraceInfo(@as(*const IActiveScriptSiteTraceInfo, @ptrCast(self)), stiEventType, guidContextID, dwScriptContextCookie, lScriptStatementStart, lScriptStatementEnd, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptTraceInfo_Value = Guid.initString("c35456e7-bebf-4a1b-86a9-24d56be8b369");
pub const IID_IActiveScriptTraceInfo = &IID_IActiveScriptTraceInfo_Value;
pub const IActiveScriptTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartScriptTracing: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptTraceInfo,
                pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo,
                guidContextID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptTraceInfo,
                pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo,
                guidContextID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopScriptTracing: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptTraceInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptTraceInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StartScriptTracing(self: *const T, pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo, guidContextID: Guid) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptTraceInfo.VTable, @ptrCast(self.vtable)).StartScriptTracing(@as(*const IActiveScriptTraceInfo, @ptrCast(self)), pSiteTraceInfo, guidContextID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StopScriptTracing(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptTraceInfo.VTable, @ptrCast(self.vtable)).StopScriptTracing(@as(*const IActiveScriptTraceInfo, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStringCompare_Value = Guid.initString("58562769-ed52-42f7-8403-4963514e1f11");
pub const IID_IActiveScriptStringCompare = &IID_IActiveScriptStringCompare_Value;
pub const IActiveScriptStringCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrComp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptStringCompare,
                bszStr1: ?BSTR,
                bszStr2: ?BSTR,
                iRet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptStringCompare,
                bszStr1: ?BSTR,
                bszStr2: ?BSTR,
                iRet: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStringCompare_StrComp(self: *const T, bszStr1: ?BSTR, bszStr2: ?BSTR, iRet: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptStringCompare.VTable, @ptrCast(self.vtable)).StrComp(@as(*const IActiveScriptStringCompare, @ptrCast(self)), bszStr1, bszStr2, iRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BREAKPOINT_STATE = enum(i32) {
    DELETED = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const BREAKPOINT_DELETED = BREAKPOINT_STATE.DELETED;
pub const BREAKPOINT_DISABLED = BREAKPOINT_STATE.DISABLED;
pub const BREAKPOINT_ENABLED = BREAKPOINT_STATE.ENABLED;

pub const BREAKREASON = enum(i32) {
    STEP = 0,
    BREAKPOINT = 1,
    DEBUGGER_BLOCK = 2,
    HOST_INITIATED = 3,
    LANGUAGE_INITIATED = 4,
    DEBUGGER_HALT = 5,
    ERROR = 6,
    JIT = 7,
    MUTATION_BREAKPOINT = 8,
};
pub const BREAKREASON_STEP = BREAKREASON.STEP;
pub const BREAKREASON_BREAKPOINT = BREAKREASON.BREAKPOINT;
pub const BREAKREASON_DEBUGGER_BLOCK = BREAKREASON.DEBUGGER_BLOCK;
pub const BREAKREASON_HOST_INITIATED = BREAKREASON.HOST_INITIATED;
pub const BREAKREASON_LANGUAGE_INITIATED = BREAKREASON.LANGUAGE_INITIATED;
pub const BREAKREASON_DEBUGGER_HALT = BREAKREASON.DEBUGGER_HALT;
pub const BREAKREASON_ERROR = BREAKREASON.ERROR;
pub const BREAKREASON_JIT = BREAKREASON.JIT;
pub const BREAKREASON_MUTATION_BREAKPOINT = BREAKREASON.MUTATION_BREAKPOINT;

pub const BREAKRESUMEACTION = enum(i32) {
    ABORT = 0,
    CONTINUE = 1,
    STEP_INTO = 2,
    STEP_OVER = 3,
    STEP_OUT = 4,
    IGNORE = 5,
    STEP_DOCUMENT = 6,
};
pub const BREAKRESUMEACTION_ABORT = BREAKRESUMEACTION.ABORT;
pub const BREAKRESUMEACTION_CONTINUE = BREAKRESUMEACTION.CONTINUE;
pub const BREAKRESUMEACTION_STEP_INTO = BREAKRESUMEACTION.STEP_INTO;
pub const BREAKRESUMEACTION_STEP_OVER = BREAKRESUMEACTION.STEP_OVER;
pub const BREAKRESUMEACTION_STEP_OUT = BREAKRESUMEACTION.STEP_OUT;
pub const BREAKRESUMEACTION_IGNORE = BREAKRESUMEACTION.IGNORE;
pub const BREAKRESUMEACTION_STEP_DOCUMENT = BREAKRESUMEACTION.STEP_DOCUMENT;

pub const ERRORRESUMEACTION = enum(i32) {
    ReexecuteErrorStatement = 0,
    AbortCallAndReturnErrorToCaller = 1,
    SkipErrorStatement = 2,
};
pub const ERRORRESUMEACTION_ReexecuteErrorStatement = ERRORRESUMEACTION.ReexecuteErrorStatement;
pub const ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller = ERRORRESUMEACTION.AbortCallAndReturnErrorToCaller;
pub const ERRORRESUMEACTION_SkipErrorStatement = ERRORRESUMEACTION.SkipErrorStatement;

pub const DOCUMENTNAMETYPE = enum(i32) {
    APPNODE = 0,
    TITLE = 1,
    FILE_TAIL = 2,
    URL = 3,
    UNIQUE_TITLE = 4,
    SOURCE_MAP_URL = 5,
};
pub const DOCUMENTNAMETYPE_APPNODE = DOCUMENTNAMETYPE.APPNODE;
pub const DOCUMENTNAMETYPE_TITLE = DOCUMENTNAMETYPE.TITLE;
pub const DOCUMENTNAMETYPE_FILE_TAIL = DOCUMENTNAMETYPE.FILE_TAIL;
pub const DOCUMENTNAMETYPE_URL = DOCUMENTNAMETYPE.URL;
pub const DOCUMENTNAMETYPE_UNIQUE_TITLE = DOCUMENTNAMETYPE.UNIQUE_TITLE;
pub const DOCUMENTNAMETYPE_SOURCE_MAP_URL = DOCUMENTNAMETYPE.SOURCE_MAP_URL;

const IID_IActiveScriptDebug32_Value = Guid.initString("51973c10-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptDebug32 = &IID_IActiveScriptDebug32_Value;
pub const IActiveScriptDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug32,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContextsOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptDebug32, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptDebug32, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug32.VTable, @ptrCast(self.vtable)).EnumCodeContextsOfPosition(@as(*const IActiveScriptDebug32, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptDebug64_Value = Guid.initString("bc437e23-f5b8-47f4-bb79-7d1ce5483b86");
pub const IID_IActiveScriptDebug64 = &IID_IActiveScriptDebug64_Value;
pub const IActiveScriptDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug64,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContextsOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptDebug64, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptDebug64, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptDebug64.VTable, @ptrCast(self.vtable)).EnumCodeContextsOfPosition(@as(*const IActiveScriptDebug64, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug32_Value = Guid.initString("51973c11-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptSiteDebug32 = &IID_IActiveScriptSiteDebug32_Value;
pub const IActiveScriptSiteDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug32,
                dwSourceContext: u32,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug32,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug32,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetDocumentContextFromPosition(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).GetRootApplicationNode(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug32.VTable, @ptrCast(self.vtable)).OnScriptErrorDebug(@as(*const IActiveScriptSiteDebug32, @ptrCast(self)), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug64_Value = Guid.initString("d6b96b0a-7463-402c-92ac-89984226942f");
pub const IID_IActiveScriptSiteDebug64 = &IID_IActiveScriptSiteDebug64_Value;
pub const IActiveScriptSiteDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug64,
                dwSourceContext: u64,
                uCharacterOffset: u32,
                uNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug64,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug64,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebug64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebug64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfEnterDebugger: ?*BOOL,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetDocumentContextFromPosition(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).GetRootApplicationNode(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebug64.VTable, @ptrCast(self.vtable)).OnScriptErrorDebug(@as(*const IActiveScriptSiteDebug64, @ptrCast(self)), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebugEx_Value = Guid.initString("bb722ccb-6ad2-41c6-b780-af9c03ee69f5");
pub const IID_IActiveScriptSiteDebugEx = &IID_IActiveScriptSiteDebugEx_Value;
pub const IActiveScriptSiteDebugEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCanNotJITScriptErrorDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptSiteDebugEx,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptSiteDebugEx,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pfCallOnScriptErrorWhenContinuing: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebugEx_OnCanNotJITScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptSiteDebugEx.VTable, @ptrCast(self.vtable)).OnCanNotJITScriptErrorDebug(@as(*const IActiveScriptSiteDebugEx, @ptrCast(self)), pErrorDebug, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptErrorDebug_Value = Guid.initString("51973c12-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptErrorDebug = &IID_IActiveScriptErrorDebug_Value;
pub const IActiveScriptErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptErrorDebug,
                ppssc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptErrorDebug,
                ppssc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptErrorDebug,
                ppdsf: ?*?*IDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptErrorDebug,
                ppdsf: ?*?*IDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetDocumentContext(self: *const T, ppssc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptErrorDebug.VTable, @ptrCast(self.vtable)).GetDocumentContext(@as(*const IActiveScriptErrorDebug, @ptrCast(self)), ppssc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetStackFrame(self: *const T, ppdsf: ?*?*IDebugStackFrame) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptErrorDebug.VTable, @ptrCast(self.vtable)).GetStackFrame(@as(*const IActiveScriptErrorDebug, @ptrCast(self)), ppdsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCodeContext_Value = Guid.initString("51973c13-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCodeContext = &IID_IDebugCodeContext_Value;
pub const IDebugCodeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugCodeContext,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugCodeContext,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugCodeContext,
                bps: BREAKPOINT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugCodeContext,
                bps: BREAKPOINT_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_GetDocumentContext(self: *const T, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugCodeContext.VTable, @ptrCast(self.vtable)).GetDocumentContext(@as(*const IDebugCodeContext, @ptrCast(self)), ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_SetBreakPoint(self: *const T, bps: BREAKPOINT_STATE) callconv(.Inline) HRESULT {
            return @as(*const IDebugCodeContext.VTable, @ptrCast(self.vtable)).SetBreakPoint(@as(*const IDebugCodeContext, @ptrCast(self)), bps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpression_Value = Guid.initString("51973c14-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpression = &IID_IDebugExpression_Value;
pub const IDebugExpression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpression,
                pdecb: ?*IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpression,
                pdecb: ?*IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultAsString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                pbstrResult: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResultAsDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                ppdp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpression,
                phrResult: ?*HRESULT,
                ppdp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Start(self: *const T, pdecb: ?*IDebugExpressionCallBack) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).Start(@as(*const IDebugExpression, @ptrCast(self)), pdecb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDebugExpression, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).QueryIsComplete(@as(*const IDebugExpression, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsString(self: *const T, phrResult: ?*HRESULT, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).GetResultAsString(@as(*const IDebugExpression, @ptrCast(self)), phrResult, pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsDebugProperty(self: *const T, phrResult: ?*HRESULT, ppdp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpression.VTable, @ptrCast(self.vtable)).GetResultAsDebugProperty(@as(*const IDebugExpression, @ptrCast(self)), phrResult, ppdp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionContext_Value = Guid.initString("51973c15-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionContext = &IID_IDebugExpressionContext_Value;
pub const IDebugExpressionContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseLanguageText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpressionContext,
                pstrCode: ?[*:0]align(1) const u16,
                nRadix: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppe: ?*?*IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpressionContext,
                pstrCode: ?[*:0]align(1) const u16,
                nRadix: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppe: ?*?*IDebugExpression,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpressionContext,
                pbstrLanguageName: ?*?BSTR,
                pLanguageID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpressionContext,
                pbstrLanguageName: ?*?BSTR,
                pLanguageID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_ParseLanguageText(self: *const T, pstrCode: ?[*:0]align(1) const u16, nRadix: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, ppe: ?*?*IDebugExpression) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpressionContext.VTable, @ptrCast(self.vtable)).ParseLanguageText(@as(*const IDebugExpressionContext, @ptrCast(self)), pstrCode, nRadix, pstrDelimiter, dwFlags, ppe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_GetLanguageInfo(self: *const T, pbstrLanguageName: ?*?BSTR, pLanguageID: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpressionContext.VTable, @ptrCast(self.vtable)).GetLanguageInfo(@as(*const IDebugExpressionContext, @ptrCast(self)), pbstrLanguageName, pLanguageID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionCallBack_Value = Guid.initString("51973c16-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionCallBack = &IID_IDebugExpressionCallBack_Value;
pub const IDebugExpressionCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExpressionCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugExpressionCallBack.VTable, @ptrCast(self.vtable)).onComplete(@as(*const IDebugExpressionCallBack, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrame_Value = Guid.initString("51973c17-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrame = &IID_IDebugStackFrame_Value;
pub const IDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodeContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame,
                ppcc: ?*?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame,
                ppcc: ?*?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame,
                fLong: BOOL,
                pbstrLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame,
                ppat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame,
                ppat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetCodeContext(self: *const T, ppcc: ?*?*IDebugCodeContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetCodeContext(@as(*const IDebugStackFrame, @ptrCast(self)), ppcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDescriptionString(self: *const T, fLong: BOOL, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetDescriptionString(@as(*const IDebugStackFrame, @ptrCast(self)), fLong, pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetLanguageString(self: *const T, fLong: BOOL, pbstrLanguage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetLanguageString(@as(*const IDebugStackFrame, @ptrCast(self)), fLong, pbstrLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetThread(self: *const T, ppat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetThread(@as(*const IDebugStackFrame, @ptrCast(self)), ppat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDebugProperty(self: *const T, ppDebugProp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame.VTable, @ptrCast(self.vtable)).GetDebugProperty(@as(*const IDebugStackFrame, @ptrCast(self)), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSniffer_Value = Guid.initString("51973c18-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSniffer = &IID_IDebugStackFrameSniffer_Value;
pub const IDebugStackFrameSniffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumStackFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrameSniffer,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrameSniffer,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSniffer_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrameSniffer.VTable, @ptrCast(self.vtable)).EnumStackFrames(@as(*const IDebugStackFrameSniffer, @ptrCast(self)), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx32_Value = Guid.initString("51973c19-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSnifferEx32 = &IID_IDebugStackFrameSnifferEx32_Value;
pub const IDebugStackFrameSnifferEx32 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrameSnifferEx32,
                dwSpMin: u32,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrameSnifferEx32,
                dwSpMin: u32,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx32_EnumStackFramesEx32(self: *const T, dwSpMin: u32, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrameSnifferEx32.VTable, @ptrCast(self.vtable)).EnumStackFramesEx32(@as(*const IDebugStackFrameSnifferEx32, @ptrCast(self)), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx64_Value = Guid.initString("8cd12af4-49c1-4d52-8d8a-c146f47581aa");
pub const IID_IDebugStackFrameSnifferEx64 = &IID_IDebugStackFrameSnifferEx64_Value;
pub const IDebugStackFrameSnifferEx64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrameSnifferEx64,
                dwSpMin: u64,
                ppedsf: ?*?*IEnumDebugStackFrames64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrameSnifferEx64,
                dwSpMin: u64,
                ppedsf: ?*?*IEnumDebugStackFrames64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx64_EnumStackFramesEx64(self: *const T, dwSpMin: u64, ppedsf: ?*?*IEnumDebugStackFrames64) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrameSnifferEx64.VTable, @ptrCast(self.vtable)).EnumStackFramesEx64(@as(*const IDebugStackFrameSnifferEx64, @ptrCast(self)), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSyncOperation_Value = Guid.initString("51973c1a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSyncOperation = &IID_IDebugSyncOperation_Value;
pub const IDebugSyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSyncOperation,
                ppatTarget: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSyncOperation,
                ppatTarget: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSyncOperation,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSyncOperation,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InProgressAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_GetTargetThread(self: *const T, ppatTarget: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).GetTargetThread(@as(*const IDebugSyncOperation, @ptrCast(self)), ppatTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_Execute(self: *const T, ppunkResult: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugSyncOperation, @ptrCast(self)), ppunkResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_InProgressAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSyncOperation.VTable, @ptrCast(self.vtable)).InProgressAbort(@as(*const IDebugSyncOperation, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperation_Value = Guid.initString("51973c1b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperation = &IID_IDebugAsyncOperation_Value;
pub const IDebugAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperation,
                ppsdo: ?*?*IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperation,
                ppsdo: ?*?*IDebugSyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperation,
                padocb: ?*IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperation,
                padocb: ?*IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperation,
                phrResult: ?*HRESULT,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperation,
                phrResult: ?*HRESULT,
                ppunkResult: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetSyncDebugOperation(self: *const T, ppsdo: ?*?*IDebugSyncOperation) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).GetSyncDebugOperation(@as(*const IDebugAsyncOperation, @ptrCast(self)), ppsdo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Start(self: *const T, padocb: ?*IDebugAsyncOperationCallBack) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).Start(@as(*const IDebugAsyncOperation, @ptrCast(self)), padocb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).Abort(@as(*const IDebugAsyncOperation, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).QueryIsComplete(@as(*const IDebugAsyncOperation, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetResult(self: *const T, phrResult: ?*HRESULT, ppunkResult: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperation.VTable, @ptrCast(self.vtable)).GetResult(@as(*const IDebugAsyncOperation, @ptrCast(self)), phrResult, ppunkResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperationCallBack_Value = Guid.initString("51973c1c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperationCallBack = &IID_IDebugAsyncOperationCallBack_Value;
pub const IDebugAsyncOperationCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAsyncOperationCallBack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperationCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugAsyncOperationCallBack.VTable, @ptrCast(self.vtable)).onComplete(@as(*const IDebugAsyncOperationCallBack, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugCodeContexts_Value = Guid.initString("51973c1d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugCodeContexts = &IID_IEnumDebugCodeContexts_Value;
pub const IEnumDebugCodeContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugCodeContexts,
                celt: u32,
                pscc: ?*?*IDebugCodeContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugCodeContexts,
                celt: u32,
                pscc: ?*?*IDebugCodeContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugCodeContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugCodeContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugCodeContexts,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugCodeContexts,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Next(self: *const T, celt: u32, pscc: ?*?*IDebugCodeContext, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), celt, pscc, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugCodeContexts, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Clone(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugCodeContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugCodeContexts, @ptrCast(self)), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DebugStackFrameDescriptor = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u32,
    dwLim: u32,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

pub const DebugStackFrameDescriptor64 = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u64,
    dwLim: u64,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

const IID_IEnumDebugStackFrames_Value = Guid.initString("51973c1e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugStackFrames = &IID_IEnumDebugStackFrames_Value;
pub const IEnumDebugStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugStackFrames,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugStackFrames,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugStackFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugStackFrames,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugStackFrames,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugStackFrames,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Next(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugStackFrames, @ptrCast(self)), celt, prgdsfd, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugStackFrames, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugStackFrames, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Clone(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugStackFrames.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugStackFrames, @ptrCast(self)), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugStackFrames64_Value = Guid.initString("0dc38853-c1b0-4176-a984-b298361027af");
pub const IID_IEnumDebugStackFrames64 = &IID_IEnumDebugStackFrames64_Value;
pub const IEnumDebugStackFrames64 = extern struct {
    pub const VTable = extern struct {
        base: IEnumDebugStackFrames.VTable,
        Next64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugStackFrames64,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor64,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugStackFrames64,
                celt: u32,
                prgdsfd: ?*DebugStackFrameDescriptor64,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnumDebugStackFrames.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames64_Next64(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor64, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugStackFrames64.VTable, @ptrCast(self.vtable)).Next64(@as(*const IEnumDebugStackFrames64, @ptrCast(self)), celt, prgdsfd, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentInfo_Value = Guid.initString("51973c1f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentInfo = &IID_IDebugDocumentInfo_Value;
pub const IDebugDocumentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentInfo,
                dnt: DOCUMENTNAMETYPE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentInfo,
                dnt: DOCUMENTNAMETYPE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentClassId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentInfo,
                pclsidDocument: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentInfo,
                pclsidDocument: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetName(self: *const T, dnt: DOCUMENTNAMETYPE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentInfo.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugDocumentInfo, @ptrCast(self)), dnt, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetDocumentClassId(self: *const T, pclsidDocument: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentInfo.VTable, @ptrCast(self.vtable)).GetDocumentClassId(@as(*const IDebugDocumentInfo, @ptrCast(self)), pclsidDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentProvider_Value = Guid.initString("51973c20-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentProvider = &IID_IDebugDocumentProvider_Value;
pub const IDebugDocumentProvider = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentProvider,
                ppssd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentProvider,
                ppssd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentProvider_GetDocument(self: *const T, ppssd: ?*?*IDebugDocument) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentProvider.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IDebugDocumentProvider, @ptrCast(self)), ppssd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocument_Value = Guid.initString("51973c21-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocument = &IID_IDebugDocument_Value;
pub const IDebugDocument = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentText_Value = Guid.initString("51973c22-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentText = &IID_IDebugDocumentText_Value;
pub const IDebugDocumentText = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocument.VTable,
        GetDocumentAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                ptextdocattr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                ptextdocattr: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                pcNumLines: ?*u32,
                pcNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                pcNumLines: ?*u32,
                pcNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionOfLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                cLineNumber: u32,
                pcCharacterPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                cLineNumber: u32,
                pcCharacterPosition: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcLineNumber: ?*u32,
                pcCharacterOffsetInLine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcLineNumber: ?*u32,
                pcCharacterOffsetInLine: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: ?[*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: ?[*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositionOfContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                psc: ?*IDebugDocumentContext,
                pcCharacterPosition: ?*u32,
                cNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                psc: ?*IDebugDocumentContext,
                pcCharacterPosition: ?*u32,
                cNumChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextOfPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                cNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentText,
                cCharacterPosition: u32,
                cNumChars: u32,
                ppsc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetDocumentAttributes(self: *const T, ptextdocattr: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetDocumentAttributes(@as(*const IDebugDocumentText, @ptrCast(self)), ptextdocattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetSize(self: *const T, pcNumLines: ?*u32, pcNumChars: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IDebugDocumentText, @ptrCast(self)), pcNumLines, pcNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfLine(self: *const T, cLineNumber: u32, pcCharacterPosition: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetPositionOfLine(@as(*const IDebugDocumentText, @ptrCast(self)), cLineNumber, pcCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetLineOfPosition(self: *const T, cCharacterPosition: u32, pcLineNumber: ?*u32, pcCharacterOffsetInLine: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetLineOfPosition(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetText(self: *const T, cCharacterPosition: u32, pcharText: [*:0]u16, pstaTextAttr: ?[*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetText(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfContext(self: *const T, psc: ?*IDebugDocumentContext, pcCharacterPosition: ?*u32, cNumChars: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetPositionOfContext(@as(*const IDebugDocumentText, @ptrCast(self)), psc, pcCharacterPosition, cNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetContextOfPosition(self: *const T, cCharacterPosition: u32, cNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentText.VTable, @ptrCast(self.vtable)).GetContextOfPosition(@as(*const IDebugDocumentText, @ptrCast(self)), cCharacterPosition, cNumChars, ppsc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextEvents_Value = Guid.initString("51973c23-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextEvents = &IID_IDebugDocumentTextEvents_Value;
pub const IDebugDocumentTextEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onDestroy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onInsertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToInsert: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToInsert: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onReplaceText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToReplace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToReplace: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onUpdateTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToUpdate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
                cCharacterPosition: u32,
                cNumToUpdate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onUpdateDocumentAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextEvents,
                textdocattr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextEvents,
                textdocattr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onDestroy(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onDestroy(@as(*const IDebugDocumentTextEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onInsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onInsertText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToInsert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onRemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onRemoveText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onReplaceText(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToReplace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateTextAttributes(self: *const T, cCharacterPosition: u32, cNumToUpdate: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onUpdateTextAttributes(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), cCharacterPosition, cNumToUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateDocumentAttributes(self: *const T, textdocattr: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextEvents.VTable, @ptrCast(self.vtable)).onUpdateDocumentAttributes(@as(*const IDebugDocumentTextEvents, @ptrCast(self)), textdocattr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextAuthor_Value = Guid.initString("51973c24-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextAuthor = &IID_IDebugDocumentTextAuthor_Value;
pub const IDebugDocumentTextAuthor = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentText.VTable,
        InsertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToInsert: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToInsert: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToRemove: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplaceText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToReplace: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextAuthor,
                cCharacterPosition: u32,
                cNumToReplace: u32,
                pcharText: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentText.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_InsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).InsertText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToInsert, pcharText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_RemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).RemoveText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_ReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextAuthor.VTable, @ptrCast(self.vtable)).ReplaceText(@as(*const IDebugDocumentTextAuthor, @ptrCast(self)), cCharacterPosition, cNumToReplace, pcharText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextExternalAuthor_Value = Guid.initString("51973c25-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextExternalAuthor = &IID_IDebugDocumentTextExternalAuthor_Value;
pub const IDebugDocumentTextExternalAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextExternalAuthor,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentTextExternalAuthor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentTextExternalAuthor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).GetPathName(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentTextExternalAuthor.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const IDebugDocumentTextExternalAuthor, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper32_Value = Guid.initString("51973c26-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHelper32 = &IID_IDebugDocumentHelper32_Value;
pub const IDebugDocumentHelper32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pda: ?*IDebugApplication32,
                pszShortName: ?[*:0]align(1) const u16,
                pszLongName: ?[*:0]align(1) const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pda: ?*IDebugApplication32,
                pszShortName: ?[*:0]align(1) const u16,
                pszLongName: ?[*:0]align(1) const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pddhParent: ?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pddhParent: ?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUnicodeText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDBCSText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pszText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDebugDocumentHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineScriptBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTextAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pszLongName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pszLongName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShortName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pszShortName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pszShortName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptBlockInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                dwSourceContext: u32,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                dwSourceContext: u32,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper32,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper32,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Init(self: *const T, pda: ?*IDebugApplication32, pszShortName: ?[*:0]align(1) const u16, pszLongName: ?[*:0]align(1) const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Init(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugDocumentHelper32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddUnicodeText(self: *const T, pszText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddUnicodeText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDBCSText(self: *const T, pszText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddDBCSText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDebugDocumentHost(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).AddDeferredText(@as(*const IDebugDocumentHelper32, @ptrCast(self)), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).DefineScriptBlock(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDefaultTextAttr(@as(*const IDebugDocumentHelper32, @ptrCast(self)), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetTextAttributes(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetLongName(self: *const T, pszLongName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetLongName(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetShortName(self: *const T, pszShortName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetShortName(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).SetDocumentAttr(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).GetDebugApplicationNode(@as(*const IDebugDocumentHelper32, @ptrCast(self)), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetScriptBlockInfo(self: *const T, dwSourceContext: u32, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).GetScriptBlockInfo(@as(*const IDebugDocumentHelper32, @ptrCast(self)), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).CreateDebugDocumentContext(@as(*const IDebugDocumentHelper32, @ptrCast(self)), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IDebugDocumentHelper32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper32.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IDebugDocumentHelper32, @ptrCast(self)), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper64_Value = Guid.initString("c4c7363c-20fd-47f9-bd82-4855e0150871");
pub const IID_IDebugDocumentHelper64 = &IID_IDebugDocumentHelper64_Value;
pub const IDebugDocumentHelper64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pda: ?*IDebugApplication64,
                pszShortName: ?[*:0]align(1) const u16,
                pszLongName: ?[*:0]align(1) const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pda: ?*IDebugApplication64,
                pszShortName: ?[*:0]align(1) const u16,
                pszLongName: ?[*:0]align(1) const u16,
                docAttr: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pddhParent: ?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pddhParent: ?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddUnicodeText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDBCSText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pszText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDebugDocumentHost: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pddh: ?*IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                cChars: u32,
                dwTextStartCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DefineScriptBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pas: ?*IActiveScript,
                fScriptlet: BOOL,
                pdwSourceContext: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultTextAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                staTextAttr: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                ulCharOffset: u32,
                cChars: u32,
                pstaTextAttr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLongName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pszLongName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pszLongName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetShortName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pszShortName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pszShortName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentAttr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pszAttributes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                ppdan: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptBlockInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                dwSourceContext: u64,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                dwSourceContext: u64,
                ppasd: ?*?*IActiveScript,
                piCharPos: ?*u32,
                pcChars: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                iCharPos: u32,
                cChars: u32,
                ppddc: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHelper64,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHelper64,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Init(self: *const T, pda: ?*IDebugApplication64, pszShortName: ?[*:0]align(1) const u16, pszLongName: ?[*:0]align(1) const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Init(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugDocumentHelper64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddUnicodeText(self: *const T, pszText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddUnicodeText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDBCSText(self: *const T, pszText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddDBCSText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDebugDocumentHost(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).AddDeferredText(@as(*const IDebugDocumentHelper64, @ptrCast(self)), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).DefineScriptBlock(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDefaultTextAttr(@as(*const IDebugDocumentHelper64, @ptrCast(self)), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetTextAttributes(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetLongName(self: *const T, pszLongName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetLongName(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetShortName(self: *const T, pszShortName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetShortName(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).SetDocumentAttr(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).GetDebugApplicationNode(@as(*const IDebugDocumentHelper64, @ptrCast(self)), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetScriptBlockInfo(self: *const T, dwSourceContext: u64, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).GetScriptBlockInfo(@as(*const IDebugDocumentHelper64, @ptrCast(self)), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).CreateDebugDocumentContext(@as(*const IDebugDocumentHelper64, @ptrCast(self)), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IDebugDocumentHelper64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHelper64.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IDebugDocumentHelper64, @ptrCast(self)), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHost_Value = Guid.initString("51973c27-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHost = &IID_IDebugDocumentHost_Value;
pub const IDebugDocumentHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeferredText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
                dwTextStartCookie: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: [*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
                dwTextStartCookie: u32,
                pcharText: [*:0]u16,
                pstaTextAttr: [*:0]u16,
                pcNumChars: ?*u32,
                cMaxChars: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
                pstrCode: [*:0]const u16,
                uNumCodeChars: u32,
                pstrDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreateDocumentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
                ppunkOuter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
                ppunkOuter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPathName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
                pbstrLongName: ?*?BSTR,
                pfIsOriginalFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
                pbstrShortName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetDeferredText(self: *const T, dwTextStartCookie: u32, pcharText: [*:0]u16, pstaTextAttr: [*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetDeferredText(@as(*const IDebugDocumentHost, @ptrCast(self)), dwTextStartCookie, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IDebugDocumentHost, @ptrCast(self)), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_OnCreateDocumentContext(self: *const T, ppunkOuter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).OnCreateDocumentContext(@as(*const IDebugDocumentHost, @ptrCast(self)), ppunkOuter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetPathName(@as(*const IDebugDocumentHost, @ptrCast(self)), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IDebugDocumentHost, @ptrCast(self)), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentHost.VTable, @ptrCast(self.vtable)).NotifyChanged(@as(*const IDebugDocumentHost, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentContext_Value = Guid.initString("51973c28-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentContext = &IID_IDebugDocumentContext_Value;
pub const IDebugDocumentContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentContext,
                ppsd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentContext,
                ppsd: ?*?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCodeContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDocumentContext,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDocumentContext,
                ppescc: ?*?*IEnumDebugCodeContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_GetDocument(self: *const T, ppsd: ?*?*IDebugDocument) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentContext.VTable, @ptrCast(self.vtable)).GetDocument(@as(*const IDebugDocumentContext, @ptrCast(self)), ppsd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_EnumCodeContexts(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @as(*const IDebugDocumentContext.VTable, @ptrCast(self.vtable)).EnumCodeContexts(@as(*const IDebugDocumentContext, @ptrCast(self)), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSessionProvider_Value = Guid.initString("51973c29-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSessionProvider = &IID_IDebugSessionProvider_Value;
pub const IDebugSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSessionProvider,
                pda: ?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSessionProvider,
                pda: ?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSessionProvider_StartDebugSession(self: *const T, pda: ?*IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @as(*const IDebugSessionProvider.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugSessionProvider, @ptrCast(self)), pda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebugger_Value = Guid.initString("51973c2a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebugger = &IID_IApplicationDebugger_Value;
pub const IApplicationDebugger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAlive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceAtDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onHandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
                prpt: ?*IRemoteDebugApplicationThread,
                br: BREAKREASON,
                pError: ?*IActiveScriptErrorDebug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
                prpt: ?*IRemoteDebugApplicationThread,
                br: BREAKREASON,
                pError: ?*IActiveScriptErrorDebug,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebugger,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebugger,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).QueryAlive(@as(*const IApplicationDebugger, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_CreateInstanceAtDebugger(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).CreateInstanceAtDebugger(@as(*const IApplicationDebugger, @ptrCast(self)), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebugOutput(self: *const T, pstr: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onDebugOutput(@as(*const IApplicationDebugger, @ptrCast(self)), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onHandleBreakPoint(self: *const T, prpt: ?*IRemoteDebugApplicationThread, br: BREAKREASON, pError: ?*IActiveScriptErrorDebug) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onHandleBreakPoint(@as(*const IApplicationDebugger, @ptrCast(self)), prpt, br, pError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onClose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onClose(@as(*const IApplicationDebugger, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebugger.VTable, @ptrCast(self.vtable)).onDebuggerEvent(@as(*const IApplicationDebugger, @ptrCast(self)), riid, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebuggerUI_Value = Guid.initString("51973c2b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebuggerUI = &IID_IApplicationDebuggerUI_Value;
pub const IApplicationDebuggerUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BringDocumentToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebuggerUI,
                pddt: ?*IDebugDocumentText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebuggerUI,
                pddt: ?*IDebugDocumentText,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BringDocumentContextToTop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApplicationDebuggerUI,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApplicationDebuggerUI,
                pddc: ?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentToTop(self: *const T, pddt: ?*IDebugDocumentText) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebuggerUI.VTable, @ptrCast(self.vtable)).BringDocumentToTop(@as(*const IApplicationDebuggerUI, @ptrCast(self)), pddt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IApplicationDebuggerUI.VTable, @ptrCast(self.vtable)).BringDocumentContextToTop(@as(*const IApplicationDebuggerUI, @ptrCast(self)), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManager_Value = Guid.initString("51973c2c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManager = &IID_IMachineDebugManager_Value;
pub const IMachineDebugManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManager,
                pda: ?*IRemoteDebugApplication,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManager,
                pda: ?*IRemoteDebugApplication,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManager,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManager,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumApplications: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManager,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManager,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IMachineDebugManager, @ptrCast(self)), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IMachineDebugManager, @ptrCast(self)), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManager.VTable, @ptrCast(self.vtable)).EnumApplications(@as(*const IMachineDebugManager, @ptrCast(self)), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerCookie_Value = Guid.initString("51973c2d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerCookie = &IID_IMachineDebugManagerCookie_Value;
pub const IMachineDebugManagerCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManagerCookie,
                pda: ?*IRemoteDebugApplication,
                dwDebugAppCookie: u32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManagerCookie,
                pda: ?*IRemoteDebugApplication,
                dwDebugAppCookie: u32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManagerCookie,
                dwDebugAppCookie: u32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManagerCookie,
                dwDebugAppCookie: u32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumApplications: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManagerCookie,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManagerCookie,
                ppeda: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwDebugAppCookie: u32, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), pda, dwDebugAppCookie, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_RemoveApplication(self: *const T, dwDebugAppCookie: u32, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), dwDebugAppCookie, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManagerCookie.VTable, @ptrCast(self.vtable)).EnumApplications(@as(*const IMachineDebugManagerCookie, @ptrCast(self)), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerEvents_Value = Guid.initString("51973c2e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerEvents = &IID_IMachineDebugManagerEvents_Value;
pub const IMachineDebugManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMachineDebugManagerEvents,
                pda: ?*IRemoteDebugApplication,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onAddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManagerEvents.VTable, @ptrCast(self.vtable)).onAddApplication(@as(*const IMachineDebugManagerEvents, @ptrCast(self)), pda, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onRemoveApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IMachineDebugManagerEvents.VTable, @ptrCast(self.vtable)).onRemoveApplication(@as(*const IMachineDebugManagerEvents, @ptrCast(self)), pda, dwAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager32_Value = Guid.initString("51973c2f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProcessDebugManager32 = &IID_IProcessDebugManager32_Value;
pub const IProcessDebugManager32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager32,
                ppda: ?*?*IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager32,
                pda: ?*IDebugApplication32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager32,
                pda: ?*IDebugApplication32,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager32,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager32,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager32,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).CreateApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).GetDefaultApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_AddApplication(self: *const T, pda: ?*IDebugApplication32, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IProcessDebugManager32, @ptrCast(self)), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager32.VTable, @ptrCast(self.vtable)).CreateDebugDocumentHelper(@as(*const IProcessDebugManager32, @ptrCast(self)), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager64_Value = Guid.initString("56b9fc1c-63a9-4cc1-ac21-087d69a17fab");
pub const IID_IProcessDebugManager64 = &IID_IProcessDebugManager64_Value;
pub const IProcessDebugManager64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager64,
                ppda: ?*?*IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager64,
                pda: ?*IDebugApplication64,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager64,
                pda: ?*IDebugApplication64,
                pdwAppCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager64,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager64,
                dwAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDebugDocumentHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProcessDebugManager64,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProcessDebugManager64,
                punkOuter: ?*IUnknown,
                pddh: ?*?*IDebugDocumentHelper64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).CreateApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).GetDefaultApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_AddApplication(self: *const T, pda: ?*IDebugApplication64, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).AddApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).RemoveApplication(@as(*const IProcessDebugManager64, @ptrCast(self)), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @as(*const IProcessDebugManager64.VTable, @ptrCast(self.vtable)).CreateDebugDocumentHelper(@as(*const IProcessDebugManager64, @ptrCast(self)), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplication_Value = Guid.initString("51973c30-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplication = &IID_IRemoteDebugApplication_Value;
pub const IRemoteDebugApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResumeFromBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                prptFocus: ?*IRemoteDebugApplicationThread,
                bra: BREAKRESUMEACTION,
                era: ERRORRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                prptFocus: ?*IRemoteDebugApplicationThread,
                bra: BREAKRESUMEACTION,
                era: ERRORRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CauseBreak: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                pad: ?*?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                pad: ?*?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateInstanceAtApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                rclsid: ?*const Guid,
                pUnkOuter: ?*IUnknown,
                dwClsContext: u32,
                riid: ?*const Guid,
                ppvObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAlive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                ppdanRoot: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumGlobalExpressionContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ResumeFromBreakPoint(self: *const T, prptFocus: ?*IRemoteDebugApplicationThread, bra: BREAKRESUMEACTION, era: ERRORRESUMEACTION) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).ResumeFromBreakPoint(@as(*const IRemoteDebugApplication, @ptrCast(self)), prptFocus, bra, era);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CauseBreak(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).CauseBreak(@as(*const IRemoteDebugApplication, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).ConnectDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_DisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).DisconnectDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetDebugger(self: *const T, pad: ?*?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetDebugger(@as(*const IRemoteDebugApplication, @ptrCast(self)), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CreateInstanceAtApplication(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).CreateInstanceAtApplication(@as(*const IRemoteDebugApplication, @ptrCast(self)), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).QueryAlive(@as(*const IRemoteDebugApplication, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumThreads(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).EnumThreads(@as(*const IRemoteDebugApplication, @ptrCast(self)), pperdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetName(@as(*const IRemoteDebugApplication, @ptrCast(self)), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetRootNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).GetRootNode(@as(*const IRemoteDebugApplication, @ptrCast(self)), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumGlobalExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication.VTable, @ptrCast(self.vtable)).EnumGlobalExpressionContexts(@as(*const IRemoteDebugApplication, @ptrCast(self)), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication32_Value = Guid.initString("51973c32-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplication32 = &IID_IDebugApplication32_Value;
pub const IDebugApplication32 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StepOutComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                br: BREAKREASON,
                pbra: ?*BREAKRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                br: BREAKREASON,
                pbra: ?*BREAKRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAsyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCurrentThreadIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SynchronousCallInDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pptc: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pptc: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleRuntimeError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUMEACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUMEACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FCanJitDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        FIsAutoJitDebugEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDebugApplication32,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        AddGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SetName(self: *const T, pstrName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).SetName(@as(*const IDebugApplication32, @ptrCast(self)), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).StepOutComplete(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_DebugOutput(self: *const T, pstr: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).DebugOutput(@as(*const IDebugApplication32, @ptrCast(self)), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUMEACTION) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).HandleBreakPoint(@as(*const IDebugApplication32, @ptrCast(self)), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).GetBreakFlags(@as(*const IDebugApplication32, @ptrCast(self)), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).GetCurrentThread(@as(*const IDebugApplication32, @ptrCast(self)), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).CreateAsyncDebugOperation(@as(*const IDebugApplication32, @ptrCast(self)), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).AddStackFrameSniffer(@as(*const IDebugApplication32, @ptrCast(self)), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).RemoveStackFrameSniffer(@as(*const IDebugApplication32, @ptrCast(self)), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).QueryCurrentThreadIsDebuggerThread(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).SynchronousCallInDebuggerThread(@as(*const IDebugApplication32, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).CreateApplicationNode(@as(*const IDebugApplication32, @ptrCast(self)), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FireDebuggerEvent(@as(*const IDebugApplication32, @ptrCast(self)), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUMEACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).HandleRuntimeError(@as(*const IDebugApplication32, @ptrCast(self)), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FCanJitDebug(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).FIsAutoJitDebugEnabled(@as(*const IDebugApplication32, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).AddGlobalExpressionContextProvider(@as(*const IDebugApplication32, @ptrCast(self)), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication32.VTable, @ptrCast(self.vtable)).RemoveGlobalExpressionContextProvider(@as(*const IDebugApplication32, @ptrCast(self)), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication64_Value = Guid.initString("4dedc754-04c7-4f10-9e60-16a390fe6e62");
pub const IID_IDebugApplication64 = &IID_IDebugApplication64_Value;
pub const IDebugApplication64 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StepOutComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                br: BREAKREASON,
                pbra: ?*BREAKRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                br: BREAKREASON,
                pbra: ?*BREAKRESUMEACTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pabf: ?*u32,
                pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pat: ?*?*IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAsyncDebugOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                psdo: ?*IDebugSyncOperation,
                ppado: ?*?*IDebugAsyncOperation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pdsfs: ?*IDebugStackFrameSniffer,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveStackFrameSniffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryCurrentThreadIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SynchronousCallInDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pptc: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pptc: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateApplicationNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                ppdanNew: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FireDebuggerEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                riid: ?*const Guid,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleRuntimeError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUMEACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pErrorDebug: ?*IActiveScriptErrorDebug,
                pScriptSite: ?*IActiveScriptSite,
                pbra: ?*BREAKRESUMEACTION,
                perra: ?*ERRORRESUMEACTION,
                pfCallOnScriptError: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FCanJitDebug: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        FIsAutoJitDebugEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDebugApplication64,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
        AddGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                pdsfs: ?*IProvideExpressionContexts,
                pdwCookie: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGlobalExpressionContextProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication64,
                dwCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication64,
                dwCookie: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SetName(self: *const T, pstrName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).SetName(@as(*const IDebugApplication64, @ptrCast(self)), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).StepOutComplete(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_DebugOutput(self: *const T, pstr: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).DebugOutput(@as(*const IDebugApplication64, @ptrCast(self)), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).StartDebugSession(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUMEACTION) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).HandleBreakPoint(@as(*const IDebugApplication64, @ptrCast(self)), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).GetBreakFlags(@as(*const IDebugApplication64, @ptrCast(self)), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).GetCurrentThread(@as(*const IDebugApplication64, @ptrCast(self)), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).CreateAsyncDebugOperation(@as(*const IDebugApplication64, @ptrCast(self)), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).AddStackFrameSniffer(@as(*const IDebugApplication64, @ptrCast(self)), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).RemoveStackFrameSniffer(@as(*const IDebugApplication64, @ptrCast(self)), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).QueryCurrentThreadIsDebuggerThread(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).SynchronousCallInDebuggerThread(@as(*const IDebugApplication64, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).CreateApplicationNode(@as(*const IDebugApplication64, @ptrCast(self)), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FireDebuggerEvent(@as(*const IDebugApplication64, @ptrCast(self)), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUMEACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).HandleRuntimeError(@as(*const IDebugApplication64, @ptrCast(self)), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FCanJitDebug(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).FIsAutoJitDebugEnabled(@as(*const IDebugApplication64, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).AddGlobalExpressionContextProvider(@as(*const IDebugApplication64, @ptrCast(self)), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication64.VTable, @ptrCast(self.vtable)).RemoveGlobalExpressionContextProvider(@as(*const IDebugApplication64, @ptrCast(self)), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationEvents_Value = Guid.initString("51973c33-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationEvents = &IID_IRemoteDebugApplicationEvents_Value;
pub const IRemoteDebugApplicationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                pad: ?*IApplicationDebugger,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDisconnectDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnSetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                pstrName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDebugOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                pstr: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEnterBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnLeaveBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnCreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDestroyThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                prdat: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBreakFlagChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationEvents,
                abf: u32,
                prdatSteppingThread: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationEvents,
                abf: u32,
                prdatSteppingThread: ?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnConnectDebugger(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDisconnectDebugger(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnSetName(self: *const T, pstrName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnSetName(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDebugOutput(self: *const T, pstr: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDebugOutput(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnClose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnClose(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnEnterBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnEnterBreakPoint(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnLeaveBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnLeaveBreakPoint(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnCreateThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnCreateThread(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDestroyThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnDestroyThread(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnBreakFlagChange(self: *const T, abf: u32, prdatSteppingThread: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationEvents.VTable, @ptrCast(self.vtable)).OnBreakFlagChange(@as(*const IRemoteDebugApplicationEvents, @ptrCast(self)), abf, prdatSteppingThread);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNode_Value = Guid.initString("51973c34-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNode = &IID_IDebugApplicationNode_Value;
pub const IDebugApplicationNode = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentProvider.VTable,
        EnumChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
                pprddp: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
                pprddp: ?*?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDocumentProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
                pddp: ?*IDebugDocumentProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
                pddp: ?*IDebugDocumentProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Attach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
                pdanParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
                pdanParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Detach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_EnumChildren(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).EnumChildren(@as(*const IDebugApplicationNode, @ptrCast(self)), pperddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_GetParent(self: *const T, pprddp: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IDebugApplicationNode, @ptrCast(self)), pprddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_SetDocumentProvider(self: *const T, pddp: ?*IDebugDocumentProvider) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).SetDocumentProvider(@as(*const IDebugApplicationNode, @ptrCast(self)), pddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Close(@as(*const IDebugApplicationNode, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Attach(self: *const T, pdanParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Attach(@as(*const IDebugApplicationNode, @ptrCast(self)), pdanParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode.VTable, @ptrCast(self.vtable)).Detach(@as(*const IDebugApplicationNode, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNodeEvents_Value = Guid.initString("51973c35-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNodeEvents = &IID_IDebugApplicationNodeEvents_Value;
pub const IDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onAddChild(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onRemoveChild(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onDetach(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).onAttach(@as(*const IDebugApplicationNodeEvents, @ptrCast(self)), prddpParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIDebugApplicationNodeEvents_Value = Guid.initString("a2e3aa3b-aa8d-4ebf-84cd-648b737b8c13");
pub const IID_AsyncIDebugApplicationNodeEvents = &IID_AsyncIDebugApplicationNodeEvents_Value;
pub const AsyncIDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onAddChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpChild: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onRemoveChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Begin_onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
                prddpParent: ?*IDebugApplicationNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Finish_onAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const AsyncIDebugApplicationNodeEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onAddChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAddChild(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onAddChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onRemoveChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onRemoveChild(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onRemoveChild(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onDetach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onDetach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Begin_onAttach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)), prddpParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAttach(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const AsyncIDebugApplicationNodeEvents.VTable, @ptrCast(self.vtable)).Finish_onAttach(@as(*const AsyncIDebugApplicationNodeEvents, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall32_Value = Guid.initString("51973c36-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugThreadCall32 = &IID_IDebugThreadCall32_Value;
pub const IDebugThreadCall32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall32_ThreadCallHandler(self: *const T, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugThreadCall32.VTable, @ptrCast(self.vtable)).ThreadCallHandler(@as(*const IDebugThreadCall32, @ptrCast(self)), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall64_Value = Guid.initString("cb3fa335-e979-42fd-9fcf-a7546a0f3905");
pub const IID_IDebugThreadCall64 = &IID_IDebugThreadCall64_Value;
pub const IDebugThreadCall64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall64_ThreadCallHandler(self: *const T, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugThreadCall64.VTable, @ptrCast(self.vtable)).ThreadCallHandler(@as(*const IDebugThreadCall64, @ptrCast(self)), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationThread_Value = Guid.initString("51973c37-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationThread = &IID_IRemoteDebugApplicationThread_Value;
pub const IRemoteDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSystemThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                dwThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                dwThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pprda: ?*?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pprda: ?*?*IRemoteDebugApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStackFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                ppedsf: ?*?*IEnumDebugStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pbstrDescription: ?*?BSTR,
                pbstrState: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pbstrDescription: ?*?BSTR,
                pbstrState: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextStatement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pStackFrame: ?*IDebugStackFrame,
                pCodeContext: ?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pStackFrame: ?*IDebugStackFrame,
                pCodeContext: ?*IDebugCodeContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Suspend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSuspendCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplicationThread,
                pdwCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSystemThreadId(self: *const T, dwThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetSystemThreadId(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetApplication(self: *const T, pprda: ?*?*IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetApplication(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pprda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).EnumStackFrames(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), ppedsf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetDescription(self: *const T, pbstrDescription: ?*?BSTR, pbstrState: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pbstrDescription, pbstrState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_SetNextStatement(self: *const T, pStackFrame: ?*IDebugStackFrame, pCodeContext: ?*IDebugCodeContext) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetNextStatement(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pStackFrame, pCodeContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetState(self: *const T, pState: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetState(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Suspend(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).Suspend(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Resume(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).Resume(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSuspendCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplicationThread.VTable, @ptrCast(self.vtable)).GetSuspendCount(@as(*const IRemoteDebugApplicationThread, @ptrCast(self)), pdwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread_Value = Guid.initString("51973c38-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationThread = &IID_IDebugApplicationThread_Value;
pub const IDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplicationThread.VTable,
        SynchronousCallIntoThread32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread,
                pstcb: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread,
                pstcb: ?*IDebugThreadCall32,
                dwParam1: u32,
                dwParam2: u32,
                dwParam3: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsDebuggerThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread,
                pstrDescription: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread,
                pstrDescription: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStateString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread,
                pstrState: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread,
                pstrState: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SynchronousCallIntoThread32(self: *const T, pstcb: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SynchronousCallIntoThread32(@as(*const IDebugApplicationThread, @ptrCast(self)), pstcb, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsCurrentThread(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).QueryIsCurrentThread(@as(*const IDebugApplicationThread, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).QueryIsDebuggerThread(@as(*const IDebugApplicationThread, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetDescription(self: *const T, pstrDescription: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetDescription(@as(*const IDebugApplicationThread, @ptrCast(self)), pstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetStateString(self: *const T, pstrState: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread.VTable, @ptrCast(self.vtable)).SetStateString(@as(*const IDebugApplicationThread, @ptrCast(self)), pstrState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread64_Value = Guid.initString("9dac5886-dbad-456d-9dee-5dec39ab3dda");
pub const IID_IDebugApplicationThread64 = &IID_IDebugApplicationThread64_Value;
pub const IDebugApplicationThread64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugApplicationThread.VTable,
        SynchronousCallIntoThread64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread64,
                pstcb: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread64,
                pstcb: ?*IDebugThreadCall64,
                dwParam1: u64,
                dwParam2: u64,
                dwParam3: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread64_SynchronousCallIntoThread64(self: *const T, pstcb: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread64.VTable, @ptrCast(self.vtable)).SynchronousCallIntoThread64(@as(*const IDebugApplicationThread64, @ptrCast(self)), pstcb, dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCookie_Value = Guid.initString("51973c39-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCookie = &IID_IDebugCookie_Value;
pub const IDebugCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebugCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugCookie,
                dwDebugAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugCookie,
                dwDebugAppCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCookie_SetDebugCookie(self: *const T, dwDebugAppCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugCookie.VTable, @ptrCast(self.vtable)).SetDebugCookie(@as(*const IDebugCookie, @ptrCast(self)), dwDebugAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugApplicationNodes_Value = Guid.initString("51973c3a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugApplicationNodes = &IID_IEnumDebugApplicationNodes_Value;
pub const IEnumDebugApplicationNodes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
                pprddp: ?*?*IDebugApplicationNode,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
                pprddp: ?*?*IDebugApplicationNode,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugApplicationNodes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugApplicationNodes,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugApplicationNodes,
                pperddp: ?*?*IEnumDebugApplicationNodes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Next(self: *const T, celt: u32, pprddp: ?*?*IDebugApplicationNode, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), celt, pprddp, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Clone(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugApplicationNodes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugApplicationNodes, @ptrCast(self)), pperddp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplications_Value = Guid.initString("51973c3b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplications = &IID_IEnumRemoteDebugApplications_Value;
pub const IEnumRemoteDebugApplications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
                ppda: ?*?*IRemoteDebugApplication,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
                ppda: ?*?*IRemoteDebugApplication,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplications,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplications,
                ppessd: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplications,
                ppessd: ?*?*IEnumRemoteDebugApplications,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Next(self: *const T, celt: u32, ppda: ?*?*IRemoteDebugApplication, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), celt, ppda, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Clone(self: *const T, ppessd: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplications.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRemoteDebugApplications, @ptrCast(self)), ppessd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplicationThreads_Value = Guid.initString("51973c3c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplicationThreads = &IID_IEnumRemoteDebugApplicationThreads_Value;
pub const IEnumRemoteDebugApplicationThreads = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
                pprdat: ?*?*IRemoteDebugApplicationThread,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
                pprdat: ?*?*IRemoteDebugApplicationThread,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRemoteDebugApplicationThreads,
                pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Next(self: *const T, celt: u32, pprdat: ?*?*IRemoteDebugApplicationThread, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), celt, pprdat, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Clone(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @as(*const IEnumRemoteDebugApplicationThreads.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRemoteDebugApplicationThreads, @ptrCast(self)), pperdat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFormatter_Value = Guid.initString("51973c05-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugFormatter = &IID_IDebugFormatter_Value;
pub const IDebugFormatter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringForVariant: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFormatter,
                pvar: ?*VARIANT,
                nRadix: u32,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFormatter,
                pvar: ?*VARIANT,
                nRadix: u32,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVariantForString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFormatter,
                pwstrValue: ?[*:0]align(1) const u16,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFormatter,
                pwstrValue: ?[*:0]align(1) const u16,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringForVarType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFormatter,
                vt: VARENUM,
                ptdescArrayType: ?*TYPEDESC,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFormatter,
                vt: VARENUM,
                ptdescArrayType: ?*TYPEDESC,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVariant(self: *const T, pvar: ?*VARIANT, nRadix: u32, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetStringForVariant(@as(*const IDebugFormatter, @ptrCast(self)), pvar, nRadix, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetVariantForString(self: *const T, pwstrValue: ?[*:0]align(1) const u16, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetVariantForString(@as(*const IDebugFormatter, @ptrCast(self)), pwstrValue, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVarType(self: *const T, vt: VARENUM, ptdescArrayType: ?*TYPEDESC, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFormatter.VTable, @ptrCast(self.vtable)).GetStringForVarType(@as(*const IDebugFormatter, @ptrCast(self)), vt, ptdescArrayType, pbstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleConnectionPoint_Value = Guid.initString("51973c3e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_ISimpleConnectionPoint = &IID_ISimpleConnectionPoint_Value;
pub const ISimpleConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISimpleConnectionPoint,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISimpleConnectionPoint,
                pulCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DescribeEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISimpleConnectionPoint,
                iEvent: u32,
                cEvents: u32,
                prgid: [*]i32,
                prgbstr: [*]?BSTR,
                pcEventsFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISimpleConnectionPoint,
                iEvent: u32,
                cEvents: u32,
                prgid: [*]i32,
                prgbstr: [*]?BSTR,
                pcEventsFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISimpleConnectionPoint,
                pdisp: ?*IDispatch,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISimpleConnectionPoint,
                pdisp: ?*IDispatch,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISimpleConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISimpleConnectionPoint,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_GetEventCount(self: *const T, pulCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).GetEventCount(@as(*const ISimpleConnectionPoint, @ptrCast(self)), pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_DescribeEvents(self: *const T, iEvent: u32, cEvents: u32, prgid: [*]i32, prgbstr: [*]?BSTR, pcEventsFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).DescribeEvents(@as(*const ISimpleConnectionPoint, @ptrCast(self)), iEvent, cEvents, prgid, prgbstr, pcEventsFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Advise(self: *const T, pdisp: ?*IDispatch, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).Advise(@as(*const ISimpleConnectionPoint, @ptrCast(self)), pdisp, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const ISimpleConnectionPoint.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const ISimpleConnectionPoint, @ptrCast(self)), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHelper_Value = Guid.initString("51973c3f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugHelper = &IID_IDebugHelper_Value;
pub const IDebugHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyBrowser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]align(1) const u16,
                pdat: ?*IDebugApplicationThread,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]align(1) const u16,
                pdat: ?*IDebugApplicationThread,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePropertyBrowserEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]align(1) const u16,
                pdat: ?*IDebugApplicationThread,
                pdf: ?*IDebugFormatter,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHelper,
                pvar: ?*VARIANT,
                bstrName: ?[*:0]align(1) const u16,
                pdat: ?*IDebugApplicationThread,
                pdf: ?*IDebugFormatter,
                ppdob: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSimpleConnectionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHelper,
                pdisp: ?*IDispatch,
                ppscp: ?*?*ISimpleConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHelper,
                pdisp: ?*IDispatch,
                ppscp: ?*?*ISimpleConnectionPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowser(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]align(1) const u16, pdat: ?*IDebugApplicationThread, ppdob: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreatePropertyBrowser(@as(*const IDebugHelper, @ptrCast(self)), pvar, bstrName, pdat, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowserEx(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]align(1) const u16, pdat: ?*IDebugApplicationThread, pdf: ?*IDebugFormatter, ppdob: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreatePropertyBrowserEx(@as(*const IDebugHelper, @ptrCast(self)), pvar, bstrName, pdat, pdf, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreateSimpleConnectionPoint(self: *const T, pdisp: ?*IDispatch, ppscp: ?*?*ISimpleConnectionPoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugHelper.VTable, @ptrCast(self.vtable)).CreateSimpleConnectionPoint(@as(*const IDebugHelper, @ptrCast(self)), pdisp, ppscp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExpressionContexts_Value = Guid.initString("51973c40-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExpressionContexts = &IID_IEnumDebugExpressionContexts_Value;
pub const IEnumDebugExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
                ppdec: ?*?*IDebugExpressionContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
                ppdec: ?*?*IDebugExpressionContext,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExpressionContexts,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Next(self: *const T, celt: u32, ppdec: ?*?*IDebugExpressionContext, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), celt, ppdec, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Clone(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExpressionContexts.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugExpressionContexts, @ptrCast(self)), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideExpressionContexts_Value = Guid.initString("51973c41-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProvideExpressionContexts = &IID_IProvideExpressionContexts_Value;
pub const IProvideExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumExpressionContexts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IProvideExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IProvideExpressionContexts,
                ppedec: ?*?*IEnumDebugExpressionContexts,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideExpressionContexts_EnumExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @as(*const IProvideExpressionContexts.VTable, @ptrCast(self.vtable)).EnumExpressionContexts(@as(*const IProvideExpressionContexts, @ptrCast(self)), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ProcessDebugManager_Value = Guid.initString("78a51822-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_ProcessDebugManager = &CLSID_ProcessDebugManager_Value;

const CLSID_DebugHelper_Value = Guid.initString("0bfcc060-8c1d-11d0-accd-00aa0060275c");
pub const CLSID_DebugHelper = &CLSID_DebugHelper_Value;

const CLSID_CDebugDocumentHelper_Value = Guid.initString("83b8bca6-687c-11d0-a405-00aa0060275c");
pub const CLSID_CDebugDocumentHelper = &CLSID_CDebugDocumentHelper_Value;

const CLSID_MachineDebugManager_RETAIL_Value = Guid.initString("0c0a3666-30c9-11d0-8f20-00805f2cd064");
pub const CLSID_MachineDebugManager_RETAIL = &CLSID_MachineDebugManager_RETAIL_Value;

const CLSID_MachineDebugManager_DEBUG_Value = Guid.initString("49769cec-3a55-4bb0-b697-88fede77e8ea");
pub const CLSID_MachineDebugManager_DEBUG = &CLSID_MachineDebugManager_DEBUG_Value;

const CLSID_DefaultDebugSessionProvider_Value = Guid.initString("834128a2-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_DefaultDebugSessionProvider = &CLSID_DefaultDebugSessionProvider_Value;

pub const PROFILER_SCRIPT_TYPE = enum(i32) {
    USER = 0,
    DYNAMIC = 1,
    NATIVE = 2,
    DOM = 3,
};
pub const PROFILER_SCRIPT_TYPE_USER = PROFILER_SCRIPT_TYPE.USER;
pub const PROFILER_SCRIPT_TYPE_DYNAMIC = PROFILER_SCRIPT_TYPE.DYNAMIC;
pub const PROFILER_SCRIPT_TYPE_NATIVE = PROFILER_SCRIPT_TYPE.NATIVE;
pub const PROFILER_SCRIPT_TYPE_DOM = PROFILER_SCRIPT_TYPE.DOM;

pub const PROFILER_EVENT_MASK = enum(i32) {
    SCRIPT_FUNCTION_CALL = 1,
    NATIVE_FUNCTION_CALL = 2,
    DOM_FUNCTION_CALL = 4,
    ALL = 3,
    ALL_WITH_DOM = 7,
    _,
    pub fn initFlags(o: struct {
        SCRIPT_FUNCTION_CALL: u1 = 0,
        NATIVE_FUNCTION_CALL: u1 = 0,
        DOM_FUNCTION_CALL: u1 = 0,
        ALL: u1 = 0,
        ALL_WITH_DOM: u1 = 0,
    }) PROFILER_EVENT_MASK {
        return @as(PROFILER_EVENT_MASK, @enumFromInt(
              (if (o.SCRIPT_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL) else 0)
            | (if (o.NATIVE_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL) else 0)
            | (if (o.DOM_FUNCTION_CALL == 1) @intFromEnum(PROFILER_EVENT_MASK.DOM_FUNCTION_CALL) else 0)
            | (if (o.ALL == 1) @intFromEnum(PROFILER_EVENT_MASK.ALL) else 0)
            | (if (o.ALL_WITH_DOM == 1) @intFromEnum(PROFILER_EVENT_MASK.ALL_WITH_DOM) else 0)
        ));
    }
};
pub const PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL = PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL = PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL = PROFILER_EVENT_MASK.DOM_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL = PROFILER_EVENT_MASK.ALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM = PROFILER_EVENT_MASK.ALL_WITH_DOM;

const IID_IActiveScriptProfilerControl_Value = Guid.initString("784b5ff0-69b0-47d1-a7dc-2518f4230e90");
pub const IID_IActiveScriptProfilerControl = &IID_IActiveScriptProfilerControl_Value;
pub const IActiveScriptProfilerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProfiling: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl,
                clsidProfilerObject: ?*const Guid,
                dwEventMask: u32,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl,
                clsidProfilerObject: ?*const Guid,
                dwEventMask: u32,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProfilerEventMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl,
                dwEventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl,
                dwEventMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopProfiling: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl,
                hrShutdownReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl,
                hrShutdownReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StartProfiling(self: *const T, clsidProfilerObject: ?*const Guid, dwEventMask: u32, dwContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).StartProfiling(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), clsidProfilerObject, dwEventMask, dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_SetProfilerEventMask(self: *const T, dwEventMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).SetProfilerEventMask(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), dwEventMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StopProfiling(self: *const T, hrShutdownReason: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl.VTable, @ptrCast(self.vtable)).StopProfiling(@as(*const IActiveScriptProfilerControl, @ptrCast(self)), hrShutdownReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl2_Value = Guid.initString("47810165-498f-40be-94f1-653557e9e7da");
pub const IID_IActiveScriptProfilerControl2 = &IID_IActiveScriptProfilerControl2_Value;
pub const IActiveScriptProfilerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl.VTable,
        CompleteProfilerStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareProfilerStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_CompleteProfilerStart(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl2.VTable, @ptrCast(self.vtable)).CompleteProfilerStart(@as(*const IActiveScriptProfilerControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_PrepareProfilerStop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl2.VTable, @ptrCast(self.vtable)).PrepareProfilerStop(@as(*const IActiveScriptProfilerControl2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_OBJECT_FLAGS = enum(i32) {
    NEW_OBJECT = 1,
    IS_ROOT = 2,
    SITE_CLOSED = 4,
    EXTERNAL = 8,
    EXTERNAL_UNKNOWN = 16,
    EXTERNAL_DISPATCH = 32,
    SIZE_APPROXIMATE = 64,
    SIZE_UNAVAILABLE = 128,
    NEW_STATE_UNAVAILABLE = 256,
    WINRT_INSTANCE = 512,
    WINRT_RUNTIMECLASS = 1024,
    WINRT_DELEGATE = 2048,
    WINRT_NAMESPACE = 4096,
    _,
    pub fn initFlags(o: struct {
        NEW_OBJECT: u1 = 0,
        IS_ROOT: u1 = 0,
        SITE_CLOSED: u1 = 0,
        EXTERNAL: u1 = 0,
        EXTERNAL_UNKNOWN: u1 = 0,
        EXTERNAL_DISPATCH: u1 = 0,
        SIZE_APPROXIMATE: u1 = 0,
        SIZE_UNAVAILABLE: u1 = 0,
        NEW_STATE_UNAVAILABLE: u1 = 0,
        WINRT_INSTANCE: u1 = 0,
        WINRT_RUNTIMECLASS: u1 = 0,
        WINRT_DELEGATE: u1 = 0,
        WINRT_NAMESPACE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_FLAGS {
        return @as(PROFILER_HEAP_OBJECT_FLAGS, @enumFromInt(
              (if (o.NEW_OBJECT == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT) else 0)
            | (if (o.IS_ROOT == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT) else 0)
            | (if (o.SITE_CLOSED == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED) else 0)
            | (if (o.EXTERNAL == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL) else 0)
            | (if (o.EXTERNAL_UNKNOWN == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN) else 0)
            | (if (o.EXTERNAL_DISPATCH == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH) else 0)
            | (if (o.SIZE_APPROXIMATE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE) else 0)
            | (if (o.SIZE_UNAVAILABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE) else 0)
            | (if (o.NEW_STATE_UNAVAILABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE) else 0)
            | (if (o.WINRT_INSTANCE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE) else 0)
            | (if (o.WINRT_RUNTIMECLASS == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS) else 0)
            | (if (o.WINRT_DELEGATE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE) else 0)
            | (if (o.WINRT_NAMESPACE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE) else 0)
        ));
    }
};
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT = PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT;
pub const PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT = PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT;
pub const PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED = PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS = PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE;

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE = enum(i32) {
    PROTOTYPE = 1,
    FUNCTION_NAME = 2,
    SCOPE_LIST = 3,
    INTERNAL_PROPERTY = 4,
    NAME_PROPERTIES = 5,
    INDEX_PROPERTIES = 6,
    ELEMENT_ATTRIBUTES_SIZE = 7,
    ELEMENT_TEXT_CHILDREN_SIZE = 8,
    RELATIONSHIPS = 9,
    WINRTEVENTS = 10,
    WEAKMAP_COLLECTION_LIST = 11,
    MAP_COLLECTION_LIST = 12,
    SET_COLLECTION_LIST = 13,
    // MAX_VALUE = 13, this enum value conflicts with SET_COLLECTION_LIST
};
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.PROTOTYPE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.FUNCTION_NAME;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SCOPE_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INTERNAL_PROPERTY;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.NAME_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INDEX_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_ATTRIBUTES_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_TEXT_CHILDREN_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.RELATIONSHIPS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WINRTEVENTS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WEAKMAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.MAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS = enum(i32) {
    NONE = 0,
    IS_GET_ACCESSOR = 65536,
    IS_SET_ACCESSOR = 131072,
    LET_VARIABLE = 262144,
    CONST_VARIABLE = 524288,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        IS_GET_ACCESSOR: u1 = 0,
        IS_SET_ACCESSOR: u1 = 0,
        LET_VARIABLE: u1 = 0,
        CONST_VARIABLE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS {
        return @as(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE) else 0)
            | (if (o.IS_GET_ACCESSOR == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR) else 0)
            | (if (o.IS_SET_ACCESSOR == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR) else 0)
            | (if (o.LET_VARIABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE) else 0)
            | (if (o.CONST_VARIABLE == 1) @intFromEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE) else 0)
        ));
    }
};
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE;

pub const PROFILER_HEAP_ENUM_FLAGS = enum(i32) {
    NONE = 0,
    STORE_RELATIONSHIP_FLAGS = 1,
    SUBSTRINGS = 2,
    RELATIONSHIP_SUBSTRINGS = 3,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        STORE_RELATIONSHIP_FLAGS: u1 = 0,
        SUBSTRINGS: u1 = 0,
        RELATIONSHIP_SUBSTRINGS: u1 = 0,
    }) PROFILER_HEAP_ENUM_FLAGS {
        return @as(PROFILER_HEAP_ENUM_FLAGS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.NONE) else 0)
            | (if (o.STORE_RELATIONSHIP_FLAGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS) else 0)
            | (if (o.SUBSTRINGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS) else 0)
            | (if (o.RELATIONSHIP_SUBSTRINGS == 1) @intFromEnum(PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS) else 0)
        ));
    }
};
pub const PROFILER_HEAP_ENUM_FLAGS_NONE = PROFILER_HEAP_ENUM_FLAGS.NONE;
pub const PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS = PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS;
pub const PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS;
pub const PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS;

pub const PROFILER_HEAP_OBJECT_SCOPE_LIST = extern struct {
    count: u32,
    scopes: [1]usize,
};

pub const PROFILER_RELATIONSHIP_INFO = enum(i32) {
    NUMBER = 1,
    STRING = 2,
    HEAP_OBJECT = 3,
    EXTERNAL_OBJECT = 4,
    BSTR = 5,
    SUBSTRING = 6,
};
pub const PROFILER_PROPERTY_TYPE_NUMBER = PROFILER_RELATIONSHIP_INFO.NUMBER;
pub const PROFILER_PROPERTY_TYPE_STRING = PROFILER_RELATIONSHIP_INFO.STRING;
pub const PROFILER_PROPERTY_TYPE_HEAP_OBJECT = PROFILER_RELATIONSHIP_INFO.HEAP_OBJECT;
pub const PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT = PROFILER_RELATIONSHIP_INFO.EXTERNAL_OBJECT;
pub const PROFILER_PROPERTY_TYPE_BSTR = PROFILER_RELATIONSHIP_INFO.BSTR;
pub const PROFILER_PROPERTY_TYPE_SUBSTRING = PROFILER_RELATIONSHIP_INFO.SUBSTRING;

pub const PROFILER_PROPERTY_TYPE_SUBSTRING_INFO = extern struct {
    length: u32,
    value: ?[*:0]align(1) const u16,
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP = extern struct {
    relationshipId: u32,
    relationshipInfo: PROFILER_RELATIONSHIP_INFO,
    Anonymous: extern union {
        numberValue: f64,
        stringValue: ?[*:0]align(1) const u16,
        bstrValue: ?BSTR,
        objectId: usize,
        externalObjectAddress: ?*anyopaque,
        subString: ?*PROFILER_PROPERTY_TYPE_SUBSTRING_INFO,
    },
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST = extern struct {
    count: u32,
    elements: [1]PROFILER_HEAP_OBJECT_RELATIONSHIP,
};

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO = extern struct {
    infoType: PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE,
    Anonymous: extern union {
        prototype: usize,
        functionName: ?[*:0]align(1) const u16,
        elementAttributesSize: u32,
        elementTextChildrenSize: u32,
        scopeList: ?*PROFILER_HEAP_OBJECT_SCOPE_LIST,
        internalProperty: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP,
        namePropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        indexPropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        relationshipList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        eventList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        weakMapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        mapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        setCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
    },
};

pub const PROFILER_HEAP_OBJECT = extern struct {
    size: u32,
    Anonymous: extern union {
        objectId: usize,
        externalObjectAddress: ?*anyopaque,
    },
    typeNameId: u32,
    flags: u32,
    unused: u16,
    optionalInfoCount: u16,
};

const IID_IActiveScriptProfilerHeapEnum_Value = Guid.initString("32e4694e-0d37-419b-b93d-fa20ded6e8ea");
pub const IID_IActiveScriptProfilerHeapEnum = &IID_IActiveScriptProfilerHeapEnum_Value;
pub const IActiveScriptProfilerHeapEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOptionalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerHeapEnum,
                heapObject: ?*PROFILER_HEAP_OBJECT,
                celt: u32,
                optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerHeapEnum,
                heapObject: ?*PROFILER_HEAP_OBJECT,
                celt: u32,
                optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeObjectAndOptionalInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerHeapEnum,
                celt: u32,
                heapObjects: [*]?*PROFILER_HEAP_OBJECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameIdMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerHeapEnum,
                pNameList: [*]const ?*const ?*?PWSTR,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerHeapEnum,
                pNameList: [*]const ?*const ?*?PWSTR,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_Next(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), celt, heapObjects, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetOptionalInfo(self: *const T, heapObject: ?*PROFILER_HEAP_OBJECT, celt: u32, optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).GetOptionalInfo(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), heapObject, celt, optionalInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_FreeObjectAndOptionalInfo(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).FreeObjectAndOptionalInfo(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), celt, heapObjects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetNameIdMap(self: *const T, pNameList: [*]const ?*const ?*?PWSTR, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerHeapEnum.VTable, @ptrCast(self.vtable)).GetNameIdMap(@as(*const IActiveScriptProfilerHeapEnum, @ptrCast(self)), pNameList, pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl3_Value = Guid.initString("0b403015-f381-4023-a5d0-6fed076de716");
pub const IID_IActiveScriptProfilerControl3 = &IID_IActiveScriptProfilerControl3_Value;
pub const IActiveScriptProfilerControl3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl2.VTable,
        EnumHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl3,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl3,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl3_EnumHeap(self: *const T, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl3.VTable, @ptrCast(self.vtable)).EnumHeap(@as(*const IActiveScriptProfilerControl3, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_SUMMARY_VERSION = enum(i32) {
    @"1" = 1,
};
pub const PROFILER_HEAP_SUMMARY_VERSION_1 = PROFILER_HEAP_SUMMARY_VERSION.@"1";

pub const PROFILER_HEAP_SUMMARY = extern struct {
    version: PROFILER_HEAP_SUMMARY_VERSION,
    totalHeapSize: u32,
};

const IID_IActiveScriptProfilerControl4_Value = Guid.initString("160f94fd-9dbc-40d4-9eac-2b71db3132f4");
pub const IID_IActiveScriptProfilerControl4 = &IID_IActiveScriptProfilerControl4_Value;
pub const IActiveScriptProfilerControl4 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl3.VTable,
        SummarizeHeap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl4,
                heapSummary: ?*PROFILER_HEAP_SUMMARY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl4,
                heapSummary: ?*PROFILER_HEAP_SUMMARY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl4_SummarizeHeap(self: *const T, heapSummary: ?*PROFILER_HEAP_SUMMARY) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl4.VTable, @ptrCast(self.vtable)).SummarizeHeap(@as(*const IActiveScriptProfilerControl4, @ptrCast(self)), heapSummary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl5_Value = Guid.initString("1c01a2d1-8f0f-46a5-9720-0d7ed2c62f0a");
pub const IID_IActiveScriptProfilerControl5 = &IID_IActiveScriptProfilerControl5_Value;
pub const IActiveScriptProfilerControl5 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl4.VTable,
        EnumHeap2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerControl5,
                enumFlags: PROFILER_HEAP_ENUM_FLAGS,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerControl5,
                enumFlags: PROFILER_HEAP_ENUM_FLAGS,
                ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl5_EnumHeap2(self: *const T, enumFlags: PROFILER_HEAP_ENUM_FLAGS, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerControl5.VTable, @ptrCast(self.vtable)).EnumHeap2(@as(*const IActiveScriptProfilerControl5, @ptrCast(self)), enumFlags, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback_Value = Guid.initString("740eca23-7d9d-42e5-ba9d-f8b24b1c7a9b");
pub const IID_IActiveScriptProfilerCallback = &IID_IActiveScriptProfilerCallback_Value;
pub const IActiveScriptProfilerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                dwContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                hrReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                hrReason: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScriptCompiled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                type: PROFILER_SCRIPT_TYPE,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                type: PROFILER_SCRIPT_TYPE,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FunctionCompiled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                functionId: i32,
                scriptId: i32,
                pwszFunctionName: ?[*:0]align(1) const u16,
                pwszFunctionNameHint: ?[*:0]align(1) const u16,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                functionId: i32,
                scriptId: i32,
                pwszFunctionName: ?[*:0]align(1) const u16,
                pwszFunctionNameHint: ?[*:0]align(1) const u16,
                pIDebugDocumentContext: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionExit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback,
                scriptId: i32,
                functionId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Initialize(self: *const T, dwContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Shutdown(self: *const T, hrReason: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), hrReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_ScriptCompiled(self: *const T, scriptId: i32, type_: PROFILER_SCRIPT_TYPE, pIDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).ScriptCompiled(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, type_, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_FunctionCompiled(self: *const T, functionId: i32, scriptId: i32, pwszFunctionName: ?[*:0]align(1) const u16, pwszFunctionNameHint: ?[*:0]align(1) const u16, pIDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).FunctionCompiled(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionEnter(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).OnFunctionEnter(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionExit(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback.VTable, @ptrCast(self.vtable)).OnFunctionExit(@as(*const IActiveScriptProfilerCallback, @ptrCast(self)), scriptId, functionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback2_Value = Guid.initString("31b7f8ad-a637-409c-b22f-040995b6103d");
pub const IID_IActiveScriptProfilerCallback2 = &IID_IActiveScriptProfilerCallback2_Value;
pub const IActiveScriptProfilerCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback.VTable,
        OnFunctionEnterByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]align(1) const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]align(1) const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFunctionExitByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]align(1) const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback2,
                pwszFunctionName: ?[*:0]align(1) const u16,
                type: PROFILER_SCRIPT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionEnterByName(self: *const T, pwszFunctionName: ?[*:0]align(1) const u16, type_: PROFILER_SCRIPT_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback2.VTable, @ptrCast(self.vtable)).OnFunctionEnterByName(@as(*const IActiveScriptProfilerCallback2, @ptrCast(self)), pwszFunctionName, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionExitByName(self: *const T, pwszFunctionName: ?[*:0]align(1) const u16, type_: PROFILER_SCRIPT_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback2.VTable, @ptrCast(self.vtable)).OnFunctionExitByName(@as(*const IActiveScriptProfilerCallback2, @ptrCast(self)), pwszFunctionName, type_);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback3_Value = Guid.initString("6ac5ad25-2037-4687-91df-b59979d93d73");
pub const IID_IActiveScriptProfilerCallback3 = &IID_IActiveScriptProfilerCallback3_Value;
pub const IActiveScriptProfilerCallback3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback2.VTable,
        SetWebWorkerId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptProfilerCallback3,
                webWorkerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptProfilerCallback3,
                webWorkerId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback3_SetWebWorkerId(self: *const T, webWorkerId: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptProfilerCallback3.VTable, @ptrCast(self.vtable)).SetWebWorkerId(@as(*const IActiveScriptProfilerCallback3, @ptrCast(self)), webWorkerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptNode_Value = Guid.initString("0aee2a94-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptNode = &IID_IScriptNode_Value;
pub const IScriptNode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                ppsnParent: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                ppsnParent: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexInParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                pisn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                pisn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCookie: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                pdwCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                pcsn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                pcsn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                isn: u32,
                ppsn: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                isn: u32,
                ppsn: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateChildEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                isn: u32,
                dwCookie: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                isn: u32,
                dwCookie: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateChildHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptNode,
                pszDefaultName: ?[*:0]align(1) const u16,
                prgpszNames: [*]?PWSTR,
                cpszNames: u32,
                pszEvent: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                ptiSignature: ?*ITypeInfo,
                iMethodSignature: u32,
                isn: u32,
                dwCookie: u32,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptNode,
                pszDefaultName: ?[*:0]align(1) const u16,
                prgpszNames: [*]?PWSTR,
                cpszNames: u32,
                pszEvent: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                ptiSignature: ?*ITypeInfo,
                iMethodSignature: u32,
                isn: u32,
                dwCookie: u32,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_Alive(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).Alive(@as(*const IScriptNode, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).Delete(@as(*const IScriptNode, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetParent(self: *const T, ppsnParent: ?*?*IScriptNode) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IScriptNode, @ptrCast(self)), ppsnParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetIndexInParent(self: *const T, pisn: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetIndexInParent(@as(*const IScriptNode, @ptrCast(self)), pisn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetCookie(self: *const T, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetCookie(@as(*const IScriptNode, @ptrCast(self)), pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetNumberOfChildren(self: *const T, pcsn: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetNumberOfChildren(@as(*const IScriptNode, @ptrCast(self)), pcsn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetChild(self: *const T, isn: u32, ppsn: ?*?*IScriptNode) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetChild(@as(*const IScriptNode, @ptrCast(self)), isn, ppsn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_GetLanguage(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IScriptNode, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_CreateChildEntry(self: *const T, isn: u32, dwCookie: u32, pszDelimiter: ?[*:0]align(1) const u16, ppse: ?*?*IScriptEntry) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).CreateChildEntry(@as(*const IScriptNode, @ptrCast(self)), isn, dwCookie, pszDelimiter, ppse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptNode_CreateChildHandler(self: *const T, pszDefaultName: ?[*:0]align(1) const u16, prgpszNames: [*]?PWSTR, cpszNames: u32, pszEvent: ?[*:0]align(1) const u16, pszDelimiter: ?[*:0]align(1) const u16, ptiSignature: ?*ITypeInfo, iMethodSignature: u32, isn: u32, dwCookie: u32, ppse: ?*?*IScriptEntry) callconv(.Inline) HRESULT {
            return @as(*const IScriptNode.VTable, @ptrCast(self.vtable)).CreateChildHandler(@as(*const IScriptNode, @ptrCast(self)), pszDefaultName, prgpszNames, cpszNames, pszEvent, pszDelimiter, ptiSignature, iMethodSignature, isn, dwCookie, ppse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEntry_Value = Guid.initString("0aee2a95-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptEntry = &IID_IScriptEntry_Value;
pub const IScriptEntry = extern struct {
    pub const VTable = extern struct {
        base: IScriptNode.VTable,
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                ppti: ?*?*ITypeInfo,
                piMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                ppti: ?*?*ITypeInfo,
                piMethod: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pti: ?*ITypeInfo,
                iMethod: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pti: ?*ITypeInfo,
                iMethod: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptEntry,
                pichMin: ?*u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptEntry,
                pichMin: ?*u32,
                pcch: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScriptNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetText(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetText(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_SetText(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetText(@as(*const IScriptEntry, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetBody(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetBody(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_SetBody(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetBody(@as(*const IScriptEntry, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetName(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_SetName(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetName(@as(*const IScriptEntry, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetItemName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetItemName(@as(*const IScriptEntry, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_SetItemName(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetItemName(@as(*const IScriptEntry, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetSignature(self: *const T, ppti: ?*?*ITypeInfo, piMethod: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetSignature(@as(*const IScriptEntry, @ptrCast(self)), ppti, piMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_SetSignature(self: *const T, pti: ?*ITypeInfo, iMethod: u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).SetSignature(@as(*const IScriptEntry, @ptrCast(self)), pti, iMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEntry_GetRange(self: *const T, pichMin: ?*u32, pcch: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IScriptEntry.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IScriptEntry, @ptrCast(self)), pichMin, pcch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptScriptlet_Value = Guid.initString("0aee2a96-bcbb-11d0-8c72-00c04fc2b085");
pub const IID_IScriptScriptlet = &IID_IScriptScriptlet_Value;
pub const IScriptScriptlet = extern struct {
    pub const VTable = extern struct {
        base: IScriptEntry.VTable,
        GetSubItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubItemName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSimpleEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                pbstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSimpleEventName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptScriptlet,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScriptEntry.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_GetSubItemName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetSubItemName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_SetSubItemName(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetSubItemName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_GetEventName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetEventName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_SetEventName(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetEventName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_GetSimpleEventName(self: *const T, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).GetSimpleEventName(@as(*const IScriptScriptlet, @ptrCast(self)), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptScriptlet_SetSimpleEventName(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IScriptScriptlet.VTable, @ptrCast(self.vtable)).SetSimpleEventName(@as(*const IScriptScriptlet, @ptrCast(self)), psz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptAuthor_Value = Guid.initString("9c109da0-7006-11d1-b36c-00a0c911e8b2");
pub const IID_IActiveScriptAuthor = &IID_IActiveScriptAuthor_Value;
pub const IActiveScriptAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pdisp: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddScriptlet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszDefaultName: ?[*:0]align(1) const u16,
                pszCode: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszSubItemName: ?[*:0]align(1) const u16,
                pszEventName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszDefaultName: ?[*:0]align(1) const u16,
                pszCode: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszSubItemName: ?[*:0]align(1) const u16,
                pszEventName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseScriptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptletTextAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszCode: [*:0]const u16,
                cch: u32,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pattr: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                ppsp: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                ppsp: ?*?*IScriptNode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pgrfasa: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pgrfasa: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventHandler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pdisp: ?*IDispatch,
                pszItem: ?[*:0]align(1) const u16,
                pszSubItem: ?[*:0]align(1) const u16,
                pszEvent: ?[*:0]align(1) const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pdisp: ?*IDispatch,
                pszItem: ?[*:0]align(1) const u16,
                pszSubItem: ?[*:0]align(1) const u16,
                pszEvent: ?[*:0]align(1) const u16,
                ppse: ?*?*IScriptEntry,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveNamedItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeLib: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                rguidTypeLib: ?*const Guid,
                dwMajor: u32,
                dwMinor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChars: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                fRequestedList: u32,
                pbstrChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                fRequestedList: u32,
                pbstrChars: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfoFromContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]align(1) const u16,
                cchCode: u32,
                ichCurrentPosition: u32,
                dwListTypesRequested: u32,
                pdwListTypesProvided: ?*u32,
                pichListAnchorPosition: ?*u32,
                pichFuncAnchorPosition: ?*u32,
                pmemid: ?*i32,
                piCurrentParameter: ?*i32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                pszCode: ?[*:0]align(1) const u16,
                cchCode: u32,
                ichCurrentPosition: u32,
                dwListTypesRequested: u32,
                pdwListTypesProvided: ?*u32,
                pichListAnchorPosition: ?*u32,
                pichFuncAnchorPosition: ?*u32,
                pmemid: ?*i32,
                piCurrentParameter: ?*i32,
                ppunk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCommitChar: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthor,
                ch: u16,
                pfcommit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthor,
                ch: u16,
                pfcommit: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_AddNamedItem(self: *const T, pszName: ?[*:0]align(1) const u16, dwFlags: u32, pdisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddNamedItem(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszName, dwFlags, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_AddScriptlet(self: *const T, pszDefaultName: ?[*:0]align(1) const u16, pszCode: ?[*:0]align(1) const u16, pszItemName: ?[*:0]align(1) const u16, pszSubItemName: ?[*:0]align(1) const u16, pszEventName: ?[*:0]align(1) const u16, pszDelimiter: ?[*:0]align(1) const u16, dwCookie: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddScriptlet(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszDefaultName, pszCode, pszItemName, pszSubItemName, pszEventName, pszDelimiter, dwCookie, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_ParseScriptText(self: *const T, pszCode: ?[*:0]align(1) const u16, pszItemName: ?[*:0]align(1) const u16, pszDelimiter: ?[*:0]align(1) const u16, dwCookie: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).ParseScriptText(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, pszItemName, pszDelimiter, dwCookie, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetScriptTextAttributes(self: *const T, pszCode: [*:0]const u16, cch: u32, pszDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetScriptTextAttributes(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cch, pszDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetScriptletTextAttributes(self: *const T, pszCode: [*:0]const u16, cch: u32, pszDelimiter: ?[*:0]align(1) const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetScriptletTextAttributes(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cch, pszDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetRoot(self: *const T, ppsp: ?*?*IScriptNode) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetRoot(@as(*const IActiveScriptAuthor, @ptrCast(self)), ppsp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetLanguageFlags(self: *const T, pgrfasa: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetLanguageFlags(@as(*const IActiveScriptAuthor, @ptrCast(self)), pgrfasa);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetEventHandler(self: *const T, pdisp: ?*IDispatch, pszItem: ?[*:0]align(1) const u16, pszSubItem: ?[*:0]align(1) const u16, pszEvent: ?[*:0]align(1) const u16, ppse: ?*?*IScriptEntry) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetEventHandler(@as(*const IActiveScriptAuthor, @ptrCast(self)), pdisp, pszItem, pszSubItem, pszEvent, ppse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_RemoveNamedItem(self: *const T, pszName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).RemoveNamedItem(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_AddTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).AddTypeLib(@as(*const IActiveScriptAuthor, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_RemoveTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).RemoveTypeLib(@as(*const IActiveScriptAuthor, @ptrCast(self)), rguidTypeLib, dwMajor, dwMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetChars(self: *const T, fRequestedList: u32, pbstrChars: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetChars(@as(*const IActiveScriptAuthor, @ptrCast(self)), fRequestedList, pbstrChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_GetInfoFromContext(self: *const T, pszCode: ?[*:0]align(1) const u16, cchCode: u32, ichCurrentPosition: u32, dwListTypesRequested: u32, pdwListTypesProvided: ?*u32, pichListAnchorPosition: ?*u32, pichFuncAnchorPosition: ?*u32, pmemid: ?*i32, piCurrentParameter: ?*i32, ppunk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).GetInfoFromContext(@as(*const IActiveScriptAuthor, @ptrCast(self)), pszCode, cchCode, ichCurrentPosition, dwListTypesRequested, pdwListTypesProvided, pichListAnchorPosition, pichFuncAnchorPosition, pmemid, piCurrentParameter, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthor_IsCommitChar(self: *const T, ch: u16, pfcommit: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthor.VTable, @ptrCast(self.vtable)).IsCommitChar(@as(*const IActiveScriptAuthor, @ptrCast(self)), ch, pfcommit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptAuthorProcedure_Value = Guid.initString("7e2d4b70-bd9a-11d0-9336-00a0c90dcaa9");
pub const IID_IActiveScriptAuthorProcedure = &IID_IActiveScriptAuthorProcedure_Value;
pub const IActiveScriptAuthorProcedure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptAuthorProcedure,
                pszCode: ?[*:0]align(1) const u16,
                pszFormalParams: ?[*:0]align(1) const u16,
                pszProcedureName: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
                pdispFor: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptAuthorProcedure,
                pszCode: ?[*:0]align(1) const u16,
                pszFormalParams: ?[*:0]align(1) const u16,
                pszProcedureName: ?[*:0]align(1) const u16,
                pszItemName: ?[*:0]align(1) const u16,
                pszDelimiter: ?[*:0]align(1) const u16,
                dwCookie: u32,
                dwFlags: u32,
                pdispFor: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptAuthorProcedure_ParseProcedureText(self: *const T, pszCode: ?[*:0]align(1) const u16, pszFormalParams: ?[*:0]align(1) const u16, pszProcedureName: ?[*:0]align(1) const u16, pszItemName: ?[*:0]align(1) const u16, pszDelimiter: ?[*:0]align(1) const u16, dwCookie: u32, dwFlags: u32, pdispFor: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptAuthorProcedure.VTable, @ptrCast(self.vtable)).ParseProcedureText(@as(*const IActiveScriptAuthorProcedure, @ptrCast(self)), pszCode, pszFormalParams, pszProcedureName, pszItemName, pszDelimiter, dwCookie, dwFlags, pdispFor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const APPLICATION_NODE_EVENT_FILTER = enum(i32) {
    NOTHING = 0,
    ANONYMOUS_CODE = 1,
    EVAL_CODE = 2,
};
pub const FILTER_EXCLUDE_NOTHING = APPLICATION_NODE_EVENT_FILTER.NOTHING;
pub const FILTER_EXCLUDE_ANONYMOUS_CODE = APPLICATION_NODE_EVENT_FILTER.ANONYMOUS_CODE;
pub const FILTER_EXCLUDE_EVAL_CODE = APPLICATION_NODE_EVENT_FILTER.EVAL_CODE;

pub const TEXT_DOCUMENT_ARRAY = extern struct {
    dwCount: u32,
    Members: ?*?*IDebugDocumentText,
};

const IID_IDebugApplicationNode100_Value = Guid.initString("90a7734e-841b-4f77-9384-a2891e76e7e2");
pub const IID_IDebugApplicationNode100 = &IID_IDebugApplicationNode100_Value;
pub const IDebugApplicationNode100 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFilterForEventSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode100,
                dwCookie: u32,
                filter: APPLICATION_NODE_EVENT_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode100,
                dwCookie: u32,
                filter: APPLICATION_NODE_EVENT_FILTER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExcludedDocuments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode100,
                filter: APPLICATION_NODE_EVENT_FILTER,
                pDocuments: ?*TEXT_DOCUMENT_ARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode100,
                filter: APPLICATION_NODE_EVENT_FILTER,
                pDocuments: ?*TEXT_DOCUMENT_ARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryIsChildNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationNode100,
                pSearchKey: ?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationNode100,
                pSearchKey: ?*IDebugDocument,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode100_SetFilterForEventSink(self: *const T, dwCookie: u32, filter: APPLICATION_NODE_EVENT_FILTER) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).SetFilterForEventSink(@as(*const IDebugApplicationNode100, @ptrCast(self)), dwCookie, filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode100_GetExcludedDocuments(self: *const T, filter: APPLICATION_NODE_EVENT_FILTER, pDocuments: ?*TEXT_DOCUMENT_ARRAY) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).GetExcludedDocuments(@as(*const IDebugApplicationNode100, @ptrCast(self)), filter, pDocuments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode100_QueryIsChildNode(self: *const T, pSearchKey: ?*IDebugDocument) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationNode100.VTable, @ptrCast(self.vtable)).QueryIsChildNode(@as(*const IDebugApplicationNode100, @ptrCast(self)), pSearchKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAppDiagnosticsSetup_Value = Guid.initString("379bfbe1-c6c9-432a-93e1-6d17656c538c");
pub const IID_IWebAppDiagnosticsSetup = &IID_IWebAppDiagnosticsSetup_Value;
pub const IWebAppDiagnosticsSetup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DiagnosticsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebAppDiagnosticsSetup,
                pRetVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebAppDiagnosticsSetup,
                pRetVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateObjectWithSiteAtWebApp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebAppDiagnosticsSetup,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                hPassToObject: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebAppDiagnosticsSetup,
                rclsid: ?*const Guid,
                dwClsContext: u32,
                riid: ?*const Guid,
                hPassToObject: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAppDiagnosticsSetup_DiagnosticsSupported(self: *const T, pRetVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IWebAppDiagnosticsSetup.VTable, @ptrCast(self.vtable)).DiagnosticsSupported(@as(*const IWebAppDiagnosticsSetup, @ptrCast(self)), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAppDiagnosticsSetup_CreateObjectWithSiteAtWebApp(self: *const T, rclsid: ?*const Guid, dwClsContext: u32, riid: ?*const Guid, hPassToObject: usize) callconv(.Inline) HRESULT {
            return @as(*const IWebAppDiagnosticsSetup.VTable, @ptrCast(self.vtable)).CreateObjectWithSiteAtWebApp(@as(*const IWebAppDiagnosticsSetup, @ptrCast(self)), rclsid, dwClsContext, riid, hPassToObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_DEBUGGER_OPTIONS = enum(i32) {
    NONE = 0,
    ENABLE_FIRST_CHANCE_EXCEPTIONS = 1,
    ENABLE_WEB_WORKER_SUPPORT = 2,
    ENABLE_NONUSER_CODE_SUPPORT = 4,
    ENABLE_LIBRARY_STACK_FRAME = 8,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        ENABLE_FIRST_CHANCE_EXCEPTIONS: u1 = 0,
        ENABLE_WEB_WORKER_SUPPORT: u1 = 0,
        ENABLE_NONUSER_CODE_SUPPORT: u1 = 0,
        ENABLE_LIBRARY_STACK_FRAME: u1 = 0,
    }) SCRIPT_DEBUGGER_OPTIONS {
        return @as(SCRIPT_DEBUGGER_OPTIONS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(SCRIPT_DEBUGGER_OPTIONS.NONE) else 0)
            | (if (o.ENABLE_FIRST_CHANCE_EXCEPTIONS == 1) @intFromEnum(SCRIPT_DEBUGGER_OPTIONS.ENABLE_FIRST_CHANCE_EXCEPTIONS) else 0)
            | (if (o.ENABLE_WEB_WORKER_SUPPORT == 1) @intFromEnum(SCRIPT_DEBUGGER_OPTIONS.ENABLE_WEB_WORKER_SUPPORT) else 0)
            | (if (o.ENABLE_NONUSER_CODE_SUPPORT == 1) @intFromEnum(SCRIPT_DEBUGGER_OPTIONS.ENABLE_NONUSER_CODE_SUPPORT) else 0)
            | (if (o.ENABLE_LIBRARY_STACK_FRAME == 1) @intFromEnum(SCRIPT_DEBUGGER_OPTIONS.ENABLE_LIBRARY_STACK_FRAME) else 0)
        ));
    }
};
pub const SDO_NONE = SCRIPT_DEBUGGER_OPTIONS.NONE;
pub const SDO_ENABLE_FIRST_CHANCE_EXCEPTIONS = SCRIPT_DEBUGGER_OPTIONS.ENABLE_FIRST_CHANCE_EXCEPTIONS;
pub const SDO_ENABLE_WEB_WORKER_SUPPORT = SCRIPT_DEBUGGER_OPTIONS.ENABLE_WEB_WORKER_SUPPORT;
pub const SDO_ENABLE_NONUSER_CODE_SUPPORT = SCRIPT_DEBUGGER_OPTIONS.ENABLE_NONUSER_CODE_SUPPORT;
pub const SDO_ENABLE_LIBRARY_STACK_FRAME = SCRIPT_DEBUGGER_OPTIONS.ENABLE_LIBRARY_STACK_FRAME;

const IID_IRemoteDebugApplication110_Value = Guid.initString("d5fe005b-2836-485e-b1f9-89d91aa24fd4");
pub const IID_IRemoteDebugApplication110 = &IID_IRemoteDebugApplication110_Value;
pub const IRemoteDebugApplication110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebuggerOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication110,
                mask: SCRIPT_DEBUGGER_OPTIONS,
                value: SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication110,
                mask: SCRIPT_DEBUGGER_OPTIONS,
                value: SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentDebuggerOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication110,
                pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication110,
                pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugApplication110,
                ppThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugApplication110,
                ppThread: ?*?*IRemoteDebugApplicationThread,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication110_SetDebuggerOptions(self: *const T, mask: SCRIPT_DEBUGGER_OPTIONS, value: SCRIPT_DEBUGGER_OPTIONS) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).SetDebuggerOptions(@as(*const IRemoteDebugApplication110, @ptrCast(self)), mask, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication110_GetCurrentDebuggerOptions(self: *const T, pCurrentOptions: ?*SCRIPT_DEBUGGER_OPTIONS) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).GetCurrentDebuggerOptions(@as(*const IRemoteDebugApplication110, @ptrCast(self)), pCurrentOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication110_GetMainThread(self: *const T, ppThread: ?*?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugApplication110.VTable, @ptrCast(self.vtable)).GetMainThread(@as(*const IRemoteDebugApplication110, @ptrCast(self)), ppThread);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication11032_Value = Guid.initString("bdb3b5de-89f2-4e11-84a5-97445f941c7d");
pub const IID_IDebugApplication11032 = &IID_IDebugApplication11032_Value;
pub const IDebugApplication11032 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication110.VTable,
        SynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallableWaitForHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11032,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11032,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication110.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11032_SynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).SynchronousCallInMainThread(@as(*const IDebugApplication11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11032_AsynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).AsynchronousCallInMainThread(@as(*const IDebugApplication11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11032_CallableWaitForHandles(self: *const T, handleCount: u32, pHandles: [*]const ?HANDLE, pIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11032.VTable, @ptrCast(self.vtable)).CallableWaitForHandles(@as(*const IDebugApplication11032, @ptrCast(self)), handleCount, pHandles, pIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication11064_Value = Guid.initString("2039d958-4eeb-496a-87bb-2e5201eadeef");
pub const IID_IDebugApplication11064 = &IID_IDebugApplication11064_Value;
pub const IDebugApplication11064 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication110.VTable,
        SynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallInMainThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallableWaitForHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplication11064,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplication11064,
                handleCount: u32,
                pHandles: [*]const ?HANDLE,
                pIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication110.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11064_SynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).SynchronousCallInMainThread(@as(*const IDebugApplication11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11064_AsynchronousCallInMainThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).AsynchronousCallInMainThread(@as(*const IDebugApplication11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication11064_CallableWaitForHandles(self: *const T, handleCount: u32, pHandles: [*]const ?HANDLE, pIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplication11064.VTable, @ptrCast(self.vtable)).CallableWaitForHandles(@as(*const IDebugApplication11064, @ptrCast(self)), handleCount, pHandles, pIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebAppDiagnosticsObjectInitialization_Value = Guid.initString("16ff3a42-a5f5-432b-b625-8e8e16f57e15");
pub const IID_IWebAppDiagnosticsObjectInitialization = &IID_IWebAppDiagnosticsObjectInitialization_Value;
pub const IWebAppDiagnosticsObjectInitialization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWebAppDiagnosticsObjectInitialization,
                hPassedHandle: HANDLE_PTR,
                pDebugApplication: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWebAppDiagnosticsObjectInitialization,
                hPassedHandle: HANDLE_PTR,
                pDebugApplication: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebAppDiagnosticsObjectInitialization_Initialize(self: *const T, hPassedHandle: HANDLE_PTR, pDebugApplication: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IWebAppDiagnosticsObjectInitialization.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IWebAppDiagnosticsObjectInitialization, @ptrCast(self)), hPassedHandle, pDebugApplication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptWinRTErrorDebug_Value = Guid.initString("73a3f82a-0fe9-4b33-ba3b-fe095f697e0a");
pub const IID_IActiveScriptWinRTErrorDebug = &IID_IActiveScriptWinRTErrorDebug_Value;
pub const IActiveScriptWinRTErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetRestrictedErrorString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptWinRTErrorDebug,
                errorString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptWinRTErrorDebug,
                errorString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRestrictedErrorReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptWinRTErrorDebug,
                referenceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptWinRTErrorDebug,
                referenceString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCapabilitySid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptWinRTErrorDebug,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptWinRTErrorDebug,
                capabilitySid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptWinRTErrorDebug_GetRestrictedErrorString(self: *const T, errorString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetRestrictedErrorString(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), errorString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptWinRTErrorDebug_GetRestrictedErrorReference(self: *const T, referenceString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetRestrictedErrorReference(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), referenceString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptWinRTErrorDebug_GetCapabilitySid(self: *const T, capabilitySid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptWinRTErrorDebug.VTable, @ptrCast(self.vtable)).GetCapabilitySid(@as(*const IActiveScriptWinRTErrorDebug, @ptrCast(self)), capabilitySid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND = enum(i32) {
    FIRST_CHANCE = 0,
    USER_UNHANDLED = 1,
    UNHANDLED = 2,
};
pub const ETK_FIRST_CHANCE = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.FIRST_CHANCE;
pub const ETK_USER_UNHANDLED = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.USER_UNHANDLED;
pub const ETK_UNHANDLED = SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND.UNHANDLED;

const IID_IActiveScriptErrorDebug110_Value = Guid.initString("516e42b6-89a8-4530-937b-5f0708431442");
pub const IID_IActiveScriptErrorDebug110 = &IID_IActiveScriptErrorDebug110_Value;
pub const IActiveScriptErrorDebug110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionThrownKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActiveScriptErrorDebug110,
                pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActiveScriptErrorDebug110,
                pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug110_GetExceptionThrownKind(self: *const T, pExceptionKind: ?*SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND) callconv(.Inline) HRESULT {
            return @as(*const IActiveScriptErrorDebug110.VTable, @ptrCast(self.vtable)).GetExceptionThrownKind(@as(*const IActiveScriptErrorDebug110, @ptrCast(self)), pExceptionKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThreadEvents110_Value = Guid.initString("84e5e468-d5da-48a8-83f4-40366429007b");
pub const IID_IDebugApplicationThreadEvents110 = &IID_IDebugApplicationThreadEvents110_Value;
pub const IDebugApplicationThreadEvents110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSuspendForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnResumeFromBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnThreadRequestComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnBeginThreadRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThreadEvents110,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThreadEvents110_OnSuspendForBreakPoint(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnSuspendForBreakPoint(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThreadEvents110_OnResumeFromBreakPoint(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnResumeFromBreakPoint(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThreadEvents110_OnThreadRequestComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnThreadRequestComplete(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThreadEvents110_OnBeginThreadRequest(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThreadEvents110.VTable, @ptrCast(self.vtable)).OnBeginThreadRequest(@as(*const IDebugApplicationThreadEvents110, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread11032_Value = Guid.initString("2194ac5c-6561-404a-a2e9-f57d72de3702");
pub const IID_IDebugApplicationThread11032 = &IID_IDebugApplicationThread11032_Value;
pub const IDebugApplicationThread11032 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveThreadRequestCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11032,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11032,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSuspendedForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11032,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11032,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadCallable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11032,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11032,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallIntoThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11032,
                pptc: ?*IDebugThreadCall32,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11032_GetActiveThreadRequestCount(self: *const T, puiThreadRequests: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).GetActiveThreadRequestCount(@as(*const IDebugApplicationThread11032, @ptrCast(self)), puiThreadRequests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11032_IsSuspendedForBreakPoint(self: *const T, pfIsSuspended: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).IsSuspendedForBreakPoint(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pfIsSuspended);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11032_IsThreadCallable(self: *const T, pfIsCallable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).IsThreadCallable(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pfIsCallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11032_AsynchronousCallIntoThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11032.VTable, @ptrCast(self.vtable)).AsynchronousCallIntoThread(@as(*const IDebugApplicationThread11032, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread11064_Value = Guid.initString("420aa4cc-efd8-4dac-983b-47127826917d");
pub const IID_IDebugApplicationThread11064 = &IID_IDebugApplicationThread11064_Value;
pub const IDebugApplicationThread11064 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveThreadRequestCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11064,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11064,
                puiThreadRequests: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSuspendedForBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11064,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11064,
                pfIsSuspended: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsThreadCallable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11064,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11064,
                pfIsCallable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AsynchronousCallIntoThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugApplicationThread11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugApplicationThread11064,
                pptc: ?*IDebugThreadCall64,
                dwParam1: usize,
                dwParam2: usize,
                dwParam3: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11064_GetActiveThreadRequestCount(self: *const T, puiThreadRequests: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).GetActiveThreadRequestCount(@as(*const IDebugApplicationThread11064, @ptrCast(self)), puiThreadRequests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11064_IsSuspendedForBreakPoint(self: *const T, pfIsSuspended: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).IsSuspendedForBreakPoint(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pfIsSuspended);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11064_IsThreadCallable(self: *const T, pfIsCallable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).IsThreadCallable(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pfIsCallable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread11064_AsynchronousCallIntoThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: usize, dwParam2: usize, dwParam3: usize) callconv(.Inline) HRESULT {
            return @as(*const IDebugApplicationThread11064.VTable, @ptrCast(self.vtable)).AsynchronousCallIntoThread(@as(*const IDebugApplicationThread11064, @ptrCast(self)), pptc, dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugCriticalErrorEvent110_Value = Guid.initString("2f69c611-6b14-47e8-9260-4bb7c52f504b");
pub const IID_IRemoteDebugCriticalErrorEvent110 = &IID_IRemoteDebugCriticalErrorEvent110_Value;
pub const IRemoteDebugCriticalErrorEvent110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugCriticalErrorEvent110,
                pbstrSource: ?*?BSTR,
                pMessageId: ?*i32,
                pbstrMessage: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugCriticalErrorEvent110,
                pbstrSource: ?*?BSTR,
                pMessageId: ?*i32,
                pbstrMessage: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugCriticalErrorEvent110_GetErrorInfo(self: *const T, pbstrSource: ?*?BSTR, pMessageId: ?*i32, pbstrMessage: ?*?BSTR, ppLocation: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugCriticalErrorEvent110.VTable, @ptrCast(self.vtable)).GetErrorInfo(@as(*const IRemoteDebugCriticalErrorEvent110, @ptrCast(self)), pbstrSource, pMessageId, pbstrMessage, ppLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SCRIPT_INVOCATION_CONTEXT_TYPE = enum(i32) {
    Event = 0,
    SetTimeout = 1,
    SetInterval = 2,
    SetImmediate = 3,
    RequestAnimationFrame = 4,
    ToString = 5,
    MutationObserverCheckpoint = 6,
    WWAExecUnsafeLocalFunction = 7,
    WWAExecAtPriority = 8,
};
pub const SICT_Event = SCRIPT_INVOCATION_CONTEXT_TYPE.Event;
pub const SICT_SetTimeout = SCRIPT_INVOCATION_CONTEXT_TYPE.SetTimeout;
pub const SICT_SetInterval = SCRIPT_INVOCATION_CONTEXT_TYPE.SetInterval;
pub const SICT_SetImmediate = SCRIPT_INVOCATION_CONTEXT_TYPE.SetImmediate;
pub const SICT_RequestAnimationFrame = SCRIPT_INVOCATION_CONTEXT_TYPE.RequestAnimationFrame;
pub const SICT_ToString = SCRIPT_INVOCATION_CONTEXT_TYPE.ToString;
pub const SICT_MutationObserverCheckpoint = SCRIPT_INVOCATION_CONTEXT_TYPE.MutationObserverCheckpoint;
pub const SICT_WWAExecUnsafeLocalFunction = SCRIPT_INVOCATION_CONTEXT_TYPE.WWAExecUnsafeLocalFunction;
pub const SICT_WWAExecAtPriority = SCRIPT_INVOCATION_CONTEXT_TYPE.WWAExecAtPriority;

const IID_IScriptInvocationContext_Value = Guid.initString("5d7741b7-af7e-4a2a-85e5-c77f4d0659fb");
pub const IID_IScriptInvocationContext = &IID_IScriptInvocationContext_Value;
pub const IScriptInvocationContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContextType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptInvocationContext,
                pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptInvocationContext,
                pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptInvocationContext,
                pDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptInvocationContext,
                pDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScriptInvocationContext,
                ppContextObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScriptInvocationContext,
                ppContextObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptInvocationContext_GetContextType(self: *const T, pInvocationContextType: ?*SCRIPT_INVOCATION_CONTEXT_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextType(@as(*const IScriptInvocationContext, @ptrCast(self)), pInvocationContextType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptInvocationContext_GetContextDescription(self: *const T, pDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextDescription(@as(*const IScriptInvocationContext, @ptrCast(self)), pDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptInvocationContext_GetContextObject(self: *const T, ppContextObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IScriptInvocationContext.VTable, @ptrCast(self.vtable)).GetContextObject(@as(*const IScriptInvocationContext, @ptrCast(self)), ppContextObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_STACKFRAME_TYPE = enum(i32) {
    SCRIPT_FRAME = 0,
    INTERNAL_FRAME = 1,
    INVOCATION_FRAME = 2,
};
pub const DST_SCRIPT_FRAME = DEBUG_STACKFRAME_TYPE.SCRIPT_FRAME;
pub const DST_INTERNAL_FRAME = DEBUG_STACKFRAME_TYPE.INTERNAL_FRAME;
pub const DST_INVOCATION_FRAME = DEBUG_STACKFRAME_TYPE.INVOCATION_FRAME;

const IID_IDebugStackFrame110_Value = Guid.initString("4b509611-b6ea-4b24-adcb-d0ccfd1a7e33");
pub const IID_IDebugStackFrame110 = &IID_IDebugStackFrame110_Value;
pub const IDebugStackFrame110 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrame.VTable,
        GetStackFrameType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame110,
                pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame110,
                pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScriptInvocationContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugStackFrame110,
                ppInvocationContext: ?*?*IScriptInvocationContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugStackFrame110,
                ppInvocationContext: ?*?*IScriptInvocationContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrame.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame110_GetStackFrameType(self: *const T, pStackFrameKind: ?*DEBUG_STACKFRAME_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame110.VTable, @ptrCast(self.vtable)).GetStackFrameType(@as(*const IDebugStackFrame110, @ptrCast(self)), pStackFrameKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame110_GetScriptInvocationContext(self: *const T, ppInvocationContext: ?*?*IScriptInvocationContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugStackFrame110.VTable, @ptrCast(self.vtable)).GetScriptInvocationContext(@as(*const IDebugStackFrame110, @ptrCast(self)), ppInvocationContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_EVENT_INFO_TYPE = enum(i32) {
    GENERAL = 0,
    ASMJS_IN_DEBUGGING = 1,
    ASMJS_SUCCEEDED = 2,
    ASMJS_FAILED = 3,
};
pub const DEIT_GENERAL = DEBUG_EVENT_INFO_TYPE.GENERAL;
pub const DEIT_ASMJS_IN_DEBUGGING = DEBUG_EVENT_INFO_TYPE.ASMJS_IN_DEBUGGING;
pub const DEIT_ASMJS_SUCCEEDED = DEBUG_EVENT_INFO_TYPE.ASMJS_SUCCEEDED;
pub const DEIT_ASMJS_FAILED = DEBUG_EVENT_INFO_TYPE.ASMJS_FAILED;

const IID_IRemoteDebugInfoEvent110_Value = Guid.initString("9ff56bb6-eb89-4c0f-8823-cc2a4c0b7f26");
pub const IID_IRemoteDebugInfoEvent110 = &IID_IRemoteDebugInfoEvent110_Value;
pub const IRemoteDebugInfoEvent110 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRemoteDebugInfoEvent110,
                pMessageType: ?*DEBUG_EVENT_INFO_TYPE,
                pbstrMessage: ?*?BSTR,
                pbstrUrl: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRemoteDebugInfoEvent110,
                pMessageType: ?*DEBUG_EVENT_INFO_TYPE,
                pbstrMessage: ?*?BSTR,
                pbstrUrl: ?*?BSTR,
                ppLocation: ?*?*IDebugDocumentContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugInfoEvent110_GetEventInfo(self: *const T, pMessageType: ?*DEBUG_EVENT_INFO_TYPE, pbstrMessage: ?*?BSTR, pbstrUrl: ?*?BSTR, ppLocation: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @as(*const IRemoteDebugInfoEvent110.VTable, @ptrCast(self.vtable)).GetEventInfo(@as(*const IRemoteDebugInfoEvent110, @ptrCast(self)), pMessageType, pbstrMessage, pbstrUrl, ppLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebug_Value = Guid.initString("be0e89da-2ac5-4c04-ac5e-59956aae3613");
pub const IID_IJsDebug = &IID_IJsDebug_Value;
pub const IJsDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenVirtualProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebug,
                processId: u32,
                runtimeJsBaseAddress: u64,
                pDataTarget: ?*IJsDebugDataTarget,
                ppProcess: ?*?*IJsDebugProcess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebug,
                processId: u32,
                runtimeJsBaseAddress: u64,
                pDataTarget: ?*IJsDebugDataTarget,
                ppProcess: ?*?*IJsDebugProcess,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebug_OpenVirtualProcess(self: *const T, processId: u32, runtimeJsBaseAddress: u64, pDataTarget: ?*IJsDebugDataTarget, ppProcess: ?*?*IJsDebugProcess) callconv(.Inline) HRESULT {
            return @as(*const IJsDebug.VTable, @ptrCast(self.vtable)).OpenVirtualProcess(@as(*const IJsDebug, @ptrCast(self)), processId, runtimeJsBaseAddress, pDataTarget, ppProcess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugProcess_Value = Guid.initString("3d587168-6a2d-4041-bd3b-0de674502862");
pub const IID_IJsDebugProcess = &IID_IJsDebugProcess_Value;
pub const IJsDebugProcess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStackWalker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProcess,
                threadId: u32,
                ppStackWalker: ?*?*IJsDebugStackWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProcess,
                threadId: u32,
                ppStackWalker: ?*?*IJsDebugStackWalker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateBreakPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProcess,
                documentId: u64,
                characterOffset: u32,
                characterCount: u32,
                isEnabled: BOOL,
                ppDebugBreakPoint: ?*?*IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProcess,
                documentId: u64,
                characterOffset: u32,
                characterCount: u32,
                isEnabled: BOOL,
                ppDebugBreakPoint: ?*?*IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PerformAsyncBreak: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProcess,
                threadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProcess,
                threadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExternalStepAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProcess,
                pCodeAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProcess,
                pCodeAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProcess_CreateStackWalker(self: *const T, threadId: u32, ppStackWalker: ?*?*IJsDebugStackWalker) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).CreateStackWalker(@as(*const IJsDebugProcess, @ptrCast(self)), threadId, ppStackWalker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProcess_CreateBreakPoint(self: *const T, documentId: u64, characterOffset: u32, characterCount: u32, isEnabled: BOOL, ppDebugBreakPoint: ?*?*IJsDebugBreakPoint) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).CreateBreakPoint(@as(*const IJsDebugProcess, @ptrCast(self)), documentId, characterOffset, characterCount, isEnabled, ppDebugBreakPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProcess_PerformAsyncBreak(self: *const T, threadId: u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).PerformAsyncBreak(@as(*const IJsDebugProcess, @ptrCast(self)), threadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProcess_GetExternalStepAddress(self: *const T, pCodeAddress: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProcess.VTable, @ptrCast(self.vtable)).GetExternalStepAddress(@as(*const IJsDebugProcess, @ptrCast(self)), pCodeAddress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugStackWalker_Value = Guid.initString("db24b094-73c4-456c-a4ec-e90ea00bdfe3");
pub const IID_IJsDebugStackWalker = &IID_IJsDebugStackWalker_Value;
pub const IJsDebugStackWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugStackWalker,
                ppFrame: ?*?*IJsDebugFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugStackWalker,
                ppFrame: ?*?*IJsDebugFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugStackWalker_GetNext(self: *const T, ppFrame: ?*?*IJsDebugFrame) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugStackWalker.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IJsDebugStackWalker, @ptrCast(self)), ppFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugFrame_Value = Guid.initString("c9196637-ab9d-44b2-bad2-13b95b3f390e");
pub const IID_IJsDebugFrame = &IID_IJsDebugFrame_Value;
pub const IJsDebugFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStackRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pStart: ?*u64,
                pEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pStart: ?*u64,
                pEnd: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPositionWithId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPositionWithName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pDocumentName: ?*?BSTR,
                pLine: ?*u32,
                pColumn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pDocumentName: ?*?BSTR,
                pLine: ?*u32,
                pColumn: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebugProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                ppDebugProperty: ?*?*IJsDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                ppDebugProperty: ?*?*IJsDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pReturnAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pReturnAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugFrame,
                pExpressionText: ?[*:0]align(1) const u16,
                ppDebugProperty: ?*?*IJsDebugProperty,
                pError: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugFrame,
                pExpressionText: ?[*:0]align(1) const u16,
                ppDebugProperty: ?*?*IJsDebugProperty,
                pError: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetStackRange(self: *const T, pStart: ?*u64, pEnd: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetStackRange(@as(*const IJsDebugFrame, @ptrCast(self)), pStart, pEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetName(@as(*const IJsDebugFrame, @ptrCast(self)), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetDocumentPositionWithId(self: *const T, pDocumentId: ?*u64, pCharacterOffset: ?*u32, pStatementCharCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDocumentPositionWithId(@as(*const IJsDebugFrame, @ptrCast(self)), pDocumentId, pCharacterOffset, pStatementCharCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetDocumentPositionWithName(self: *const T, pDocumentName: ?*?BSTR, pLine: ?*u32, pColumn: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDocumentPositionWithName(@as(*const IJsDebugFrame, @ptrCast(self)), pDocumentName, pLine, pColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetDebugProperty(self: *const T, ppDebugProperty: ?*?*IJsDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetDebugProperty(@as(*const IJsDebugFrame, @ptrCast(self)), ppDebugProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_GetReturnAddress(self: *const T, pReturnAddress: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).GetReturnAddress(@as(*const IJsDebugFrame, @ptrCast(self)), pReturnAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugFrame_Evaluate(self: *const T, pExpressionText: ?[*:0]align(1) const u16, ppDebugProperty: ?*?*IJsDebugProperty, pError: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugFrame.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IJsDebugFrame, @ptrCast(self)), pExpressionText, ppDebugProperty, pError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const JS_PROPERTY_MEMBERS = enum(i32) {
    LL = 0,
    RGUMENTS = 1,
};
pub const JS_PROPERTY_MEMBERS_ALL = JS_PROPERTY_MEMBERS.LL;
pub const JS_PROPERTY_MEMBERS_ARGUMENTS = JS_PROPERTY_MEMBERS.RGUMENTS;

pub const JS_PROPERTY_ATTRIBUTES = enum(i32) {
    ATTRIBUTE_NONE = 0,
    HAS_CHILDREN = 1,
    FAKE = 2,
    METHOD = 4,
    READONLY = 8,
    NATIVE_WINRT_POINTER = 16,
    FRAME_INTRYBLOCK = 32,
    FRAME_INCATCHBLOCK = 64,
    FRAME_INFINALLYBLOCK = 128,
};
pub const JS_PROPERTY_ATTRIBUTE_NONE = JS_PROPERTY_ATTRIBUTES.ATTRIBUTE_NONE;
pub const JS_PROPERTY_HAS_CHILDREN = JS_PROPERTY_ATTRIBUTES.HAS_CHILDREN;
pub const JS_PROPERTY_FAKE = JS_PROPERTY_ATTRIBUTES.FAKE;
pub const JS_PROPERTY_METHOD = JS_PROPERTY_ATTRIBUTES.METHOD;
pub const JS_PROPERTY_READONLY = JS_PROPERTY_ATTRIBUTES.READONLY;
pub const JS_PROPERTY_NATIVE_WINRT_POINTER = JS_PROPERTY_ATTRIBUTES.NATIVE_WINRT_POINTER;
pub const JS_PROPERTY_FRAME_INTRYBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INTRYBLOCK;
pub const JS_PROPERTY_FRAME_INCATCHBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INCATCHBLOCK;
pub const JS_PROPERTY_FRAME_INFINALLYBLOCK = JS_PROPERTY_ATTRIBUTES.FRAME_INFINALLYBLOCK;

pub const JsDebugPropertyInfo = extern struct {
    name: ?BSTR,
    type: ?BSTR,
    value: ?BSTR,
    fullName: ?BSTR,
    attr: JS_PROPERTY_ATTRIBUTES,
};

const IID_IJsDebugProperty_Value = Guid.initString("f8ffcf2b-3aa4-4320-85c3-52a312ba9633");
pub const IID_IJsDebugProperty = &IID_IJsDebugProperty_Value;
pub const IJsDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProperty,
                nRadix: u32,
                pPropertyInfo: ?*JsDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProperty,
                nRadix: u32,
                pPropertyInfo: ?*JsDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugProperty,
                members: JS_PROPERTY_MEMBERS,
                ppEnum: ?*?*IJsEnumDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugProperty,
                members: JS_PROPERTY_MEMBERS,
                ppEnum: ?*?*IJsEnumDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProperty_GetPropertyInfo(self: *const T, nRadix: u32, pPropertyInfo: ?*JsDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProperty.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IJsDebugProperty, @ptrCast(self)), nRadix, pPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugProperty_GetMembers(self: *const T, members: JS_PROPERTY_MEMBERS, ppEnum: ?*?*IJsEnumDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugProperty.VTable, @ptrCast(self.vtable)).GetMembers(@as(*const IJsDebugProperty, @ptrCast(self)), members, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsEnumDebugProperty_Value = Guid.initString("4092432f-2f0f-4fe1-b638-5b74a52cdcbe");
pub const IID_IJsEnumDebugProperty = &IID_IJsEnumDebugProperty_Value;
pub const IJsEnumDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsEnumDebugProperty,
                count: u32,
                ppDebugProperty: [*]?*IJsDebugProperty,
                pActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsEnumDebugProperty,
                count: u32,
                ppDebugProperty: [*]?*IJsDebugProperty,
                pActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsEnumDebugProperty,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsEnumDebugProperty,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsEnumDebugProperty_Next(self: *const T, count: u32, ppDebugProperty: [*]?*IJsDebugProperty, pActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsEnumDebugProperty.VTable, @ptrCast(self.vtable)).Next(@as(*const IJsEnumDebugProperty, @ptrCast(self)), count, ppDebugProperty, pActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsEnumDebugProperty_GetCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsEnumDebugProperty.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IJsEnumDebugProperty, @ptrCast(self)), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IJsDebugBreakPoint_Value = Guid.initString("df6773e3-ed8d-488b-8a3e-5812577d1542");
pub const IID_IJsDebugBreakPoint = &IID_IJsDebugBreakPoint_Value;
pub const IJsDebugBreakPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugBreakPoint,
                pIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugBreakPoint,
                pIsEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugBreakPoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDocumentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugBreakPoint,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugBreakPoint,
                pDocumentId: ?*u64,
                pCharacterOffset: ?*u32,
                pStatementCharCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugBreakPoint_IsEnabled(self: *const T, pIsEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IJsDebugBreakPoint, @ptrCast(self)), pIsEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugBreakPoint_Enable(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Enable(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugBreakPoint_Disable(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Disable(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugBreakPoint_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).Delete(@as(*const IJsDebugBreakPoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugBreakPoint_GetDocumentPosition(self: *const T, pDocumentId: ?*u64, pCharacterOffset: ?*u32, pStatementCharCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugBreakPoint.VTable, @ptrCast(self.vtable)).GetDocumentPosition(@as(*const IJsDebugBreakPoint, @ptrCast(self)), pDocumentId, pCharacterOffset, pStatementCharCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const JS_NATIVE_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
};

const IID_IEnumJsStackFrames_Value = Guid.initString("5e7da34b-fb51-4791-abe7-cb5bdf419755");
pub const IID_IEnumJsStackFrames = &IID_IEnumJsStackFrames_Value;
pub const IEnumJsStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumJsStackFrames,
                cFrameCount: u32,
                pFrames: [*]JS_NATIVE_FRAME,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumJsStackFrames,
                cFrameCount: u32,
                pFrames: [*]JS_NATIVE_FRAME,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumJsStackFrames_Next(self: *const T, cFrameCount: u32, pFrames: [*]JS_NATIVE_FRAME, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumJsStackFrames.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumJsStackFrames, @ptrCast(self)), cFrameCount, pFrames, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumJsStackFrames_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumJsStackFrames.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumJsStackFrames, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const JsDebugReadMemoryFlags = enum(i32) {
    None = 0,
    d = 1,
};
// NOTE: not creating aliases because this enum is 'Scoped'

const IID_IJsDebugDataTarget_Value = Guid.initString("53b28977-53a1-48e5-9000-5d0dfa893931");
pub const IID_IJsDebugDataTarget = &IID_IJsDebugDataTarget_Value;
pub const IJsDebugDataTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                flags: JsDebugReadMemoryFlags,
                pBuffer: [*:0]u8,
                size: u32,
                pBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                flags: JsDebugReadMemoryFlags,
                pBuffer: [*:0]u8,
                size: u32,
                pBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                pMemory: [*:0]u8,
                size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                pMemory: [*:0]u8,
                size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateVirtualMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                allocationType: u32,
                pageProtection: u32,
                pAllocatedAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                allocationType: u32,
                pageProtection: u32,
                pAllocatedAddress: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeVirtualMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                freeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                size: u32,
                freeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTlsValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                tlsIndex: u32,
                pValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                tlsIndex: u32,
                pValue: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBSTR: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadNullTerminatedString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                characterSize: u16,
                maxCharacters: u32,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                address: u64,
                characterSize: u16,
                maxCharacters: u32,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStackFrameEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                ppEnumerator: ?*?*IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                ppEnumerator: ?*?*IEnumJsStackFrames,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                contextFlags: u32,
                contextSize: u32,
                pContext: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IJsDebugDataTarget,
                threadId: u32,
                contextFlags: u32,
                contextSize: u32,
                pContext: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_ReadMemory(self: *const T, address: u64, flags: JsDebugReadMemoryFlags, pBuffer: [*:0]u8, size: u32, pBytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, flags, pBuffer, size, pBytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_WriteMemory(self: *const T, address: u64, pMemory: [*:0]u8, size: u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).WriteMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, pMemory, size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_AllocateVirtualMemory(self: *const T, address: u64, size: u32, allocationType: u32, pageProtection: u32, pAllocatedAddress: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).AllocateVirtualMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, size, allocationType, pageProtection, pAllocatedAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_FreeVirtualMemory(self: *const T, address: u64, size: u32, freeType: u32) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).FreeVirtualMemory(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, size, freeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_GetTlsValue(self: *const T, threadId: u32, tlsIndex: u32, pValue: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).GetTlsValue(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, tlsIndex, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_ReadBSTR(self: *const T, address: u64, pString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadBSTR(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, pString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_ReadNullTerminatedString(self: *const T, address: u64, characterSize: u16, maxCharacters: u32, pString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).ReadNullTerminatedString(@as(*const IJsDebugDataTarget, @ptrCast(self)), address, characterSize, maxCharacters, pString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_CreateStackFrameEnumerator(self: *const T, threadId: u32, ppEnumerator: ?*?*IEnumJsStackFrames) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).CreateStackFrameEnumerator(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, ppEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IJsDebugDataTarget_GetThreadContext(self: *const T, threadId: u32, contextFlags: u32, contextSize: u32, pContext: [*]u8) callconv(.Inline) HRESULT {
            return @as(*const IJsDebugDataTarget.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IJsDebugDataTarget, @ptrCast(self)), threadId, contextFlags, contextSize, pContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (19)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../../zig.zig").Guid;
const BOOL = @import("../../../../../windows/win32/foundation.zig").BOOL;
const BSTR = @import("../../../../../windows/win32/foundation.zig").BSTR;
const DISPPARAMS = @import("../../../../../windows/win32/system/com.zig").DISPPARAMS;
const EXCEPINFO = @import("../../../../../windows/win32/system/com.zig").EXCEPINFO;
const HANDLE = @import("../../../../../windows/win32/foundation.zig").HANDLE;
const HANDLE_PTR = @import("../../../../../windows/win32/foundation.zig").HANDLE_PTR;
const HRESULT = @import("../../../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../../../windows/win32/foundation.zig").HWND;
const IDebugProperty = @import("../../../../../windows/win32/system/diagnostics/debug.zig").IDebugProperty;
const IDispatch = @import("../../../../../windows/win32/system/com.zig").IDispatch;
const ITypeInfo = @import("../../../../../windows/win32/system/com.zig").ITypeInfo;
const IUnknown = @import("../../../../../windows/win32/system/com.zig").IUnknown;
const PSTR = @import("../../../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../../../windows/win32/foundation.zig").PWSTR;
const TYPEDESC = @import("../../../../../windows/win32/system/com.zig").TYPEDESC;
const VARENUM = @import("../../../../../windows/win32/system/variant.zig").VARENUM;
const VARIANT = @import("../../../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../../../windows/win32/foundation.zig").VARIANT_BOOL;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
