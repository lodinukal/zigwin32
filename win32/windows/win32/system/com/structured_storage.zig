//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (66)
//--------------------------------------------------------------------------------
pub const PROPSETFLAG_DEFAULT = @as(u32, 0);
pub const PROPSETFLAG_NONSIMPLE = @as(u32, 1);
pub const PROPSETFLAG_ANSI = @as(u32, 2);
pub const PROPSETFLAG_UNBUFFERED = @as(u32, 4);
pub const PROPSETFLAG_CASE_SENSITIVE = @as(u32, 8);
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE = @as(u32, 1);
pub const PID_DICTIONARY = @as(u32, 0);
pub const PID_CODEPAGE = @as(u32, 1);
pub const PID_FIRST_USABLE = @as(u32, 2);
pub const PID_FIRST_NAME_DEFAULT = @as(u32, 4095);
pub const PID_LOCALE = @as(u32, 2147483648);
pub const PID_MODIFY_TIME = @as(u32, 2147483649);
pub const PID_SECURITY = @as(u32, 2147483650);
pub const PID_BEHAVIOR = @as(u32, 2147483651);
pub const PID_ILLEGAL = @as(u32, 4294967295);
pub const PID_MIN_READONLY = @as(u32, 2147483648);
pub const PID_MAX_READONLY = @as(u32, 3221225471);
pub const PRSPEC_INVALID = @as(u32, 4294967295);
pub const PROPSETHDR_OSVERSION_UNKNOWN = @as(u32, 4294967295);
pub const PIDDI_THUMBNAIL = @as(i32, 2);
pub const PIDSI_TITLE = @as(i32, 2);
pub const PIDSI_SUBJECT = @as(i32, 3);
pub const PIDSI_AUTHOR = @as(i32, 4);
pub const PIDSI_KEYWORDS = @as(i32, 5);
pub const PIDSI_COMMENTS = @as(i32, 6);
pub const PIDSI_TEMPLATE = @as(i32, 7);
pub const PIDSI_LASTAUTHOR = @as(i32, 8);
pub const PIDSI_REVNUMBER = @as(i32, 9);
pub const PIDSI_EDITTIME = @as(i32, 10);
pub const PIDSI_LASTPRINTED = @as(i32, 11);
pub const PIDSI_CREATE_DTM = @as(i32, 12);
pub const PIDSI_LASTSAVE_DTM = @as(i32, 13);
pub const PIDSI_PAGECOUNT = @as(i32, 14);
pub const PIDSI_WORDCOUNT = @as(i32, 15);
pub const PIDSI_CHARCOUNT = @as(i32, 16);
pub const PIDSI_THUMBNAIL = @as(i32, 17);
pub const PIDSI_APPNAME = @as(i32, 18);
pub const PIDSI_DOC_SECURITY = @as(i32, 19);
pub const PIDDSI_CATEGORY = @as(u32, 2);
pub const PIDDSI_PRESFORMAT = @as(u32, 3);
pub const PIDDSI_BYTECOUNT = @as(u32, 4);
pub const PIDDSI_LINECOUNT = @as(u32, 5);
pub const PIDDSI_PARCOUNT = @as(u32, 6);
pub const PIDDSI_SLIDECOUNT = @as(u32, 7);
pub const PIDDSI_NOTECOUNT = @as(u32, 8);
pub const PIDDSI_HIDDENCOUNT = @as(u32, 9);
pub const PIDDSI_MMCLIPCOUNT = @as(u32, 10);
pub const PIDDSI_SCALE = @as(u32, 11);
pub const PIDDSI_HEADINGPAIR = @as(u32, 12);
pub const PIDDSI_DOCPARTS = @as(u32, 13);
pub const PIDDSI_MANAGER = @as(u32, 14);
pub const PIDDSI_COMPANY = @as(u32, 15);
pub const PIDDSI_LINKSDIRTY = @as(u32, 16);
pub const PIDMSI_EDITOR = @as(i32, 2);
pub const PIDMSI_SUPPLIER = @as(i32, 3);
pub const PIDMSI_SOURCE = @as(i32, 4);
pub const PIDMSI_SEQUENCE_NO = @as(i32, 5);
pub const PIDMSI_PROJECT = @as(i32, 6);
pub const PIDMSI_STATUS = @as(i32, 7);
pub const PIDMSI_OWNER = @as(i32, 8);
pub const PIDMSI_RATING = @as(i32, 9);
pub const PIDMSI_PRODUCTION = @as(i32, 10);
pub const PIDMSI_COPYRIGHT = @as(i32, 11);
pub const CWCSTORAGENAME = @as(u32, 32);
pub const STGOPTIONS_VERSION = @as(u32, 1);
pub const CCH_MAX_PROPSTG_NAME = @as(u32, 31);

//--------------------------------------------------------------------------------
// Section: Types (56)
//--------------------------------------------------------------------------------
pub const PROPSPEC_KIND = enum(u32) {
    LPWSTR = 0,
    PROPID = 1,
};
pub const PRSPEC_LPWSTR = PROPSPEC_KIND.LPWSTR;
pub const PRSPEC_PROPID = PROPSPEC_KIND.PROPID;

pub const STGFMT = enum(u32) {
    STORAGE = 0,
    NATIVE = 1,
    FILE = 3,
    ANY = 4,
    DOCFILE = 5,
    // DOCUMENT = 0, this enum value conflicts with STORAGE
};
pub const STGFMT_STORAGE = STGFMT.STORAGE;
pub const STGFMT_NATIVE = STGFMT.NATIVE;
pub const STGFMT_FILE = STGFMT.FILE;
pub const STGFMT_ANY = STGFMT.ANY;
pub const STGFMT_DOCFILE = STGFMT.DOCFILE;
pub const STGFMT_DOCUMENT = STGFMT.STORAGE;

pub const STGMOVE = enum(i32) {
    MOVE = 0,
    COPY = 1,
    SHALLOWCOPY = 2,
};
pub const STGMOVE_MOVE = STGMOVE.MOVE;
pub const STGMOVE_COPY = STGMOVE.COPY;
pub const STGMOVE_SHALLOWCOPY = STGMOVE.SHALLOWCOPY;

pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: ?*u8,
};

pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: ?*u8,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATSTG_Value = Guid.initString("0000000d-0000-0000-c000-000000000046");
pub const IID_IEnumSTATSTG = &IID_IEnumSTATSTG_Value;
pub const IEnumSTATSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                celt: u32,
                rgelt: [*]STATSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                celt: u32,
                rgelt: [*]STATSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATSTG,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATSTG,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Next(self: *const T, celt: u32, rgelt: [*]STATSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RemSNB = extern struct {
    ulCntStr: u32,
    ulCntChar: u32,
    rgString: [1]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStorage_Value = Guid.initString("0000000b-0000-0000-c000-000000000046");
pub const IID_IStorage = &IID_IStorage_Value;
pub const IStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                reserved1: ?*anyopaque,
                grfMode: STGM,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                reserved1: ?*anyopaque,
                grfMode: STGM,
                reserved2: u32,
                ppstm: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                grfMode: STGM,
                reserved1: u32,
                reserved2: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pstgPriority: ?*IStorage,
                grfMode: STGM,
                snbExclude: ?*?*u16,
                reserved: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pstgPriority: ?*IStorage,
                grfMode: STGM,
                snbExclude: ?*?*u16,
                reserved: u32,
                ppstg: ?*?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                ciidExclude: u32,
                rgiidExclude: ?[*]const Guid,
                snbExclude: ?*?*u16,
                pstgDest: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                ciidExclude: u32,
                rgiidExclude: ?[*]const Guid,
                snbExclude: ?*?*u16,
                pstgDest: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MoveElementTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pstgDest: ?*IStorage,
                pwcsNewName: ?[*:0]align(1) const u16,
                grfFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pstgDest: ?*IStorage,
                pwcsNewName: ?[*:0]align(1) const u16,
                grfFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                reserved1: u32,
                reserved2: ?*anyopaque,
                reserved3: u32,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                reserved1: u32,
                reserved2: ?*anyopaque,
                reserved3: u32,
                ppenum: ?*?*IEnumSTATSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenameElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsOldName: ?[*:0]align(1) const u16,
                pwcsNewName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsOldName: ?[*:0]align(1) const u16,
                pwcsNewName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetElementTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pwcsName: ?[*:0]align(1) const u16,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStateBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                grfStateBits: u32,
                grfMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                grfStateBits: u32,
                grfMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStorage,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStorage,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStream(self: *const T, pwcsName: ?[*:0]align(1) const u16, grfMode: STGM, reserved1: u32, reserved2: u32, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStream(@as(*const IStorage, @ptrCast(self)), pwcsName, grfMode, reserved1, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStream(self: *const T, pwcsName: ?[*:0]align(1) const u16, reserved1: ?*anyopaque, grfMode: STGM, reserved2: u32, ppstm: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStream(@as(*const IStorage, @ptrCast(self)), pwcsName, reserved1, grfMode, reserved2, ppstm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CreateStorage(self: *const T, pwcsName: ?[*:0]align(1) const u16, grfMode: STGM, reserved1: u32, reserved2: u32, ppstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CreateStorage(@as(*const IStorage, @ptrCast(self)), pwcsName, grfMode, reserved1, reserved2, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_OpenStorage(self: *const T, pwcsName: ?[*:0]align(1) const u16, pstgPriority: ?*IStorage, grfMode: STGM, snbExclude: ?*?*u16, reserved: u32, ppstg: ?*?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).OpenStorage(@as(*const IStorage, @ptrCast(self)), pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_CopyTo(self: *const T, ciidExclude: u32, rgiidExclude: ?[*]const Guid, snbExclude: ?*?*u16, pstgDest: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).CopyTo(@as(*const IStorage, @ptrCast(self)), ciidExclude, rgiidExclude, snbExclude, pstgDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_MoveElementTo(self: *const T, pwcsName: ?[*:0]align(1) const u16, pstgDest: ?*IStorage, pwcsNewName: ?[*:0]align(1) const u16, grfFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).MoveElementTo(@as(*const IStorage, @ptrCast(self)), pwcsName, pstgDest, pwcsNewName, grfFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IStorage, @ptrCast(self)), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_EnumElements(self: *const T, reserved1: u32, reserved2: ?*anyopaque, reserved3: u32, ppenum: ?*?*IEnumSTATSTG) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).EnumElements(@as(*const IStorage, @ptrCast(self)), reserved1, reserved2, reserved3, ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_DestroyElement(self: *const T, pwcsName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).DestroyElement(@as(*const IStorage, @ptrCast(self)), pwcsName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_RenameElement(self: *const T, pwcsOldName: ?[*:0]align(1) const u16, pwcsNewName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).RenameElement(@as(*const IStorage, @ptrCast(self)), pwcsOldName, pwcsNewName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetElementTimes(self: *const T, pwcsName: ?[*:0]align(1) const u16, pctime: ?*const FILETIME, patime: ?*const FILETIME, pmtime: ?*const FILETIME) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetElementTimes(@as(*const IStorage, @ptrCast(self)), pwcsName, pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetClass(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IStorage, @ptrCast(self)), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_SetStateBits(self: *const T, grfStateBits: u32, grfMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).SetStateBits(@as(*const IStorage, @ptrCast(self)), grfStateBits, grfMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStorage_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const IStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IStorage, @ptrCast(self)), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistStorage_Value = Guid.initString("0000010a-0000-0000-c000-000000000046");
pub const IID_IPersistStorage = &IID_IPersistStorage_Value;
pub const IPersistStorage = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        IsDirty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStg: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStgSave: ?*IStorage,
                fSameAsLoad: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStgSave: ?*IStorage,
                fSameAsLoad: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveCompleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
                pStgNew: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
                pStgNew: ?*IStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandsOffStorage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_IsDirty(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).IsDirty(@as(*const IPersistStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_InitNew(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistStorage, @ptrCast(self)), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Load(self: *const T, pStg: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistStorage, @ptrCast(self)), pStg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_Save(self: *const T, pStgSave: ?*IStorage, fSameAsLoad: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistStorage, @ptrCast(self)), pStgSave, fSameAsLoad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_SaveCompleted(self: *const T, pStgNew: ?*IStorage) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).SaveCompleted(@as(*const IPersistStorage, @ptrCast(self)), pStgNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistStorage_HandsOffStorage(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistStorage.VTable, @ptrCast(self.vtable)).HandsOffStorage(@as(*const IPersistStorage, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILockBytes_Value = Guid.initString("0000000a-0000-0000-c000-000000000046");
pub const IID_ILockBytes = &IID_ILockBytes_Value;
pub const ILockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*anyopaque,
                cb: u32,
                pcbRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                cb: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                cb: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                libOffset: u64,
                cb: u64,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                libOffset: u64,
                cb: u64,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                libOffset: u64,
                cb: u64,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                libOffset: u64,
                cb: u64,
                dwLockType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILockBytes,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILockBytes,
                pstatstg: ?*STATSTG,
                grfStatFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_ReadAt(self: *const T, ulOffset: u64, pv: ?*anyopaque, cb: u32, pcbRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).ReadAt(@as(*const ILockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_WriteAt(self: *const T, ulOffset: u64, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).WriteAt(@as(*const ILockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Flush(@as(*const ILockBytes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_SetSize(self: *const T, cb: u64) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).SetSize(@as(*const ILockBytes, @ptrCast(self)), cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_LockRegion(self: *const T, libOffset: u64, cb: u64, dwLockType: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).LockRegion(@as(*const ILockBytes, @ptrCast(self)), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_UnlockRegion(self: *const T, libOffset: u64, cb: u64, dwLockType: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).UnlockRegion(@as(*const ILockBytes, @ptrCast(self)), libOffset, cb, dwLockType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILockBytes_Stat(self: *const T, pstatstg: ?*STATSTG, grfStatFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const ILockBytes.VTable, @ptrCast(self.vtable)).Stat(@as(*const ILockBytes, @ptrCast(self)), pstatstg, grfStatFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IRootStorage_Value = Guid.initString("00000012-0000-0000-c000-000000000046");
pub const IID_IRootStorage = &IID_IRootStorage_Value;
pub const IRootStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchToFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRootStorage,
                pszFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRootStorage,
                pszFile: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRootStorage_SwitchToFile(self: *const T, pszFile: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IRootStorage.VTable, @ptrCast(self.vtable)).SwitchToFile(@as(*const IRootStorage, @ptrCast(self)), pszFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFillLockBytes_Value = Guid.initString("99caf010-415e-11cf-8814-00aa00b569f5");
pub const IID_IFillLockBytes = &IID_IFillLockBytes_Value;
pub const IFillLockBytes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FillAppend: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                // TODO: what to do with BytesParamIndex 1?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                ulOffset: u64,
                // TODO: what to do with BytesParamIndex 2?
                pv: ?*const anyopaque,
                cb: u32,
                pcbWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFillSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                ulSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                ulSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFillLockBytes,
                bCanceled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFillLockBytes,
                bCanceled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAppend(self: *const T, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAppend(@as(*const IFillLockBytes, @ptrCast(self)), pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_FillAt(self: *const T, ulOffset: u64, pv: ?*const anyopaque, cb: u32, pcbWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).FillAt(@as(*const IFillLockBytes, @ptrCast(self)), ulOffset, pv, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_SetFillSize(self: *const T, ulSize: u64) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).SetFillSize(@as(*const IFillLockBytes, @ptrCast(self)), ulSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFillLockBytes_Terminate(self: *const T, bCanceled: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IFillLockBytes.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IFillLockBytes, @ptrCast(self)), bCanceled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ILayoutStorage_Value = Guid.initString("0e6d4d90-6738-11cf-9608-00aa00680db4");
pub const IID_ILayoutStorage = &IID_ILayoutStorage_Value;
pub const ILayoutStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LayoutScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pStorageLayout: [*]StorageLayout,
                nEntries: u32,
                glfInterleavedFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pStorageLayout: [*]StorageLayout,
                nEntries: u32,
                glfInterleavedFlag: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReLayoutDocfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pwcsNewDfName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pwcsNewDfName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReLayoutDocfileOnILockBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILayoutStorage,
                pILockBytes: ?*ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILayoutStorage,
                pILockBytes: ?*ILockBytes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_LayoutScript(self: *const T, pStorageLayout: [*]StorageLayout, nEntries: u32, glfInterleavedFlag: u32) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).LayoutScript(@as(*const ILayoutStorage, @ptrCast(self)), pStorageLayout, nEntries, glfInterleavedFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_BeginMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).BeginMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_EndMonitor(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).EndMonitor(@as(*const ILayoutStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfile(self: *const T, pwcsNewDfName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfile(@as(*const ILayoutStorage, @ptrCast(self)), pwcsNewDfName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILayoutStorage_ReLayoutDocfileOnILockBytes(self: *const T, pILockBytes: ?*ILockBytes) callconv(.Inline) HRESULT {
            return @as(*const ILayoutStorage.VTable, @ptrCast(self.vtable)).ReLayoutDocfileOnILockBytes(@as(*const ILayoutStorage, @ptrCast(self)), pILockBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectWriterLock_Value = Guid.initString("0e6d4d92-6738-11cf-9608-00aa00680db4");
pub const IID_IDirectWriterLock = &IID_IDirectWriterLock_Value;
pub const IDirectWriterLock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
                dwTimeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HaveWriteAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectWriterLock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_WaitForWriteAccess(self: *const T, dwTimeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).WaitForWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)), dwTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_ReleaseWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).ReleaseWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectWriterLock_HaveWriteAccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectWriterLock.VTable, @ptrCast(self.vtable)).HaveWriteAccess(@as(*const IDirectWriterLock, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VERSIONEDSTREAM = extern struct {
    guidVersion: Guid,
    pStream: ?*IStream,
};

pub const CAC = extern struct {
    cElems: u32,
    pElems: ?PSTR,
};

pub const CAUB = extern struct {
    cElems: u32,
    pElems: ?*u8,
};

pub const CAI = extern struct {
    cElems: u32,
    pElems: ?*i16,
};

pub const CAUI = extern struct {
    cElems: u32,
    pElems: ?*u16,
};

pub const CAL = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAUL = extern struct {
    cElems: u32,
    pElems: ?*u32,
};

pub const CAFLT = extern struct {
    cElems: u32,
    pElems: ?*f32,
};

pub const CADBL = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CACY = extern struct {
    cElems: u32,
    pElems: ?*CY,
};

pub const CADATE = extern struct {
    cElems: u32,
    pElems: ?*f64,
};

pub const CABSTR = extern struct {
    cElems: u32,
    pElems: ?*?BSTR,
};

pub const CABSTRBLOB = extern struct {
    cElems: u32,
    pElems: ?*BSTRBLOB,
};

pub const CABOOL = extern struct {
    cElems: u32,
    pElems: ?*VARIANT_BOOL,
};

pub const CASCODE = extern struct {
    cElems: u32,
    pElems: ?*i32,
};

pub const CAPROPVARIANT = extern struct {
    cElems: u32,
    pElems: ?*PROPVARIANT,
};

pub const CAH = extern struct {
    cElems: u32,
    pElems: ?*i64,
};

pub const CAUH = extern struct {
    cElems: u32,
    pElems: ?*u64,
};

pub const CALPSTR = extern struct {
    cElems: u32,
    pElems: ?*?PSTR,
};

pub const CALPWSTR = extern struct {
    cElems: u32,
    pElems: ?*?PWSTR,
};

pub const CAFILETIME = extern struct {
    cElems: u32,
    pElems: ?*FILETIME,
};

pub const CACLIPDATA = extern struct {
    cElems: u32,
    pElems: ?*CLIPDATA,
};

pub const CACLSID = extern struct {
    cElems: u32,
    pElems: ?*Guid,
};

pub const PROPVARIANT = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            vt: VARENUM,
            wReserved1: u16,
            wReserved2: u16,
            wReserved3: u16,
            Anonymous: extern union {
                cVal: CHAR,
                bVal: u8,
                iVal: i16,
                uiVal: u16,
                lVal: i32,
                ulVal: u32,
                intVal: i32,
                uintVal: u32,
                hVal: i64,
                uhVal: u64,
                fltVal: f32,
                dblVal: f64,
                boolVal: VARIANT_BOOL,
                __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
                scode: i32,
                cyVal: CY,
                date: f64,
                filetime: FILETIME,
                puuid: ?*Guid,
                pclipdata: ?*CLIPDATA,
                bstrVal: ?BSTR,
                bstrblobVal: BSTRBLOB,
                blob: BLOB,
                pszVal: ?PSTR,
                pwszVal: ?PWSTR,
                punkVal: ?*IUnknown,
                pdispVal: ?*IDispatch,
                pStream: ?*IStream,
                pStorage: ?*IStorage,
                pVersionedStream: ?*VERSIONEDSTREAM,
                parray: ?*SAFEARRAY,
                cac: CAC,
                caub: CAUB,
                cai: CAI,
                caui: CAUI,
                cal: CAL,
                caul: CAUL,
                cah: CAH,
                cauh: CAUH,
                caflt: CAFLT,
                cadbl: CADBL,
                cabool: CABOOL,
                cascode: CASCODE,
                cacy: CACY,
                cadate: CADATE,
                cafiletime: CAFILETIME,
                cauuid: CACLSID,
                caclipdata: CACLIPDATA,
                cabstr: CABSTR,
                cabstrblob: CABSTRBLOB,
                calpstr: CALPSTR,
                calpwstr: CALPWSTR,
                capropvar: CAPROPVARIANT,
                pcVal: ?PSTR,
                pbVal: ?*u8,
                piVal: ?*i16,
                puiVal: ?*u16,
                plVal: ?*i32,
                pulVal: ?*u32,
                pintVal: ?*i32,
                puintVal: ?*u32,
                pfltVal: ?*f32,
                pdblVal: ?*f64,
                pboolVal: ?*VARIANT_BOOL,
                pdecVal: ?*DECIMAL,
                pscode: ?*i32,
                pcyVal: ?*CY,
                pdate: ?*f64,
                pbstrVal: ?*?BSTR,
                ppunkVal: ?*?*IUnknown,
                ppdispVal: ?*?*IDispatch,
                pparray: ?*?*SAFEARRAY,
                pvarVal: ?*PROPVARIANT,
            },
        },
        decVal: DECIMAL,
    },
};

pub const PROPSPEC = extern struct {
    ulKind: PROPSPEC_KIND,
    Anonymous: extern union {
        propid: u32,
        lpwstr: ?PWSTR,
    },
};

pub const STATPROPSTG = extern struct {
    lpwstrName: ?PWSTR,
    propid: u32,
    vt: VARENUM,
};

pub const STATPROPSETSTG = extern struct {
    fmtid: Guid,
    clsid: Guid,
    grfFlags: u32,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertyStorage_Value = Guid.initString("00000138-0000-0000-c000-000000000046");
pub const IID_IPropertyStorage = &IID_IPropertyStorage_Value;
pub const IPropertyStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]PROPVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]const PROPVARIANT,
                propidNameFirst: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
                rgpropvar: [*]const PROPVARIANT,
                propidNameFirst: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpspec: u32,
                rgpspec: [*]const PROPSPEC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
                rglpwstrName: [*]const ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePropertyNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                cpropid: u32,
                rgpropid: [*]const u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                grfCommitFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Revert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                pctime: ?*const FILETIME,
                patime: ?*const FILETIME,
                pmtime: ?*const FILETIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyStorage,
                pstatpsstg: ?*STATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyStorage,
                pstatpsstg: ?*STATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]PROPVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec, rgpropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WriteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC, rgpropvar: [*]const PROPVARIANT, propidNameFirst: u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WriteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec, rgpropvar, propidNameFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeleteMultiple(self: *const T, cpspec: u32, rgpspec: [*]const PROPSPEC) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeleteMultiple(@as(*const IPropertyStorage, @ptrCast(self)), cpspec, rgpspec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_ReadPropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).ReadPropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_WritePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32, rglpwstrName: [*]const ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).WritePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid, rglpwstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_DeletePropertyNames(self: *const T, cpropid: u32, rgpropid: [*]const u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).DeletePropertyNames(@as(*const IPropertyStorage, @ptrCast(self)), cpropid, rgpropid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Commit(self: *const T, grfCommitFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Commit(@as(*const IPropertyStorage, @ptrCast(self)), grfCommitFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Revert(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Revert(@as(*const IPropertyStorage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Enum(self: *const T, ppenum: ?*?*IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertyStorage, @ptrCast(self)), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetTimes(self: *const T, pctime: ?*const FILETIME, patime: ?*const FILETIME, pmtime: ?*const FILETIME) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetTimes(@as(*const IPropertyStorage, @ptrCast(self)), pctime, patime, pmtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_SetClass(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).SetClass(@as(*const IPropertyStorage, @ptrCast(self)), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyStorage_Stat(self: *const T, pstatpsstg: ?*STATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertyStorage.VTable, @ptrCast(self.vtable)).Stat(@as(*const IPropertyStorage, @ptrCast(self)), pstatpsstg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPropertySetStorage_Value = Guid.initString("0000013a-0000-0000-c000-000000000046");
pub const IID_IPropertySetStorage = &IID_IPropertySetStorage_Value;
pub const IPropertySetStorage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                pclsid: ?*const Guid,
                grfFlags: u32,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                pclsid: ?*const Guid,
                grfFlags: u32,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Open: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
                grfMode: u32,
                ppprstg: ?*?*IPropertyStorage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Delete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                rfmtid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertySetStorage,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertySetStorage,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Create(self: *const T, rfmtid: ?*const Guid, pclsid: ?*const Guid, grfFlags: u32, grfMode: u32, ppprstg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Create(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid, pclsid, grfFlags, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Open(self: *const T, rfmtid: ?*const Guid, grfMode: u32, ppprstg: ?*?*IPropertyStorage) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Open(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid, grfMode, ppprstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Delete(self: *const T, rfmtid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Delete(@as(*const IPropertySetStorage, @ptrCast(self)), rfmtid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertySetStorage_Enum(self: *const T, ppenum: ?*?*IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IPropertySetStorage.VTable, @ptrCast(self.vtable)).Enum(@as(*const IPropertySetStorage, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSTG_Value = Guid.initString("00000139-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSTG = &IID_IEnumSTATPROPSTG_Value;
pub const IEnumSTATPROPSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
                rgelt: [*]STATPROPSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
                rgelt: [*]STATPROPSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSTG,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSTG,
                ppenum: ?*?*IEnumSTATPROPSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATPROPSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumSTATPROPSETSTG_Value = Guid.initString("0000013b-0000-0000-c000-000000000046");
pub const IID_IEnumSTATPROPSETSTG = &IID_IEnumSTATPROPSETSTG_Value;
pub const IEnumSTATPROPSETSTG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
                rgelt: [*]STATPROPSETSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
                rgelt: [*]STATPROPSETSTG,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumSTATPROPSETSTG,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumSTATPROPSETSTG,
                ppenum: ?*?*IEnumSTATPROPSETSTG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Next(self: *const T, celt: u32, rgelt: [*]STATPROPSETSTG, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSTATPROPSETSTG_Clone(self: *const T, ppenum: ?*?*IEnumSTATPROPSETSTG) callconv(.Inline) HRESULT {
            return @as(*const IEnumSTATPROPSETSTG.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumSTATPROPSETSTG, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STGOPTIONS = extern struct {
    usVersion: u16,
    reserved: u16,
    ulSectorSize: u32,
    pwcsTemplateFile: ?[*:0]align(1) const u16,
};

pub const PIDMSI_STATUS_VALUE = enum(i32) {
    NORMAL = 0,
    NEW = 1,
    PRELIM = 2,
    DRAFT = 3,
    INPROGRESS = 4,
    EDIT = 5,
    REVIEW = 6,
    PROOF = 7,
    FINAL = 8,
    OTHER = 32767,
};
pub const PIDMSI_STATUS_NORMAL = PIDMSI_STATUS_VALUE.NORMAL;
pub const PIDMSI_STATUS_NEW = PIDMSI_STATUS_VALUE.NEW;
pub const PIDMSI_STATUS_PRELIM = PIDMSI_STATUS_VALUE.PRELIM;
pub const PIDMSI_STATUS_DRAFT = PIDMSI_STATUS_VALUE.DRAFT;
pub const PIDMSI_STATUS_INPROGRESS = PIDMSI_STATUS_VALUE.INPROGRESS;
pub const PIDMSI_STATUS_EDIT = PIDMSI_STATUS_VALUE.EDIT;
pub const PIDMSI_STATUS_REVIEW = PIDMSI_STATUS_VALUE.REVIEW;
pub const PIDMSI_STATUS_PROOF = PIDMSI_STATUS_VALUE.PROOF;
pub const PIDMSI_STATUS_FINAL = PIDMSI_STATUS_VALUE.FINAL;
pub const PIDMSI_STATUS_OTHER = PIDMSI_STATUS_VALUE.OTHER;

pub const SERIALIZEDPROPERTYVALUE = extern struct {
    dwType: u32,
    rgb: [1]u8,
};

const IID_IPropertyBag_Value = Guid.initString("55272a00-42cb-11ce-8135-00aa004bb851");
pub const IID_IPropertyBag = &IID_IPropertyBag_Value;
pub const IPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]align(1) const u16,
                pVar: ?*VARIANT,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]align(1) const u16,
                pVar: ?*VARIANT,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]align(1) const u16,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag,
                pszPropName: ?[*:0]align(1) const u16,
                pVar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Read(self: *const T, pszPropName: ?[*:0]align(1) const u16, pVar: ?*VARIANT, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag, @ptrCast(self)), pszPropName, pVar, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag_Write(self: *const T, pszPropName: ?[*:0]align(1) const u16, pVar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag, @ptrCast(self)), pszPropName, pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const OLESTREAMVTBL = extern struct {
    Get: isize,
    Put: isize,
};

pub const OLESTREAM = extern struct {
    lpstbl: ?*OLESTREAMVTBL,
};

pub const PROPBAG2 = extern struct {
    dwType: u32,
    vt: VARENUM,
    cfType: u16,
    dwHint: u32,
    pstrName: ?PWSTR,
    clsid: Guid,
};

const IID_IPropertyBag2_Value = Guid.initString("22f55882-280b-11d0-a8a9-00a0c90c2004");
pub const IID_IPropertyBag2 = &IID_IPropertyBag2_Value;
pub const IPropertyBag2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Read: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pErrLog: ?*IErrorLog,
                pvarValue: [*]VARIANT,
                phrError: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pErrLog: ?*IErrorLog,
                pvarValue: [*]VARIANT,
                phrError: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pvarValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pvarValue: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CountProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                iProperty: u32,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                iProperty: u32,
                cProperties: u32,
                pPropBag: [*]PROPBAG2,
                pcProperties: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPropertyBag2,
                pstrName: ?[*:0]align(1) const u16,
                dwHint: u32,
                pUnkObject: ?*IUnknown,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPropertyBag2,
                pstrName: ?[*:0]align(1) const u16,
                dwHint: u32,
                pUnkObject: ?*IUnknown,
                pErrLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Read(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pErrLog: ?*IErrorLog, pvarValue: [*]VARIANT, phrError: [*]HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Read(@as(*const IPropertyBag2, @ptrCast(self)), cProperties, pPropBag, pErrLog, pvarValue, phrError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_Write(self: *const T, cProperties: u32, pPropBag: [*]PROPBAG2, pvarValue: [*]VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).Write(@as(*const IPropertyBag2, @ptrCast(self)), cProperties, pPropBag, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_CountProperties(self: *const T, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).CountProperties(@as(*const IPropertyBag2, @ptrCast(self)), pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_GetPropertyInfo(self: *const T, iProperty: u32, cProperties: u32, pPropBag: [*]PROPBAG2, pcProperties: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IPropertyBag2, @ptrCast(self)), iProperty, cProperties, pPropBag, pcProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPropertyBag2_LoadObject(self: *const T, pstrName: ?[*:0]align(1) const u16, dwHint: u32, pUnkObject: ?*IUnknown, pErrLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @as(*const IPropertyBag2.VTable, @ptrCast(self.vtable)).LoadObject(@as(*const IPropertyBag2, @ptrCast(self)), pstrName, dwHint, pUnkObject, pErrLog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROPVAR_COMPARE_UNIT = enum(i32) {
    DEFAULT = 0,
    SECOND = 1,
    MINUTE = 2,
    HOUR = 3,
    DAY = 4,
    MONTH = 5,
    YEAR = 6,
};
pub const PVCU_DEFAULT = PROPVAR_COMPARE_UNIT.DEFAULT;
pub const PVCU_SECOND = PROPVAR_COMPARE_UNIT.SECOND;
pub const PVCU_MINUTE = PROPVAR_COMPARE_UNIT.MINUTE;
pub const PVCU_HOUR = PROPVAR_COMPARE_UNIT.HOUR;
pub const PVCU_DAY = PROPVAR_COMPARE_UNIT.DAY;
pub const PVCU_MONTH = PROPVAR_COMPARE_UNIT.MONTH;
pub const PVCU_YEAR = PROPVAR_COMPARE_UNIT.YEAR;

pub const PROPVAR_COMPARE_FLAGS = enum(i32) {
    DEFAULT = 0,
    TREATEMPTYASGREATERTHAN = 1,
    USESTRCMP = 2,
    USESTRCMPC = 4,
    USESTRCMPI = 8,
    USESTRCMPIC = 16,
    DIGITSASNUMBERS_CASESENSITIVE = 32,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        TREATEMPTYASGREATERTHAN: u1 = 0,
        USESTRCMP: u1 = 0,
        USESTRCMPC: u1 = 0,
        USESTRCMPI: u1 = 0,
        USESTRCMPIC: u1 = 0,
        DIGITSASNUMBERS_CASESENSITIVE: u1 = 0,
    }) PROPVAR_COMPARE_FLAGS {
        return @as(PROPVAR_COMPARE_FLAGS, @enumFromInt(
              (if (o.DEFAULT == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.DEFAULT) else 0)
            | (if (o.TREATEMPTYASGREATERTHAN == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.TREATEMPTYASGREATERTHAN) else 0)
            | (if (o.USESTRCMP == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.USESTRCMP) else 0)
            | (if (o.USESTRCMPC == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.USESTRCMPC) else 0)
            | (if (o.USESTRCMPI == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.USESTRCMPI) else 0)
            | (if (o.USESTRCMPIC == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.USESTRCMPIC) else 0)
            | (if (o.DIGITSASNUMBERS_CASESENSITIVE == 1) @intFromEnum(PROPVAR_COMPARE_FLAGS.DIGITSASNUMBERS_CASESENSITIVE) else 0)
        ));
    }
};
pub const PVCF_DEFAULT = PROPVAR_COMPARE_FLAGS.DEFAULT;
pub const PVCF_TREATEMPTYASGREATERTHAN = PROPVAR_COMPARE_FLAGS.TREATEMPTYASGREATERTHAN;
pub const PVCF_USESTRCMP = PROPVAR_COMPARE_FLAGS.USESTRCMP;
pub const PVCF_USESTRCMPC = PROPVAR_COMPARE_FLAGS.USESTRCMPC;
pub const PVCF_USESTRCMPI = PROPVAR_COMPARE_FLAGS.USESTRCMPI;
pub const PVCF_USESTRCMPIC = PROPVAR_COMPARE_FLAGS.USESTRCMPIC;
pub const PVCF_DIGITSASNUMBERS_CASESENSITIVE = PROPVAR_COMPARE_FLAGS.DIGITSASNUMBERS_CASESENSITIVE;

pub const PROPVAR_CHANGE_FLAGS = enum(i32) {
    DEFAULT = 0,
    NOVALUEPROP = 1,
    ALPHABOOL = 2,
    NOUSEROVERRIDE = 4,
    LOCALBOOL = 8,
    NOHEXSTRING = 16,
    _,
    pub fn initFlags(o: struct {
        DEFAULT: u1 = 0,
        NOVALUEPROP: u1 = 0,
        ALPHABOOL: u1 = 0,
        NOUSEROVERRIDE: u1 = 0,
        LOCALBOOL: u1 = 0,
        NOHEXSTRING: u1 = 0,
    }) PROPVAR_CHANGE_FLAGS {
        return @as(PROPVAR_CHANGE_FLAGS, @enumFromInt(
              (if (o.DEFAULT == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.DEFAULT) else 0)
            | (if (o.NOVALUEPROP == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.NOVALUEPROP) else 0)
            | (if (o.ALPHABOOL == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.ALPHABOOL) else 0)
            | (if (o.NOUSEROVERRIDE == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.NOUSEROVERRIDE) else 0)
            | (if (o.LOCALBOOL == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.LOCALBOOL) else 0)
            | (if (o.NOHEXSTRING == 1) @intFromEnum(PROPVAR_CHANGE_FLAGS.NOHEXSTRING) else 0)
        ));
    }
};
pub const PVCHF_DEFAULT = PROPVAR_CHANGE_FLAGS.DEFAULT;
pub const PVCHF_NOVALUEPROP = PROPVAR_CHANGE_FLAGS.NOVALUEPROP;
pub const PVCHF_ALPHABOOL = PROPVAR_CHANGE_FLAGS.ALPHABOOL;
pub const PVCHF_NOUSEROVERRIDE = PROPVAR_CHANGE_FLAGS.NOUSEROVERRIDE;
pub const PVCHF_LOCALBOOL = PROPVAR_CHANGE_FLAGS.LOCALBOOL;
pub const PVCHF_NOHEXSTRING = PROPVAR_CHANGE_FLAGS.NOHEXSTRING;


//--------------------------------------------------------------------------------
// Section: Functions (123)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromFile(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    grfMode: u32,
    pwszName: ?PWSTR,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInstanceFromIStorage(
    pServerInfo: ?*COSERVERINFO,
    pClsid: ?*Guid,
    punkOuter: ?*IUnknown,
    dwClsCtx: CLSCTX,
    pstg: ?*IStorage,
    dwCount: u32,
    pResults: [*]MULTI_QI,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(
    pflb: ?*IFillLockBytes,
    grfMode: u32,
    asyncFlags: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(
    pilb: ?*ILockBytes,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ole32" fn StgGetIFillLockBytesOnFile(
    pwcsName: ?[*:0]align(1) const u16,
    ppflb: ?*?*IFillLockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dflayout" fn StgOpenLayoutDocfile(
    pwcsDfName: ?[*:0]align(1) const u16,
    grfMode: u32,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateStreamOnHGlobal(
    hGlobal: ?HGLOBAL,
    fDeleteOnRelease: BOOL,
    ppstm: ?*?*IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromStream(
    pstm: ?*IStream,
    phglobal: ?*?HGLOBAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CoGetInterfaceAndReleaseStream(
    pStm: ?*IStream,
    iid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantCopy(
    pvarDest: ?*PROPVARIANT,
    pvarSrc: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropVariantClear(
    pvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FreePropVariantArray(
    cVariants: u32,
    rgvars: [*]PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfile(
    pwcsName: ?[*:0]align(1) const u16,
    grfMode: STGM,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateDocfileOnILockBytes(
    plkbyt: ?*ILockBytes,
    grfMode: STGM,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorage(
    pwcsName: ?[*:0]align(1) const u16,
    pstgPriority: ?*IStorage,
    grfMode: STGM,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageOnILockBytes(
    plkbyt: ?*ILockBytes,
    pstgPriority: ?*IStorage,
    grfMode: STGM,
    snbExclude: ?*?*u16,
    reserved: u32,
    ppstgOpen: ?*?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageFile(
    pwcsName: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgIsStorageILockBytes(
    plkbyt: ?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgSetTimes(
    lpszName: ?[*:0]align(1) const u16,
    pctime: ?*const FILETIME,
    patime: ?*const FILETIME,
    pmtime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreateStorageEx(
    pwcsName: ?[*:0]align(1) const u16,
    grfMode: STGM,
    stgfmt: STGFMT,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    ppObjectOpen: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenStorageEx(
    pwcsName: ?[*:0]align(1) const u16,
    grfMode: STGM,
    stgfmt: STGFMT,
    grfAttrs: u32,
    pStgOptions: ?*STGOPTIONS,
    pSecurityDescriptor: ?PSECURITY_DESCRIPTOR,
    riid: ?*const Guid,
    ppObjectOpen: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropStg(
    pUnk: ?*IUnknown,
    fmtid: ?*const Guid,
    pclsid: ?*const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgOpenPropStg(
    pUnk: ?*IUnknown,
    fmtid: ?*const Guid,
    grfFlags: u32,
    dwReserved: u32,
    ppPropStg: ?*?*IPropertyStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgCreatePropSetStg(
    pStorage: ?*IStorage,
    dwReserved: u32,
    ppPropSetStg: ?*?*IPropertySetStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn FmtIdToPropStgName(
    pfmtid: ?*const Guid,
    oszName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn PropStgNameToFmtId(
    oszName: ?[*:0]align(1) const u16,
    pfmtid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStg(
    pStg: ?*IStorage,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStg(
    pStg: ?*IStorage,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadClassStm(
    pStm: ?*IStream,
    pclsid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteClassStm(
    pStm: ?*IStream,
    rclsid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetHGlobalFromILockBytes(
    plkbyt: ?*ILockBytes,
    phglobal: ?*?HGLOBAL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn CreateILockBytesOnHGlobal(
    hGlobal: ?HGLOBAL,
    fDeleteOnRelease: BOOL,
    pplkbyt: ?*?*ILockBytes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn GetConvertStg(
    pStg: ?*IStorage,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgConvertVariantToProperty(
    pvar: ?*const PROPVARIANT,
    CodePage: u16,
    // TODO: what to do with BytesParamIndex 3?
    pprop: ?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
    pid: u32,
    fReserved: BOOLEAN,
    pcIndirect: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*SERIALIZEDPROPERTYVALUE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn StgPropertyLengthAsVariant(
    // TODO: what to do with BytesParamIndex 1?
    pProp: ?*const SERIALIZEDPROPERTYVALUE,
    cbProp: u32,
    CodePage: u16,
    bReserved: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn WriteFmtUserTypeStg(
    pstg: ?*IStorage,
    cf: u16,
    lpszUserType: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn ReadFmtUserTypeStg(
    pstg: ?*IStorage,
    pcf: ?*u16,
    lplpszUserType: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(
    lpolestream: ?*OLESTREAM,
    pstg: ?*IStorage,
    ptd: ?*const DVTARGETDEVICE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(
    pstg: ?*IStorage,
    lpolestream: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn SetConvertStg(
    pStg: ?*IStorage,
    fConvert: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(
    pstg: ?*IStorage,
    cfFormat: u16,
    lWidth: i32,
    lHeight: i32,
    dwSize: u32,
    pmedium: ?*STGMEDIUM,
    polestm: ?*OLESTREAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(
    polestm: ?*OLESTREAM,
    pstg: ?*IStorage,
    pcfFormat: ?*u16,
    plwWidth: ?*i32,
    plHeight: ?*i32,
    pdwSize: ?*u32,
    pmedium: ?*STGMEDIUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "propsys" fn PropVariantToWinRTPropertyValue(
    propvar: ?*const PROPVARIANT,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows8.0'
pub extern "propsys" fn WinRTPropertyValueToPropVariant(
    punkPropertyValue: ?*IUnknown,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromResource(
    hinst: ?HINSTANCE,
    id: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromBuffer(
    // TODO: what to do with BytesParamIndex 1?
    pv: ?*const anyopaque,
    cb: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromCLSID(
    clsid: ?*const Guid,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromGUIDAsString(
    guid: ?*const Guid,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromFileTime(
    pftIn: ?*const FILETIME,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromPropVariantVectorElem(
    propvarIn: ?*const PROPVARIANT,
    iElem: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantVectorFromPropVariant(
    propvarSingle: ?*const PROPVARIANT,
    ppropvarVector: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromBooleanVector(
    prgf: ?[*]const BOOL,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromInt16Vector(
    prgn: ?[*]const i16,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromUInt16Vector(
    prgn: ?[*:0]const u16,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromInt32Vector(
    prgn: ?[*]const i32,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromUInt32Vector(
    prgn: ?[*]const u32,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromInt64Vector(
    prgn: ?[*]const i64,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromUInt64Vector(
    prgn: ?[*]const u64,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromDoubleVector(
    prgn: ?[*]const f64,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromFileTimeVector(
    prgft: ?[*]const FILETIME,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromStringVector(
    prgsz: ?[*]const ?[*:0]align(1) const u16,
    cElems: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn InitPropVariantFromStringAsVector(
    psz: ?[*:0]align(1) const u16,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBooleanWithDefault(
    propvarIn: ?*const PROPVARIANT,
    fDefault: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt16WithDefault(
    propvarIn: ?*const PROPVARIANT,
    iDefault: i16,
) callconv(@import("std").os.windows.WINAPI) i16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt16WithDefault(
    propvarIn: ?*const PROPVARIANT,
    uiDefault: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt32WithDefault(
    propvarIn: ?*const PROPVARIANT,
    lDefault: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt32WithDefault(
    propvarIn: ?*const PROPVARIANT,
    ulDefault: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt64WithDefault(
    propvarIn: ?*const PROPVARIANT,
    llDefault: i64,
) callconv(@import("std").os.windows.WINAPI) i64;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt64WithDefault(
    propvarIn: ?*const PROPVARIANT,
    ullDefault: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToDoubleWithDefault(
    propvarIn: ?*const PROPVARIANT,
    dblDefault: f64,
) callconv(@import("std").os.windows.WINAPI) f64;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToStringWithDefault(
    propvarIn: ?*const PROPVARIANT,
    pszDefault: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBoolean(
    propvarIn: ?*const PROPVARIANT,
    pfRet: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt16(
    propvarIn: ?*const PROPVARIANT,
    piRet: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt16(
    propvarIn: ?*const PROPVARIANT,
    puiRet: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt32(
    propvarIn: ?*const PROPVARIANT,
    plRet: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt32(
    propvarIn: ?*const PROPVARIANT,
    pulRet: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt64(
    propvarIn: ?*const PROPVARIANT,
    pllRet: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt64(
    propvarIn: ?*const PROPVARIANT,
    pullRet: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToDouble(
    propvarIn: ?*const PROPVARIANT,
    pdblRet: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBuffer(
    propvar: ?*const PROPVARIANT,
    // TODO: what to do with BytesParamIndex 2?
    pv: ?*anyopaque,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToString(
    propvar: ?*const PROPVARIANT,
    psz: [*:0]u16,
    cch: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToGUID(
    propvar: ?*const PROPVARIANT,
    pguid: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToStringAlloc(
    propvar: ?*const PROPVARIANT,
    ppszOut: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBSTR(
    propvar: ?*const PROPVARIANT,
    pbstrOut: ?*?BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToFileTime(
    propvar: ?*const PROPVARIANT,
    pstfOut: PSTIME_FLAGS,
    pftOut: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetElementCount(
    propvar: ?*const PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBooleanVector(
    propvar: ?*const PROPVARIANT,
    prgf: [*]BOOL,
    crgf: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt16Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]i16,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt16Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*:0]u16,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt32Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]i32,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt32Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]u32,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt64Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]i64,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt64Vector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]u64,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToDoubleVector(
    propvar: ?*const PROPVARIANT,
    prgn: [*]f64,
    crgn: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToFileTimeVector(
    propvar: ?*const PROPVARIANT,
    prgft: [*]FILETIME,
    crgft: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToStringVector(
    propvar: ?*const PROPVARIANT,
    prgsz: [*]?PWSTR,
    crgsz: u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToBooleanVectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgf: ?*?*BOOL,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt16VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*i16,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt16VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*u16,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt32VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*i32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt32VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*u32,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToInt64VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*i64,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToUInt64VectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*u64,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToDoubleVectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgn: ?*?*f64,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToFileTimeVectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgft: ?*?*FILETIME,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantToStringVectorAlloc(
    propvar: ?*const PROPVARIANT,
    pprgsz: ?*?*?PWSTR,
    pcElem: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetBooleanElem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pfVal: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetInt16Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*i16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetUInt16Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetInt32Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetUInt32Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetInt64Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetUInt64Elem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetDoubleElem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pnVal: ?*f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetFileTimeElem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    pftVal: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantGetStringElem(
    propvar: ?*const PROPVARIANT,
    iElem: u32,
    ppszVal: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn ClearPropVariantArray(
    rgPropVar: [*]PROPVARIANT,
    cVars: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantCompareEx(
    propvar1: ?*const PROPVARIANT,
    propvar2: ?*const PROPVARIANT,
    unit: PROPVAR_COMPARE_UNIT,
    flags: PROPVAR_COMPARE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "propsys" fn PropVariantChangeType(
    ppropvarDest: ?*PROPVARIANT,
    propvarSrc: ?*const PROPVARIANT,
    flags: PROPVAR_CHANGE_FLAGS,
    vt: VARENUM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "propsys" fn PropVariantToVariant(
    pPropVar: ?*const PROPVARIANT,
    pVar: ?*VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "propsys" fn VariantToPropVariant(
    pVar: ?*const VARIANT,
    pPropVar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgSerializePropVariant(
    ppropvar: ?*const PROPVARIANT,
    ppProp: ?*?*SERIALIZEDPROPERTYVALUE,
    pcb: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.0'
pub extern "propsys" fn StgDeserializePropVariant(
    pprop: ?*const SERIALIZEDPROPERTYVALUE,
    cbMax: u32,
    ppropvar: ?*PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (33)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../zig.zig").Guid;
const BLOB = @import("../../../../windows/win32/system/com.zig").BLOB;
const BOOL = @import("../../../../windows/win32/foundation.zig").BOOL;
const BOOLEAN = @import("../../../../windows/win32/foundation.zig").BOOLEAN;
const BSTR = @import("../../../../windows/win32/foundation.zig").BSTR;
const CHAR = @import("../../../../windows/win32/foundation.zig").CHAR;
const CLSCTX = @import("../../../../windows/win32/system/com.zig").CLSCTX;
const COSERVERINFO = @import("../../../../windows/win32/system/com.zig").COSERVERINFO;
const CY = @import("../../../../windows/win32/system/com.zig").CY;
const DECIMAL = @import("../../../../windows/win32/foundation.zig").DECIMAL;
const DVTARGETDEVICE = @import("../../../../windows/win32/system/com.zig").DVTARGETDEVICE;
const FILETIME = @import("../../../../windows/win32/foundation.zig").FILETIME;
const HGLOBAL = @import("../../../../windows/win32/foundation.zig").HGLOBAL;
const HINSTANCE = @import("../../../../windows/win32/foundation.zig").HINSTANCE;
const HRESULT = @import("../../../../windows/win32/foundation.zig").HRESULT;
const IDispatch = @import("../../../../windows/win32/system/com.zig").IDispatch;
const IErrorLog = @import("../../../../windows/win32/system/com.zig").IErrorLog;
const IPersist = @import("../../../../windows/win32/system/com.zig").IPersist;
const IStream = @import("../../../../windows/win32/system/com.zig").IStream;
const IUnknown = @import("../../../../windows/win32/system/com.zig").IUnknown;
const MULTI_QI = @import("../../../../windows/win32/system/com.zig").MULTI_QI;
const PSECURITY_DESCRIPTOR = @import("../../../../windows/win32/security.zig").PSECURITY_DESCRIPTOR;
const PSTIME_FLAGS = @import("../../../../windows/win32/system/variant.zig").PSTIME_FLAGS;
const PSTR = @import("../../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../../windows/win32/foundation.zig").PWSTR;
const SAFEARRAY = @import("../../../../windows/win32/system/com.zig").SAFEARRAY;
const STATSTG = @import("../../../../windows/win32/system/com.zig").STATSTG;
const STGM = @import("../../../../windows/win32/system/com.zig").STGM;
const STGMEDIUM = @import("../../../../windows/win32/system/com.zig").STGMEDIUM;
const StorageLayout = @import("../../../../windows/win32/system/com.zig").StorageLayout;
const VARENUM = @import("../../../../windows/win32/system/variant.zig").VARENUM;
const VARIANT = @import("../../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../../windows/win32/foundation.zig").VARIANT_BOOL;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
