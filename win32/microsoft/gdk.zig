//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (7)
//--------------------------------------------------------------------------------
pub const FACILITY_GAMEINPUT = @as(u32, 906);
pub const GAMEINPUT_E_DEVICE_DISCONNECTED = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108031));
pub const GAMEINPUT_E_DEVICE_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108030));
pub const GAMEINPUT_E_READING_NOT_FOUND = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108029));
pub const GAMEINPUT_E_REFERENCE_READING_TOO_OLD = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108028));
pub const GAMEINPUT_E_TIMESTAMP_OUT_OF_RANGE = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108027));
pub const GAMEINPUT_E_INSUFFICIENT_FORCE_FEEDBACK_RESOURCES = @import("../zig.zig").typedConst(HRESULT, @as(i32, -2088108026));

//--------------------------------------------------------------------------------
// Section: Types (79)
//--------------------------------------------------------------------------------
pub const GameInputKind = enum(i32) {
    Unknown = 0,
    RawDeviceReport = 1,
    ControllerAxis = 2,
    ControllerButton = 4,
    ControllerSwitch = 8,
    Controller = 14,
    Keyboard = 16,
    Mouse = 32,
    Touch = 256,
    Motion = 4096,
    ArcadeStick = 65536,
    FlightStick = 131072,
    Gamepad = 262144,
    RacingWheel = 524288,
    UiNavigation = 16777216,
    _,
    pub fn initFlags(o: struct {
        Unknown: u1 = 0,
        RawDeviceReport: u1 = 0,
        ControllerAxis: u1 = 0,
        ControllerButton: u1 = 0,
        ControllerSwitch: u1 = 0,
        Controller: u1 = 0,
        Keyboard: u1 = 0,
        Mouse: u1 = 0,
        Touch: u1 = 0,
        Motion: u1 = 0,
        ArcadeStick: u1 = 0,
        FlightStick: u1 = 0,
        Gamepad: u1 = 0,
        RacingWheel: u1 = 0,
        UiNavigation: u1 = 0,
    }) GameInputKind {
        return @as(GameInputKind, @enumFromInt(
              (if (o.Unknown == 1) @intFromEnum(GameInputKind.Unknown) else 0)
            | (if (o.RawDeviceReport == 1) @intFromEnum(GameInputKind.RawDeviceReport) else 0)
            | (if (o.ControllerAxis == 1) @intFromEnum(GameInputKind.ControllerAxis) else 0)
            | (if (o.ControllerButton == 1) @intFromEnum(GameInputKind.ControllerButton) else 0)
            | (if (o.ControllerSwitch == 1) @intFromEnum(GameInputKind.ControllerSwitch) else 0)
            | (if (o.Controller == 1) @intFromEnum(GameInputKind.Controller) else 0)
            | (if (o.Keyboard == 1) @intFromEnum(GameInputKind.Keyboard) else 0)
            | (if (o.Mouse == 1) @intFromEnum(GameInputKind.Mouse) else 0)
            | (if (o.Touch == 1) @intFromEnum(GameInputKind.Touch) else 0)
            | (if (o.Motion == 1) @intFromEnum(GameInputKind.Motion) else 0)
            | (if (o.ArcadeStick == 1) @intFromEnum(GameInputKind.ArcadeStick) else 0)
            | (if (o.FlightStick == 1) @intFromEnum(GameInputKind.FlightStick) else 0)
            | (if (o.Gamepad == 1) @intFromEnum(GameInputKind.Gamepad) else 0)
            | (if (o.RacingWheel == 1) @intFromEnum(GameInputKind.RacingWheel) else 0)
            | (if (o.UiNavigation == 1) @intFromEnum(GameInputKind.UiNavigation) else 0)
        ));
    }
};
pub const GameInputKindUnknown = GameInputKind.Unknown;
pub const GameInputKindRawDeviceReport = GameInputKind.RawDeviceReport;
pub const GameInputKindControllerAxis = GameInputKind.ControllerAxis;
pub const GameInputKindControllerButton = GameInputKind.ControllerButton;
pub const GameInputKindControllerSwitch = GameInputKind.ControllerSwitch;
pub const GameInputKindController = GameInputKind.Controller;
pub const GameInputKindKeyboard = GameInputKind.Keyboard;
pub const GameInputKindMouse = GameInputKind.Mouse;
pub const GameInputKindTouch = GameInputKind.Touch;
pub const GameInputKindMotion = GameInputKind.Motion;
pub const GameInputKindArcadeStick = GameInputKind.ArcadeStick;
pub const GameInputKindFlightStick = GameInputKind.FlightStick;
pub const GameInputKindGamepad = GameInputKind.Gamepad;
pub const GameInputKindRacingWheel = GameInputKind.RacingWheel;
pub const GameInputKindUiNavigation = GameInputKind.UiNavigation;

pub const GameInputEnumerationKind = enum(i32) {
    NoEnumeration = 0,
    AsyncEnumeration = 1,
    BlockingEnumeration = 2,
};
pub const GameInputNoEnumeration = GameInputEnumerationKind.NoEnumeration;
pub const GameInputAsyncEnumeration = GameInputEnumerationKind.AsyncEnumeration;
pub const GameInputBlockingEnumeration = GameInputEnumerationKind.BlockingEnumeration;

pub const GameInputFocusPolicy = enum(i32) {
    DefaultFocusPolicy = 0,
    DisableBackgroundInput = 1,
    ExclusiveForegroundInput = 2,
    _,
    pub fn initFlags(o: struct {
        DefaultFocusPolicy: u1 = 0,
        DisableBackgroundInput: u1 = 0,
        ExclusiveForegroundInput: u1 = 0,
    }) GameInputFocusPolicy {
        return @as(GameInputFocusPolicy, @enumFromInt(
              (if (o.DefaultFocusPolicy == 1) @intFromEnum(GameInputFocusPolicy.DefaultFocusPolicy) else 0)
            | (if (o.DisableBackgroundInput == 1) @intFromEnum(GameInputFocusPolicy.DisableBackgroundInput) else 0)
            | (if (o.ExclusiveForegroundInput == 1) @intFromEnum(GameInputFocusPolicy.ExclusiveForegroundInput) else 0)
        ));
    }
};
pub const GameInputDefaultFocusPolicy = GameInputFocusPolicy.DefaultFocusPolicy;
pub const GameInputDisableBackgroundInput = GameInputFocusPolicy.DisableBackgroundInput;
pub const GameInputExclusiveForegroundInput = GameInputFocusPolicy.ExclusiveForegroundInput;

pub const GameInputSwitchKind = enum(i32) {
    UnknownSwitchKind = -1,
    @"2WaySwitch" = 0,
    @"4WaySwitch" = 1,
    @"8WaySwitch" = 2,
};
pub const GameInputUnknownSwitchKind = GameInputSwitchKind.UnknownSwitchKind;
pub const GameInput2WaySwitch = GameInputSwitchKind.@"2WaySwitch";
pub const GameInput4WaySwitch = GameInputSwitchKind.@"4WaySwitch";
pub const GameInput8WaySwitch = GameInputSwitchKind.@"8WaySwitch";

pub const GameInputSwitchPosition = enum(i32) {
    Center = 0,
    Up = 1,
    UpRight = 2,
    Right = 3,
    DownRight = 4,
    Down = 5,
    DownLeft = 6,
    Left = 7,
    UpLeft = 8,
};
pub const GameInputSwitchCenter = GameInputSwitchPosition.Center;
pub const GameInputSwitchUp = GameInputSwitchPosition.Up;
pub const GameInputSwitchUpRight = GameInputSwitchPosition.UpRight;
pub const GameInputSwitchRight = GameInputSwitchPosition.Right;
pub const GameInputSwitchDownRight = GameInputSwitchPosition.DownRight;
pub const GameInputSwitchDown = GameInputSwitchPosition.Down;
pub const GameInputSwitchDownLeft = GameInputSwitchPosition.DownLeft;
pub const GameInputSwitchLeft = GameInputSwitchPosition.Left;
pub const GameInputSwitchUpLeft = GameInputSwitchPosition.UpLeft;

pub const GameInputKeyboardKind = enum(i32) {
    UnknownKeyboard = -1,
    AnsiKeyboard = 0,
    IsoKeyboard = 1,
    KsKeyboard = 2,
    AbntKeyboard = 3,
    JisKeyboard = 4,
};
pub const GameInputUnknownKeyboard = GameInputKeyboardKind.UnknownKeyboard;
pub const GameInputAnsiKeyboard = GameInputKeyboardKind.AnsiKeyboard;
pub const GameInputIsoKeyboard = GameInputKeyboardKind.IsoKeyboard;
pub const GameInputKsKeyboard = GameInputKeyboardKind.KsKeyboard;
pub const GameInputAbntKeyboard = GameInputKeyboardKind.AbntKeyboard;
pub const GameInputJisKeyboard = GameInputKeyboardKind.JisKeyboard;

pub const GameInputMouseButtons = enum(i32) {
    None = 0,
    LeftButton = 1,
    RightButton = 2,
    MiddleButton = 4,
    Button4 = 8,
    Button5 = 16,
    WheelTiltLeft = 32,
    WheelTiltRight = 64,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        LeftButton: u1 = 0,
        RightButton: u1 = 0,
        MiddleButton: u1 = 0,
        Button4: u1 = 0,
        Button5: u1 = 0,
        WheelTiltLeft: u1 = 0,
        WheelTiltRight: u1 = 0,
    }) GameInputMouseButtons {
        return @as(GameInputMouseButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputMouseButtons.None) else 0)
            | (if (o.LeftButton == 1) @intFromEnum(GameInputMouseButtons.LeftButton) else 0)
            | (if (o.RightButton == 1) @intFromEnum(GameInputMouseButtons.RightButton) else 0)
            | (if (o.MiddleButton == 1) @intFromEnum(GameInputMouseButtons.MiddleButton) else 0)
            | (if (o.Button4 == 1) @intFromEnum(GameInputMouseButtons.Button4) else 0)
            | (if (o.Button5 == 1) @intFromEnum(GameInputMouseButtons.Button5) else 0)
            | (if (o.WheelTiltLeft == 1) @intFromEnum(GameInputMouseButtons.WheelTiltLeft) else 0)
            | (if (o.WheelTiltRight == 1) @intFromEnum(GameInputMouseButtons.WheelTiltRight) else 0)
        ));
    }
};
pub const GameInputMouseNone = GameInputMouseButtons.None;
pub const GameInputMouseLeftButton = GameInputMouseButtons.LeftButton;
pub const GameInputMouseRightButton = GameInputMouseButtons.RightButton;
pub const GameInputMouseMiddleButton = GameInputMouseButtons.MiddleButton;
pub const GameInputMouseButton4 = GameInputMouseButtons.Button4;
pub const GameInputMouseButton5 = GameInputMouseButtons.Button5;
pub const GameInputMouseWheelTiltLeft = GameInputMouseButtons.WheelTiltLeft;
pub const GameInputMouseWheelTiltRight = GameInputMouseButtons.WheelTiltRight;

pub const GameInputTouchShape = enum(i32) {
    Unknown = -1,
    Point = 0,
    @"1DLinear" = 1,
    @"1DRadial" = 2,
    @"1DIrregular" = 3,
    @"2DRectangular" = 4,
    @"2DElliptical" = 5,
    @"2DIrregular" = 6,
};
pub const GameInputTouchShapeUnknown = GameInputTouchShape.Unknown;
pub const GameInputTouchShapePoint = GameInputTouchShape.Point;
pub const GameInputTouchShape1DLinear = GameInputTouchShape.@"1DLinear";
pub const GameInputTouchShape1DRadial = GameInputTouchShape.@"1DRadial";
pub const GameInputTouchShape1DIrregular = GameInputTouchShape.@"1DIrregular";
pub const GameInputTouchShape2DRectangular = GameInputTouchShape.@"2DRectangular";
pub const GameInputTouchShape2DElliptical = GameInputTouchShape.@"2DElliptical";
pub const GameInputTouchShape2DIrregular = GameInputTouchShape.@"2DIrregular";

pub const GameInputMotionAccuracy = enum(i32) {
    AccuracyUnknown = -1,
    Unavailable = 0,
    Unreliable = 1,
    Approximate = 2,
    Accurate = 3,
};
pub const GameInputMotionAccuracyUnknown = GameInputMotionAccuracy.AccuracyUnknown;
pub const GameInputMotionUnavailable = GameInputMotionAccuracy.Unavailable;
pub const GameInputMotionUnreliable = GameInputMotionAccuracy.Unreliable;
pub const GameInputMotionApproximate = GameInputMotionAccuracy.Approximate;
pub const GameInputMotionAccurate = GameInputMotionAccuracy.Accurate;

pub const GameInputArcadeStickButtons = enum(i32) {
    None = 0,
    Menu = 1,
    View = 2,
    Up = 4,
    Down = 8,
    Left = 16,
    Right = 32,
    Action1 = 64,
    Action2 = 128,
    Action3 = 256,
    Action4 = 512,
    Action5 = 1024,
    Action6 = 2048,
    Special1 = 4096,
    Special2 = 8192,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Menu: u1 = 0,
        View: u1 = 0,
        Up: u1 = 0,
        Down: u1 = 0,
        Left: u1 = 0,
        Right: u1 = 0,
        Action1: u1 = 0,
        Action2: u1 = 0,
        Action3: u1 = 0,
        Action4: u1 = 0,
        Action5: u1 = 0,
        Action6: u1 = 0,
        Special1: u1 = 0,
        Special2: u1 = 0,
    }) GameInputArcadeStickButtons {
        return @as(GameInputArcadeStickButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputArcadeStickButtons.None) else 0)
            | (if (o.Menu == 1) @intFromEnum(GameInputArcadeStickButtons.Menu) else 0)
            | (if (o.View == 1) @intFromEnum(GameInputArcadeStickButtons.View) else 0)
            | (if (o.Up == 1) @intFromEnum(GameInputArcadeStickButtons.Up) else 0)
            | (if (o.Down == 1) @intFromEnum(GameInputArcadeStickButtons.Down) else 0)
            | (if (o.Left == 1) @intFromEnum(GameInputArcadeStickButtons.Left) else 0)
            | (if (o.Right == 1) @intFromEnum(GameInputArcadeStickButtons.Right) else 0)
            | (if (o.Action1 == 1) @intFromEnum(GameInputArcadeStickButtons.Action1) else 0)
            | (if (o.Action2 == 1) @intFromEnum(GameInputArcadeStickButtons.Action2) else 0)
            | (if (o.Action3 == 1) @intFromEnum(GameInputArcadeStickButtons.Action3) else 0)
            | (if (o.Action4 == 1) @intFromEnum(GameInputArcadeStickButtons.Action4) else 0)
            | (if (o.Action5 == 1) @intFromEnum(GameInputArcadeStickButtons.Action5) else 0)
            | (if (o.Action6 == 1) @intFromEnum(GameInputArcadeStickButtons.Action6) else 0)
            | (if (o.Special1 == 1) @intFromEnum(GameInputArcadeStickButtons.Special1) else 0)
            | (if (o.Special2 == 1) @intFromEnum(GameInputArcadeStickButtons.Special2) else 0)
        ));
    }
};
pub const GameInputArcadeStickNone = GameInputArcadeStickButtons.None;
pub const GameInputArcadeStickMenu = GameInputArcadeStickButtons.Menu;
pub const GameInputArcadeStickView = GameInputArcadeStickButtons.View;
pub const GameInputArcadeStickUp = GameInputArcadeStickButtons.Up;
pub const GameInputArcadeStickDown = GameInputArcadeStickButtons.Down;
pub const GameInputArcadeStickLeft = GameInputArcadeStickButtons.Left;
pub const GameInputArcadeStickRight = GameInputArcadeStickButtons.Right;
pub const GameInputArcadeStickAction1 = GameInputArcadeStickButtons.Action1;
pub const GameInputArcadeStickAction2 = GameInputArcadeStickButtons.Action2;
pub const GameInputArcadeStickAction3 = GameInputArcadeStickButtons.Action3;
pub const GameInputArcadeStickAction4 = GameInputArcadeStickButtons.Action4;
pub const GameInputArcadeStickAction5 = GameInputArcadeStickButtons.Action5;
pub const GameInputArcadeStickAction6 = GameInputArcadeStickButtons.Action6;
pub const GameInputArcadeStickSpecial1 = GameInputArcadeStickButtons.Special1;
pub const GameInputArcadeStickSpecial2 = GameInputArcadeStickButtons.Special2;

pub const GameInputFlightStickButtons = enum(i32) {
    None = 0,
    Menu = 1,
    View = 2,
    FirePrimary = 4,
    FireSecondary = 8,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Menu: u1 = 0,
        View: u1 = 0,
        FirePrimary: u1 = 0,
        FireSecondary: u1 = 0,
    }) GameInputFlightStickButtons {
        return @as(GameInputFlightStickButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputFlightStickButtons.None) else 0)
            | (if (o.Menu == 1) @intFromEnum(GameInputFlightStickButtons.Menu) else 0)
            | (if (o.View == 1) @intFromEnum(GameInputFlightStickButtons.View) else 0)
            | (if (o.FirePrimary == 1) @intFromEnum(GameInputFlightStickButtons.FirePrimary) else 0)
            | (if (o.FireSecondary == 1) @intFromEnum(GameInputFlightStickButtons.FireSecondary) else 0)
        ));
    }
};
pub const GameInputFlightStickNone = GameInputFlightStickButtons.None;
pub const GameInputFlightStickMenu = GameInputFlightStickButtons.Menu;
pub const GameInputFlightStickView = GameInputFlightStickButtons.View;
pub const GameInputFlightStickFirePrimary = GameInputFlightStickButtons.FirePrimary;
pub const GameInputFlightStickFireSecondary = GameInputFlightStickButtons.FireSecondary;

pub const GameInputGamepadButtons = enum(i32) {
    None = 0,
    Menu = 1,
    View = 2,
    A = 4,
    B = 8,
    X = 16,
    Y = 32,
    DPadUp = 64,
    DPadDown = 128,
    DPadLeft = 256,
    DPadRight = 512,
    LeftShoulder = 1024,
    RightShoulder = 2048,
    LeftThumbstick = 4096,
    RightThumbstick = 8192,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Menu: u1 = 0,
        View: u1 = 0,
        A: u1 = 0,
        B: u1 = 0,
        X: u1 = 0,
        Y: u1 = 0,
        DPadUp: u1 = 0,
        DPadDown: u1 = 0,
        DPadLeft: u1 = 0,
        DPadRight: u1 = 0,
        LeftShoulder: u1 = 0,
        RightShoulder: u1 = 0,
        LeftThumbstick: u1 = 0,
        RightThumbstick: u1 = 0,
    }) GameInputGamepadButtons {
        return @as(GameInputGamepadButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputGamepadButtons.None) else 0)
            | (if (o.Menu == 1) @intFromEnum(GameInputGamepadButtons.Menu) else 0)
            | (if (o.View == 1) @intFromEnum(GameInputGamepadButtons.View) else 0)
            | (if (o.A == 1) @intFromEnum(GameInputGamepadButtons.A) else 0)
            | (if (o.B == 1) @intFromEnum(GameInputGamepadButtons.B) else 0)
            | (if (o.X == 1) @intFromEnum(GameInputGamepadButtons.X) else 0)
            | (if (o.Y == 1) @intFromEnum(GameInputGamepadButtons.Y) else 0)
            | (if (o.DPadUp == 1) @intFromEnum(GameInputGamepadButtons.DPadUp) else 0)
            | (if (o.DPadDown == 1) @intFromEnum(GameInputGamepadButtons.DPadDown) else 0)
            | (if (o.DPadLeft == 1) @intFromEnum(GameInputGamepadButtons.DPadLeft) else 0)
            | (if (o.DPadRight == 1) @intFromEnum(GameInputGamepadButtons.DPadRight) else 0)
            | (if (o.LeftShoulder == 1) @intFromEnum(GameInputGamepadButtons.LeftShoulder) else 0)
            | (if (o.RightShoulder == 1) @intFromEnum(GameInputGamepadButtons.RightShoulder) else 0)
            | (if (o.LeftThumbstick == 1) @intFromEnum(GameInputGamepadButtons.LeftThumbstick) else 0)
            | (if (o.RightThumbstick == 1) @intFromEnum(GameInputGamepadButtons.RightThumbstick) else 0)
        ));
    }
};
pub const GameInputGamepadNone = GameInputGamepadButtons.None;
pub const GameInputGamepadMenu = GameInputGamepadButtons.Menu;
pub const GameInputGamepadView = GameInputGamepadButtons.View;
pub const GameInputGamepadA = GameInputGamepadButtons.A;
pub const GameInputGamepadB = GameInputGamepadButtons.B;
pub const GameInputGamepadX = GameInputGamepadButtons.X;
pub const GameInputGamepadY = GameInputGamepadButtons.Y;
pub const GameInputGamepadDPadUp = GameInputGamepadButtons.DPadUp;
pub const GameInputGamepadDPadDown = GameInputGamepadButtons.DPadDown;
pub const GameInputGamepadDPadLeft = GameInputGamepadButtons.DPadLeft;
pub const GameInputGamepadDPadRight = GameInputGamepadButtons.DPadRight;
pub const GameInputGamepadLeftShoulder = GameInputGamepadButtons.LeftShoulder;
pub const GameInputGamepadRightShoulder = GameInputGamepadButtons.RightShoulder;
pub const GameInputGamepadLeftThumbstick = GameInputGamepadButtons.LeftThumbstick;
pub const GameInputGamepadRightThumbstick = GameInputGamepadButtons.RightThumbstick;

pub const GameInputRacingWheelButtons = enum(i32) {
    None = 0,
    Menu = 1,
    View = 2,
    PreviousGear = 4,
    NextGear = 8,
    DpadUp = 16,
    DpadDown = 32,
    DpadLeft = 64,
    DpadRight = 128,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Menu: u1 = 0,
        View: u1 = 0,
        PreviousGear: u1 = 0,
        NextGear: u1 = 0,
        DpadUp: u1 = 0,
        DpadDown: u1 = 0,
        DpadLeft: u1 = 0,
        DpadRight: u1 = 0,
    }) GameInputRacingWheelButtons {
        return @as(GameInputRacingWheelButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputRacingWheelButtons.None) else 0)
            | (if (o.Menu == 1) @intFromEnum(GameInputRacingWheelButtons.Menu) else 0)
            | (if (o.View == 1) @intFromEnum(GameInputRacingWheelButtons.View) else 0)
            | (if (o.PreviousGear == 1) @intFromEnum(GameInputRacingWheelButtons.PreviousGear) else 0)
            | (if (o.NextGear == 1) @intFromEnum(GameInputRacingWheelButtons.NextGear) else 0)
            | (if (o.DpadUp == 1) @intFromEnum(GameInputRacingWheelButtons.DpadUp) else 0)
            | (if (o.DpadDown == 1) @intFromEnum(GameInputRacingWheelButtons.DpadDown) else 0)
            | (if (o.DpadLeft == 1) @intFromEnum(GameInputRacingWheelButtons.DpadLeft) else 0)
            | (if (o.DpadRight == 1) @intFromEnum(GameInputRacingWheelButtons.DpadRight) else 0)
        ));
    }
};
pub const GameInputRacingWheelNone = GameInputRacingWheelButtons.None;
pub const GameInputRacingWheelMenu = GameInputRacingWheelButtons.Menu;
pub const GameInputRacingWheelView = GameInputRacingWheelButtons.View;
pub const GameInputRacingWheelPreviousGear = GameInputRacingWheelButtons.PreviousGear;
pub const GameInputRacingWheelNextGear = GameInputRacingWheelButtons.NextGear;
pub const GameInputRacingWheelDpadUp = GameInputRacingWheelButtons.DpadUp;
pub const GameInputRacingWheelDpadDown = GameInputRacingWheelButtons.DpadDown;
pub const GameInputRacingWheelDpadLeft = GameInputRacingWheelButtons.DpadLeft;
pub const GameInputRacingWheelDpadRight = GameInputRacingWheelButtons.DpadRight;

pub const GameInputUiNavigationButtons = enum(i32) {
    None = 0,
    Menu = 1,
    View = 2,
    Accept = 4,
    Cancel = 8,
    Up = 16,
    Down = 32,
    Left = 64,
    Right = 128,
    Context1 = 256,
    Context2 = 512,
    Context3 = 1024,
    Context4 = 2048,
    PageUp = 4096,
    PageDown = 8192,
    PageLeft = 16384,
    PageRight = 32768,
    ScrollUp = 65536,
    ScrollDown = 131072,
    ScrollLeft = 262144,
    ScrollRight = 524288,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Menu: u1 = 0,
        View: u1 = 0,
        Accept: u1 = 0,
        Cancel: u1 = 0,
        Up: u1 = 0,
        Down: u1 = 0,
        Left: u1 = 0,
        Right: u1 = 0,
        Context1: u1 = 0,
        Context2: u1 = 0,
        Context3: u1 = 0,
        Context4: u1 = 0,
        PageUp: u1 = 0,
        PageDown: u1 = 0,
        PageLeft: u1 = 0,
        PageRight: u1 = 0,
        ScrollUp: u1 = 0,
        ScrollDown: u1 = 0,
        ScrollLeft: u1 = 0,
        ScrollRight: u1 = 0,
    }) GameInputUiNavigationButtons {
        return @as(GameInputUiNavigationButtons, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputUiNavigationButtons.None) else 0)
            | (if (o.Menu == 1) @intFromEnum(GameInputUiNavigationButtons.Menu) else 0)
            | (if (o.View == 1) @intFromEnum(GameInputUiNavigationButtons.View) else 0)
            | (if (o.Accept == 1) @intFromEnum(GameInputUiNavigationButtons.Accept) else 0)
            | (if (o.Cancel == 1) @intFromEnum(GameInputUiNavigationButtons.Cancel) else 0)
            | (if (o.Up == 1) @intFromEnum(GameInputUiNavigationButtons.Up) else 0)
            | (if (o.Down == 1) @intFromEnum(GameInputUiNavigationButtons.Down) else 0)
            | (if (o.Left == 1) @intFromEnum(GameInputUiNavigationButtons.Left) else 0)
            | (if (o.Right == 1) @intFromEnum(GameInputUiNavigationButtons.Right) else 0)
            | (if (o.Context1 == 1) @intFromEnum(GameInputUiNavigationButtons.Context1) else 0)
            | (if (o.Context2 == 1) @intFromEnum(GameInputUiNavigationButtons.Context2) else 0)
            | (if (o.Context3 == 1) @intFromEnum(GameInputUiNavigationButtons.Context3) else 0)
            | (if (o.Context4 == 1) @intFromEnum(GameInputUiNavigationButtons.Context4) else 0)
            | (if (o.PageUp == 1) @intFromEnum(GameInputUiNavigationButtons.PageUp) else 0)
            | (if (o.PageDown == 1) @intFromEnum(GameInputUiNavigationButtons.PageDown) else 0)
            | (if (o.PageLeft == 1) @intFromEnum(GameInputUiNavigationButtons.PageLeft) else 0)
            | (if (o.PageRight == 1) @intFromEnum(GameInputUiNavigationButtons.PageRight) else 0)
            | (if (o.ScrollUp == 1) @intFromEnum(GameInputUiNavigationButtons.ScrollUp) else 0)
            | (if (o.ScrollDown == 1) @intFromEnum(GameInputUiNavigationButtons.ScrollDown) else 0)
            | (if (o.ScrollLeft == 1) @intFromEnum(GameInputUiNavigationButtons.ScrollLeft) else 0)
            | (if (o.ScrollRight == 1) @intFromEnum(GameInputUiNavigationButtons.ScrollRight) else 0)
        ));
    }
};
pub const GameInputUiNavigationNone = GameInputUiNavigationButtons.None;
pub const GameInputUiNavigationMenu = GameInputUiNavigationButtons.Menu;
pub const GameInputUiNavigationView = GameInputUiNavigationButtons.View;
pub const GameInputUiNavigationAccept = GameInputUiNavigationButtons.Accept;
pub const GameInputUiNavigationCancel = GameInputUiNavigationButtons.Cancel;
pub const GameInputUiNavigationUp = GameInputUiNavigationButtons.Up;
pub const GameInputUiNavigationDown = GameInputUiNavigationButtons.Down;
pub const GameInputUiNavigationLeft = GameInputUiNavigationButtons.Left;
pub const GameInputUiNavigationRight = GameInputUiNavigationButtons.Right;
pub const GameInputUiNavigationContext1 = GameInputUiNavigationButtons.Context1;
pub const GameInputUiNavigationContext2 = GameInputUiNavigationButtons.Context2;
pub const GameInputUiNavigationContext3 = GameInputUiNavigationButtons.Context3;
pub const GameInputUiNavigationContext4 = GameInputUiNavigationButtons.Context4;
pub const GameInputUiNavigationPageUp = GameInputUiNavigationButtons.PageUp;
pub const GameInputUiNavigationPageDown = GameInputUiNavigationButtons.PageDown;
pub const GameInputUiNavigationPageLeft = GameInputUiNavigationButtons.PageLeft;
pub const GameInputUiNavigationPageRight = GameInputUiNavigationButtons.PageRight;
pub const GameInputUiNavigationScrollUp = GameInputUiNavigationButtons.ScrollUp;
pub const GameInputUiNavigationScrollDown = GameInputUiNavigationButtons.ScrollDown;
pub const GameInputUiNavigationScrollLeft = GameInputUiNavigationButtons.ScrollLeft;
pub const GameInputUiNavigationScrollRight = GameInputUiNavigationButtons.ScrollRight;

pub const GameInputDeviceStatus = enum(i32) {
    NoStatus = 0,
    Connected = 1,
    InputEnabled = 2,
    OutputEnabled = 4,
    RawIoEnabled = 8,
    AudioCapture = 16,
    AudioRender = 32,
    Synchronized = 64,
    Wireless = 128,
    UserIdle = 1048576,
    AnyStatus = 16777215,
    _,
    pub fn initFlags(o: struct {
        NoStatus: u1 = 0,
        Connected: u1 = 0,
        InputEnabled: u1 = 0,
        OutputEnabled: u1 = 0,
        RawIoEnabled: u1 = 0,
        AudioCapture: u1 = 0,
        AudioRender: u1 = 0,
        Synchronized: u1 = 0,
        Wireless: u1 = 0,
        UserIdle: u1 = 0,
        AnyStatus: u1 = 0,
    }) GameInputDeviceStatus {
        return @as(GameInputDeviceStatus, @enumFromInt(
              (if (o.NoStatus == 1) @intFromEnum(GameInputDeviceStatus.NoStatus) else 0)
            | (if (o.Connected == 1) @intFromEnum(GameInputDeviceStatus.Connected) else 0)
            | (if (o.InputEnabled == 1) @intFromEnum(GameInputDeviceStatus.InputEnabled) else 0)
            | (if (o.OutputEnabled == 1) @intFromEnum(GameInputDeviceStatus.OutputEnabled) else 0)
            | (if (o.RawIoEnabled == 1) @intFromEnum(GameInputDeviceStatus.RawIoEnabled) else 0)
            | (if (o.AudioCapture == 1) @intFromEnum(GameInputDeviceStatus.AudioCapture) else 0)
            | (if (o.AudioRender == 1) @intFromEnum(GameInputDeviceStatus.AudioRender) else 0)
            | (if (o.Synchronized == 1) @intFromEnum(GameInputDeviceStatus.Synchronized) else 0)
            | (if (o.Wireless == 1) @intFromEnum(GameInputDeviceStatus.Wireless) else 0)
            | (if (o.UserIdle == 1) @intFromEnum(GameInputDeviceStatus.UserIdle) else 0)
            | (if (o.AnyStatus == 1) @intFromEnum(GameInputDeviceStatus.AnyStatus) else 0)
        ));
    }
};
pub const GameInputDeviceNoStatus = GameInputDeviceStatus.NoStatus;
pub const GameInputDeviceConnected = GameInputDeviceStatus.Connected;
pub const GameInputDeviceInputEnabled = GameInputDeviceStatus.InputEnabled;
pub const GameInputDeviceOutputEnabled = GameInputDeviceStatus.OutputEnabled;
pub const GameInputDeviceRawIoEnabled = GameInputDeviceStatus.RawIoEnabled;
pub const GameInputDeviceAudioCapture = GameInputDeviceStatus.AudioCapture;
pub const GameInputDeviceAudioRender = GameInputDeviceStatus.AudioRender;
pub const GameInputDeviceSynchronized = GameInputDeviceStatus.Synchronized;
pub const GameInputDeviceWireless = GameInputDeviceStatus.Wireless;
pub const GameInputDeviceUserIdle = GameInputDeviceStatus.UserIdle;
pub const GameInputDeviceAnyStatus = GameInputDeviceStatus.AnyStatus;

pub const GameInputBatteryStatus = enum(i32) {
    Unknown = -1,
    NotPresent = 0,
    Discharging = 1,
    Idle = 2,
    Charging = 3,
};
pub const GameInputBatteryUnknown = GameInputBatteryStatus.Unknown;
pub const GameInputBatteryNotPresent = GameInputBatteryStatus.NotPresent;
pub const GameInputBatteryDischarging = GameInputBatteryStatus.Discharging;
pub const GameInputBatteryIdle = GameInputBatteryStatus.Idle;
pub const GameInputBatteryCharging = GameInputBatteryStatus.Charging;

pub const GameInputDeviceFamily = enum(i32) {
    Virtual = -1,
    Aggregate = 0,
    XboxOne = 1,
    Xbox360 = 2,
    Hid = 3,
    I8042 = 4,
};
pub const GameInputFamilyVirtual = GameInputDeviceFamily.Virtual;
pub const GameInputFamilyAggregate = GameInputDeviceFamily.Aggregate;
pub const GameInputFamilyXboxOne = GameInputDeviceFamily.XboxOne;
pub const GameInputFamilyXbox360 = GameInputDeviceFamily.Xbox360;
pub const GameInputFamilyHid = GameInputDeviceFamily.Hid;
pub const GameInputFamilyI8042 = GameInputDeviceFamily.I8042;

pub const GameInputDeviceCapabilities = enum(i32) {
    None = 0,
    Audio = 1,
    PluginModule = 2,
    PowerOff = 4,
    Synchronization = 8,
    Wireless = 16,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        Audio: u1 = 0,
        PluginModule: u1 = 0,
        PowerOff: u1 = 0,
        Synchronization: u1 = 0,
        Wireless: u1 = 0,
    }) GameInputDeviceCapabilities {
        return @as(GameInputDeviceCapabilities, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputDeviceCapabilities.None) else 0)
            | (if (o.Audio == 1) @intFromEnum(GameInputDeviceCapabilities.Audio) else 0)
            | (if (o.PluginModule == 1) @intFromEnum(GameInputDeviceCapabilities.PluginModule) else 0)
            | (if (o.PowerOff == 1) @intFromEnum(GameInputDeviceCapabilities.PowerOff) else 0)
            | (if (o.Synchronization == 1) @intFromEnum(GameInputDeviceCapabilities.Synchronization) else 0)
            | (if (o.Wireless == 1) @intFromEnum(GameInputDeviceCapabilities.Wireless) else 0)
        ));
    }
};
pub const GameInputDeviceCapabilityNone = GameInputDeviceCapabilities.None;
pub const GameInputDeviceCapabilityAudio = GameInputDeviceCapabilities.Audio;
pub const GameInputDeviceCapabilityPluginModule = GameInputDeviceCapabilities.PluginModule;
pub const GameInputDeviceCapabilityPowerOff = GameInputDeviceCapabilities.PowerOff;
pub const GameInputDeviceCapabilitySynchronization = GameInputDeviceCapabilities.Synchronization;
pub const GameInputDeviceCapabilityWireless = GameInputDeviceCapabilities.Wireless;

pub const GameInputRawDeviceReportKind = enum(i32) {
    InputReport = 0,
    OutputReport = 1,
    FeatureReport = 2,
};
pub const GameInputRawInputReport = GameInputRawDeviceReportKind.InputReport;
pub const GameInputRawOutputReport = GameInputRawDeviceReportKind.OutputReport;
pub const GameInputRawFeatureReport = GameInputRawDeviceReportKind.FeatureReport;

pub const GameInputRawDeviceReportItemFlags = enum(i32) {
    DefaultItem = 0,
    ConstantItem = 1,
    ArrayItem = 2,
    RelativeItem = 4,
    WraparoundItem = 8,
    NonlinearItem = 16,
    StableItem = 32,
    NullableItem = 64,
    VolatileItem = 128,
    BufferedItem = 256,
    _,
    pub fn initFlags(o: struct {
        DefaultItem: u1 = 0,
        ConstantItem: u1 = 0,
        ArrayItem: u1 = 0,
        RelativeItem: u1 = 0,
        WraparoundItem: u1 = 0,
        NonlinearItem: u1 = 0,
        StableItem: u1 = 0,
        NullableItem: u1 = 0,
        VolatileItem: u1 = 0,
        BufferedItem: u1 = 0,
    }) GameInputRawDeviceReportItemFlags {
        return @as(GameInputRawDeviceReportItemFlags, @enumFromInt(
              (if (o.DefaultItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.DefaultItem) else 0)
            | (if (o.ConstantItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.ConstantItem) else 0)
            | (if (o.ArrayItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.ArrayItem) else 0)
            | (if (o.RelativeItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.RelativeItem) else 0)
            | (if (o.WraparoundItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.WraparoundItem) else 0)
            | (if (o.NonlinearItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.NonlinearItem) else 0)
            | (if (o.StableItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.StableItem) else 0)
            | (if (o.NullableItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.NullableItem) else 0)
            | (if (o.VolatileItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.VolatileItem) else 0)
            | (if (o.BufferedItem == 1) @intFromEnum(GameInputRawDeviceReportItemFlags.BufferedItem) else 0)
        ));
    }
};
pub const GameInputDefaultItem = GameInputRawDeviceReportItemFlags.DefaultItem;
pub const GameInputConstantItem = GameInputRawDeviceReportItemFlags.ConstantItem;
pub const GameInputArrayItem = GameInputRawDeviceReportItemFlags.ArrayItem;
pub const GameInputRelativeItem = GameInputRawDeviceReportItemFlags.RelativeItem;
pub const GameInputWraparoundItem = GameInputRawDeviceReportItemFlags.WraparoundItem;
pub const GameInputNonlinearItem = GameInputRawDeviceReportItemFlags.NonlinearItem;
pub const GameInputStableItem = GameInputRawDeviceReportItemFlags.StableItem;
pub const GameInputNullableItem = GameInputRawDeviceReportItemFlags.NullableItem;
pub const GameInputVolatileItem = GameInputRawDeviceReportItemFlags.VolatileItem;
pub const GameInputBufferedItem = GameInputRawDeviceReportItemFlags.BufferedItem;

pub const GameInputRawDeviceItemCollectionKind = enum(i32) {
    UnknownItemCollection = -1,
    PhysicalItemCollection = 0,
    ApplicationItemCollection = 1,
    LogicalItemCollection = 2,
    ReportItemCollection = 3,
    NamedArrayItemCollection = 4,
    UsageSwitchItemCollection = 5,
    UsageModifierItemCollection = 6,
};
pub const GameInputUnknownItemCollection = GameInputRawDeviceItemCollectionKind.UnknownItemCollection;
pub const GameInputPhysicalItemCollection = GameInputRawDeviceItemCollectionKind.PhysicalItemCollection;
pub const GameInputApplicationItemCollection = GameInputRawDeviceItemCollectionKind.ApplicationItemCollection;
pub const GameInputLogicalItemCollection = GameInputRawDeviceItemCollectionKind.LogicalItemCollection;
pub const GameInputReportItemCollection = GameInputRawDeviceItemCollectionKind.ReportItemCollection;
pub const GameInputNamedArrayItemCollection = GameInputRawDeviceItemCollectionKind.NamedArrayItemCollection;
pub const GameInputUsageSwitchItemCollection = GameInputRawDeviceItemCollectionKind.UsageSwitchItemCollection;
pub const GameInputUsageModifierItemCollection = GameInputRawDeviceItemCollectionKind.UsageModifierItemCollection;

pub const GameInputRawDevicePhysicalUnitKind = enum(i32) {
    Unknown = -1,
    None = 0,
    Time = 1,
    Frequency = 2,
    Length = 3,
    Velocity = 4,
    Acceleration = 5,
    Mass = 6,
    Momentum = 7,
    Force = 8,
    Pressure = 9,
    Angle = 10,
    AngularVelocity = 11,
    AngularAcceleration = 12,
    AngularMass = 13,
    AngularMomentum = 14,
    AngularTorque = 15,
    ElectricCurrent = 16,
    ElectricCharge = 17,
    ElectricPotential = 18,
    Energy = 19,
    Power = 20,
    Temperature = 21,
    LuminousIntensity = 22,
    LuminousFlux = 23,
    Illuminance = 24,
};
pub const GameInputPhysicalUnitUnknown = GameInputRawDevicePhysicalUnitKind.Unknown;
pub const GameInputPhysicalUnitNone = GameInputRawDevicePhysicalUnitKind.None;
pub const GameInputPhysicalUnitTime = GameInputRawDevicePhysicalUnitKind.Time;
pub const GameInputPhysicalUnitFrequency = GameInputRawDevicePhysicalUnitKind.Frequency;
pub const GameInputPhysicalUnitLength = GameInputRawDevicePhysicalUnitKind.Length;
pub const GameInputPhysicalUnitVelocity = GameInputRawDevicePhysicalUnitKind.Velocity;
pub const GameInputPhysicalUnitAcceleration = GameInputRawDevicePhysicalUnitKind.Acceleration;
pub const GameInputPhysicalUnitMass = GameInputRawDevicePhysicalUnitKind.Mass;
pub const GameInputPhysicalUnitMomentum = GameInputRawDevicePhysicalUnitKind.Momentum;
pub const GameInputPhysicalUnitForce = GameInputRawDevicePhysicalUnitKind.Force;
pub const GameInputPhysicalUnitPressure = GameInputRawDevicePhysicalUnitKind.Pressure;
pub const GameInputPhysicalUnitAngle = GameInputRawDevicePhysicalUnitKind.Angle;
pub const GameInputPhysicalUnitAngularVelocity = GameInputRawDevicePhysicalUnitKind.AngularVelocity;
pub const GameInputPhysicalUnitAngularAcceleration = GameInputRawDevicePhysicalUnitKind.AngularAcceleration;
pub const GameInputPhysicalUnitAngularMass = GameInputRawDevicePhysicalUnitKind.AngularMass;
pub const GameInputPhysicalUnitAngularMomentum = GameInputRawDevicePhysicalUnitKind.AngularMomentum;
pub const GameInputPhysicalUnitAngularTorque = GameInputRawDevicePhysicalUnitKind.AngularTorque;
pub const GameInputPhysicalUnitElectricCurrent = GameInputRawDevicePhysicalUnitKind.ElectricCurrent;
pub const GameInputPhysicalUnitElectricCharge = GameInputRawDevicePhysicalUnitKind.ElectricCharge;
pub const GameInputPhysicalUnitElectricPotential = GameInputRawDevicePhysicalUnitKind.ElectricPotential;
pub const GameInputPhysicalUnitEnergy = GameInputRawDevicePhysicalUnitKind.Energy;
pub const GameInputPhysicalUnitPower = GameInputRawDevicePhysicalUnitKind.Power;
pub const GameInputPhysicalUnitTemperature = GameInputRawDevicePhysicalUnitKind.Temperature;
pub const GameInputPhysicalUnitLuminousIntensity = GameInputRawDevicePhysicalUnitKind.LuminousIntensity;
pub const GameInputPhysicalUnitLuminousFlux = GameInputRawDevicePhysicalUnitKind.LuminousFlux;
pub const GameInputPhysicalUnitIlluminance = GameInputRawDevicePhysicalUnitKind.Illuminance;

pub const GameInputLabel = enum(i32) {
    Unknown = -1,
    None = 0,
    XboxGuide = 1,
    XboxBack = 2,
    XboxStart = 3,
    XboxMenu = 4,
    XboxView = 5,
    XboxA = 7,
    XboxB = 8,
    XboxX = 9,
    XboxY = 10,
    XboxDPadUp = 11,
    XboxDPadDown = 12,
    XboxDPadLeft = 13,
    XboxDPadRight = 14,
    XboxLeftShoulder = 15,
    XboxLeftTrigger = 16,
    XboxLeftStickButton = 17,
    XboxRightShoulder = 18,
    XboxRightTrigger = 19,
    XboxRightStickButton = 20,
    XboxPaddle1 = 21,
    XboxPaddle2 = 22,
    XboxPaddle3 = 23,
    XboxPaddle4 = 24,
    LetterA = 25,
    LetterB = 26,
    LetterC = 27,
    LetterD = 28,
    LetterE = 29,
    LetterF = 30,
    LetterG = 31,
    LetterH = 32,
    LetterI = 33,
    LetterJ = 34,
    LetterK = 35,
    LetterL = 36,
    LetterM = 37,
    LetterN = 38,
    LetterO = 39,
    LetterP = 40,
    LetterQ = 41,
    LetterR = 42,
    LetterS = 43,
    LetterT = 44,
    LetterU = 45,
    LetterV = 46,
    LetterW = 47,
    LetterX = 48,
    LetterY = 49,
    LetterZ = 50,
    Number0 = 51,
    Number1 = 52,
    Number2 = 53,
    Number3 = 54,
    Number4 = 55,
    Number5 = 56,
    Number6 = 57,
    Number7 = 58,
    Number8 = 59,
    Number9 = 60,
    ArrowUp = 61,
    ArrowUpRight = 62,
    ArrowRight = 63,
    ArrowDownRight = 64,
    ArrowDown = 65,
    ArrowDownLLeft = 66,
    ArrowLeft = 67,
    ArrowUpLeft = 68,
    ArrowUpDown = 69,
    ArrowLeftRight = 70,
    ArrowUpDownLeftRight = 71,
    ArrowClockwise = 72,
    ArrowCounterClockwise = 73,
    ArrowReturn = 74,
    IconBranding = 75,
    IconHome = 76,
    IconMenu = 77,
    IconCross = 78,
    IconCircle = 79,
    IconSquare = 80,
    IconTriangle = 81,
    IconStar = 82,
    IconDPadUp = 83,
    IconDPadDown = 84,
    IconDPadLeft = 85,
    IconDPadRight = 86,
    IconDialClockwise = 87,
    IconDialCounterClockwise = 88,
    IconSliderLeftRight = 89,
    IconSliderUpDown = 90,
    IconWheelUpDown = 91,
    IconPlus = 92,
    IconMinus = 93,
    IconSuspension = 94,
    Home = 95,
    Guide = 96,
    Mode = 97,
    Select = 98,
    Menu = 99,
    View = 100,
    Back = 101,
    Start = 102,
    Options = 103,
    Share = 104,
    Up = 105,
    Down = 106,
    Left = 107,
    Right = 108,
    LB = 109,
    LT = 110,
    LSB = 111,
    L1 = 112,
    L2 = 113,
    L3 = 114,
    RB = 115,
    RT = 116,
    RSB = 117,
    R1 = 118,
    R2 = 119,
    R3 = 120,
    P1 = 121,
    P2 = 122,
    P3 = 123,
    P4 = 124,
};
pub const GameInputLabelUnknown = GameInputLabel.Unknown;
pub const GameInputLabelNone = GameInputLabel.None;
pub const GameInputLabelXboxGuide = GameInputLabel.XboxGuide;
pub const GameInputLabelXboxBack = GameInputLabel.XboxBack;
pub const GameInputLabelXboxStart = GameInputLabel.XboxStart;
pub const GameInputLabelXboxMenu = GameInputLabel.XboxMenu;
pub const GameInputLabelXboxView = GameInputLabel.XboxView;
pub const GameInputLabelXboxA = GameInputLabel.XboxA;
pub const GameInputLabelXboxB = GameInputLabel.XboxB;
pub const GameInputLabelXboxX = GameInputLabel.XboxX;
pub const GameInputLabelXboxY = GameInputLabel.XboxY;
pub const GameInputLabelXboxDPadUp = GameInputLabel.XboxDPadUp;
pub const GameInputLabelXboxDPadDown = GameInputLabel.XboxDPadDown;
pub const GameInputLabelXboxDPadLeft = GameInputLabel.XboxDPadLeft;
pub const GameInputLabelXboxDPadRight = GameInputLabel.XboxDPadRight;
pub const GameInputLabelXboxLeftShoulder = GameInputLabel.XboxLeftShoulder;
pub const GameInputLabelXboxLeftTrigger = GameInputLabel.XboxLeftTrigger;
pub const GameInputLabelXboxLeftStickButton = GameInputLabel.XboxLeftStickButton;
pub const GameInputLabelXboxRightShoulder = GameInputLabel.XboxRightShoulder;
pub const GameInputLabelXboxRightTrigger = GameInputLabel.XboxRightTrigger;
pub const GameInputLabelXboxRightStickButton = GameInputLabel.XboxRightStickButton;
pub const GameInputLabelXboxPaddle1 = GameInputLabel.XboxPaddle1;
pub const GameInputLabelXboxPaddle2 = GameInputLabel.XboxPaddle2;
pub const GameInputLabelXboxPaddle3 = GameInputLabel.XboxPaddle3;
pub const GameInputLabelXboxPaddle4 = GameInputLabel.XboxPaddle4;
pub const GameInputLabelLetterA = GameInputLabel.LetterA;
pub const GameInputLabelLetterB = GameInputLabel.LetterB;
pub const GameInputLabelLetterC = GameInputLabel.LetterC;
pub const GameInputLabelLetterD = GameInputLabel.LetterD;
pub const GameInputLabelLetterE = GameInputLabel.LetterE;
pub const GameInputLabelLetterF = GameInputLabel.LetterF;
pub const GameInputLabelLetterG = GameInputLabel.LetterG;
pub const GameInputLabelLetterH = GameInputLabel.LetterH;
pub const GameInputLabelLetterI = GameInputLabel.LetterI;
pub const GameInputLabelLetterJ = GameInputLabel.LetterJ;
pub const GameInputLabelLetterK = GameInputLabel.LetterK;
pub const GameInputLabelLetterL = GameInputLabel.LetterL;
pub const GameInputLabelLetterM = GameInputLabel.LetterM;
pub const GameInputLabelLetterN = GameInputLabel.LetterN;
pub const GameInputLabelLetterO = GameInputLabel.LetterO;
pub const GameInputLabelLetterP = GameInputLabel.LetterP;
pub const GameInputLabelLetterQ = GameInputLabel.LetterQ;
pub const GameInputLabelLetterR = GameInputLabel.LetterR;
pub const GameInputLabelLetterS = GameInputLabel.LetterS;
pub const GameInputLabelLetterT = GameInputLabel.LetterT;
pub const GameInputLabelLetterU = GameInputLabel.LetterU;
pub const GameInputLabelLetterV = GameInputLabel.LetterV;
pub const GameInputLabelLetterW = GameInputLabel.LetterW;
pub const GameInputLabelLetterX = GameInputLabel.LetterX;
pub const GameInputLabelLetterY = GameInputLabel.LetterY;
pub const GameInputLabelLetterZ = GameInputLabel.LetterZ;
pub const GameInputLabelNumber0 = GameInputLabel.Number0;
pub const GameInputLabelNumber1 = GameInputLabel.Number1;
pub const GameInputLabelNumber2 = GameInputLabel.Number2;
pub const GameInputLabelNumber3 = GameInputLabel.Number3;
pub const GameInputLabelNumber4 = GameInputLabel.Number4;
pub const GameInputLabelNumber5 = GameInputLabel.Number5;
pub const GameInputLabelNumber6 = GameInputLabel.Number6;
pub const GameInputLabelNumber7 = GameInputLabel.Number7;
pub const GameInputLabelNumber8 = GameInputLabel.Number8;
pub const GameInputLabelNumber9 = GameInputLabel.Number9;
pub const GameInputLabelArrowUp = GameInputLabel.ArrowUp;
pub const GameInputLabelArrowUpRight = GameInputLabel.ArrowUpRight;
pub const GameInputLabelArrowRight = GameInputLabel.ArrowRight;
pub const GameInputLabelArrowDownRight = GameInputLabel.ArrowDownRight;
pub const GameInputLabelArrowDown = GameInputLabel.ArrowDown;
pub const GameInputLabelArrowDownLLeft = GameInputLabel.ArrowDownLLeft;
pub const GameInputLabelArrowLeft = GameInputLabel.ArrowLeft;
pub const GameInputLabelArrowUpLeft = GameInputLabel.ArrowUpLeft;
pub const GameInputLabelArrowUpDown = GameInputLabel.ArrowUpDown;
pub const GameInputLabelArrowLeftRight = GameInputLabel.ArrowLeftRight;
pub const GameInputLabelArrowUpDownLeftRight = GameInputLabel.ArrowUpDownLeftRight;
pub const GameInputLabelArrowClockwise = GameInputLabel.ArrowClockwise;
pub const GameInputLabelArrowCounterClockwise = GameInputLabel.ArrowCounterClockwise;
pub const GameInputLabelArrowReturn = GameInputLabel.ArrowReturn;
pub const GameInputLabelIconBranding = GameInputLabel.IconBranding;
pub const GameInputLabelIconHome = GameInputLabel.IconHome;
pub const GameInputLabelIconMenu = GameInputLabel.IconMenu;
pub const GameInputLabelIconCross = GameInputLabel.IconCross;
pub const GameInputLabelIconCircle = GameInputLabel.IconCircle;
pub const GameInputLabelIconSquare = GameInputLabel.IconSquare;
pub const GameInputLabelIconTriangle = GameInputLabel.IconTriangle;
pub const GameInputLabelIconStar = GameInputLabel.IconStar;
pub const GameInputLabelIconDPadUp = GameInputLabel.IconDPadUp;
pub const GameInputLabelIconDPadDown = GameInputLabel.IconDPadDown;
pub const GameInputLabelIconDPadLeft = GameInputLabel.IconDPadLeft;
pub const GameInputLabelIconDPadRight = GameInputLabel.IconDPadRight;
pub const GameInputLabelIconDialClockwise = GameInputLabel.IconDialClockwise;
pub const GameInputLabelIconDialCounterClockwise = GameInputLabel.IconDialCounterClockwise;
pub const GameInputLabelIconSliderLeftRight = GameInputLabel.IconSliderLeftRight;
pub const GameInputLabelIconSliderUpDown = GameInputLabel.IconSliderUpDown;
pub const GameInputLabelIconWheelUpDown = GameInputLabel.IconWheelUpDown;
pub const GameInputLabelIconPlus = GameInputLabel.IconPlus;
pub const GameInputLabelIconMinus = GameInputLabel.IconMinus;
pub const GameInputLabelIconSuspension = GameInputLabel.IconSuspension;
pub const GameInputLabelHome = GameInputLabel.Home;
pub const GameInputLabelGuide = GameInputLabel.Guide;
pub const GameInputLabelMode = GameInputLabel.Mode;
pub const GameInputLabelSelect = GameInputLabel.Select;
pub const GameInputLabelMenu = GameInputLabel.Menu;
pub const GameInputLabelView = GameInputLabel.View;
pub const GameInputLabelBack = GameInputLabel.Back;
pub const GameInputLabelStart = GameInputLabel.Start;
pub const GameInputLabelOptions = GameInputLabel.Options;
pub const GameInputLabelShare = GameInputLabel.Share;
pub const GameInputLabelUp = GameInputLabel.Up;
pub const GameInputLabelDown = GameInputLabel.Down;
pub const GameInputLabelLeft = GameInputLabel.Left;
pub const GameInputLabelRight = GameInputLabel.Right;
pub const GameInputLabelLB = GameInputLabel.LB;
pub const GameInputLabelLT = GameInputLabel.LT;
pub const GameInputLabelLSB = GameInputLabel.LSB;
pub const GameInputLabelL1 = GameInputLabel.L1;
pub const GameInputLabelL2 = GameInputLabel.L2;
pub const GameInputLabelL3 = GameInputLabel.L3;
pub const GameInputLabelRB = GameInputLabel.RB;
pub const GameInputLabelRT = GameInputLabel.RT;
pub const GameInputLabelRSB = GameInputLabel.RSB;
pub const GameInputLabelR1 = GameInputLabel.R1;
pub const GameInputLabelR2 = GameInputLabel.R2;
pub const GameInputLabelR3 = GameInputLabel.R3;
pub const GameInputLabelP1 = GameInputLabel.P1;
pub const GameInputLabelP2 = GameInputLabel.P2;
pub const GameInputLabelP3 = GameInputLabel.P3;
pub const GameInputLabelP4 = GameInputLabel.P4;

pub const GameInputLocation = enum(i32) {
    Unknown = -1,
    Chassis = 0,
    Display = 1,
    Axis = 2,
    Button = 3,
    Switch = 4,
    Key = 5,
    TouchPad = 6,
};
pub const GameInputLocationUnknown = GameInputLocation.Unknown;
pub const GameInputLocationChassis = GameInputLocation.Chassis;
pub const GameInputLocationDisplay = GameInputLocation.Display;
pub const GameInputLocationAxis = GameInputLocation.Axis;
pub const GameInputLocationButton = GameInputLocation.Button;
pub const GameInputLocationSwitch = GameInputLocation.Switch;
pub const GameInputLocationKey = GameInputLocation.Key;
pub const GameInputLocationTouchPad = GameInputLocation.TouchPad;

pub const GameInputFeedbackAxes = enum(i32) {
    None = 0,
    LinearX = 1,
    LinearY = 2,
    LinearZ = 4,
    AngularX = 8,
    AngularY = 16,
    AngularZ = 32,
    Normal = 64,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        LinearX: u1 = 0,
        LinearY: u1 = 0,
        LinearZ: u1 = 0,
        AngularX: u1 = 0,
        AngularY: u1 = 0,
        AngularZ: u1 = 0,
        Normal: u1 = 0,
    }) GameInputFeedbackAxes {
        return @as(GameInputFeedbackAxes, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputFeedbackAxes.None) else 0)
            | (if (o.LinearX == 1) @intFromEnum(GameInputFeedbackAxes.LinearX) else 0)
            | (if (o.LinearY == 1) @intFromEnum(GameInputFeedbackAxes.LinearY) else 0)
            | (if (o.LinearZ == 1) @intFromEnum(GameInputFeedbackAxes.LinearZ) else 0)
            | (if (o.AngularX == 1) @intFromEnum(GameInputFeedbackAxes.AngularX) else 0)
            | (if (o.AngularY == 1) @intFromEnum(GameInputFeedbackAxes.AngularY) else 0)
            | (if (o.AngularZ == 1) @intFromEnum(GameInputFeedbackAxes.AngularZ) else 0)
            | (if (o.Normal == 1) @intFromEnum(GameInputFeedbackAxes.Normal) else 0)
        ));
    }
};
pub const GameInputFeedbackAxisNone = GameInputFeedbackAxes.None;
pub const GameInputFeedbackAxisLinearX = GameInputFeedbackAxes.LinearX;
pub const GameInputFeedbackAxisLinearY = GameInputFeedbackAxes.LinearY;
pub const GameInputFeedbackAxisLinearZ = GameInputFeedbackAxes.LinearZ;
pub const GameInputFeedbackAxisAngularX = GameInputFeedbackAxes.AngularX;
pub const GameInputFeedbackAxisAngularY = GameInputFeedbackAxes.AngularY;
pub const GameInputFeedbackAxisAngularZ = GameInputFeedbackAxes.AngularZ;
pub const GameInputFeedbackAxisNormal = GameInputFeedbackAxes.Normal;

pub const GameInputFeedbackEffectState = enum(i32) {
    Stopped = 0,
    Running = 1,
    Paused = 2,
};
pub const GameInputFeedbackStopped = GameInputFeedbackEffectState.Stopped;
pub const GameInputFeedbackRunning = GameInputFeedbackEffectState.Running;
pub const GameInputFeedbackPaused = GameInputFeedbackEffectState.Paused;

pub const GameInputForceFeedbackEffectKind = enum(i32) {
    Constant = 0,
    Ramp = 1,
    SineWave = 2,
    SquareWave = 3,
    TriangleWave = 4,
    SawtoothUpWave = 5,
    SawtoothDownWave = 6,
    Spring = 7,
    Friction = 8,
    Damper = 9,
    Inertia = 10,
};
pub const GameInputForceFeedbackConstant = GameInputForceFeedbackEffectKind.Constant;
pub const GameInputForceFeedbackRamp = GameInputForceFeedbackEffectKind.Ramp;
pub const GameInputForceFeedbackSineWave = GameInputForceFeedbackEffectKind.SineWave;
pub const GameInputForceFeedbackSquareWave = GameInputForceFeedbackEffectKind.SquareWave;
pub const GameInputForceFeedbackTriangleWave = GameInputForceFeedbackEffectKind.TriangleWave;
pub const GameInputForceFeedbackSawtoothUpWave = GameInputForceFeedbackEffectKind.SawtoothUpWave;
pub const GameInputForceFeedbackSawtoothDownWave = GameInputForceFeedbackEffectKind.SawtoothDownWave;
pub const GameInputForceFeedbackSpring = GameInputForceFeedbackEffectKind.Spring;
pub const GameInputForceFeedbackFriction = GameInputForceFeedbackEffectKind.Friction;
pub const GameInputForceFeedbackDamper = GameInputForceFeedbackEffectKind.Damper;
pub const GameInputForceFeedbackInertia = GameInputForceFeedbackEffectKind.Inertia;

pub const GameInputRumbleMotors = enum(i32) {
    None = 0,
    LowFrequency = 1,
    HighFrequency = 2,
    LeftTrigger = 4,
    RightTrigger = 8,
    _,
    pub fn initFlags(o: struct {
        None: u1 = 0,
        LowFrequency: u1 = 0,
        HighFrequency: u1 = 0,
        LeftTrigger: u1 = 0,
        RightTrigger: u1 = 0,
    }) GameInputRumbleMotors {
        return @as(GameInputRumbleMotors, @enumFromInt(
              (if (o.None == 1) @intFromEnum(GameInputRumbleMotors.None) else 0)
            | (if (o.LowFrequency == 1) @intFromEnum(GameInputRumbleMotors.LowFrequency) else 0)
            | (if (o.HighFrequency == 1) @intFromEnum(GameInputRumbleMotors.HighFrequency) else 0)
            | (if (o.LeftTrigger == 1) @intFromEnum(GameInputRumbleMotors.LeftTrigger) else 0)
            | (if (o.RightTrigger == 1) @intFromEnum(GameInputRumbleMotors.RightTrigger) else 0)
        ));
    }
};
pub const GameInputRumbleNone = GameInputRumbleMotors.None;
pub const GameInputRumbleLowFrequency = GameInputRumbleMotors.LowFrequency;
pub const GameInputRumbleHighFrequency = GameInputRumbleMotors.HighFrequency;
pub const GameInputRumbleLeftTrigger = GameInputRumbleMotors.LeftTrigger;
pub const GameInputRumbleRightTrigger = GameInputRumbleMotors.RightTrigger;

pub const GameInputReadingCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        callbackToken: u64,
        context: ?*anyopaque,
        reading: ?*IGameInputReading,
        hasOverrunOccurred: bool,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        callbackToken: u64,
        context: ?*anyopaque,
        reading: ?*IGameInputReading,
        hasOverrunOccurred: bool,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const GameInputDeviceCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        currentStatus: GameInputDeviceStatus,
        previousStatus: GameInputDeviceStatus,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        currentStatus: GameInputDeviceStatus,
        previousStatus: GameInputDeviceStatus,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const GameInputGuideButtonCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        isPressed: bool,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        isPressed: bool,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const GameInputKeyboardLayoutCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        currentLayout: u32,
        previousLayout: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        callbackToken: u64,
        context: ?*anyopaque,
        device: ?*IGameInputDevice,
        timestamp: u64,
        currentLayout: u32,
        previousLayout: u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const GameInputKeyState = extern struct {
    scanCode: u32,
    codePoint: u32,
    virtualKey: u8,
    isDeadKey: u8,
};

pub const GameInputMouseState = extern struct {
    buttons: GameInputMouseButtons,
    positionX: i64,
    positionY: i64,
    wheelX: i64,
    wheelY: i64,
};

pub const GameInputTouchState = extern struct {
    touchId: u64,
    sensorIndex: u32,
    positionX: f32,
    positionY: f32,
    pressure: f32,
    proximity: f32,
    contactRectTop: f32,
    contactRectLeft: f32,
    contactRectRight: f32,
    contactRectBottom: f32,
};

pub const GameInputMotionState = extern struct {
    accelerationX: f32,
    accelerationY: f32,
    accelerationZ: f32,
    angularVelocityX: f32,
    angularVelocityY: f32,
    angularVelocityZ: f32,
    magneticFieldX: f32,
    magneticFieldY: f32,
    magneticFieldZ: f32,
    orientationW: f32,
    orientationX: f32,
    orientationY: f32,
    orientationZ: f32,
    accelerometerAccuracy: GameInputMotionAccuracy,
    gyroscopeAccuracy: GameInputMotionAccuracy,
    magnetometerAccuracy: GameInputMotionAccuracy,
    orientationAccuracy: GameInputMotionAccuracy,
};

pub const GameInputArcadeStickState = extern struct {
    buttons: GameInputArcadeStickButtons,
};

pub const GameInputFlightStickState = extern struct {
    buttons: GameInputFlightStickButtons,
    hatSwitch: GameInputSwitchPosition,
    roll: f32,
    pitch: f32,
    yaw: f32,
    throttle: f32,
};

pub const GameInputGamepadState = extern struct {
    buttons: GameInputGamepadButtons,
    leftTrigger: f32,
    rightTrigger: f32,
    leftThumbstickX: f32,
    leftThumbstickY: f32,
    rightThumbstickX: f32,
    rightThumbstickY: f32,
};

pub const GameInputRacingWheelState = extern struct {
    buttons: GameInputRacingWheelButtons,
    patternShifterGear: i32,
    wheel: f32,
    throttle: f32,
    brake: f32,
    clutch: f32,
    handbrake: f32,
};

pub const GameInputUiNavigationState = extern struct {
    buttons: GameInputUiNavigationButtons,
};

pub const GameInputBatteryState = extern struct {
    chargeRate: f32,
    maxChargeRate: f32,
    remainingCapacity: f32,
    fullChargeCapacity: f32,
    status: GameInputBatteryStatus,
};

pub const GameInputString = extern struct {
    sizeInBytes: u32,
    codePointCount: u32,
    data: ?[*:0]align(1) const u8,
};

pub const GameInputUsage = extern struct {
    page: u16,
    id: u16,
};

pub const GameInputVersion = extern struct {
    major: u16,
    minor: u16,
    build: u16,
    revision: u16,
};

pub const GameInputRawDeviceItemCollectionInfo = extern struct {
    kind: GameInputRawDeviceItemCollectionKind,
    childCount: u32,
    siblingCount: u32,
    usageCount: u32,
    usages: ?*const CM_DEVNODE_STATUS_FLAGS,
    parent: ?*const GameInputRawDeviceItemCollectionInfo,
    firstSibling: ?*const GameInputRawDeviceItemCollectionInfo,
    previousSibling: ?*const GameInputRawDeviceItemCollectionInfo,
    nextSibling: ?*const GameInputRawDeviceItemCollectionInfo,
    lastSibling: ?*const GameInputRawDeviceItemCollectionInfo,
    firstChild: ?*const GameInputRawDeviceItemCollectionInfo,
    lastChild: ?*const GameInputRawDeviceItemCollectionInfo,
};

pub const GameInputRawDeviceReportItemInfo = extern struct {
    bitOffset: u32,
    bitSize: u32,
    logicalMin: i64,
    logicalMax: i64,
    physicalMin: f64,
    physicalMax: f64,
    physicalUnits: GameInputRawDevicePhysicalUnitKind,
    rawPhysicalUnits: u32,
    rawPhysicalUnitsExponent: i32,
    flags: GameInputRawDeviceReportItemFlags,
    usageCount: u32,
    usages: ?*const CM_DEVNODE_STATUS_FLAGS,
    collection: ?*const GameInputRawDeviceItemCollectionInfo,
    itemString: ?*const CM_LOG_CONF,
};

pub const GameInputRawDeviceReportInfo = extern struct {
    kind: GameInputRawDeviceReportKind,
    id: u32,
    size: u32,
    itemCount: u32,
    items: ?*const CM_CDMASK,
};

pub const GameInputControllerAxisInfo = extern struct {
    mappedInputKinds: GameInputKind,
    label: GameInputLabel,
    isContinuous: u8,
    isNonlinear: u8,
    isQuantized: u8,
    hasRestValue: u8,
    restValue: f32,
    resolution: u64,
    legacyDInputIndex: u16,
    legacyHidIndex: u16,
    rawReportIndex: u32,
    inputReport: ?*const CM_CDFLAGS,
    inputReportItem: ?*const CM_CDMASK,
};

pub const GameInputControllerButtonInfo = extern struct {
    mappedInputKinds: GameInputKind,
    label: GameInputLabel,
    legacyDInputIndex: u16,
    legacyHidIndex: u16,
    rawReportIndex: u32,
    inputReport: ?*const CM_CDFLAGS,
    inputReportItem: ?*const CM_CDMASK,
};

pub const GameInputControllerSwitchInfo = extern struct {
    mappedInputKinds: GameInputKind,
    label: GameInputLabel,
    positionLabels: [9]GameInputLabel,
    kind: GameInputSwitchKind,
    legacyDInputIndex: u16,
    legacyHidIndex: u16,
    rawReportIndex: u32,
    inputReport: ?*const CM_CDFLAGS,
    inputReportItem: ?*const CM_CDMASK,
};

pub const GameInputKeyboardInfo = extern struct {
    kind: GameInputKeyboardKind,
    layout: u32,
    keyCount: u32,
    functionKeyCount: u32,
    maxSimultaneousKeys: u32,
    platformType: u32,
    platformSubtype: u32,
    nativeLanguage: ?*const CM_LOG_CONF,
};

pub const GameInputMouseInfo = extern struct {
    supportedButtons: GameInputMouseButtons,
    sampleRate: u32,
    sensorDpi: u32,
    hasWheelX: u8,
    hasWheelY: u8,
};

pub const GameInputTouchSensorInfo = extern struct {
    mappedInputKinds: GameInputKind,
    label: GameInputLabel,
    location: GameInputLocation,
    locationId: u32,
    resolutionX: u64,
    resolutionY: u64,
    shape: GameInputTouchShape,
    aspectRatio: f32,
    orientation: f32,
    physicalWidth: f32,
    physicalHeight: f32,
    maxPressure: f32,
    maxProximity: f32,
    maxTouchPoints: u32,
};

pub const GameInputMotionInfo = extern struct {
    maxAcceleration: f32,
    maxAngularVelocity: f32,
    maxMagneticFieldStrength: f32,
};

pub const GameInputArcadeStickInfo = extern struct {
    menuButtonLabel: GameInputLabel,
    viewButtonLabel: GameInputLabel,
    stickUpLabel: GameInputLabel,
    stickDownLabel: GameInputLabel,
    stickLeftLabel: GameInputLabel,
    stickRightLabel: GameInputLabel,
    actionButton1Label: GameInputLabel,
    actionButton2Label: GameInputLabel,
    actionButton3Label: GameInputLabel,
    actionButton4Label: GameInputLabel,
    actionButton5Label: GameInputLabel,
    actionButton6Label: GameInputLabel,
    specialButton1Label: GameInputLabel,
    specialButton2Label: GameInputLabel,
};

pub const GameInputFlightStickInfo = extern struct {
    menuButtonLabel: GameInputLabel,
    viewButtonLabel: GameInputLabel,
    firePrimaryButtonLabel: GameInputLabel,
    fireSecondaryButtonLabel: GameInputLabel,
    hatSwitchKind: GameInputSwitchKind,
};

pub const GameInputGamepadInfo = extern struct {
    menuButtonLabel: GameInputLabel,
    viewButtonLabel: GameInputLabel,
    aButtonLabel: GameInputLabel,
    bButtonLabel: GameInputLabel,
    xButtonLabel: GameInputLabel,
    yButtonLabel: GameInputLabel,
    dpadUpLabel: GameInputLabel,
    dpadDownLabel: GameInputLabel,
    dpadLeftLabel: GameInputLabel,
    dpadRightLabel: GameInputLabel,
    leftShoulderButtonLabel: GameInputLabel,
    rightShoulderButtonLabel: GameInputLabel,
    leftThumbstickButtonLabel: GameInputLabel,
    rightThumbstickButtonLabel: GameInputLabel,
};

pub const GameInputRacingWheelInfo = extern struct {
    menuButtonLabel: GameInputLabel,
    viewButtonLabel: GameInputLabel,
    previousGearButtonLabel: GameInputLabel,
    nextGearButtonLabel: GameInputLabel,
    dpadUpLabel: GameInputLabel,
    dpadDownLabel: GameInputLabel,
    dpadLeftLabel: GameInputLabel,
    dpadRightLabel: GameInputLabel,
    hasClutch: u8,
    hasHandbrake: u8,
    hasPatternShifter: u8,
    minPatternShifterGear: i32,
    maxPatternShifterGear: i32,
    maxWheelAngle: f32,
};

pub const GameInputUiNavigationInfo = extern struct {
    menuButtonLabel: GameInputLabel,
    viewButtonLabel: GameInputLabel,
    acceptButtonLabel: GameInputLabel,
    cancelButtonLabel: GameInputLabel,
    upButtonLabel: GameInputLabel,
    downButtonLabel: GameInputLabel,
    leftButtonLabel: GameInputLabel,
    rightButtonLabel: GameInputLabel,
    contextButton1Label: GameInputLabel,
    contextButton2Label: GameInputLabel,
    contextButton3Label: GameInputLabel,
    contextButton4Label: GameInputLabel,
    pageUpButtonLabel: GameInputLabel,
    pageDownButtonLabel: GameInputLabel,
    pageLeftButtonLabel: GameInputLabel,
    pageRightButtonLabel: GameInputLabel,
    scrollUpButtonLabel: GameInputLabel,
    scrollDownButtonLabel: GameInputLabel,
    scrollLeftButtonLabel: GameInputLabel,
    scrollRightButtonLabel: GameInputLabel,
    guideButtonLabel: GameInputLabel,
};

pub const GameInputForceFeedbackMotorInfo = extern struct {
    supportedAxes: GameInputFeedbackAxes,
    location: GameInputLocation,
    locationId: u32,
    maxSimultaneousEffects: u32,
    isConstantEffectSupported: u8,
    isRampEffectSupported: u8,
    isSineWaveEffectSupported: u8,
    isSquareWaveEffectSupported: u8,
    isTriangleWaveEffectSupported: u8,
    isSawtoothUpWaveEffectSupported: u8,
    isSawtoothDownWaveEffectSupported: u8,
    isSpringEffectSupported: u8,
    isFrictionEffectSupported: u8,
    isDamperEffectSupported: u8,
    isInertiaEffectSupported: u8,
};

pub const GameInputHapticWaveformInfo = extern struct {
    usage: CM_DEVNODE_STATUS_FLAGS,
    isDurationSupported: u8,
    isIntensitySupported: u8,
    isRepeatSupported: u8,
    isRepeatDelaySupported: u8,
    defaultDuration: u64,
};

pub const GameInputHapticFeedbackMotorInfo = extern struct {
    mappedRumbleMotors: GameInputRumbleMotors,
    location: GameInputLocation,
    locationId: u32,
    waveformCount: u32,
    waveformInfo: ?*const GameInputHapticWaveformInfo,
};

pub const GameInputDeviceInfo = extern struct {
    infoSize: u32,
    vendorId: u16,
    productId: u16,
    revisionNumber: u16,
    interfaceNumber: u8,
    collectionNumber: u8,
    usage: CM_DEVNODE_STATUS_FLAGS,
    hardwareVersion: CM_PROB,
    firmwareVersion: CM_PROB,
    deviceId: APP_LOCAL_DEVICE_ID,
    deviceRootId: APP_LOCAL_DEVICE_ID,
    deviceFamily: GameInputDeviceFamily,
    capabilities: GameInputDeviceCapabilities,
    supportedInput: GameInputKind,
    supportedRumbleMotors: GameInputRumbleMotors,
    inputReportCount: u32,
    outputReportCount: u32,
    featureReportCount: u32,
    controllerAxisCount: u32,
    controllerButtonCount: u32,
    controllerSwitchCount: u32,
    touchPointCount: u32,
    touchSensorCount: u32,
    forceFeedbackMotorCount: u32,
    hapticFeedbackMotorCount: u32,
    deviceStringCount: u32,
    deviceDescriptorSize: u32,
    inputReportInfo: ?*const CM_CDFLAGS,
    outputReportInfo: ?*const CM_CDFLAGS,
    featureReportInfo: ?*const CM_CDFLAGS,
    controllerAxisInfo: ?*const CM_REMOVAL_POLICY,
    controllerButtonInfo: ?*const CM_INSTALL_STATE,
    controllerSwitchInfo: ?*const CM_DEVCAP,
    keyboardInfo: ?*const SET_DISPLAY_CONFIG_FLAGS,
    mouseInfo: ?*const QUERY_DISPLAY_CONFIG_FLAGS,
    touchSensorInfo: ?*const GameInputTouchSensorInfo,
    motionInfo: ?*const DEVPROPTYPE,
    arcadeStickInfo: ?*const WINUSB_PIPE_POLICY,
    flightStickInfo: ?*const WINUSB_POWER_POLICY,
    gamepadInfo: ?*const CONFIGRET,
    racingWheelInfo: ?*const GameInputRacingWheelInfo,
    uiNavigationInfo: ?*const D2D_COLOR_F,
    forceFeedbackMotorInfo: ?*const D2D1_COLOR_F,
    hapticFeedbackMotorInfo: ?*const GameInputHapticFeedbackMotorInfo,
    displayName: ?*const CM_LOG_CONF,
    deviceStrings: ?*const CM_LOG_CONF,
    deviceDescriptorData: ?*const anyopaque,
};

pub const GameInputForceFeedbackEnvelope = extern struct {
    attackDuration: u64,
    sustainDuration: u64,
    releaseDuration: u64,
    attackGain: f32,
    sustainGain: f32,
    releaseGain: f32,
    playCount: u32,
    repeatDelay: u64,
};

pub const GameInputForceFeedbackMagnitude = extern struct {
    linearX: f32,
    linearY: f32,
    linearZ: f32,
    angularX: f32,
    angularY: f32,
    angularZ: f32,
    normal: f32,
};

pub const GameInputForceFeedbackConditionParams = extern struct {
    magnitude: GameInputForceFeedbackMagnitude,
    positiveCoefficient: f32,
    negativeCoefficient: f32,
    maxPositiveMagnitude: f32,
    maxNegativeMagnitude: f32,
    deadZone: f32,
    bias: f32,
};

pub const GameInputForceFeedbackConstantParams = extern struct {
    envelope: GameInputForceFeedbackEnvelope,
    magnitude: GameInputForceFeedbackMagnitude,
};

pub const GameInputForceFeedbackPeriodicParams = extern struct {
    envelope: GameInputForceFeedbackEnvelope,
    magnitude: GameInputForceFeedbackMagnitude,
    frequency: f32,
    phase: f32,
    bias: f32,
};

pub const GameInputForceFeedbackRampParams = extern struct {
    envelope: GameInputForceFeedbackEnvelope,
    startMagnitude: GameInputForceFeedbackMagnitude,
    endMagnitude: GameInputForceFeedbackMagnitude,
};

pub const GameInputForceFeedbackParams = extern struct {
    kind: GameInputForceFeedbackEffectKind,
    data: extern union {
        constant: DWRITE_COLOR_F,
        ramp: GameInputForceFeedbackRampParams,
        sineWave: DXGI_RGBA,
        squareWave: DXGI_RGBA,
        triangleWave: DXGI_RGBA,
        sawtoothUpWave: DXGI_RGBA,
        sawtoothDownWave: DXGI_RGBA,
        spring: DWRITE_FONT_AXIS_TAG,
        friction: DWRITE_FONT_AXIS_TAG,
        damper: DWRITE_FONT_AXIS_TAG,
        inertia: DWRITE_FONT_AXIS_TAG,
    },
};

pub const GameInputHapticFeedbackParams = extern struct {
    waveformIndex: u32,
    duration: u64,
    intensity: f32,
    playCount: u32,
    repeatDelay: u64,
};

pub const GameInputRumbleParams = extern struct {
    lowFrequency: f32,
    highFrequency: f32,
    leftTrigger: f32,
    rightTrigger: f32,
};

const IID_IGameInput_Value = Guid.initString("11be2a7e-4254-445a-9c09-ffc40f006918");
pub const IID_IGameInput = &IID_IGameInput_Value;
pub const IGameInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTimestamp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IGameInput,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetCurrentReading: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextReading: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                referenceReading: ?*IGameInputReading,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                referenceReading: ?*IGameInputReading,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousReading: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                referenceReading: ?*IGameInputReading,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                referenceReading: ?*IGameInputReading,
                inputKind: GameInputKind,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTemporalReading: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                timestamp: u64,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                timestamp: u64,
                device: ?*IGameInputDevice,
                reading: ?*?*IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterReadingCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                inputKind: GameInputKind,
                analogThreshold: f32,
                context: ?*anyopaque,
                callbackFunc: OEM_SOURCE_MEDIA_TYPE,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                inputKind: GameInputKind,
                analogThreshold: f32,
                context: ?*anyopaque,
                callbackFunc: OEM_SOURCE_MEDIA_TYPE,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterDeviceCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                inputKind: GameInputKind,
                statusFilter: GameInputDeviceStatus,
                enumerationKind: GameInputEnumerationKind,
                context: ?*anyopaque,
                callbackFunc: SETUP_DI_BUILD_DRIVER_DRIVER_TYPE,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                inputKind: GameInputKind,
                statusFilter: GameInputDeviceStatus,
                enumerationKind: GameInputEnumerationKind,
                context: ?*anyopaque,
                callbackFunc: SETUP_DI_BUILD_DRIVER_DRIVER_TYPE,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterGuideButtonCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                context: ?*anyopaque,
                callbackFunc: DIINSTALLDEVICE_FLAGS,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                context: ?*anyopaque,
                callbackFunc: DIINSTALLDEVICE_FLAGS,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterKeyboardLayoutCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                context: ?*anyopaque,
                callbackFunc: DIINSTALLDRIVER_FLAGS,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                device: ?*IGameInputDevice,
                context: ?*anyopaque,
                callbackFunc: DIINSTALLDRIVER_FLAGS,
                callbackToken: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                callbackToken: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInput,
                callbackToken: u64,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        UnregisterCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                callbackToken: u64,
                timeoutInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInput,
                callbackToken: u64,
                timeoutInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        CreateDispatcher: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                dispatcher: ?*?*IGameInputDispatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                dispatcher: ?*?*IGameInputDispatcher,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAggregateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                inputKind: GameInputKind,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                inputKind: GameInputKind,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindDeviceFromId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                value: ?*const APP_LOCAL_DEVICE_ID,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                value: ?*const APP_LOCAL_DEVICE_ID,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindDeviceFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                value: ?*IUnknown,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                value: ?*IUnknown,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindDeviceFromPlatformHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                value: ?HANDLE,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                value: ?HANDLE,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindDeviceFromPlatformString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                value: ?[*:0]align(1) const u16,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                value: ?[*:0]align(1) const u16,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnableOemDeviceSupport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                vendorId: u16,
                productId: u16,
                interfaceNumber: u8,
                collectionNumber: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInput,
                vendorId: u16,
                productId: u16,
                interfaceNumber: u8,
                collectionNumber: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocusPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInput,
                policy: GameInputFocusPolicy,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInput,
                policy: GameInputFocusPolicy,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_GetCurrentTimestamp(self: *const T) callconv(.Inline) u64 {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).GetCurrentTimestamp(@as(*const IGameInput, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_GetCurrentReading(self: *const T, inputKind: GameInputKind, device: ?*IGameInputDevice, reading: ?*?*IGameInputReading) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).GetCurrentReading(@as(*const IGameInput, @ptrCast(self)), inputKind, device, reading);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_GetNextReading(self: *const T, referenceReading: ?*IGameInputReading, inputKind: GameInputKind, device: ?*IGameInputDevice, reading: ?*?*IGameInputReading) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).GetNextReading(@as(*const IGameInput, @ptrCast(self)), referenceReading, inputKind, device, reading);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_GetPreviousReading(self: *const T, referenceReading: ?*IGameInputReading, inputKind: GameInputKind, device: ?*IGameInputDevice, reading: ?*?*IGameInputReading) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).GetPreviousReading(@as(*const IGameInput, @ptrCast(self)), referenceReading, inputKind, device, reading);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_GetTemporalReading(self: *const T, timestamp: u64, device: ?*IGameInputDevice, reading: ?*?*IGameInputReading) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).GetTemporalReading(@as(*const IGameInput, @ptrCast(self)), timestamp, device, reading);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_RegisterReadingCallback(self: *const T, device: ?*IGameInputDevice, inputKind: GameInputKind, analogThreshold: f32, context: ?*anyopaque, callbackFunc: OEM_SOURCE_MEDIA_TYPE, callbackToken: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).RegisterReadingCallback(@as(*const IGameInput, @ptrCast(self)), device, inputKind, analogThreshold, context, callbackFunc, callbackToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_RegisterDeviceCallback(self: *const T, device: ?*IGameInputDevice, inputKind: GameInputKind, statusFilter: GameInputDeviceStatus, enumerationKind: GameInputEnumerationKind, context: ?*anyopaque, callbackFunc: SETUP_DI_BUILD_DRIVER_DRIVER_TYPE, callbackToken: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).RegisterDeviceCallback(@as(*const IGameInput, @ptrCast(self)), device, inputKind, statusFilter, enumerationKind, context, callbackFunc, callbackToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_RegisterGuideButtonCallback(self: *const T, device: ?*IGameInputDevice, context: ?*anyopaque, callbackFunc: DIINSTALLDEVICE_FLAGS, callbackToken: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).RegisterGuideButtonCallback(@as(*const IGameInput, @ptrCast(self)), device, context, callbackFunc, callbackToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_RegisterKeyboardLayoutCallback(self: *const T, device: ?*IGameInputDevice, context: ?*anyopaque, callbackFunc: DIINSTALLDRIVER_FLAGS, callbackToken: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).RegisterKeyboardLayoutCallback(@as(*const IGameInput, @ptrCast(self)), device, context, callbackFunc, callbackToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_StopCallback(self: *const T, callbackToken: u64) callconv(.Inline) void {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).StopCallback(@as(*const IGameInput, @ptrCast(self)), callbackToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_UnregisterCallback(self: *const T, callbackToken: u64, timeoutInMicroseconds: u64) callconv(.Inline) bool {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).UnregisterCallback(@as(*const IGameInput, @ptrCast(self)), callbackToken, timeoutInMicroseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_CreateDispatcher(self: *const T, dispatcher: ?*?*IGameInputDispatcher) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).CreateDispatcher(@as(*const IGameInput, @ptrCast(self)), dispatcher);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_CreateAggregateDevice(self: *const T, inputKind: GameInputKind, device: ?*?*IGameInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).CreateAggregateDevice(@as(*const IGameInput, @ptrCast(self)), inputKind, device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_FindDeviceFromId(self: *const T, value: ?*const APP_LOCAL_DEVICE_ID, device: ?*?*IGameInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).FindDeviceFromId(@as(*const IGameInput, @ptrCast(self)), value, device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_FindDeviceFromObject(self: *const T, value: ?*IUnknown, device: ?*?*IGameInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).FindDeviceFromObject(@as(*const IGameInput, @ptrCast(self)), value, device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_FindDeviceFromPlatformHandle(self: *const T, value: ?HANDLE, device: ?*?*IGameInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).FindDeviceFromPlatformHandle(@as(*const IGameInput, @ptrCast(self)), value, device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_FindDeviceFromPlatformString(self: *const T, value: ?[*:0]align(1) const u16, device: ?*?*IGameInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).FindDeviceFromPlatformString(@as(*const IGameInput, @ptrCast(self)), value, device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_EnableOemDeviceSupport(self: *const T, vendorId: u16, productId: u16, interfaceNumber: u8, collectionNumber: u8) callconv(.Inline) HRESULT {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).EnableOemDeviceSupport(@as(*const IGameInput, @ptrCast(self)), vendorId, productId, interfaceNumber, collectionNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInput_SetFocusPolicy(self: *const T, policy: GameInputFocusPolicy) callconv(.Inline) void {
            return @as(*const IGameInput.VTable, @ptrCast(self.vtable)).SetFocusPolicy(@as(*const IGameInput, @ptrCast(self)), policy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGameInputReading_Value = Guid.initString("2156947a-e1fa-4de0-a30b-d812931dbd8d");
pub const IID_IGameInputReading = &IID_IGameInputReading_Value;
pub const IGameInputReading = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) GameInputKind,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) GameInputKind,
        },
        GetSequenceNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                inputKind: GameInputKind,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IGameInputReading,
                inputKind: GameInputKind,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetTimestamp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputReading,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetRawReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetControllerAxisCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetControllerAxisState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]f32,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetControllerButtonCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetControllerButtonState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]bool,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]bool,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetControllerSwitchCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetControllerSwitchState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]GameInputSwitchPosition,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]GameInputSwitchPosition,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetKeyCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetKeyState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]DIUNINSTALLDRIVER_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]DIUNINSTALLDRIVER_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetMouseState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*DIROLLBACKDRIVER_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*DIROLLBACKDRIVER_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetTouchCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetTouchState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputReading,
                stateArrayCount: u32,
                stateArray: [*]UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetMotionState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*CM_RESTYPE,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*CM_RESTYPE,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetArcadeStickState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*CM_GET_DEVICE_INTERFACE_LIST_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*CM_GET_DEVICE_INTERFACE_LIST_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetFlightStickState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*CM_LOCATE_DEVNODE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*CM_LOCATE_DEVNODE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetGamepadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*CM_REENUMERATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*CM_REENUMERATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetRacingWheelState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*CM_ENUMERATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*CM_ENUMERATE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetUiNavigationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputReading,
                state: ?*INF_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputReading,
                state: ?*INF_STYLE,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetInputKind(self: *const T) callconv(.Inline) GameInputKind {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetInputKind(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetSequenceNumber(self: *const T, inputKind: GameInputKind) callconv(.Inline) u64 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetSequenceNumber(@as(*const IGameInputReading, @ptrCast(self)), inputKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetTimestamp(self: *const T) callconv(.Inline) u64 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetTimestamp(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetDevice(self: *const T, device: ?*?*IGameInputDevice) callconv(.Inline) void {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IGameInputReading, @ptrCast(self)), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetRawReport(self: *const T, report: ?*?*IGameInputRawDeviceReport) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetRawReport(@as(*const IGameInputReading, @ptrCast(self)), report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerAxisCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerAxisCount(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerAxisState(self: *const T, stateArrayCount: u32, stateArray: [*]f32) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerAxisState(@as(*const IGameInputReading, @ptrCast(self)), stateArrayCount, stateArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerButtonCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerButtonCount(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerButtonState(self: *const T, stateArrayCount: u32, stateArray: [*]bool) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerButtonState(@as(*const IGameInputReading, @ptrCast(self)), stateArrayCount, stateArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerSwitchCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerSwitchCount(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetControllerSwitchState(self: *const T, stateArrayCount: u32, stateArray: [*]GameInputSwitchPosition) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetControllerSwitchState(@as(*const IGameInputReading, @ptrCast(self)), stateArrayCount, stateArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetKeyCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetKeyCount(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetKeyState(self: *const T, stateArrayCount: u32, stateArray: [*]DIUNINSTALLDRIVER_FLAGS) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetKeyState(@as(*const IGameInputReading, @ptrCast(self)), stateArrayCount, stateArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetMouseState(self: *const T, state: ?*DIROLLBACKDRIVER_FLAGS) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetMouseState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetTouchCount(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetTouchCount(@as(*const IGameInputReading, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetTouchState(self: *const T, stateArrayCount: u32, stateArray: [*]UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS) callconv(.Inline) u32 {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetTouchState(@as(*const IGameInputReading, @ptrCast(self)), stateArrayCount, stateArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetMotionState(self: *const T, state: ?*CM_RESTYPE) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetMotionState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetArcadeStickState(self: *const T, state: ?*CM_GET_DEVICE_INTERFACE_LIST_FLAGS) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetArcadeStickState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetFlightStickState(self: *const T, state: ?*CM_LOCATE_DEVNODE_FLAGS) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetFlightStickState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetGamepadState(self: *const T, state: ?*CM_REENUMERATE_FLAGS) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetGamepadState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetRacingWheelState(self: *const T, state: ?*CM_ENUMERATE_FLAGS) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetRacingWheelState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputReading_GetUiNavigationState(self: *const T, state: ?*INF_STYLE) callconv(.Inline) bool {
            return @as(*const IGameInputReading.VTable, @ptrCast(self.vtable)).GetUiNavigationState(@as(*const IGameInputReading, @ptrCast(self)), state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGameInputDevice_Value = Guid.initString("31dd86fb-4c1b-408a-868f-439b3cd47125");
pub const IID_IGameInputDevice = &IID_IGameInputDevice_Value;
pub const IGameInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) ?*GameInputDeviceInfo,
            else => *const fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) ?*GameInputDeviceInfo,
        },
        GetDeviceStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) GameInputDeviceStatus,
            else => *const fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) GameInputDeviceStatus,
        },
        GetBatteryState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                state: ?*SETUPSCANFILEQUEUE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
                state: ?*SETUPSCANFILEQUEUE_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateForceFeedbackEffect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                params: ?*const GameInputForceFeedbackParams,
                effect: ?*?*IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                params: ?*const GameInputForceFeedbackParams,
                effect: ?*?*IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsForceFeedbackMotorPoweredOn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        SetForceFeedbackMotorGain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                masterGain: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                masterGain: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetHapticMotorState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                params: ?*const FILE_FLAGS_AND_ATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                motorIndex: u32,
                params: ?*const FILE_FLAGS_AND_ATTRIBUTES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRumbleState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                params: ?*const FILE_ACCESS_RIGHTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
                params: ?*const FILE_ACCESS_RIGHTS,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetInputSynchronizationState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                enabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
                enabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SendInputSynchronizationHint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        PowerOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        CreateRawDeviceReport: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                reportId: u32,
                reportKind: GameInputRawDeviceReportKind,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                reportId: u32,
                reportKind: GameInputRawDeviceReportKind,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawDeviceFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                reportId: u32,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                reportId: u32,
                report: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRawDeviceFeature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                report: ?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                report: ?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendRawDeviceOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                report: ?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                report: ?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendRawDeviceOutputWithResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                requestReport: ?*IGameInputRawDeviceReport,
                responseReport: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                requestReport: ?*IGameInputRawDeviceReport,
                responseReport: ?*?*IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteRawDeviceIoControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                controlCode: u32,
                inputBufferSize: usize,
                // TODO: what to do with BytesParamIndex 1?
                inputBuffer: ?*const anyopaque,
                outputBufferSize: usize,
                // TODO: what to do with BytesParamIndex 3?
                outputBuffer: ?*anyopaque,
                outputSize: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDevice,
                controlCode: u32,
                inputBufferSize: usize,
                // TODO: what to do with BytesParamIndex 1?
                inputBuffer: ?*const anyopaque,
                outputBufferSize: usize,
                // TODO: what to do with BytesParamIndex 3?
                outputBuffer: ?*anyopaque,
                outputSize: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquireExclusiveRawDeviceAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
                timeoutInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputDevice,
                timeoutInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        ReleaseExclusiveRawDeviceAccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_GetDeviceInfo(self: *const T) callconv(.Inline) ?*GameInputDeviceInfo {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).GetDeviceInfo(@as(*const IGameInputDevice, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_GetDeviceStatus(self: *const T) callconv(.Inline) GameInputDeviceStatus {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).GetDeviceStatus(@as(*const IGameInputDevice, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_GetBatteryState(self: *const T, state: ?*SETUPSCANFILEQUEUE_FLAGS) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).GetBatteryState(@as(*const IGameInputDevice, @ptrCast(self)), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_CreateForceFeedbackEffect(self: *const T, motorIndex: u32, params: ?*const GameInputForceFeedbackParams, effect: ?*?*IGameInputForceFeedbackEffect) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).CreateForceFeedbackEffect(@as(*const IGameInputDevice, @ptrCast(self)), motorIndex, params, effect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_IsForceFeedbackMotorPoweredOn(self: *const T, motorIndex: u32) callconv(.Inline) bool {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).IsForceFeedbackMotorPoweredOn(@as(*const IGameInputDevice, @ptrCast(self)), motorIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SetForceFeedbackMotorGain(self: *const T, motorIndex: u32, masterGain: f32) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SetForceFeedbackMotorGain(@as(*const IGameInputDevice, @ptrCast(self)), motorIndex, masterGain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SetHapticMotorState(self: *const T, motorIndex: u32, params: ?*const FILE_FLAGS_AND_ATTRIBUTES) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SetHapticMotorState(@as(*const IGameInputDevice, @ptrCast(self)), motorIndex, params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SetRumbleState(self: *const T, params: ?*const FILE_ACCESS_RIGHTS) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SetRumbleState(@as(*const IGameInputDevice, @ptrCast(self)), params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SetInputSynchronizationState(self: *const T, enabled: u8) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SetInputSynchronizationState(@as(*const IGameInputDevice, @ptrCast(self)), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SendInputSynchronizationHint(self: *const T) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SendInputSynchronizationHint(@as(*const IGameInputDevice, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_PowerOff(self: *const T) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).PowerOff(@as(*const IGameInputDevice, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_CreateRawDeviceReport(self: *const T, reportId: u32, reportKind: GameInputRawDeviceReportKind, report: ?*?*IGameInputRawDeviceReport) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).CreateRawDeviceReport(@as(*const IGameInputDevice, @ptrCast(self)), reportId, reportKind, report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_GetRawDeviceFeature(self: *const T, reportId: u32, report: ?*?*IGameInputRawDeviceReport) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).GetRawDeviceFeature(@as(*const IGameInputDevice, @ptrCast(self)), reportId, report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SetRawDeviceFeature(self: *const T, report: ?*IGameInputRawDeviceReport) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SetRawDeviceFeature(@as(*const IGameInputDevice, @ptrCast(self)), report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SendRawDeviceOutput(self: *const T, report: ?*IGameInputRawDeviceReport) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SendRawDeviceOutput(@as(*const IGameInputDevice, @ptrCast(self)), report);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_SendRawDeviceOutputWithResponse(self: *const T, requestReport: ?*IGameInputRawDeviceReport, responseReport: ?*?*IGameInputRawDeviceReport) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).SendRawDeviceOutputWithResponse(@as(*const IGameInputDevice, @ptrCast(self)), requestReport, responseReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_ExecuteRawDeviceIoControl(self: *const T, controlCode: u32, inputBufferSize: usize, inputBuffer: ?*const anyopaque, outputBufferSize: usize, outputBuffer: ?*anyopaque, outputSize: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).ExecuteRawDeviceIoControl(@as(*const IGameInputDevice, @ptrCast(self)), controlCode, inputBufferSize, inputBuffer, outputBufferSize, outputBuffer, outputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_AcquireExclusiveRawDeviceAccess(self: *const T, timeoutInMicroseconds: u64) callconv(.Inline) bool {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).AcquireExclusiveRawDeviceAccess(@as(*const IGameInputDevice, @ptrCast(self)), timeoutInMicroseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDevice_ReleaseExclusiveRawDeviceAccess(self: *const T) callconv(.Inline) void {
            return @as(*const IGameInputDevice.VTable, @ptrCast(self.vtable)).ReleaseExclusiveRawDeviceAccess(@as(*const IGameInputDevice, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGameInputDispatcher_Value = Guid.initString("415eed2e-98cb-42c2-8f28-b94601074e31");
pub const IID_IGameInputDispatcher = &IID_IGameInputDispatcher_Value;
pub const IGameInputDispatcher = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Dispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDispatcher,
                quotaInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputDispatcher,
                quotaInMicroseconds: u64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        OpenWaitHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputDispatcher,
                waitHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGameInputDispatcher,
                waitHandle: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDispatcher_Dispatch(self: *const T, quotaInMicroseconds: u64) callconv(.Inline) bool {
            return @as(*const IGameInputDispatcher.VTable, @ptrCast(self.vtable)).Dispatch(@as(*const IGameInputDispatcher, @ptrCast(self)), quotaInMicroseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputDispatcher_OpenWaitHandle(self: *const T, waitHandle: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IGameInputDispatcher.VTable, @ptrCast(self.vtable)).OpenWaitHandle(@as(*const IGameInputDispatcher, @ptrCast(self)), waitHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGameInputForceFeedbackEffect_Value = Guid.initString("51bda05e-f742-45d9-b085-9444ae48381d");
pub const IID_IGameInputForceFeedbackEffect = &IID_IGameInputForceFeedbackEffect_Value;
pub const IGameInputForceFeedbackEffect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetMotorIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetGain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) f32,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) f32,
        },
        SetGain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
                gain: f32,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
                params: ?*GameInputForceFeedbackParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
                params: ?*GameInputForceFeedbackParams,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        SetParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
                params: ?*const GameInputForceFeedbackParams,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
                params: ?*const GameInputForceFeedbackParams,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) GameInputFeedbackEffectState,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
            ) callconv(@import("std").os.windows.WINAPI) GameInputFeedbackEffectState,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputForceFeedbackEffect,
                state: GameInputFeedbackEffectState,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputForceFeedbackEffect,
                state: GameInputFeedbackEffectState,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_GetDevice(self: *const T, device: ?*?*IGameInputDevice) callconv(.Inline) void {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_GetMotorIndex(self: *const T) callconv(.Inline) u32 {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).GetMotorIndex(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_GetGain(self: *const T) callconv(.Inline) f32 {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).GetGain(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_SetGain(self: *const T, gain: f32) callconv(.Inline) void {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).SetGain(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)), gain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_GetParams(self: *const T, params: ?*GameInputForceFeedbackParams) callconv(.Inline) void {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).GetParams(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)), params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_SetParams(self: *const T, params: ?*const GameInputForceFeedbackParams) callconv(.Inline) bool {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).SetParams(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)), params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_GetState(self: *const T) callconv(.Inline) GameInputFeedbackEffectState {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).GetState(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputForceFeedbackEffect_SetState(self: *const T, state: GameInputFeedbackEffectState) callconv(.Inline) void {
            return @as(*const IGameInputForceFeedbackEffect.VTable, @ptrCast(self.vtable)).SetState(@as(*const IGameInputForceFeedbackEffect, @ptrCast(self)), state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGameInputRawDeviceReport_Value = Guid.initString("61f08cf1-1ffc-40ca-a2b8-e1ab8bc5b6dc");
pub const IID_IGameInputRawDeviceReport = &IID_IGameInputRawDeviceReport_Value;
pub const IGameInputRawDeviceReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                device: ?*?*IGameInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetReportInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) ?*CM_CDFLAGS,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) ?*CM_CDFLAGS,
        },
        GetRawDataSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        GetRawData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                bufferSize: usize,
                buffer: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) usize,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                bufferSize: usize,
                buffer: [*]u8,
            ) callconv(@import("std").os.windows.WINAPI) usize,
        },
        SetRawData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                bufferSize: usize,
                buffer: [*]const u8,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                bufferSize: usize,
                buffer: [*]const u8,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        GetItemValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
                value: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
                value: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        SetItemValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
                value: i64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
                value: i64,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        ResetItemValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
                itemIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        ResetAllItems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IGameInputRawDeviceReport,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_GetDevice(self: *const T, device: ?*?*IGameInputDevice) callconv(.Inline) void {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).GetDevice(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), device);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_GetReportInfo(self: *const T) callconv(.Inline) ?*CM_CDFLAGS {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).GetReportInfo(@as(*const IGameInputRawDeviceReport, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_GetRawDataSize(self: *const T) callconv(.Inline) usize {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).GetRawDataSize(@as(*const IGameInputRawDeviceReport, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_GetRawData(self: *const T, bufferSize: usize, buffer: [*]u8) callconv(.Inline) usize {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).GetRawData(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), bufferSize, buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_SetRawData(self: *const T, bufferSize: usize, buffer: [*]const u8) callconv(.Inline) bool {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).SetRawData(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), bufferSize, buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_GetItemValue(self: *const T, itemIndex: u32, value: ?*i64) callconv(.Inline) bool {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).GetItemValue(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), itemIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_SetItemValue(self: *const T, itemIndex: u32, value: i64) callconv(.Inline) bool {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).SetItemValue(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), itemIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_ResetItemValue(self: *const T, itemIndex: u32) callconv(.Inline) bool {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).ResetItemValue(@as(*const IGameInputRawDeviceReport, @ptrCast(self)), itemIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGameInputRawDeviceReport_ResetAllItems(self: *const T) callconv(.Inline) bool {
            return @as(*const IGameInputRawDeviceReport.VTable, @ptrCast(self.vtable)).ResetAllItems(@as(*const IGameInputRawDeviceReport, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (1)
//--------------------------------------------------------------------------------
pub extern "gameinput" fn GameInputCreate(
    gameInput: ?*?*IGameInput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (42)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const APP_LOCAL_DEVICE_ID = @import("../windows/win32/foundation.zig").APP_LOCAL_DEVICE_ID;
const CM_CDFLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_CDFLAGS;
const CM_CDMASK = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_CDMASK;
const CM_DEVCAP = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_DEVCAP;
const CM_DEVNODE_STATUS_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_DEVNODE_STATUS_FLAGS;
const CM_ENUMERATE_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_ENUMERATE_FLAGS;
const CM_GET_DEVICE_INTERFACE_LIST_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_GET_DEVICE_INTERFACE_LIST_FLAGS;
const CM_INSTALL_STATE = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_INSTALL_STATE;
const CM_LOCATE_DEVNODE_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_LOCATE_DEVNODE_FLAGS;
const CM_LOG_CONF = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_LOG_CONF;
const CM_PROB = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_PROB;
const CM_REENUMERATE_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_REENUMERATE_FLAGS;
const CM_REMOVAL_POLICY = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_REMOVAL_POLICY;
const CM_RESTYPE = @import("../windows/win32/devices/device_and_driver_installation.zig").CM_RESTYPE;
const CONFIGRET = @import("../windows/win32/devices/device_and_driver_installation.zig").CONFIGRET;
const D2D1_COLOR_F = @import("../windows/win32/graphics/direct2d/common.zig").D2D1_COLOR_F;
const D2D_COLOR_F = @import("../windows/win32/graphics/direct2d/common.zig").D2D_COLOR_F;
const DEVPROPTYPE = @import("../windows/win32/devices/properties.zig").DEVPROPTYPE;
const DIINSTALLDEVICE_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").DIINSTALLDEVICE_FLAGS;
const DIINSTALLDRIVER_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").DIINSTALLDRIVER_FLAGS;
const DIROLLBACKDRIVER_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").DIROLLBACKDRIVER_FLAGS;
const DIUNINSTALLDRIVER_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").DIUNINSTALLDRIVER_FLAGS;
const DWRITE_COLOR_F = @import("../windows/win32/graphics/direct_write.zig").DWRITE_COLOR_F;
const DWRITE_FONT_AXIS_TAG = @import("../windows/win32/graphics/direct_write.zig").DWRITE_FONT_AXIS_TAG;
const DXGI_RGBA = @import("../windows/win32/graphics/dxgi.zig").DXGI_RGBA;
const FILE_ACCESS_RIGHTS = @import("../windows/win32/storage/file_system.zig").FILE_ACCESS_RIGHTS;
const FILE_FLAGS_AND_ATTRIBUTES = @import("../windows/win32/storage/file_system.zig").FILE_FLAGS_AND_ATTRIBUTES;
const HANDLE = @import("../windows/win32/foundation.zig").HANDLE;
const HRESULT = @import("../windows/win32/foundation.zig").HRESULT;
const INF_STYLE = @import("../windows/win32/devices/device_and_driver_installation.zig").INF_STYLE;
const IUnknown = @import("../windows/win32/system/com.zig").IUnknown;
const OEM_SOURCE_MEDIA_TYPE = @import("../windows/win32/devices/device_and_driver_installation.zig").OEM_SOURCE_MEDIA_TYPE;
const PSTR = @import("../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../windows/win32/foundation.zig").PWSTR;
const QUERY_DISPLAY_CONFIG_FLAGS = @import("../windows/win32/devices/display.zig").QUERY_DISPLAY_CONFIG_FLAGS;
const SET_DISPLAY_CONFIG_FLAGS = @import("../windows/win32/devices/display.zig").SET_DISPLAY_CONFIG_FLAGS;
const SETUP_DI_BUILD_DRIVER_DRIVER_TYPE = @import("../windows/win32/devices/device_and_driver_installation.zig").SETUP_DI_BUILD_DRIVER_DRIVER_TYPE;
const SETUPSCANFILEQUEUE_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").SETUPSCANFILEQUEUE_FLAGS;
const UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS = @import("../windows/win32/devices/device_and_driver_installation.zig").UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS;
const WINUSB_PIPE_POLICY = @import("../windows/win32/devices/usb.zig").WINUSB_PIPE_POLICY;
const WINUSB_POWER_POLICY = @import("../windows/win32/devices/usb.zig").WINUSB_POWER_POLICY;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "GameInputReadingCallback")) { _ = GameInputReadingCallback; }
    if (@hasDecl(@This(), "GameInputDeviceCallback")) { _ = GameInputDeviceCallback; }
    if (@hasDecl(@This(), "GameInputGuideButtonCallback")) { _ = GameInputGuideButtonCallback; }
    if (@hasDecl(@This(), "GameInputKeyboardLayoutCallback")) { _ = GameInputKeyboardLayoutCallback; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
