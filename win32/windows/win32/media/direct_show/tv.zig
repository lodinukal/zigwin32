//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (228)
//--------------------------------------------------------------------------------
pub const DTV_CardStatus_Inserted = @as(u32, 0);
pub const DTV_CardStatus_Removed = @as(u32, 1);
pub const DTV_CardStatus_Error = @as(u32, 2);
pub const DTV_CardStatus_FirmwareDownload = @as(u32, 3);
pub const OCUR_PAIRING_PROTOCOL_VERSION = @as(u32, 2);
pub const PBDA_PAIRING_PROTOCOL_VERSION = @as(u32, 3);
pub const DTV_MMIMessage_Open = @as(u32, 0);
pub const DTV_MMIMessage_Close = @as(u32, 1);
pub const DTV_Entitlement_CanDecrypt = @as(u32, 0);
pub const DTV_Entitlement_NotEntitled = @as(u32, 1);
pub const DTV_Entitlement_TechnicalFailure = @as(u32, 2);
pub const AudioType_Standard = @as(u32, 0);
pub const AudioType_Music_And_Effects = @as(u32, 1);
pub const AudioType_Visually_Impaired = @as(u32, 2);
pub const AudioType_Hearing_Impaired = @as(u32, 3);
pub const AudioType_Dialogue = @as(u32, 4);
pub const AudioType_Commentary = @as(u32, 5);
pub const AudioType_Emergency = @as(u32, 6);
pub const AudioType_Voiceover = @as(u32, 7);
pub const AudioType_Reserved = @as(i32, -1);
pub const MAX_COUNTRY_CODE_STRING = @as(u32, 3);
pub const PARENTAL_CONTROL_TIME_RANGE = @as(u32, 1);
pub const REQUIRED_PARENTAL_CONTROL_TIME_RANGE = @as(u32, 2);
pub const PARENTAL_CONTROL_CONTENT_RATING = @as(u32, 256);
pub const PARENTAL_CONTROL_ATTRIB_VIOLENCE = @as(u32, 512);
pub const PARENTAL_CONTROL_ATTRIB_LANGUAGE = @as(u32, 513);
pub const PARENTAL_CONTROL_ATTRIB_SEXUAL = @as(u32, 514);
pub const PARENTAL_CONTROL_ATTRIB_DIALOGUE = @as(u32, 515);
pub const PARENTAL_CONTROL_ATTRIB_FANTASY = @as(u32, 516);
pub const PARENTAL_CONTROL_VALUE_UNDEFINED = @as(u32, 0);
pub const MPEG2_FILTER_VERSION_1_SIZE = @as(u32, 124);
pub const MPEG2_FILTER_VERSION_2_SIZE = @as(u32, 133);
pub const SID_MSVidCtl_CurrentAudioEndpoint = Guid.initString("cf9a88f4-abcf-4ed8-9b74-7db33445459e");
pub const STREAMBUFFER_EC_BASE = @as(u32, 806);
pub const EVENTID_SBE2RecControlStarted = Guid.initString("8966a89e-f83e-4c0e-bc3b-bfa7649e04cb");
pub const EVENTID_SBE2RecControlStopped = Guid.initString("454b1ec8-0c9b-4caa-b1a1-1e7a2666f6c3");
pub const SBE2_STREAM_DESC_EVENT = Guid.initString("2313a4ed-bf2d-454f-ad8a-d95ba7f91fee");
pub const SBE2_V1_STREAMS_CREATION_EVENT = Guid.initString("000fcf09-97f5-46ac-9769-7a83b35384fb");
pub const SBE2_V2_STREAMS_CREATION_EVENT = Guid.initString("a72530a3-0344-4cab-a2d0-fe937dbdcab3");
pub const SBE2_STREAM_DESC_VERSION = @as(u32, 1);
pub const SID_DRMSecureServiceChannel = Guid.initString("c4c4c4c4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterEncProperties = Guid.initString("c4c4c481-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilterTagProperties = Guid.initString("c4c4c491-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_PTFilter = Guid.initString("9cd31617-b303-4f96-8330-2eb173ea4dc6");
pub const CLSID_DTFilterEncProperties = Guid.initString("c4c4c482-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilterTagProperties = Guid.initString("c4c4c492-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecProperties = Guid.initString("c4c4c483-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodecTagProperties = Guid.initString("c4c4c493-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CPCAFiltersCategory = Guid.initString("c4c4c4fc-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSRating = Guid.initString("c4c4c4e0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecDuplicateXDSRating = Guid.initString("c4c4c4df-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_XDSCodecNewXDSPacket = Guid.initString("c4c4c4e1-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingChange = Guid.initString("c4c4c4e2-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsBlock = Guid.initString("c4c4c4e3-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterRatingsUnblock = Guid.initString("c4c4c4e4-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterXDSPacket = Guid.initString("c4c4c4e5-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOn = Guid.initString("c4c4c4e6-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterEncryptionOff = Guid.initString("c4c4c4e7-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPUnblock = Guid.initString("c4c4c4e8-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_EncDecFilterError = Guid.initString("c4c4c4e9-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterCOPPBlock = Guid.initString("c4c4c4ea-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyOnce = Guid.initString("c4c4c4eb-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETFilterCopyNever = Guid.initString("c4c4c4f0-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatOK = Guid.initString("c4c4c4ec-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_DTFilterDataFormatFailure = Guid.initString("c4c4c4ed-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseOK = Guid.initString("c4c4c4ee-0049-4e2b-98fb-9537f6ce516d");
pub const EVENTID_ETDTFilterLicenseFailure = Guid.initString("c4c4c4ef-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d0-0049-4e2b-98fb-9537f6ce516d");
pub const FORMATTYPE_ETDTFilter_Tagged = Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const MEDIASUBTYPE_CPFilters_Processed = Guid.initString("46adbd28-6fd0-4796-93b2-155c51dc048d");
pub const FORMATTYPE_CPFilters_Processed = Guid.initString("6739b36f-1d5f-4ac2-8192-28bb0e73d16a");
pub const EVENTID_EncDecFilterEvent = Guid.initString("4a1b465b-0fb9-4159-afbd-e33006a0f9f4");
pub const EVENTID_FormatNotSupportedEvent = Guid.initString("24b2280a-b2aa-4777-bf65-63f35e7b024a");
pub const EVENTID_DemultiplexerFilterDiscontinuity = Guid.initString("16155770-aed5-475c-bb98-95a33070df0c");
pub const DSATTRIB_WMDRMProtectionInfo = Guid.initString("40749583-6b9d-4eec-b43c-67a1801e1a9b");
pub const DSATTRIB_BadSampleInfo = Guid.initString("e4846dda-5838-42b4-b897-6f7e5faa2f2f");
pub const MPEG_PAT_PID = @as(u32, 0);
pub const MPEG_PAT_TID = @as(u32, 0);
pub const MPEG_CAT_PID = @as(u32, 1);
pub const MPEG_CAT_TID = @as(u32, 1);
pub const MPEG_PMT_TID = @as(u32, 2);
pub const MPEG_TSDT_PID = @as(u32, 2);
pub const MPEG_TSDT_TID = @as(u32, 3);
pub const ATSC_MGT_PID = @as(u32, 8187);
pub const ATSC_MGT_TID = @as(u32, 199);
pub const ATSC_VCT_PID = @as(u32, 8187);
pub const ATSC_VCT_TERR_TID = @as(u32, 200);
pub const ATSC_VCT_CABL_TID = @as(u32, 201);
pub const ATSC_EIT_TID = @as(u32, 203);
pub const ATSC_ETT_TID = @as(u32, 204);
pub const ATSC_RRT_TID = @as(u32, 202);
pub const ATSC_RRT_PID = @as(u32, 8187);
pub const ATSC_STT_PID = @as(u32, 8187);
pub const ATSC_STT_TID = @as(u32, 205);
pub const ATSC_PIT_TID = @as(u32, 208);
pub const DVB_NIT_PID = @as(u32, 16);
pub const DVB_NIT_ACTUAL_TID = @as(u32, 64);
pub const DVB_NIT_OTHER_TID = @as(u32, 65);
pub const DVB_SDT_PID = @as(u32, 17);
pub const DVB_SDT_ACTUAL_TID = @as(u32, 66);
pub const DVB_SDT_OTHER_TID = @as(u32, 70);
pub const DVB_BAT_PID = @as(u32, 17);
pub const DVB_BAT_TID = @as(u32, 74);
pub const DVB_EIT_PID = @as(u32, 18);
pub const DVB_EIT_ACTUAL_TID = @as(u32, 78);
pub const DVB_EIT_OTHER_TID = @as(u32, 79);
pub const DVB_RST_PID = @as(u32, 19);
pub const DVB_RST_TID = @as(u32, 113);
pub const DVB_TDT_PID = @as(u32, 20);
pub const DVB_TDT_TID = @as(u32, 112);
pub const DVB_ST_PID_16 = @as(u32, 16);
pub const DVB_ST_PID_17 = @as(u32, 17);
pub const DVB_ST_PID_18 = @as(u32, 18);
pub const DVB_ST_PID_19 = @as(u32, 19);
pub const DVB_ST_PID_20 = @as(u32, 20);
pub const DVB_ST_TID = @as(u32, 114);
pub const ISDB_ST_TID = @as(u32, 114);
pub const DVB_TOT_PID = @as(u32, 20);
pub const DVB_TOT_TID = @as(u32, 115);
pub const DVB_DIT_PID = @as(u32, 30);
pub const DVB_DIT_TID = @as(u32, 126);
pub const DVB_SIT_PID = @as(u32, 31);
pub const DVB_SIT_TID = @as(u32, 127);
pub const ISDB_EMM_TID = @as(u32, 133);
pub const ISDB_BIT_PID = @as(u32, 36);
pub const ISDB_BIT_TID = @as(u32, 196);
pub const ISDB_NBIT_PID = @as(u32, 37);
pub const ISDB_NBIT_MSG_TID = @as(u32, 197);
pub const ISDB_NBIT_REF_TID = @as(u32, 198);
pub const ISDB_LDT_PID = @as(u32, 37);
pub const ISDB_LDT_TID = @as(u32, 199);
pub const ISDB_SDTT_PID = @as(u32, 35);
pub const ISDB_SDTT_ALT_PID = @as(u32, 40);
pub const ISDB_SDTT_TID = @as(u32, 195);
pub const ISDB_CDT_PID = @as(u32, 41);
pub const ISDB_CDT_TID = @as(u32, 200);
pub const SCTE_EAS_TID = @as(u32, 216);
pub const SCTE_EAS_IB_PID = @as(u32, 8187);
pub const SCTE_EAS_OOB_PID = @as(u32, 8188);
pub const CLSID_Mpeg2TableFilter = Guid.initString("752845f1-758f-4c83-a043-4270c593308e");
pub const ATSC_ETM_LOCATION_NOT_PRESENT = @as(u32, 0);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_PSIP = @as(u32, 1);
pub const ATSC_ETM_LOCATION_IN_PTC_FOR_EVENT = @as(u32, 2);
pub const ATSC_ETM_LOCATION_RESERVED = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_HEADER = @as(u32, 1);
pub const SAMPLE_SEQ_GOP_HEADER = @as(u32, 2);
pub const SAMPLE_SEQ_PICTURE_HEADER = @as(u32, 3);
pub const SAMPLE_SEQ_SEQUENCE_START = @as(u32, 1);
pub const SAMPLE_SEQ_SEEK_POINT = @as(u32, 2);
pub const SAMPLE_SEQ_FRAME_START = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_UNKNOWN = @as(u32, 0);
pub const SAMPLE_SEQ_CONTENT_I_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_P_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_B_FRAME = @as(u32, 3);
pub const SAMPLE_SEQ_CONTENT_STANDALONE_FRAME = @as(u32, 1);
pub const SAMPLE_SEQ_CONTENT_REF_FRAME = @as(u32, 2);
pub const SAMPLE_SEQ_CONTENT_NONREF_FRAME = @as(u32, 3);
pub const COMPONENT_TAG_CAPTION_MIN = @as(u32, 48);
pub const COMPONENT_TAG_CAPTION_MAX = @as(u32, 55);
pub const COMPONENT_TAG_SUPERIMPOSE_MIN = @as(u32, 56);
pub const COMPONENT_TAG_SUPERIMPOSE_MAX = @as(u32, 63);
pub const DVBS_SCAN_TABLE_MAX_SIZE = @as(u32, 400);
pub const g_wszStreamBufferRecordingDuration = "Duration";
pub const g_wszStreamBufferRecordingBitrate = "Bitrate";
pub const g_wszStreamBufferRecordingSeekable = "Seekable";
pub const g_wszStreamBufferRecordingStridable = "Stridable";
pub const g_wszStreamBufferRecordingBroadcast = "Broadcast";
pub const g_wszStreamBufferRecordingProtected = "Is_Protected";
pub const g_wszStreamBufferRecordingTrusted = "Is_Trusted";
pub const g_wszStreamBufferRecordingSignature_Name = "Signature_Name";
pub const g_wszStreamBufferRecordingHasAudio = "HasAudio";
pub const g_wszStreamBufferRecordingHasImage = "HasImage";
pub const g_wszStreamBufferRecordingHasScript = "HasScript";
pub const g_wszStreamBufferRecordingHasVideo = "HasVideo";
pub const g_wszStreamBufferRecordingCurrentBitrate = "CurrentBitrate";
pub const g_wszStreamBufferRecordingOptimalBitrate = "OptimalBitrate";
pub const g_wszStreamBufferRecordingHasAttachedImages = "HasAttachedImages";
pub const g_wszStreamBufferRecordingSkipBackward = "Can_Skip_Backward";
pub const g_wszStreamBufferRecordingSkipForward = "Can_Skip_Forward";
pub const g_wszStreamBufferRecordingNumberOfFrames = "NumberOfFrames";
pub const g_wszStreamBufferRecordingFileSize = "FileSize";
pub const g_wszStreamBufferRecordingHasArbitraryDataStream = "HasArbitraryDataStream";
pub const g_wszStreamBufferRecordingHasFileTransferStream = "HasFileTransferStream";
pub const g_wszStreamBufferRecordingTitle = "Title";
pub const g_wszStreamBufferRecordingAuthor = "Author";
pub const g_wszStreamBufferRecordingDescription = "Description";
pub const g_wszStreamBufferRecordingRating = "Rating";
pub const g_wszStreamBufferRecordingCopyright = "Copyright";
pub const g_wszStreamBufferRecordingUse_DRM = "Use_DRM";
pub const g_wszStreamBufferRecordingDRM_Flags = "DRM_Flags";
pub const g_wszStreamBufferRecordingDRM_Level = "DRM_Level";
pub const g_wszStreamBufferRecordingAlbumTitle = "WM/AlbumTitle";
pub const g_wszStreamBufferRecordingTrack = "WM/Track";
pub const g_wszStreamBufferRecordingPromotionURL = "WM/PromotionURL";
pub const g_wszStreamBufferRecordingAlbumCoverURL = "WM/AlbumCoverURL";
pub const g_wszStreamBufferRecordingGenre = "WM/Genre";
pub const g_wszStreamBufferRecordingYear = "WM/Year";
pub const g_wszStreamBufferRecordingGenreID = "WM/GenreID";
pub const g_wszStreamBufferRecordingMCDI = "WM/MCDI";
pub const g_wszStreamBufferRecordingComposer = "WM/Composer";
pub const g_wszStreamBufferRecordingLyrics = "WM/Lyrics";
pub const g_wszStreamBufferRecordingTrackNumber = "WM/TrackNumber";
pub const g_wszStreamBufferRecordingToolName = "WM/ToolName";
pub const g_wszStreamBufferRecordingToolVersion = "WM/ToolVersion";
pub const g_wszStreamBufferRecordingIsVBR = "IsVBR";
pub const g_wszStreamBufferRecordingAlbumArtist = "WM/AlbumArtist";
pub const g_wszStreamBufferRecordingBannerImageType = "BannerImageType";
pub const g_wszStreamBufferRecordingBannerImageData = "BannerImageData";
pub const g_wszStreamBufferRecordingBannerImageURL = "BannerImageURL";
pub const g_wszStreamBufferRecordingCopyrightURL = "CopyrightURL";
pub const g_wszStreamBufferRecordingAspectRatioX = "AspectRatioX";
pub const g_wszStreamBufferRecordingAspectRatioY = "AspectRatioY";
pub const g_wszStreamBufferRecordingNSCName = "NSC_Name";
pub const g_wszStreamBufferRecordingNSCAddress = "NSC_Address";
pub const g_wszStreamBufferRecordingNSCPhone = "NSC_Phone";
pub const g_wszStreamBufferRecordingNSCEmail = "NSC_Email";
pub const g_wszStreamBufferRecordingNSCDescription = "NSC_Description";
pub const STREAMBUFFER_EC_TIMEHOLE = @as(i32, 806);
pub const STREAMBUFFER_EC_STALE_DATA_READ = @as(i32, 807);
pub const STREAMBUFFER_EC_STALE_FILE_DELETED = @as(i32, 808);
pub const STREAMBUFFER_EC_CONTENT_BECOMING_STALE = @as(i32, 809);
pub const STREAMBUFFER_EC_WRITE_FAILURE = @as(i32, 810);
pub const STREAMBUFFER_EC_WRITE_FAILURE_CLEAR = @as(i32, 811);
pub const STREAMBUFFER_EC_READ_FAILURE = @as(i32, 812);
pub const STREAMBUFFER_EC_RATE_CHANGED = @as(i32, 813);
pub const STREAMBUFFER_EC_PRIMARY_AUDIO = @as(i32, 814);
pub const STREAMBUFFER_EC_RATE_CHANGING_FOR_SETPOSITIONS = @as(i32, 815);
pub const STREAMBUFFER_EC_SETPOSITIONS_EVENTS_DONE = @as(i32, 816);

//--------------------------------------------------------------------------------
// Section: Types (776)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICreatePropBagOnRegKey_Value = Guid.initString("8a674b48-1f63-11d3-b64c-00c04f79498e");
pub const IID_ICreatePropBagOnRegKey = &IID_ICreatePropBagOnRegKey_Value;
pub const ICreatePropBagOnRegKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICreatePropBagOnRegKey,
                hkey: ?HKEY,
                subkey: ?[*:0]align(1) const u16,
                ulOptions: u32,
                samDesired: u32,
                iid: ?*const Guid,
                ppBag: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICreatePropBagOnRegKey,
                hkey: ?HKEY,
                subkey: ?[*:0]align(1) const u16,
                ulOptions: u32,
                samDesired: u32,
                iid: ?*const Guid,
                ppBag: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreatePropBagOnRegKey_Create(self: *const T, hkey: ?HKEY, subkey: ?[*:0]align(1) const u16, ulOptions: u32, samDesired: u32, iid: ?*const Guid, ppBag: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICreatePropBagOnRegKey.VTable, @ptrCast(self.vtable)).Create(@as(*const ICreatePropBagOnRegKey, @ptrCast(self)), hkey, subkey, ulOptions, samDesired, iid, ppBag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DISPID_TUNER = enum(i32) {
    TUNER_TS_UNIQUENAME = 1,
    TUNER_TS_FRIENDLYNAME = 2,
    TUNER_TS_CLSID = 3,
    TUNER_TS_NETWORKTYPE = 4,
    TUNER_TS__NETWORKTYPE = 5,
    TUNER_TS_CREATETUNEREQUEST = 6,
    TUNER_TS_ENUMCATEGORYGUIDS = 7,
    TUNER_TS_ENUMDEVICEMONIKERS = 8,
    TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = 9,
    TUNER_TS_FREQMAP = 10,
    TUNER_TS_DEFLOCATOR = 11,
    TUNER_TS_CLONE = 12,
    // TUNER_TR_TUNINGSPACE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_TR_COMPONENTS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_TR_CLONE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_TR_LOCATOR = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT_CATEGORY = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_CT_MEDIAMAJORTYPE = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_CT__MEDIAMAJORTYPE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_CT_MEDIASUBTYPE = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_CT__MEDIASUBTYPE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_CT_MEDIAFORMATTYPE = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_CT__MEDIAFORMATTYPE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_CT_MEDIATYPE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    // TUNER_CT_CLONE = 9, this enum value conflicts with TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES
    TUNER_LCT_LANGID = 100,
    TUNER_MP2CT_TYPE = 200,
    TUNER_ATSCCT_FLAGS = 300,
    // TUNER_L_CARRFREQ = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_L_INNERFECMETHOD = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_L_INNERFECRATE = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_L_OUTERFECMETHOD = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_L_OUTERFECRATE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    // TUNER_L_MOD = 6, this enum value conflicts with TUNER_TS_CREATETUNEREQUEST
    // TUNER_L_SYMRATE = 7, this enum value conflicts with TUNER_TS_ENUMCATEGORYGUIDS
    // TUNER_L_CLONE = 8, this enum value conflicts with TUNER_TS_ENUMDEVICEMONIKERS
    TUNER_L_ATSC_PHYS_CHANNEL = 201,
    TUNER_L_ATSC_TSID = 202,
    TUNER_L_ATSC_MP2_PROGNO = 203,
    TUNER_L_DVBT_BANDWIDTH = 301,
    TUNER_L_DVBT_LPINNERFECMETHOD = 302,
    TUNER_L_DVBT_LPINNERFECRATE = 303,
    TUNER_L_DVBT_GUARDINTERVAL = 304,
    TUNER_L_DVBT_HALPHA = 305,
    TUNER_L_DVBT_TRANSMISSIONMODE = 306,
    TUNER_L_DVBT_INUSE = 307,
    TUNER_L_DVBT2_PHYSICALLAYERPIPEID = 351,
    TUNER_L_DVBS_POLARISATION = 401,
    TUNER_L_DVBS_WEST = 402,
    TUNER_L_DVBS_ORBITAL = 403,
    TUNER_L_DVBS_AZIMUTH = 404,
    TUNER_L_DVBS_ELEVATION = 405,
    TUNER_L_DVBS2_DISEQ_LNB_SOURCE = 406,
    TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = 407,
    TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = 408,
    TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = 409,
    TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = 410,
    TUNER_L_DVBS2_ROLLOFF = 411,
    TUNER_L_DVBS2_PILOT = 412,
    TUNER_L_ANALOG_STANDARD = 601,
    TUNER_L_DTV_O_MAJOR_CHANNEL = 701,
    // TUNER_C_TYPE = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
    // TUNER_C_STATUS = 2, this enum value conflicts with TUNER_TS_FRIENDLYNAME
    // TUNER_C_LANGID = 3, this enum value conflicts with TUNER_TS_CLSID
    // TUNER_C_DESCRIPTION = 4, this enum value conflicts with TUNER_TS_NETWORKTYPE
    // TUNER_C_CLONE = 5, this enum value conflicts with TUNER_TS__NETWORKTYPE
    TUNER_C_MP2_PID = 101,
    TUNER_C_MP2_PCRPID = 102,
    TUNER_C_MP2_PROGNO = 103,
    // TUNER_C_ANALOG_AUDIO = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_DVB_SYSTEMTYPE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_DVB2_NETWORK_ID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    TUNER_TS_DVBS_LOW_OSC_FREQ = 1001,
    TUNER_TS_DVBS_HI_OSC_FREQ = 1002,
    TUNER_TS_DVBS_LNB_SWITCH_FREQ = 1003,
    TUNER_TS_DVBS_INPUT_RANGE = 1004,
    TUNER_TS_DVBS_SPECTRAL_INVERSION = 1005,
    // TUNER_TS_AR_MINFREQUENCY = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_AR_MAXFREQUENCY = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_AR_STEP = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    TUNER_TS_AR_COUNTRYCODE = 104,
    // TUNER_TS_AUX_COUNTRYCODE = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MINCHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // TUNER_TS_ATV_MAXCHANNEL = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // TUNER_TS_ATV_INPUTTYPE = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // TUNER_TS_ATV_COUNTRYCODE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // TUNER_TS_ATSC_MINMINORCHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // TUNER_TS_ATSC_MAXMINORCHANNEL = 202, this enum value conflicts with TUNER_L_ATSC_TSID
    // TUNER_TS_ATSC_MINPHYSCHANNEL = 203, this enum value conflicts with TUNER_L_ATSC_MP2_PROGNO
    TUNER_TS_ATSC_MAXPHYSCHANNEL = 204,
    // TUNER_TS_DC_MINMAJORCHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // TUNER_TS_DC_MAXMAJORCHANNEL = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // TUNER_TS_DC_MINSOURCEID = 303, this enum value conflicts with TUNER_L_DVBT_LPINNERFECRATE
    // TUNER_TS_DC_MAXSOURCEID = 304, this enum value conflicts with TUNER_L_DVBT_GUARDINTERVAL
    // CHTUNER_ATVAC_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_SYSTEM = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ATVDC_CONTENT = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // CHTUNER_CIDTR_CHANNELID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_CTR_CHANNEL = 101, this enum value conflicts with TUNER_C_MP2_PID
    // CHTUNER_ACTR_MINOR_CHANNEL = 201, this enum value conflicts with TUNER_L_ATSC_PHYS_CHANNEL
    // CHTUNER_DCTR_MAJOR_CHANNEL = 301, this enum value conflicts with TUNER_L_DVBT_BANDWIDTH
    // CHTUNER_DCTR_SRCID = 302, this enum value conflicts with TUNER_L_DVBT_LPINNERFECMETHOD
    // DVBTUNER_DVBC_ATTRIBUTESVALID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_DVBC_PID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_DVBC_TAG = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // DVBTUNER_DVBC_COMPONENTTYPE = 104, this enum value conflicts with TUNER_TS_AR_COUNTRYCODE
    // DVBTUNER_ONID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // DVBTUNER_TSID = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // DVBTUNER_SID = 103, this enum value conflicts with TUNER_C_MP2_PROGNO
    // MP2TUNER_TSID = 101, this enum value conflicts with TUNER_C_MP2_PID
    // MP2TUNER_PROGNO = 102, this enum value conflicts with TUNER_C_MP2_PCRPID
    // MP2TUNERFACTORY_CREATETUNEREQUEST = 1, this enum value conflicts with TUNER_TS_UNIQUENAME
};
pub const DISPID_TUNER_TS_UNIQUENAME = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TS_FRIENDLYNAME = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TS_CLSID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TS_NETWORKTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_TS__NETWORKTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_TS_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_TS_ENUMCATEGORYGUIDS = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_TS_ENUMDEVICEMONIKERS = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_TS_FREQMAP = DISPID_TUNER.TUNER_TS_FREQMAP;
pub const DISPID_TUNER_TS_DEFLOCATOR = DISPID_TUNER.TUNER_TS_DEFLOCATOR;
pub const DISPID_TUNER_TS_CLONE = DISPID_TUNER.TUNER_TS_CLONE;
pub const DISPID_TUNER_TR_TUNINGSPACE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_TR_COMPONENTS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_TR_CLONE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_TR_LOCATOR = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT_CATEGORY = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_CT_MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_CT__MEDIAMAJORTYPE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_CT_MEDIASUBTYPE = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_CT__MEDIASUBTYPE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_CT_MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_CT__MEDIAFORMATTYPE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_CT_MEDIATYPE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_CT_CLONE = DISPID_TUNER.TUNER_TS_DEFAULTPREFERREDCOMPONENTTYPES;
pub const DISPID_TUNER_LCT_LANGID = DISPID_TUNER.TUNER_LCT_LANGID;
pub const DISPID_TUNER_MP2CT_TYPE = DISPID_TUNER.TUNER_MP2CT_TYPE;
pub const DISPID_TUNER_ATSCCT_FLAGS = DISPID_TUNER.TUNER_ATSCCT_FLAGS;
pub const DISPID_TUNER_L_CARRFREQ = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_L_INNERFECMETHOD = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_L_INNERFECRATE = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_L_OUTERFECMETHOD = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_L_OUTERFECRATE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_L_MOD = DISPID_TUNER.TUNER_TS_CREATETUNEREQUEST;
pub const DISPID_TUNER_L_SYMRATE = DISPID_TUNER.TUNER_TS_ENUMCATEGORYGUIDS;
pub const DISPID_TUNER_L_CLONE = DISPID_TUNER.TUNER_TS_ENUMDEVICEMONIKERS;
pub const DISPID_TUNER_L_ATSC_PHYS_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_L_ATSC_TSID = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_L_ATSC_MP2_PROGNO = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_L_DVBT_BANDWIDTH = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_L_DVBT_LPINNERFECMETHOD = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_L_DVBT_LPINNERFECRATE = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_L_DVBT_GUARDINTERVAL = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_TUNER_L_DVBT_HALPHA = DISPID_TUNER.TUNER_L_DVBT_HALPHA;
pub const DISPID_TUNER_L_DVBT_TRANSMISSIONMODE = DISPID_TUNER.TUNER_L_DVBT_TRANSMISSIONMODE;
pub const DISPID_TUNER_L_DVBT_INUSE = DISPID_TUNER.TUNER_L_DVBT_INUSE;
pub const DISPID_TUNER_L_DVBT2_PHYSICALLAYERPIPEID = DISPID_TUNER.TUNER_L_DVBT2_PHYSICALLAYERPIPEID;
pub const DISPID_TUNER_L_DVBS_POLARISATION = DISPID_TUNER.TUNER_L_DVBS_POLARISATION;
pub const DISPID_TUNER_L_DVBS_WEST = DISPID_TUNER.TUNER_L_DVBS_WEST;
pub const DISPID_TUNER_L_DVBS_ORBITAL = DISPID_TUNER.TUNER_L_DVBS_ORBITAL;
pub const DISPID_TUNER_L_DVBS_AZIMUTH = DISPID_TUNER.TUNER_L_DVBS_AZIMUTH;
pub const DISPID_TUNER_L_DVBS_ELEVATION = DISPID_TUNER.TUNER_L_DVBS_ELEVATION;
pub const DISPID_TUNER_L_DVBS2_DISEQ_LNB_SOURCE = DISPID_TUNER.TUNER_L_DVBS2_DISEQ_LNB_SOURCE;
pub const DISPID_TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LOW_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_HI_OSC_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_LNB_SWITCH_FREQ_OVERRIDE;
pub const DISPID_TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE = DISPID_TUNER.TUNER_TS_DVBS2_SPECTRAL_INVERSION_OVERRIDE;
pub const DISPID_TUNER_L_DVBS2_ROLLOFF = DISPID_TUNER.TUNER_L_DVBS2_ROLLOFF;
pub const DISPID_TUNER_L_DVBS2_PILOT = DISPID_TUNER.TUNER_L_DVBS2_PILOT;
pub const DISPID_TUNER_L_ANALOG_STANDARD = DISPID_TUNER.TUNER_L_ANALOG_STANDARD;
pub const DISPID_TUNER_L_DTV_O_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DTV_O_MAJOR_CHANNEL;
pub const DISPID_TUNER_C_TYPE = DISPID_TUNER.TUNER_TS_UNIQUENAME;
pub const DISPID_TUNER_C_STATUS = DISPID_TUNER.TUNER_TS_FRIENDLYNAME;
pub const DISPID_TUNER_C_LANGID = DISPID_TUNER.TUNER_TS_CLSID;
pub const DISPID_TUNER_C_DESCRIPTION = DISPID_TUNER.TUNER_TS_NETWORKTYPE;
pub const DISPID_TUNER_C_CLONE = DISPID_TUNER.TUNER_TS__NETWORKTYPE;
pub const DISPID_TUNER_C_MP2_PID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_C_MP2_PCRPID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_C_MP2_PROGNO = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_C_ANALOG_AUDIO = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_DVB_SYSTEMTYPE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_DVB2_NETWORK_ID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_DVBS_LOW_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LOW_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_HI_OSC_FREQ = DISPID_TUNER.TUNER_TS_DVBS_HI_OSC_FREQ;
pub const DISPID_TUNER_TS_DVBS_LNB_SWITCH_FREQ = DISPID_TUNER.TUNER_TS_DVBS_LNB_SWITCH_FREQ;
pub const DISPID_TUNER_TS_DVBS_INPUT_RANGE = DISPID_TUNER.TUNER_TS_DVBS_INPUT_RANGE;
pub const DISPID_TUNER_TS_DVBS_SPECTRAL_INVERSION = DISPID_TUNER.TUNER_TS_DVBS_SPECTRAL_INVERSION;
pub const DISPID_TUNER_TS_AR_MINFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_AR_MAXFREQUENCY = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_AR_STEP = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_AR_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_AUX_COUNTRYCODE = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MINCHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_TUNER_TS_ATV_MAXCHANNEL = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_TUNER_TS_ATV_INPUTTYPE = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATV_COUNTRYCODE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_TUNER_TS_ATSC_MINMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_TUNER_TS_ATSC_MAXMINORCHANNEL = DISPID_TUNER.TUNER_L_ATSC_TSID;
pub const DISPID_TUNER_TS_ATSC_MINPHYSCHANNEL = DISPID_TUNER.TUNER_L_ATSC_MP2_PROGNO;
pub const DISPID_TUNER_TS_ATSC_MAXPHYSCHANNEL = DISPID_TUNER.TUNER_TS_ATSC_MAXPHYSCHANNEL;
pub const DISPID_TUNER_TS_DC_MINMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_TUNER_TS_DC_MAXMAJORCHANNEL = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_TUNER_TS_DC_MINSOURCEID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECRATE;
pub const DISPID_TUNER_TS_DC_MAXSOURCEID = DISPID_TUNER.TUNER_L_DVBT_GUARDINTERVAL;
pub const DISPID_CHTUNER_ATVAC_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_SYSTEM = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ATVDC_CONTENT = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_CHTUNER_CIDTR_CHANNELID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_CTR_CHANNEL = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_CHTUNER_ACTR_MINOR_CHANNEL = DISPID_TUNER.TUNER_L_ATSC_PHYS_CHANNEL;
pub const DISPID_CHTUNER_DCTR_MAJOR_CHANNEL = DISPID_TUNER.TUNER_L_DVBT_BANDWIDTH;
pub const DISPID_CHTUNER_DCTR_SRCID = DISPID_TUNER.TUNER_L_DVBT_LPINNERFECMETHOD;
pub const DISPID_DVBTUNER_DVBC_ATTRIBUTESVALID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_DVBC_PID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_DVBC_TAG = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_DVBTUNER_DVBC_COMPONENTTYPE = DISPID_TUNER.TUNER_TS_AR_COUNTRYCODE;
pub const DISPID_DVBTUNER_ONID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_DVBTUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_DVBTUNER_SID = DISPID_TUNER.TUNER_C_MP2_PROGNO;
pub const DISPID_MP2TUNER_TSID = DISPID_TUNER.TUNER_C_MP2_PID;
pub const DISPID_MP2TUNER_PROGNO = DISPID_TUNER.TUNER_C_MP2_PCRPID;
pub const DISPID_MP2TUNERFACTORY_CREATETUNEREQUEST = DISPID_TUNER.TUNER_TS_UNIQUENAME;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaces_Value = Guid.initString("901284e4-33fe-4b69-8d63-634a596f3756");
pub const IID_ITuningSpaces = &IID_ITuningSpaces_Value;
pub const ITuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaces,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaces,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaces,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaces,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaces,
                varIndex: VARIANT,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaces,
                varIndex: VARIANT,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaces,
                NewEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaces,
                NewEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ITuningSpaces, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ITuningSpaces, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ITuningSpaces, @ptrCast(self)), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaces_get_EnumTuningSpaces(self: *const T, NewEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaces.VTable, @ptrCast(self.vtable)).get_EnumTuningSpaces(@as(*const ITuningSpaces, @ptrCast(self)), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpaceContainer_Value = Guid.initString("5b692e84-e2f1-11d2-9493-00c04f72d980");
pub const IID_ITuningSpaceContainer = &IID_ITuningSpaceContainer_Value;
pub const ITuningSpaceContainer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaceContainer,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaceContainer,
                NewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                varIndex: VARIANT,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                varIndex: VARIANT,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                varIndex: VARIANT,
                TuningSpace: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                varIndex: VARIANT,
                TuningSpace: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TuningSpacesForCLSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                SpaceCLSID: ?BSTR,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                SpaceCLSID: ?BSTR,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _TuningSpacesForCLSID2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                SpaceCLSID: ?*const Guid,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                SpaceCLSID: ?*const Guid,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TuningSpacesForName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                Name: ?BSTR,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                Name: ?BSTR,
                NewColl: ?*?*ITuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                TuningSpace: ?*ITuningSpace,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                TuningSpace: ?*ITuningSpace,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                TuningSpace: ?*ITuningSpace,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                TuningSpace: ?*ITuningSpace,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnumTuningSpaces: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaceContainer,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpaceContainer,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                MaxCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaceContainer,
                MaxCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpaceContainer,
                MaxCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpaceContainer,
                MaxCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_Count(@as(*const ITuningSpaceContainer, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get__NewEnum(self: *const T, NewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const ITuningSpaceContainer, @ptrCast(self)), NewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_Item(@as(*const ITuningSpaceContainer, @ptrCast(self)), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_put_Item(self: *const T, varIndex: VARIANT, TuningSpace: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).put_Item(@as(*const ITuningSpaceContainer, @ptrCast(self)), varIndex, TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_TuningSpacesForCLSID(self: *const T, SpaceCLSID: ?BSTR, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).TuningSpacesForCLSID(@as(*const ITuningSpaceContainer, @ptrCast(self)), SpaceCLSID, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer__TuningSpacesForCLSID2(self: *const T, SpaceCLSID: ?*const Guid, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable))._TuningSpacesForCLSID2(@as(*const ITuningSpaceContainer, @ptrCast(self)), SpaceCLSID, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_TuningSpacesForName(self: *const T, Name: ?BSTR, NewColl: ?*?*ITuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).TuningSpacesForName(@as(*const ITuningSpaceContainer, @ptrCast(self)), Name, NewColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_FindID(self: *const T, TuningSpace: ?*ITuningSpace, ID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).FindID(@as(*const ITuningSpaceContainer, @ptrCast(self)), TuningSpace, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_Add(self: *const T, TuningSpace: ?*ITuningSpace, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).Add(@as(*const ITuningSpaceContainer, @ptrCast(self)), TuningSpace, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_EnumTuningSpaces(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_EnumTuningSpaces(@as(*const ITuningSpaceContainer, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).Remove(@as(*const ITuningSpaceContainer, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_get_MaxCount(self: *const T, MaxCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).get_MaxCount(@as(*const ITuningSpaceContainer, @ptrCast(self)), MaxCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpaceContainer_put_MaxCount(self: *const T, MaxCount: i32) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpaceContainer.VTable, @ptrCast(self.vtable)).put_MaxCount(@as(*const ITuningSpaceContainer, @ptrCast(self)), MaxCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuningSpace_Value = Guid.initString("061c6e30-e622-11d2-9493-00c04f72d980");
pub const IID_ITuningSpace = &IID_ITuningSpace_Value;
pub const ITuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UniqueName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UniqueName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FriendlyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FriendlyName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CLSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                SpaceCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                SpaceCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NetworkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__NetworkType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                NetworkTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTuneRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpace,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpace,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCategoryGUIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpace,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpace,
                ppEnum: ?*?*IEnumGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDeviceMonikers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpace,
                ppEnum: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpace,
                ppEnum: ?*?*IEnumMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultPreferredComponentTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                ComponentTypes: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                ComponentTypes: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultPreferredComponentTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                NewComponentTypes: ?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                NewComponentTypes: ?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMapping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                pMapping: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                pMapping: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMapping: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                Mapping: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                Mapping: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultLocator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                LocatorVal: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                LocatorVal: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultLocator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuningSpace,
                LocatorVal: ?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuningSpace,
                LocatorVal: ?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuningSpace,
                NewTS: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuningSpace,
                NewTS: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_UniqueName(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_UniqueName(@as(*const ITuningSpace, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_UniqueName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_UniqueName(@as(*const ITuningSpace, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_FriendlyName(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_FriendlyName(@as(*const ITuningSpace, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_FriendlyName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_FriendlyName(@as(*const ITuningSpace, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_CLSID(self: *const T, SpaceCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_CLSID(@as(*const ITuningSpace, @ptrCast(self)), SpaceCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_NetworkType(self: *const T, NetworkTypeGuid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_NetworkType(@as(*const ITuningSpace, @ptrCast(self)), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_NetworkType(self: *const T, NetworkTypeGuid: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_NetworkType(@as(*const ITuningSpace, @ptrCast(self)), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get__NetworkType(self: *const T, NetworkTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get__NetworkType(@as(*const ITuningSpace, @ptrCast(self)), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put__NetworkType(self: *const T, NetworkTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put__NetworkType(@as(*const ITuningSpace, @ptrCast(self)), NetworkTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_CreateTuneRequest(self: *const T, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).CreateTuneRequest(@as(*const ITuningSpace, @ptrCast(self)), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_EnumCategoryGUIDs(self: *const T, ppEnum: ?*?*IEnumGUID) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).EnumCategoryGUIDs(@as(*const ITuningSpace, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_EnumDeviceMonikers(self: *const T, ppEnum: ?*?*IEnumMoniker) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).EnumDeviceMonikers(@as(*const ITuningSpace, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_DefaultPreferredComponentTypes(self: *const T, ComponentTypes: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_DefaultPreferredComponentTypes(@as(*const ITuningSpace, @ptrCast(self)), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_DefaultPreferredComponentTypes(self: *const T, NewComponentTypes: ?*IComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_DefaultPreferredComponentTypes(@as(*const ITuningSpace, @ptrCast(self)), NewComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_FrequencyMapping(self: *const T, pMapping: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_FrequencyMapping(@as(*const ITuningSpace, @ptrCast(self)), pMapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_FrequencyMapping(self: *const T, Mapping: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_FrequencyMapping(@as(*const ITuningSpace, @ptrCast(self)), Mapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_get_DefaultLocator(self: *const T, LocatorVal: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).get_DefaultLocator(@as(*const ITuningSpace, @ptrCast(self)), LocatorVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_put_DefaultLocator(self: *const T, LocatorVal: ?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).put_DefaultLocator(@as(*const ITuningSpace, @ptrCast(self)), LocatorVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuningSpace_Clone(self: *const T, NewTS: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuningSpace.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITuningSpace, @ptrCast(self)), NewTS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumTuningSpaces_Value = Guid.initString("8b8eb248-fc2b-11d2-9d8c-00c04f72d980");
pub const IID_IEnumTuningSpaces = &IID_IEnumTuningSpaces_Value;
pub const IEnumTuningSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuningSpaces,
                celt: u32,
                rgelt: [*]?*ITuningSpace,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuningSpaces,
                celt: u32,
                rgelt: [*]?*ITuningSpace,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuningSpaces,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuningSpaces,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuningSpaces,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuningSpaces,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Next(self: *const T, celt: u32, rgelt: [*]?*ITuningSpace, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTuningSpaces, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTuningSpaces, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTuningSpaces, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuningSpaces_Clone(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuningSpaces.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTuningSpaces, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace_Value = Guid.initString("ada0b268-3b19-4e5b-acc4-49f852be13ba");
pub const IID_IDVBTuningSpace = &IID_IDVBTuningSpace_Value;
pub const IDVBTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SystemType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuningSpace,
                SysType: ?*DVBSystemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuningSpace,
                SysType: ?*DVBSystemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SystemType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuningSpace,
                SysType: DVBSystemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuningSpace,
                SysType: DVBSystemType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace_get_SystemType(self: *const T, SysType: ?*DVBSystemType) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuningSpace.VTable, @ptrCast(self.vtable)).get_SystemType(@as(*const IDVBTuningSpace, @ptrCast(self)), SysType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace_put_SystemType(self: *const T, SysType: DVBSystemType) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuningSpace.VTable, @ptrCast(self.vtable)).put_SystemType(@as(*const IDVBTuningSpace, @ptrCast(self)), SysType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuningSpace2_Value = Guid.initString("843188b4-ce62-43db-966b-8145a094e040");
pub const IID_IDVBTuningSpace2 = &IID_IDVBTuningSpace2_Value;
pub const IDVBTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NetworkID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuningSpace2,
                NetworkID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuningSpace2,
                NetworkID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_NetworkID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuningSpace2,
                NetworkID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuningSpace2,
                NetworkID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace2_get_NetworkID(self: *const T, NetworkID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuningSpace2.VTable, @ptrCast(self.vtable)).get_NetworkID(@as(*const IDVBTuningSpace2, @ptrCast(self)), NetworkID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuningSpace2_put_NetworkID(self: *const T, NetworkID: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuningSpace2.VTable, @ptrCast(self.vtable)).put_NetworkID(@as(*const IDVBTuningSpace2, @ptrCast(self)), NetworkID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSTuningSpace_Value = Guid.initString("cdf7be60-d954-42fd-a972-78971958e470");
pub const IID_IDVBSTuningSpace = &IID_IDVBSTuningSpace_Value;
pub const IDVBSTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IDVBTuningSpace2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LowOscillator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                LowOscillator: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                LowOscillator: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LowOscillator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                LowOscillator: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                LowOscillator: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighOscillator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                HighOscillator: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                HighOscillator: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighOscillator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                HighOscillator: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                HighOscillator: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LNBSwitch: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                LNBSwitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                LNBSwitch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LNBSwitch: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                LNBSwitch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                LNBSwitch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                InputRange: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                InputRange: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                InputRange: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                InputRange: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                SpectralInversionVal: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                SpectralInversionVal: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSTuningSpace,
                SpectralInversionVal: SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSTuningSpace,
                SpectralInversionVal: SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTuningSpace2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_LowOscillator(self: *const T, LowOscillator: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_LowOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), LowOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_LowOscillator(self: *const T, LowOscillator: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_LowOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), LowOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_HighOscillator(self: *const T, HighOscillator: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_HighOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), HighOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_HighOscillator(self: *const T, HighOscillator: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_HighOscillator(@as(*const IDVBSTuningSpace, @ptrCast(self)), HighOscillator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_LNBSwitch(self: *const T, LNBSwitch: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_LNBSwitch(@as(*const IDVBSTuningSpace, @ptrCast(self)), LNBSwitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_LNBSwitch(self: *const T, LNBSwitch: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_LNBSwitch(@as(*const IDVBSTuningSpace, @ptrCast(self)), LNBSwitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_InputRange(self: *const T, InputRange: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_InputRange(@as(*const IDVBSTuningSpace, @ptrCast(self)), InputRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_InputRange(self: *const T, InputRange: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_InputRange(@as(*const IDVBSTuningSpace, @ptrCast(self)), InputRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_get_SpectralInversion(self: *const T, SpectralInversionVal: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).get_SpectralInversion(@as(*const IDVBSTuningSpace, @ptrCast(self)), SpectralInversionVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSTuningSpace_put_SpectralInversion(self: *const T, SpectralInversionVal: SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IDVBSTuningSpace.VTable, @ptrCast(self.vtable)).put_SpectralInversion(@as(*const IDVBSTuningSpace, @ptrCast(self)), SpectralInversionVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAuxInTuningSpace_Value = Guid.initString("e48244b8-7e17-4f76-a763-5090ff1e2f30");
pub const IID_IAuxInTuningSpace = &IID_IAuxInTuningSpace_Value;
pub const IAuxInTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAuxInTuningSpace2_Value = Guid.initString("b10931ed-8bfe-4ab0-9dce-e469c29a9729");
pub const IID_IAuxInTuningSpace2 = &IID_IAuxInTuningSpace2_Value;
pub const IAuxInTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAuxInTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAuxInTuningSpace2,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAuxInTuningSpace2,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAuxInTuningSpace2,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAuxInTuningSpace2,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAuxInTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuxInTuningSpace2_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAuxInTuningSpace2.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAuxInTuningSpace2, @ptrCast(self)), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAuxInTuningSpace2_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAuxInTuningSpace2.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAuxInTuningSpace2, @ptrCast(self)), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogTVTuningSpace_Value = Guid.initString("2a6e293c-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogTVTuningSpace = &IID_IAnalogTVTuningSpace_Value;
pub const IAnalogTVTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                MinChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                MinChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                NewMinChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                NewMinChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                MaxChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                MaxChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                NewMaxChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                NewMaxChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                InputTypeVal: ?*TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                InputTypeVal: ?*TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                NewInputTypeVal: TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                NewInputTypeVal: TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogTVTuningSpace,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogTVTuningSpace,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_MinChannel(self: *const T, MinChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_MinChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), MinChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_MinChannel(self: *const T, NewMinChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_MinChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), NewMinChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_MaxChannel(self: *const T, MaxChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), MaxChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_MaxChannel(self: *const T, NewMaxChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxChannel(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), NewMaxChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_InputType(self: *const T, InputTypeVal: ?*TunerInputType) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_InputType(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), InputTypeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_InputType(self: *const T, NewInputTypeVal: TunerInputType) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_InputType(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), NewInputTypeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogTVTuningSpace_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogTVTuningSpace.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAnalogTVTuningSpace, @ptrCast(self)), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCTuningSpace_Value = Guid.initString("0369b4e2-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCTuningSpace = &IID_IATSCTuningSpace_Value;
pub const IATSCTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IAnalogTVTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                MinMinorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                MinMinorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                NewMinMinorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                NewMinMinorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                MaxMinorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                MaxMinorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                NewMaxMinorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                NewMaxMinorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinPhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                MinPhysicalChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                MinPhysicalChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinPhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                NewMinPhysicalChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                NewMinPhysicalChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxPhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                MaxPhysicalChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                MaxPhysicalChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxPhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCTuningSpace,
                NewMaxPhysicalChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCTuningSpace,
                NewMaxPhysicalChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAnalogTVTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MinMinorChannel(self: *const T, MinMinorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MinMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), MinMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MinMinorChannel(self: *const T, NewMinMinorChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MinMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), NewMinMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MaxMinorChannel(self: *const T, MaxMinorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), MaxMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MaxMinorChannel(self: *const T, NewMaxMinorChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxMinorChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), NewMaxMinorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MinPhysicalChannel(self: *const T, MinPhysicalChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MinPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), MinPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MinPhysicalChannel(self: *const T, NewMinPhysicalChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MinPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), NewMinPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_get_MaxPhysicalChannel(self: *const T, MaxPhysicalChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), MaxPhysicalChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCTuningSpace_put_MaxPhysicalChannel(self: *const T, NewMaxPhysicalChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxPhysicalChannel(@as(*const IATSCTuningSpace, @ptrCast(self)), NewMaxPhysicalChannelVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuningSpace_Value = Guid.initString("013f9f9c-b449-4ec7-a6d2-9d4f2fc70ae5");
pub const IID_IDigitalCableTuningSpace = &IID_IDigitalCableTuningSpace_Value;
pub const IDigitalCableTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: IATSCTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinMajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                MinMajorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                MinMajorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinMajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                NewMinMajorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                NewMinMajorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxMajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                MaxMajorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                MaxMajorChannelVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxMajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                NewMaxMajorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                NewMaxMajorChannelVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinSourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                MinSourceIDVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                MinSourceIDVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinSourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                NewMinSourceIDVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                NewMinSourceIDVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxSourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                MaxSourceIDVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                MaxSourceIDVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxSourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuningSpace,
                NewMaxSourceIDVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuningSpace,
                NewMaxSourceIDVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MinMajorChannel(self: *const T, MinMajorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MinMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), MinMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MinMajorChannel(self: *const T, NewMinMajorChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MinMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), NewMinMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MaxMajorChannel(self: *const T, MaxMajorChannelVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), MaxMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MaxMajorChannel(self: *const T, NewMaxMajorChannelVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxMajorChannel(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), NewMaxMajorChannelVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MinSourceID(self: *const T, MinSourceIDVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MinSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), MinSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MinSourceID(self: *const T, NewMinSourceIDVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MinSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), NewMinSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_get_MaxSourceID(self: *const T, MaxSourceIDVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), MaxSourceIDVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuningSpace_put_MaxSourceID(self: *const T, NewMaxSourceIDVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxSourceID(@as(*const IDigitalCableTuningSpace, @ptrCast(self)), NewMaxSourceIDVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAnalogRadioTuningSpace_Value = Guid.initString("2a6e293b-2595-11d3-b64c-00c04f79498e");
pub const IID_IAnalogRadioTuningSpace = &IID_IAnalogRadioTuningSpace_Value;
pub const IAnalogRadioTuningSpace = extern struct {
    pub const VTable = extern struct {
        base: ITuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                MinFrequencyVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                MinFrequencyVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                NewMinFrequencyVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                NewMinFrequencyVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                MaxFrequencyVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                MaxFrequencyVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaxFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                NewMaxFrequencyVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                NewMaxFrequencyVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Step: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                StepVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                StepVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Step: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace,
                NewStepVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace,
                NewStepVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_MinFrequency(self: *const T, MinFrequencyVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_MinFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), MinFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_MinFrequency(self: *const T, NewMinFrequencyVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_MinFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), NewMinFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_MaxFrequency(self: *const T, MaxFrequencyVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_MaxFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), MaxFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_MaxFrequency(self: *const T, NewMaxFrequencyVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_MaxFrequency(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), NewMaxFrequencyVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_get_Step(self: *const T, StepVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).get_Step(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), StepVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace_put_Step(self: *const T, NewStepVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace.VTable, @ptrCast(self.vtable)).put_Step(@as(*const IAnalogRadioTuningSpace, @ptrCast(self)), NewStepVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAnalogRadioTuningSpace2_Value = Guid.initString("39dd45da-2da8-46ba-8a8a-87e2b73d983a");
pub const IID_IAnalogRadioTuningSpace2 = &IID_IAnalogRadioTuningSpace2_Value;
pub const IAnalogRadioTuningSpace2 = extern struct {
    pub const VTable = extern struct {
        base: IAnalogRadioTuningSpace.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace2,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace2,
                CountryCodeVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogRadioTuningSpace2,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogRadioTuningSpace2,
                NewCountryCodeVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAnalogRadioTuningSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace2_get_CountryCode(self: *const T, CountryCodeVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace2.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAnalogRadioTuningSpace2, @ptrCast(self)), CountryCodeVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogRadioTuningSpace2_put_CountryCode(self: *const T, NewCountryCodeVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IAnalogRadioTuningSpace2.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAnalogRadioTuningSpace2, @ptrCast(self)), NewCountryCodeVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ITuneRequest_Value = Guid.initString("07ddc146-fc3d-11d2-9d8c-00c04f72d980");
pub const IID_ITuneRequest = &IID_ITuneRequest_Value;
pub const ITuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuneRequest,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuneRequest,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Components: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuneRequest,
                Components: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuneRequest,
                Components: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequest,
                NewTuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequest,
                NewTuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Locator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuneRequest,
                Locator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuneRequest,
                Locator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Locator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuneRequest,
                Locator: ?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuneRequest,
                Locator: ?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_TuningSpace(self: *const T, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const ITuneRequest, @ptrCast(self)), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_Components(self: *const T, Components: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_Components(@as(*const ITuneRequest, @ptrCast(self)), Components);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_Clone(self: *const T, NewTuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).Clone(@as(*const ITuneRequest, @ptrCast(self)), NewTuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_get_Locator(self: *const T, Locator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).get_Locator(@as(*const ITuneRequest, @ptrCast(self)), Locator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequest_put_Locator(self: *const T, Locator: ?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequest.VTable, @ptrCast(self.vtable)).put_Locator(@as(*const ITuneRequest, @ptrCast(self)), Locator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IChannelIDTuneRequest_Value = Guid.initString("156eff60-86f4-4e28-89fc-109799fd57ee");
pub const IID_IChannelIDTuneRequest = &IID_IChannelIDTuneRequest_Value;
pub const IChannelIDTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IChannelIDTuneRequest,
                ChannelID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IChannelIDTuneRequest,
                ChannelID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ChannelID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IChannelIDTuneRequest,
                ChannelID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IChannelIDTuneRequest,
                ChannelID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelIDTuneRequest_get_ChannelID(self: *const T, ChannelID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IChannelIDTuneRequest.VTable, @ptrCast(self.vtable)).get_ChannelID(@as(*const IChannelIDTuneRequest, @ptrCast(self)), ChannelID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelIDTuneRequest_put_ChannelID(self: *const T, ChannelID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IChannelIDTuneRequest.VTable, @ptrCast(self.vtable)).put_ChannelID(@as(*const IChannelIDTuneRequest, @ptrCast(self)), ChannelID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IChannelTuneRequest_Value = Guid.initString("0369b4e0-45b6-11d3-b650-00c04f79498e");
pub const IID_IChannelTuneRequest = &IID_IChannelTuneRequest_Value;
pub const IChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IChannelTuneRequest,
                Channel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IChannelTuneRequest,
                Channel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IChannelTuneRequest,
                Channel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IChannelTuneRequest,
                Channel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelTuneRequest_get_Channel(self: *const T, Channel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IChannelTuneRequest.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IChannelTuneRequest, @ptrCast(self)), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChannelTuneRequest_put_Channel(self: *const T, Channel: i32) callconv(.Inline) HRESULT {
            return @as(*const IChannelTuneRequest.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IChannelTuneRequest, @ptrCast(self)), Channel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCChannelTuneRequest_Value = Guid.initString("0369b4e1-45b6-11d3-b650-00c04f79498e");
pub const IID_IATSCChannelTuneRequest = &IID_IATSCChannelTuneRequest_Value;
pub const IATSCChannelTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCChannelTuneRequest,
                MinorChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCChannelTuneRequest,
                MinorChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MinorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCChannelTuneRequest,
                MinorChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCChannelTuneRequest,
                MinorChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IChannelTuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCChannelTuneRequest_get_MinorChannel(self: *const T, MinorChannel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCChannelTuneRequest.VTable, @ptrCast(self.vtable)).get_MinorChannel(@as(*const IATSCChannelTuneRequest, @ptrCast(self)), MinorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCChannelTuneRequest_put_MinorChannel(self: *const T, MinorChannel: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCChannelTuneRequest.VTable, @ptrCast(self.vtable)).put_MinorChannel(@as(*const IATSCChannelTuneRequest, @ptrCast(self)), MinorChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableTuneRequest_Value = Guid.initString("bad7753b-6b37-4810-ae57-3ce0c4a9e6cb");
pub const IID_IDigitalCableTuneRequest = &IID_IDigitalCableTuneRequest_Value;
pub const IDigitalCableTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: IATSCChannelTuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuneRequest,
                pMajorChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuneRequest,
                pMajorChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MajorChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuneRequest,
                MajorChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuneRequest,
                MajorChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuneRequest,
                pSourceID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuneRequest,
                pSourceID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDigitalCableTuneRequest,
                SourceID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDigitalCableTuneRequest,
                SourceID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCChannelTuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_get_MajorChannel(self: *const T, pMajorChannel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).get_MajorChannel(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), pMajorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_put_MajorChannel(self: *const T, MajorChannel: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).put_MajorChannel(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), MajorChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_get_SourceID(self: *const T, pSourceID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).get_SourceID(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), pSourceID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDigitalCableTuneRequest_put_SourceID(self: *const T, SourceID: i32) callconv(.Inline) HRESULT {
            return @as(*const IDigitalCableTuneRequest.VTable, @ptrCast(self.vtable)).put_SourceID(@as(*const IDigitalCableTuneRequest, @ptrCast(self)), SourceID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTuneRequest_Value = Guid.initString("0d6f567e-a636-42bb-83ba-ce4c1704afa2");
pub const IID_IDVBTuneRequest = &IID_IDVBTuneRequest_Value;
pub const IDVBTuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ONID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                ONID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                ONID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ONID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                ONID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                ONID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                SID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                SID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTuneRequest,
                SID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTuneRequest,
                SID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_ONID(self: *const T, ONID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_ONID(@as(*const IDVBTuneRequest, @ptrCast(self)), ONID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_ONID(self: *const T, ONID: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_ONID(@as(*const IDVBTuneRequest, @ptrCast(self)), ONID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IDVBTuneRequest, @ptrCast(self)), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IDVBTuneRequest, @ptrCast(self)), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_get_SID(self: *const T, SID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).get_SID(@as(*const IDVBTuneRequest, @ptrCast(self)), SID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTuneRequest_put_SID(self: *const T, SID: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTuneRequest.VTable, @ptrCast(self.vtable)).put_SID(@as(*const IDVBTuneRequest, @ptrCast(self)), SID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequest_Value = Guid.initString("eb7d987f-8a01-42ad-b8ae-574deee44d1a");
pub const IID_IMPEG2TuneRequest = &IID_IMPEG2TuneRequest_Value;
pub const IMPEG2TuneRequest = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequest.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2TuneRequest,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2TuneRequest,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2TuneRequest,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2TuneRequest,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgNo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2TuneRequest,
                ProgNo: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2TuneRequest,
                ProgNo: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgNo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2TuneRequest,
                ProgNo: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2TuneRequest,
                ProgNo: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequest.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IMPEG2TuneRequest, @ptrCast(self)), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IMPEG2TuneRequest, @ptrCast(self)), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_get_ProgNo(self: *const T, ProgNo: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).get_ProgNo(@as(*const IMPEG2TuneRequest, @ptrCast(self)), ProgNo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequest_put_ProgNo(self: *const T, ProgNo: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2TuneRequest.VTable, @ptrCast(self.vtable)).put_ProgNo(@as(*const IMPEG2TuneRequest, @ptrCast(self)), ProgNo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestFactory_Value = Guid.initString("14e11abd-ee37-4893-9ea1-6964de933e39");
pub const IID_IMPEG2TuneRequestFactory = &IID_IMPEG2TuneRequestFactory_Value;
pub const IMPEG2TuneRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateTuneRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2TuneRequestFactory,
                TuningSpace: ?*ITuningSpace,
                TuneRequest: ?*?*IMPEG2TuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2TuneRequestFactory,
                TuningSpace: ?*ITuningSpace,
                TuneRequest: ?*?*IMPEG2TuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2TuneRequestFactory_CreateTuneRequest(self: *const T, TuningSpace: ?*ITuningSpace, TuneRequest: ?*?*IMPEG2TuneRequest) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2TuneRequestFactory.VTable, @ptrCast(self.vtable)).CreateTuneRequest(@as(*const IMPEG2TuneRequestFactory, @ptrCast(self)), TuningSpace, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2TuneRequestSupport_Value = Guid.initString("1b9d5fc3-5bbc-4b6c-bb18-b9d10e3eeebf");
pub const IID_IMPEG2TuneRequestSupport = &IID_IMPEG2TuneRequestSupport_Value;
pub const IMPEG2TuneRequestSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITunerCap_Value = Guid.initString("e60dfa45-8d56-4e65-a8ab-d6be9412c249");
pub const IID_ITunerCap = &IID_ITunerCap_Value;
pub const ITunerCap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_SupportedNetworkTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITunerCap,
                ulcNetworkTypesMax: u32,
                pulcNetworkTypes: ?*u32,
                pguidNetworkTypes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITunerCap,
                ulcNetworkTypesMax: u32,
                pulcNetworkTypes: ?*u32,
                pguidNetworkTypes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SupportedVideoFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITunerCap,
                pulAMTunerModeType: ?*u32,
                pulAnalogVideoStandard: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITunerCap,
                pulAMTunerModeType: ?*u32,
                pulAnalogVideoStandard: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_AuxInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITunerCap,
                pulCompositeCount: ?*u32,
                pulSvideoCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITunerCap,
                pulCompositeCount: ?*u32,
                pulSvideoCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_SupportedNetworkTypes(self: *const T, ulcNetworkTypesMax: u32, pulcNetworkTypes: ?*u32, pguidNetworkTypes: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_SupportedNetworkTypes(@as(*const ITunerCap, @ptrCast(self)), ulcNetworkTypesMax, pulcNetworkTypes, pguidNetworkTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_SupportedVideoFormats(self: *const T, pulAMTunerModeType: ?*u32, pulAnalogVideoStandard: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_SupportedVideoFormats(@as(*const ITunerCap, @ptrCast(self)), pulAMTunerModeType, pulAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCap_get_AuxInputCount(self: *const T, pulCompositeCount: ?*u32, pulSvideoCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITunerCap.VTable, @ptrCast(self.vtable)).get_AuxInputCount(@as(*const ITunerCap, @ptrCast(self)), pulCompositeCount, pulSvideoCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ITunerCapEx_Value = Guid.initString("ed3e0c66-18c8-4ea6-9300-f6841fdd35dc");
pub const IID_ITunerCapEx = &IID_ITunerCapEx_Value;
pub const ITunerCapEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Has608_708Caption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITunerCapEx,
                pbHasCaption: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITunerCapEx,
                pbHasCaption: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITunerCapEx_get_Has608_708Caption(self: *const T, pbHasCaption: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const ITunerCapEx.VTable, @ptrCast(self.vtable)).get_Has608_708Caption(@as(*const ITunerCapEx, @ptrCast(self)), pbHasCaption);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuner_Value = Guid.initString("28c52640-018a-11d3-9d8e-00c04f72d980");
pub const IID_ITuner = &IID_ITuner_Value;
pub const ITuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                TuningSpace: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                TuningSpace: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                TuningSpace: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumTuningSpaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuner,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuner,
                ppEnum: ?*?*IEnumTuningSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuneRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuneRequest: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                TuneRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                TuneRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Validate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuner,
                TuneRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuner,
                TuneRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredComponentTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                ComponentTypes: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                ComponentTypes: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PreferredComponentTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                ComponentTypes: ?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                ComponentTypes: ?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ITuner,
                Strength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ITuner,
                Strength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TriggerSignalEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuner,
                Interval: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuner,
                Interval: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_TuningSpace(self: *const T, TuningSpace: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const ITuner, @ptrCast(self)), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_TuningSpace(self: *const T, TuningSpace: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const ITuner, @ptrCast(self)), TuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_EnumTuningSpaces(self: *const T, ppEnum: ?*?*IEnumTuningSpaces) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).EnumTuningSpaces(@as(*const ITuner, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_TuneRequest(self: *const T, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_TuneRequest(@as(*const ITuner, @ptrCast(self)), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_TuneRequest(self: *const T, TuneRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_TuneRequest(@as(*const ITuner, @ptrCast(self)), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_Validate(self: *const T, TuneRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).Validate(@as(*const ITuner, @ptrCast(self)), TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_PreferredComponentTypes(self: *const T, ComponentTypes: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_PreferredComponentTypes(@as(*const ITuner, @ptrCast(self)), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_put_PreferredComponentTypes(self: *const T, ComponentTypes: ?*IComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).put_PreferredComponentTypes(@as(*const ITuner, @ptrCast(self)), ComponentTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_get_SignalStrength(self: *const T, Strength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).get_SignalStrength(@as(*const ITuner, @ptrCast(self)), Strength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuner_TriggerSignalEvents(self: *const T, Interval: i32) callconv(.Inline) HRESULT {
            return @as(*const ITuner.VTable, @ptrCast(self.vtable)).TriggerSignalEvents(@as(*const ITuner, @ptrCast(self)), Interval);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTuner_Value = Guid.initString("1dfd0a5c-0284-11d3-9d8e-00c04f72d980");
pub const IID_IScanningTuner = &IID_IScanningTuner_Value;
pub const IScanningTuner = extern struct {
    pub const VTable = extern struct {
        base: ITuner.VTable,
        SeekUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SeekDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScanUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTuner,
                MillisecondsPause: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTuner,
                MillisecondsPause: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScanDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTuner,
                MillisecondsPause: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTuner,
                MillisecondsPause: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_SeekUp(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).SeekUp(@as(*const IScanningTuner, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_SeekDown(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).SeekDown(@as(*const IScanningTuner, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_ScanUp(self: *const T, MillisecondsPause: i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).ScanUp(@as(*const IScanningTuner, @ptrCast(self)), MillisecondsPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_ScanDown(self: *const T, MillisecondsPause: i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).ScanDown(@as(*const IScanningTuner, @ptrCast(self)), MillisecondsPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTuner_AutoProgram(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IScanningTuner.VTable, @ptrCast(self.vtable)).AutoProgram(@as(*const IScanningTuner, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScanningTunerEx_Value = Guid.initString("04bbd195-0e2d-4593-9bd5-4f908bc33cf5");
pub const IID_IScanningTunerEx = &IID_IScanningTunerEx_Value;
pub const IScanningTunerEx = extern struct {
    pub const VTable = extern struct {
        base: IScanningTuner.VTable,
        GetCurrentLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                pILocator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                pILocator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PerformExhaustiveScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                dwLowerFreq: i32,
                dwHigherFreq: i32,
                bFineTune: VARIANT_BOOL,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                dwLowerFreq: i32,
                dwHigherFreq: i32,
                bFineTune: VARIANT_BOOL,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                pcurrentFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                pcurrentFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeCurrentScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTunerScanningCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                HardwareAssistedScanning: ?*i32,
                NumStandardsSupported: ?*i32,
                BroadcastStandards: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                HardwareAssistedScanning: ?*i32,
                NumStandardsSupported: ?*i32,
                BroadcastStandards: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTunerStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                SecondsLeft: ?*i32,
                CurrentLockType: ?*i32,
                AutoDetect: ?*i32,
                CurrentFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                SecondsLeft: ?*i32,
                CurrentLockType: ?*i32,
                AutoDetect: ?*i32,
                CurrentFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTunerStandardCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                CurrentBroadcastStandard: Guid,
                SettlingTime: ?*i32,
                TvStandardsSupported: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                CurrentBroadcastStandard: Guid,
                SettlingTime: ?*i32,
                TvStandardsSupported: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScanSignalTypeFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IScanningTunerEx,
                ScanModulationTypes: i32,
                AnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IScanningTunerEx,
                ScanModulationTypes: i32,
                AnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IScanningTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetCurrentLocator(self: *const T, pILocator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetCurrentLocator(@as(*const IScanningTunerEx, @ptrCast(self)), pILocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_PerformExhaustiveScan(self: *const T, dwLowerFreq: i32, dwHigherFreq: i32, bFineTune: VARIANT_BOOL, hEvent: usize) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).PerformExhaustiveScan(@as(*const IScanningTunerEx, @ptrCast(self)), dwLowerFreq, dwHigherFreq, bFineTune, hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_TerminateCurrentScan(self: *const T, pcurrentFreq: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).TerminateCurrentScan(@as(*const IScanningTunerEx, @ptrCast(self)), pcurrentFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_ResumeCurrentScan(self: *const T, hEvent: usize) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).ResumeCurrentScan(@as(*const IScanningTunerEx, @ptrCast(self)), hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetTunerScanningCapability(self: *const T, HardwareAssistedScanning: ?*i32, NumStandardsSupported: ?*i32, BroadcastStandards: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetTunerScanningCapability(@as(*const IScanningTunerEx, @ptrCast(self)), HardwareAssistedScanning, NumStandardsSupported, BroadcastStandards);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetTunerStatus(self: *const T, SecondsLeft: ?*i32, CurrentLockType: ?*i32, AutoDetect: ?*i32, CurrentFreq: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetTunerStatus(@as(*const IScanningTunerEx, @ptrCast(self)), SecondsLeft, CurrentLockType, AutoDetect, CurrentFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_GetCurrentTunerStandardCapability(self: *const T, CurrentBroadcastStandard: Guid, SettlingTime: ?*i32, TvStandardsSupported: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).GetCurrentTunerStandardCapability(@as(*const IScanningTunerEx, @ptrCast(self)), CurrentBroadcastStandard, SettlingTime, TvStandardsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScanningTunerEx_SetScanSignalTypeFilter(self: *const T, ScanModulationTypes: i32, _param_AnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @as(*const IScanningTunerEx.VTable, @ptrCast(self.vtable)).SetScanSignalTypeFilter(@as(*const IScanningTunerEx, @ptrCast(self)), ScanModulationTypes, _param_AnalogVideoStandard);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentType_Value = Guid.initString("6a340dc0-0311-11d3-9d8e-00c04f72d980");
pub const IID_IComponentType = &IID_IComponentType_Value;
pub const IComponentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                Category: ?*ComponentCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                Category: ?*ComponentCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                Category: ComponentCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                Category: ComponentCategory,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaMajorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaMajorType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaMajorType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaMajorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaMajorType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaMajorType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaMajorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaMajorTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaMajorTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaMajorType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaMajorTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaMajorTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaSubType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaSubType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaSubType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaSubType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaSubType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaSubType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaSubType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaSubTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaSubTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaSubType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaSubTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaSubTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaFormatType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaFormatType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaFormatType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaFormatType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaFormatType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaFormatType: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MediaFormatType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaFormatTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaFormatTypeGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MediaFormatType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaFormatTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaFormatTypeGuid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentType,
                MediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentType,
                MediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentType,
                NewCT: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentType,
                NewCT: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_Category(self: *const T, Category: ?*ComponentCategory) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IComponentType, @ptrCast(self)), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_Category(self: *const T, Category: ComponentCategory) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_Category(@as(*const IComponentType, @ptrCast(self)), Category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaMajorType(self: *const T, MediaMajorType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaMajorType(@as(*const IComponentType, @ptrCast(self)), MediaMajorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaMajorType(self: *const T, MediaMajorType: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaMajorType(@as(*const IComponentType, @ptrCast(self)), MediaMajorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaMajorType(self: *const T, MediaMajorTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaMajorType(@as(*const IComponentType, @ptrCast(self)), MediaMajorTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaMajorType(self: *const T, MediaMajorTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaMajorType(@as(*const IComponentType, @ptrCast(self)), MediaMajorTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaSubType(self: *const T, MediaSubType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaSubType(@as(*const IComponentType, @ptrCast(self)), MediaSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaSubType(self: *const T, MediaSubType: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaSubType(@as(*const IComponentType, @ptrCast(self)), MediaSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaSubType(self: *const T, MediaSubTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaSubType(@as(*const IComponentType, @ptrCast(self)), MediaSubTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaSubType(self: *const T, MediaSubTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaSubType(@as(*const IComponentType, @ptrCast(self)), MediaSubTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaFormatType(self: *const T, MediaFormatType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaFormatType(@as(*const IComponentType, @ptrCast(self)), MediaFormatType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaFormatType(self: *const T, MediaFormatType: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaFormatType(@as(*const IComponentType, @ptrCast(self)), MediaFormatType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get__MediaFormatType(self: *const T, MediaFormatTypeGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get__MediaFormatType(@as(*const IComponentType, @ptrCast(self)), MediaFormatTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put__MediaFormatType(self: *const T, MediaFormatTypeGuid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put__MediaFormatType(@as(*const IComponentType, @ptrCast(self)), MediaFormatTypeGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_get_MediaType(self: *const T, MediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).get_MediaType(@as(*const IComponentType, @ptrCast(self)), MediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_put_MediaType(self: *const T, MediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).put_MediaType(@as(*const IComponentType, @ptrCast(self)), MediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentType_Clone(self: *const T, NewCT: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @as(*const IComponentType.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentType, @ptrCast(self)), NewCT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILanguageComponentType_Value = Guid.initString("b874c8ba-0fa2-11d3-9d8e-00c04f72d980");
pub const IID_ILanguageComponentType = &IID_ILanguageComponentType_Value;
pub const ILanguageComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LangID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILanguageComponentType,
                LangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILanguageComponentType,
                LangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LangID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILanguageComponentType,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILanguageComponentType,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageComponentType_get_LangID(self: *const T, LangID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ILanguageComponentType.VTable, @ptrCast(self.vtable)).get_LangID(@as(*const ILanguageComponentType, @ptrCast(self)), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILanguageComponentType_put_LangID(self: *const T, LangID: i32) callconv(.Inline) HRESULT {
            return @as(*const ILanguageComponentType.VTable, @ptrCast(self.vtable)).put_LangID(@as(*const ILanguageComponentType, @ptrCast(self)), LangID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2ComponentType_Value = Guid.initString("2c073d84-b51c-48c9-aa9f-68971e1f6e38");
pub const IID_IMPEG2ComponentType = &IID_IMPEG2ComponentType_Value;
pub const IMPEG2ComponentType = extern struct {
    pub const VTable = extern struct {
        base: ILanguageComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StreamType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2ComponentType,
                MP2StreamType: ?*MPEG2StreamType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2ComponentType,
                MP2StreamType: ?*MPEG2StreamType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StreamType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2ComponentType,
                MP2StreamType: MPEG2StreamType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2ComponentType,
                MP2StreamType: MPEG2StreamType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILanguageComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2ComponentType_get_StreamType(self: *const T, MP2StreamType: ?*MPEG2StreamType) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2ComponentType.VTable, @ptrCast(self.vtable)).get_StreamType(@as(*const IMPEG2ComponentType, @ptrCast(self)), MP2StreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2ComponentType_put_StreamType(self: *const T, MP2StreamType: MPEG2StreamType) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2ComponentType.VTable, @ptrCast(self.vtable)).put_StreamType(@as(*const IMPEG2ComponentType, @ptrCast(self)), MP2StreamType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCComponentType_Value = Guid.initString("fc189e4d-7bd4-4125-b3b3-3a76a332cc96");
pub const IID_IATSCComponentType = &IID_IATSCComponentType_Value;
pub const IATSCComponentType = extern struct {
    pub const VTable = extern struct {
        base: IMPEG2ComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Flags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCComponentType,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCComponentType,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Flags: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCComponentType,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCComponentType,
                flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMPEG2ComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCComponentType_get_Flags(self: *const T, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCComponentType.VTable, @ptrCast(self.vtable)).get_Flags(@as(*const IATSCComponentType, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCComponentType_put_Flags(self: *const T, flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCComponentType.VTable, @ptrCast(self.vtable)).put_Flags(@as(*const IATSCComponentType, @ptrCast(self)), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponentTypes_Value = Guid.initString("8a674b4a-1f63-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponentTypes = &IID_IEnumComponentTypes_Value;
pub const IEnumComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponentTypes,
                celt: u32,
                rgelt: [*]?*IComponentType,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponentTypes,
                celt: u32,
                rgelt: [*]?*IComponentType,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponentTypes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponentTypes,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponentTypes,
                ppEnum: ?*?*IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponentTypes,
                ppEnum: ?*?*IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Next(self: *const T, celt: u32, rgelt: [*]?*IComponentType, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumComponentTypes, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumComponentTypes, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumComponentTypes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponentTypes_Clone(self: *const T, ppEnum: ?*?*IEnumComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponentTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumComponentTypes, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponentTypes_Value = Guid.initString("0dc13d4a-0313-11d3-9d8e-00c04f72d980");
pub const IID_IComponentTypes = &IID_IComponentTypes_Value;
pub const IComponentTypes = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentTypes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentTypes,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentTypes,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentTypes,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumComponentTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                ppNewEnum: ?*?*IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                ppNewEnum: ?*?*IEnumComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                Index: VARIANT,
                ComponentType: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                Index: VARIANT,
                ComponentType: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                Index: VARIANT,
                ComponentType: ?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                Index: VARIANT,
                ComponentType: ?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                ComponentType: ?*IComponentType,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                ComponentType: ?*IComponentType,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentTypes,
                NewList: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentTypes,
                NewList: ?*?*IComponentTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponentTypes, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponentTypes, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_EnumComponentTypes(self: *const T, ppNewEnum: ?*?*IEnumComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).EnumComponentTypes(@as(*const IComponentTypes, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_get_Item(self: *const T, Index: VARIANT, ComponentType: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponentTypes, @ptrCast(self)), Index, ComponentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_put_Item(self: *const T, Index: VARIANT, ComponentType: ?*IComponentType) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IComponentTypes, @ptrCast(self)), Index, ComponentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Add(self: *const T, ComponentType: ?*IComponentType, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponentTypes, @ptrCast(self)), ComponentType, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponentTypes, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentTypes_Clone(self: *const T, NewList: ?*?*IComponentTypes) callconv(.Inline) HRESULT {
            return @as(*const IComponentTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentTypes, @ptrCast(self)), NewList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IComponent_Value = Guid.initString("1a5576fc-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponent = &IID_IComponent_Value;
pub const IComponent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                CT: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                CT: ?*?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                CT: ?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                CT: ?*IComponentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DescLangID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                LangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                LangID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DescLangID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                LangID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                Status: ?*ComponentStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                Status: ?*ComponentStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                Status: ComponentStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                Status: ComponentStatus,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                Description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                Description: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponent,
                Description: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponent,
                Description: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponent,
                NewComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponent,
                NewComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Type(self: *const T, CT: ?*?*IComponentType) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IComponent, @ptrCast(self)), CT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Type(self: *const T, CT: ?*IComponentType) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Type(@as(*const IComponent, @ptrCast(self)), CT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_DescLangID(self: *const T, LangID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_DescLangID(@as(*const IComponent, @ptrCast(self)), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_DescLangID(self: *const T, LangID: i32) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_DescLangID(@as(*const IComponent, @ptrCast(self)), LangID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Status(self: *const T, Status: ?*ComponentStatus) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IComponent, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Status(self: *const T, Status: ComponentStatus) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Status(@as(*const IComponent, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_get_Description(self: *const T, Description: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IComponent, @ptrCast(self)), Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_put_Description(self: *const T, Description: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).put_Description(@as(*const IComponent, @ptrCast(self)), Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponent_Clone(self: *const T, NewComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @as(*const IComponent.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponent, @ptrCast(self)), NewComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogAudioComponentType_Value = Guid.initString("2cfeb2a8-1787-4a24-a941-c6eaec39c842");
pub const IID_IAnalogAudioComponentType = &IID_IAnalogAudioComponentType_Value;
pub const IAnalogAudioComponentType = extern struct {
    pub const VTable = extern struct {
        base: IComponentType.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnalogAudioMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogAudioComponentType,
                Mode: ?*TVAudioMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogAudioComponentType,
                Mode: ?*TVAudioMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AnalogAudioMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogAudioComponentType,
                Mode: TVAudioMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogAudioComponentType,
                Mode: TVAudioMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponentType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogAudioComponentType_get_AnalogAudioMode(self: *const T, Mode: ?*TVAudioMode) callconv(.Inline) HRESULT {
            return @as(*const IAnalogAudioComponentType.VTable, @ptrCast(self.vtable)).get_AnalogAudioMode(@as(*const IAnalogAudioComponentType, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogAudioComponentType_put_AnalogAudioMode(self: *const T, Mode: TVAudioMode) callconv(.Inline) HRESULT {
            return @as(*const IAnalogAudioComponentType.VTable, @ptrCast(self.vtable)).put_AnalogAudioMode(@as(*const IAnalogAudioComponentType, @ptrCast(self)), Mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2Component_Value = Guid.initString("1493e353-1eb6-473c-802d-8e6b8ec9d2a9");
pub const IID_IMPEG2Component = &IID_IMPEG2Component_Value;
pub const IMPEG2Component = extern struct {
    pub const VTable = extern struct {
        base: IComponent.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                PID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                PID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                PID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                PID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PCRPID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                PCRPID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                PCRPID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PCRPID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                PCRPID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                PCRPID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                ProgramNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                ProgramNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMPEG2Component,
                ProgramNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMPEG2Component,
                ProgramNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_PID(self: *const T, PID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_PID(@as(*const IMPEG2Component, @ptrCast(self)), PID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_PID(self: *const T, PID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_PID(@as(*const IMPEG2Component, @ptrCast(self)), PID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_PCRPID(self: *const T, PCRPID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_PCRPID(@as(*const IMPEG2Component, @ptrCast(self)), PCRPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_PCRPID(self: *const T, PCRPID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_PCRPID(@as(*const IMPEG2Component, @ptrCast(self)), PCRPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_get_ProgramNumber(self: *const T, ProgramNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).get_ProgramNumber(@as(*const IMPEG2Component, @ptrCast(self)), ProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2Component_put_ProgramNumber(self: *const T, ProgramNumber: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2Component.VTable, @ptrCast(self.vtable)).put_ProgramNumber(@as(*const IMPEG2Component, @ptrCast(self)), ProgramNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumComponents_Value = Guid.initString("2a6e2939-2595-11d3-b64c-00c04f79498e");
pub const IID_IEnumComponents = &IID_IEnumComponents_Value;
pub const IEnumComponents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponents,
                celt: u32,
                rgelt: [*]?*IComponent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponents,
                celt: u32,
                rgelt: [*]?*IComponent,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponents,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponents,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumComponents,
                ppEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumComponents,
                ppEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Next(self: *const T, celt: u32, rgelt: [*]?*IComponent, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumComponents, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumComponents, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumComponents, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumComponents_Clone(self: *const T, ppEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @as(*const IEnumComponents.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumComponents, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IComponents_Value = Guid.initString("39a48091-fffe-4182-a161-3ff802640e26");
pub const IID_IComponents = &IID_IComponents_Value;
pub const IComponents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponents,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponents,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponents,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponents,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumComponents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                ppNewEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                ppNewEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                Index: VARIANT,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                Index: VARIANT,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                Component: ?*IComponent,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                Component: ?*IComponent,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                NewList: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                NewList: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponents,
                Index: VARIANT,
                ppComponent: ?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponents,
                Index: VARIANT,
                ppComponent: ?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponents, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponents, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_EnumComponents(self: *const T, ppNewEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).EnumComponents(@as(*const IComponents, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_get_Item(self: *const T, Index: VARIANT, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponents, @ptrCast(self)), Index, ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Add(self: *const T, Component: ?*IComponent, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponents, @ptrCast(self)), Component, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponents, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_Clone(self: *const T, NewList: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponents, @ptrCast(self)), NewList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponents_put_Item(self: *const T, Index: VARIANT, ppComponent: ?*IComponent) callconv(.Inline) HRESULT {
            return @as(*const IComponents.VTable, @ptrCast(self.vtable)).put_Item(@as(*const IComponents, @ptrCast(self)), Index, ppComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IComponentsOld_Value = Guid.initString("fcd01846-0e19-11d3-9d8e-00c04f72d980");
pub const IID_IComponentsOld = &IID_IComponentsOld_Value;
pub const IComponentsOld = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentsOld,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentsOld,
                Count: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IComponentsOld,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IComponentsOld,
                ppNewEnum: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumComponents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentsOld,
                ppNewEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentsOld,
                ppNewEnum: ?*?*IEnumComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentsOld,
                Index: VARIANT,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentsOld,
                Index: VARIANT,
                ppComponent: ?*?*IComponent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentsOld,
                Component: ?*IComponent,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentsOld,
                Component: ?*IComponent,
                NewIndex: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentsOld,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentsOld,
                Index: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComponentsOld,
                NewList: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComponentsOld,
                NewList: ?*?*IComponents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IComponentsOld, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get__NewEnum(self: *const T, ppNewEnum: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IComponentsOld, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_EnumComponents(self: *const T, ppNewEnum: ?*?*IEnumComponents) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).EnumComponents(@as(*const IComponentsOld, @ptrCast(self)), ppNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_get_Item(self: *const T, Index: VARIANT, ppComponent: ?*?*IComponent) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IComponentsOld, @ptrCast(self)), Index, ppComponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Add(self: *const T, Component: ?*IComponent, NewIndex: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Add(@as(*const IComponentsOld, @ptrCast(self)), Component, NewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Remove(self: *const T, Index: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Remove(@as(*const IComponentsOld, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComponentsOld_Clone(self: *const T, NewList: ?*?*IComponents) callconv(.Inline) HRESULT {
            return @as(*const IComponentsOld.VTable, @ptrCast(self.vtable)).Clone(@as(*const IComponentsOld, @ptrCast(self)), NewList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ILocator_Value = Guid.initString("286d7f89-760c-4f89-80c4-66841d2507aa");
pub const IID_ILocator = &IID_ILocator_Value;
pub const ILocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CarrierFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Frequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Frequency: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CarrierFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Frequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Frequency: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Modulation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Modulation: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Modulation: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Modulation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Modulation: ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Modulation: ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Rate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Rate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ILocator,
                Rate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ILocator,
                Rate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ILocator,
                NewLocator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ILocator,
                NewLocator: ?*?*ILocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_CarrierFrequency(self: *const T, Frequency: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_CarrierFrequency(@as(*const ILocator, @ptrCast(self)), Frequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_CarrierFrequency(self: *const T, Frequency: i32) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_CarrierFrequency(@as(*const ILocator, @ptrCast(self)), Frequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_InnerFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_InnerFEC(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_InnerFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_InnerFEC(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_InnerFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_InnerFECRate(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_InnerFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_InnerFECRate(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_OuterFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_OuterFEC(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_OuterFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_OuterFEC(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_OuterFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_OuterFECRate(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_OuterFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_OuterFECRate(@as(*const ILocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_Modulation(self: *const T, Modulation: ?*ModulationType) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_Modulation(@as(*const ILocator, @ptrCast(self)), Modulation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_Modulation(self: *const T, Modulation: ModulationType) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_Modulation(@as(*const ILocator, @ptrCast(self)), Modulation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_get_SymbolRate(self: *const T, Rate: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).get_SymbolRate(@as(*const ILocator, @ptrCast(self)), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_put_SymbolRate(self: *const T, Rate: i32) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).put_SymbolRate(@as(*const ILocator, @ptrCast(self)), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocator_Clone(self: *const T, NewLocator: ?*?*ILocator) callconv(.Inline) HRESULT {
            return @as(*const ILocator.VTable, @ptrCast(self.vtable)).Clone(@as(*const ILocator, @ptrCast(self)), NewLocator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAnalogLocator_Value = Guid.initString("34d1f26b-e339-430d-abce-738cb48984dc");
pub const IID_IAnalogLocator = &IID_IAnalogLocator_Value;
pub const IAnalogLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoStandard: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogLocator,
                AVS: ?*AnalogVideoStandard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogLocator,
                AVS: ?*AnalogVideoStandard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoStandard: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAnalogLocator,
                AVS: AnalogVideoStandard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAnalogLocator,
                AVS: AnalogVideoStandard,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogLocator_get_VideoStandard(self: *const T, AVS: ?*AnalogVideoStandard) callconv(.Inline) HRESULT {
            return @as(*const IAnalogLocator.VTable, @ptrCast(self.vtable)).get_VideoStandard(@as(*const IAnalogLocator, @ptrCast(self)), AVS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnalogLocator_put_VideoStandard(self: *const T, AVS: AnalogVideoStandard) callconv(.Inline) HRESULT {
            return @as(*const IAnalogLocator.VTable, @ptrCast(self.vtable)).put_VideoStandard(@as(*const IAnalogLocator, @ptrCast(self)), AVS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalLocator_Value = Guid.initString("19b595d8-839a-47f0-96df-4f194f3c768c");
pub const IID_IDigitalLocator = &IID_IDigitalLocator_Value;
pub const IDigitalLocator = extern struct {
    pub const VTable = extern struct {
        base: ILocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IATSCLocator_Value = Guid.initString("bf8d986f-8c2b-4131-94d7-4d3d9fcc21ef");
pub const IID_IATSCLocator = &IID_IATSCLocator_Value;
pub const IATSCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator,
                PhysicalChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator,
                PhysicalChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalChannel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator,
                PhysicalChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator,
                PhysicalChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator,
                TSID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TSID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator,
                TSID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_get_PhysicalChannel(self: *const T, PhysicalChannel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).get_PhysicalChannel(@as(*const IATSCLocator, @ptrCast(self)), PhysicalChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_put_PhysicalChannel(self: *const T, PhysicalChannel: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).put_PhysicalChannel(@as(*const IATSCLocator, @ptrCast(self)), PhysicalChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_get_TSID(self: *const T, TSID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).get_TSID(@as(*const IATSCLocator, @ptrCast(self)), TSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator_put_TSID(self: *const T, TSID: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator.VTable, @ptrCast(self.vtable)).put_TSID(@as(*const IATSCLocator, @ptrCast(self)), TSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IATSCLocator2_Value = Guid.initString("612aa885-66cf-4090-ba0a-566f5312e4ca");
pub const IID_IATSCLocator2 = &IID_IATSCLocator2_Value;
pub const IATSCLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProgramNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator2,
                ProgramNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator2,
                ProgramNumber: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProgramNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IATSCLocator2,
                ProgramNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IATSCLocator2,
                ProgramNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator2_get_ProgramNumber(self: *const T, ProgramNumber: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator2.VTable, @ptrCast(self.vtable)).get_ProgramNumber(@as(*const IATSCLocator2, @ptrCast(self)), ProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSCLocator2_put_ProgramNumber(self: *const T, ProgramNumber: i32) callconv(.Inline) HRESULT {
            return @as(*const IATSCLocator2.VTable, @ptrCast(self.vtable)).put_ProgramNumber(@as(*const IATSCLocator2, @ptrCast(self)), ProgramNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDigitalCableLocator_Value = Guid.initString("48f66a11-171a-419a-9525-beeecd51584c");
pub const IID_IDigitalCableLocator = &IID_IDigitalCableLocator_Value;
pub const IDigitalCableLocator = extern struct {
    pub const VTable = extern struct {
        base: IATSCLocator2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IATSCLocator2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBTLocator_Value = Guid.initString("8664da16-dda2-42ac-926a-c18f9127c302");
pub const IID_IDVBTLocator = &IID_IDVBTLocator_Value;
pub const IDVBTLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                BandWidthVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                BandWidthVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                BandwidthVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                BandwidthVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                FEC: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFEC: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                FEC: FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LPInnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                FEC: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LPInnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                FEC: BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HAlpha: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                Alpha: ?*HierarchyAlpha,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                Alpha: ?*HierarchyAlpha,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HAlpha: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                Alpha: HierarchyAlpha,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                Alpha: HierarchyAlpha,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Guard: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                GI: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                GI: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Guard: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                GI: GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                GI: GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                mode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                mode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                mode: TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                mode: TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OtherFrequencyInUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                OtherFrequencyInUseVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                OtherFrequencyInUseVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OtherFrequencyInUse: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator,
                OtherFrequencyInUseVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator,
                OtherFrequencyInUseVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Bandwidth(self: *const T, BandWidthVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IDVBTLocator, @ptrCast(self)), BandWidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Bandwidth(self: *const T, BandwidthVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Bandwidth(@as(*const IDVBTLocator, @ptrCast(self)), BandwidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_LPInnerFEC(self: *const T, FEC: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_LPInnerFEC(@as(*const IDVBTLocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_LPInnerFEC(self: *const T, FEC: FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_LPInnerFEC(@as(*const IDVBTLocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_LPInnerFECRate(self: *const T, FEC: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_LPInnerFECRate(@as(*const IDVBTLocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_LPInnerFECRate(self: *const T, FEC: BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_LPInnerFECRate(@as(*const IDVBTLocator, @ptrCast(self)), FEC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_HAlpha(self: *const T, Alpha: ?*HierarchyAlpha) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_HAlpha(@as(*const IDVBTLocator, @ptrCast(self)), Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_HAlpha(self: *const T, Alpha: HierarchyAlpha) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_HAlpha(@as(*const IDVBTLocator, @ptrCast(self)), Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Guard(self: *const T, GI: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Guard(@as(*const IDVBTLocator, @ptrCast(self)), GI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Guard(self: *const T, GI: GuardInterval) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Guard(@as(*const IDVBTLocator, @ptrCast(self)), GI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_Mode(self: *const T, mode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IDVBTLocator, @ptrCast(self)), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_Mode(self: *const T, mode: TransmissionMode) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IDVBTLocator, @ptrCast(self)), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_get_OtherFrequencyInUse(self: *const T, OtherFrequencyInUseVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).get_OtherFrequencyInUse(@as(*const IDVBTLocator, @ptrCast(self)), OtherFrequencyInUseVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator_put_OtherFrequencyInUse(self: *const T, OtherFrequencyInUseVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator.VTable, @ptrCast(self.vtable)).put_OtherFrequencyInUse(@as(*const IDVBTLocator, @ptrCast(self)), OtherFrequencyInUseVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBTLocator2_Value = Guid.initString("448a2edf-ae95-4b43-a3cc-747843c453d4");
pub const IID_IDVBTLocator2 = &IID_IDVBTLocator2_Value;
pub const IDVBTLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBTLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PhysicalLayerPipeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator2,
                PhysicalLayerPipeIdVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator2,
                PhysicalLayerPipeIdVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PhysicalLayerPipeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBTLocator2,
                PhysicalLayerPipeIdVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBTLocator2,
                PhysicalLayerPipeIdVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBTLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator2_get_PhysicalLayerPipeId(self: *const T, PhysicalLayerPipeIdVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator2.VTable, @ptrCast(self.vtable)).get_PhysicalLayerPipeId(@as(*const IDVBTLocator2, @ptrCast(self)), PhysicalLayerPipeIdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBTLocator2_put_PhysicalLayerPipeId(self: *const T, PhysicalLayerPipeIdVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBTLocator2.VTable, @ptrCast(self.vtable)).put_PhysicalLayerPipeId(@as(*const IDVBTLocator2, @ptrCast(self)), PhysicalLayerPipeIdVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBSLocator_Value = Guid.initString("3d7c353c-0d04-45f1-a742-f97cc1188dc8");
pub const IID_IDVBSLocator = &IID_IDVBSLocator_Value;
pub const IDVBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPolarisation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                PolarisationVal: ?*Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                PolarisationVal: ?*Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPolarisation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                PolarisationVal: Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                PolarisationVal: Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WestPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                WestLongitude: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                WestLongitude: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WestPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                WestLongitude: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                WestLongitude: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OrbitalPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                longitude: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                longitude: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OrbitalPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                longitude: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                longitude: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Azimuth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                Azimuth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                Azimuth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Azimuth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                Azimuth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                Azimuth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Elevation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                Elevation: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                Elevation: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Elevation: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator,
                Elevation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator,
                Elevation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_SignalPolarisation(self: *const T, PolarisationVal: ?*Polarisation) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_SignalPolarisation(@as(*const IDVBSLocator, @ptrCast(self)), PolarisationVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_SignalPolarisation(self: *const T, PolarisationVal: Polarisation) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_SignalPolarisation(@as(*const IDVBSLocator, @ptrCast(self)), PolarisationVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_WestPosition(self: *const T, WestLongitude: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_WestPosition(@as(*const IDVBSLocator, @ptrCast(self)), WestLongitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_WestPosition(self: *const T, WestLongitude: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_WestPosition(@as(*const IDVBSLocator, @ptrCast(self)), WestLongitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_OrbitalPosition(self: *const T, longitude: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_OrbitalPosition(@as(*const IDVBSLocator, @ptrCast(self)), longitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_OrbitalPosition(self: *const T, longitude: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_OrbitalPosition(@as(*const IDVBSLocator, @ptrCast(self)), longitude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_Azimuth(self: *const T, Azimuth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_Azimuth(@as(*const IDVBSLocator, @ptrCast(self)), Azimuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_Azimuth(self: *const T, Azimuth: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_Azimuth(@as(*const IDVBSLocator, @ptrCast(self)), Azimuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_get_Elevation(self: *const T, Elevation: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).get_Elevation(@as(*const IDVBSLocator, @ptrCast(self)), Elevation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator_put_Elevation(self: *const T, Elevation: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator.VTable, @ptrCast(self.vtable)).put_Elevation(@as(*const IDVBSLocator, @ptrCast(self)), Elevation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVBSLocator2_Value = Guid.initString("6044634a-1733-4f99-b982-5fb12afce4f0");
pub const IID_IDVBSLocator2 = &IID_IDVBSLocator2_Value;
pub const IDVBSLocator2 = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DiseqLNBSource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                DiseqLNBSourceVal: ?*LNB_Source,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                DiseqLNBSourceVal: ?*LNB_Source,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                DiseqLNBSourceVal: LNB_Source,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                DiseqLNBSourceVal: LNB_Source,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideLow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideLowVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideLowVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideLow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideLowVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideLowVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscillatorOverrideHigh: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideHighVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideHighVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscillatorOverrideHigh: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideHighVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalOscillatorOverrideHighVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalLNBSwitchOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalLNBSwitchOverrideVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalLNBSwitchOverrideVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalLNBSwitchOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalLNBSwitchOverrideVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalLNBSwitchOverrideVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalSpectralInversionOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalSpectralInversionOverrideVal: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalSpectralInversionOverrideVal: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalSpectralInversionOverride: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                LocalSpectralInversionOverrideVal: SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                LocalSpectralInversionOverrideVal: SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalRollOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                RollOffVal: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                RollOffVal: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalRollOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                RollOffVal: RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                RollOffVal: RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPilot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                PilotVal: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                PilotVal: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPilot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDVBSLocator2,
                PilotVal: Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDVBSLocator2,
                PilotVal: Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBSLocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_DiseqLNBSource(self: *const T, DiseqLNBSourceVal: ?*LNB_Source) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_DiseqLNBSource(@as(*const IDVBSLocator2, @ptrCast(self)), DiseqLNBSourceVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_DiseqLNBSource(self: *const T, DiseqLNBSourceVal: LNB_Source) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_DiseqLNBSource(@as(*const IDVBSLocator2, @ptrCast(self)), DiseqLNBSourceVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalOscillatorOverrideLow(self: *const T, LocalOscillatorOverrideLowVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalOscillatorOverrideLow(@as(*const IDVBSLocator2, @ptrCast(self)), LocalOscillatorOverrideLowVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalOscillatorOverrideLow(self: *const T, LocalOscillatorOverrideLowVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalOscillatorOverrideLow(@as(*const IDVBSLocator2, @ptrCast(self)), LocalOscillatorOverrideLowVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalOscillatorOverrideHigh(self: *const T, LocalOscillatorOverrideHighVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalOscillatorOverrideHigh(@as(*const IDVBSLocator2, @ptrCast(self)), LocalOscillatorOverrideHighVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalOscillatorOverrideHigh(self: *const T, LocalOscillatorOverrideHighVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalOscillatorOverrideHigh(@as(*const IDVBSLocator2, @ptrCast(self)), LocalOscillatorOverrideHighVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalLNBSwitchOverride(self: *const T, LocalLNBSwitchOverrideVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalLNBSwitchOverride(@as(*const IDVBSLocator2, @ptrCast(self)), LocalLNBSwitchOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalLNBSwitchOverride(self: *const T, LocalLNBSwitchOverrideVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalLNBSwitchOverride(@as(*const IDVBSLocator2, @ptrCast(self)), LocalLNBSwitchOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_LocalSpectralInversionOverride(self: *const T, LocalSpectralInversionOverrideVal: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_LocalSpectralInversionOverride(@as(*const IDVBSLocator2, @ptrCast(self)), LocalSpectralInversionOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_LocalSpectralInversionOverride(self: *const T, LocalSpectralInversionOverrideVal: SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_LocalSpectralInversionOverride(@as(*const IDVBSLocator2, @ptrCast(self)), LocalSpectralInversionOverrideVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_SignalRollOff(self: *const T, RollOffVal: ?*RollOff) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_SignalRollOff(@as(*const IDVBSLocator2, @ptrCast(self)), RollOffVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_SignalRollOff(self: *const T, RollOffVal: RollOff) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_SignalRollOff(@as(*const IDVBSLocator2, @ptrCast(self)), RollOffVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_get_SignalPilot(self: *const T, PilotVal: ?*Pilot) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).get_SignalPilot(@as(*const IDVBSLocator2, @ptrCast(self)), PilotVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVBSLocator2_put_SignalPilot(self: *const T, PilotVal: Pilot) callconv(.Inline) HRESULT {
            return @as(*const IDVBSLocator2.VTable, @ptrCast(self.vtable)).put_SignalPilot(@as(*const IDVBSLocator2, @ptrCast(self)), PilotVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVBCLocator_Value = Guid.initString("6e42f36e-1dd2-43c4-9f78-69d25ae39034");
pub const IID_IDVBCLocator = &IID_IDVBCLocator_Value;
pub const IDVBCLocator = extern struct {
    pub const VTable = extern struct {
        base: IDigitalLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDigitalLocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IISDBSLocator_Value = Guid.initString("c9897087-e29c-473f-9e4b-7072123dea14");
pub const IID_IISDBSLocator = &IID_IISDBSLocator_Value;
pub const IISDBSLocator = extern struct {
    pub const VTable = extern struct {
        base: IDVBSLocator.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVBSLocator.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESOpenMmiEvent_Value = Guid.initString("ba4b6526-1a35-4635-8b56-3ec612746a8c");
pub const IID_IESOpenMmiEvent = &IID_IESOpenMmiEvent_Value;
pub const IESOpenMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESOpenMmiEvent,
                pDialogRequest: ?*u32,
                pDialogNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESOpenMmiEvent,
                pDialogRequest: ?*u32,
                pDialogNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDialogType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESOpenMmiEvent,
                guidDialogType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESOpenMmiEvent,
                guidDialogType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDialogData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESOpenMmiEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESOpenMmiEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDialogStringData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESOpenMmiEvent,
                pbstrBaseUrl: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESOpenMmiEvent,
                pbstrBaseUrl: ?*?BSTR,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogNumber(self: *const T, pDialogRequest: ?*u32, pDialogNumber: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogNumber(@as(*const IESOpenMmiEvent, @ptrCast(self)), pDialogRequest, pDialogNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogType(self: *const T, guidDialogType: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogType(@as(*const IESOpenMmiEvent, @ptrCast(self)), guidDialogType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogData(@as(*const IESOpenMmiEvent, @ptrCast(self)), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESOpenMmiEvent_GetDialogStringData(self: *const T, pbstrBaseUrl: ?*?BSTR, pbstrData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IESOpenMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogStringData(@as(*const IESOpenMmiEvent, @ptrCast(self)), pbstrBaseUrl, pbstrData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESCloseMmiEvent_Value = Guid.initString("6b80e96f-55e2-45aa-b754-0c23c8e7d5c1");
pub const IID_IESCloseMmiEvent = &IID_IESCloseMmiEvent_Value;
pub const IESCloseMmiEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetDialogNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESCloseMmiEvent,
                pDialogNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESCloseMmiEvent,
                pDialogNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESCloseMmiEvent_GetDialogNumber(self: *const T, pDialogNumber: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESCloseMmiEvent.VTable, @ptrCast(self.vtable)).GetDialogNumber(@as(*const IESCloseMmiEvent, @ptrCast(self)), pDialogNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESValueUpdatedEvent_Value = Guid.initString("8a24c46e-bb63-4664-8602-5d9c718c146d");
pub const IID_IESValueUpdatedEvent = &IID_IESValueUpdatedEvent_Value;
pub const IESValueUpdatedEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetValueNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESValueUpdatedEvent,
                pbstrNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESValueUpdatedEvent,
                pbstrNames: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESValueUpdatedEvent_GetValueNames(self: *const T, pbstrNames: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IESValueUpdatedEvent.VTable, @ptrCast(self.vtable)).GetValueNames(@as(*const IESValueUpdatedEvent, @ptrCast(self)), pbstrNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESRequestTunerEvent_Value = Guid.initString("54c7a5e8-c3bb-4f51-af14-e0e2c0e34c6d");
pub const IID_IESRequestTunerEvent = &IID_IESRequestTunerEvent_Value;
pub const IESRequestTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESRequestTunerEvent,
                pbyPriority: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESRequestTunerEvent,
                pbyPriority: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReason: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESRequestTunerEvent,
                pbyReason: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESRequestTunerEvent,
                pbyReason: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConsequences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESRequestTunerEvent,
                pbyConsequences: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESRequestTunerEvent,
                pbyConsequences: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEstimatedTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESRequestTunerEvent,
                pdwEstimatedTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESRequestTunerEvent,
                pdwEstimatedTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetPriority(self: *const T, pbyPriority: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IESRequestTunerEvent, @ptrCast(self)), pbyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetReason(self: *const T, pbyReason: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetReason(@as(*const IESRequestTunerEvent, @ptrCast(self)), pbyReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetConsequences(self: *const T, pbyConsequences: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetConsequences(@as(*const IESRequestTunerEvent, @ptrCast(self)), pbyConsequences);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESRequestTunerEvent_GetEstimatedTime(self: *const T, pdwEstimatedTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESRequestTunerEvent.VTable, @ptrCast(self.vtable)).GetEstimatedTime(@as(*const IESRequestTunerEvent, @ptrCast(self)), pdwEstimatedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESIsdbCasResponseEvent_Value = Guid.initString("2017cb03-dc0f-4c24-83ca-36307b2cd19f");
pub const IID_IESIsdbCasResponseEvent = &IID_IESIsdbCasResponseEvent_Value;
pub const IESIsdbCasResponseEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetRequestId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESIsdbCasResponseEvent,
                pRequestId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESIsdbCasResponseEvent,
                pRequestId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESIsdbCasResponseEvent,
                pStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESIsdbCasResponseEvent,
                pStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESIsdbCasResponseEvent,
                pRequestLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESIsdbCasResponseEvent,
                pRequestLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetResponseData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESIsdbCasResponseEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESIsdbCasResponseEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetRequestId(self: *const T, pRequestId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetRequestId(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), pRequestId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetStatus(self: *const T, pStatus: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetDataLength(self: *const T, pRequestLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetDataLength(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), pRequestLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESIsdbCasResponseEvent_GetResponseData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IESIsdbCasResponseEvent.VTable, @ptrCast(self.vtable)).GetResponseData(@as(*const IESIsdbCasResponseEvent, @ptrCast(self)), pbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGpnvsCommonBase_Value = Guid.initString("907e0b5c-e42d-4f04-91f0-26f401f36907");
pub const IID_IGpnvsCommonBase = &IID_IGpnvsCommonBase_Value;
pub const IGpnvsCommonBase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueUpdateName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGpnvsCommonBase,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGpnvsCommonBase,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGpnvsCommonBase_GetValueUpdateName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IGpnvsCommonBase.VTable, @ptrCast(self.vtable)).GetValueUpdateName(@as(*const IGpnvsCommonBase, @ptrCast(self)), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IESEventFactory_Value = Guid.initString("506a09b8-7f86-4e04-ac05-3303bfe8fc49");
pub const IID_IESEventFactory = &IID_IESEventFactory_Value;
pub const IESEventFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateESEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventFactory,
                pServiceProvider: ?*IUnknown,
                dwEventId: u32,
                guidEventType: Guid,
                dwEventDataLength: u32,
                pEventData: [*:0]u8,
                bstrBaseUrl: ?BSTR,
                pInitContext: ?*IUnknown,
                ppESEvent: ?*?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventFactory,
                pServiceProvider: ?*IUnknown,
                dwEventId: u32,
                guidEventType: Guid,
                dwEventDataLength: u32,
                pEventData: [*:0]u8,
                bstrBaseUrl: ?BSTR,
                pInitContext: ?*IUnknown,
                ppESEvent: ?*?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventFactory_CreateESEvent(self: *const T, pServiceProvider: ?*IUnknown, dwEventId: u32, guidEventType: Guid, dwEventDataLength: u32, pEventData: [*:0]u8, bstrBaseUrl: ?BSTR, pInitContext: ?*IUnknown, ppESEvent: ?*?*IESEvent) callconv(.Inline) HRESULT {
            return @as(*const IESEventFactory.VTable, @ptrCast(self.vtable)).CreateESEvent(@as(*const IESEventFactory, @ptrCast(self)), pServiceProvider, dwEventId, guidEventType, dwEventDataLength, pEventData, bstrBaseUrl, pInitContext, ppESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESLicenseRenewalResultEvent_Value = Guid.initString("d5a48ef5-a81b-4df0-acaa-5e35e7ea45d4");
pub const IID_IESLicenseRenewalResultEvent = &IID_IESLicenseRenewalResultEvent_Value;
pub const IESLicenseRenewalResultEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetCallersId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwCallersId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwCallersId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pbstrFilename: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pbstrFilename: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsRenewalSuccessful: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pfRenewalSuccessful: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pfRenewalSuccessful: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCheckEntitlementCallRequired: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pfCheckEntTokenCallNeeded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pfCheckEntTokenCallNeeded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescrambledStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pDescrambledStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pDescrambledStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenewalResultCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwRenewalResultCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwRenewalResultCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCASFailureCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwCASFailureCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwCASFailureCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenewalHResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                phr: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                phr: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntitlementTokenLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pdwLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntitlementToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpiryDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESLicenseRenewalResultEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESLicenseRenewalResultEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetCallersId(self: *const T, pdwCallersId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetCallersId(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdwCallersId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetFileName(self: *const T, pbstrFilename: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetFileName(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pbstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_IsRenewalSuccessful(self: *const T, pfRenewalSuccessful: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).IsRenewalSuccessful(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pfRenewalSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_IsCheckEntitlementCallRequired(self: *const T, pfCheckEntTokenCallNeeded: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).IsCheckEntitlementCallRequired(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pfCheckEntTokenCallNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetDescrambledStatus(self: *const T, pDescrambledStatus: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetDescrambledStatus(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pDescrambledStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetRenewalResultCode(self: *const T, pdwRenewalResultCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetRenewalResultCode(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdwRenewalResultCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetCASFailureCode(self: *const T, pdwCASFailureCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetCASFailureCode(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdwCASFailureCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetRenewalHResult(self: *const T, phr: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetRenewalHResult(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), phr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetEntitlementTokenLength(self: *const T, pdwLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetEntitlementTokenLength(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetEntitlementToken(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetEntitlementToken(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESLicenseRenewalResultEvent_GetExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IESLicenseRenewalResultEvent.VTable, @ptrCast(self.vtable)).GetExpiryDate(@as(*const IESLicenseRenewalResultEvent, @ptrCast(self)), pqwExpiryDate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESFileExpiryDateEvent_Value = Guid.initString("ba9edcb6-4d36-4cfe-8c56-87a6b0ca48e1");
pub const IID_IESFileExpiryDateEvent = &IID_IESFileExpiryDateEvent_Value;
pub const IESFileExpiryDateEvent = extern struct {
    pub const VTable = extern struct {
        base: IESEvent.VTable,
        GetTunerId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                pguidTunerId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                pguidTunerId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpiryDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFinalExpiryDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                pqwExpiryDate: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxRenewalCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                dwMaxRenewalCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                dwMaxRenewalCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEntitlementTokenPresent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                pfEntTokenPresent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                pfEntTokenPresent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DoesExpireAfterFirstUse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESFileExpiryDateEvent,
                pfExpireAfterFirstUse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESFileExpiryDateEvent,
                pfExpireAfterFirstUse: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IESEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetTunerId(self: *const T, pguidTunerId: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetTunerId(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pguidTunerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetExpiryDate(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pqwExpiryDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetFinalExpiryDate(self: *const T, pqwExpiryDate: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetFinalExpiryDate(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pqwExpiryDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_GetMaxRenewalCount(self: *const T, dwMaxRenewalCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).GetMaxRenewalCount(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), dwMaxRenewalCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_IsEntitlementTokenPresent(self: *const T, pfEntTokenPresent: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).IsEntitlementTokenPresent(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pfEntTokenPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESFileExpiryDateEvent_DoesExpireAfterFirstUse(self: *const T, pfExpireAfterFirstUse: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IESFileExpiryDateEvent.VTable, @ptrCast(self.vtable)).DoesExpireAfterFirstUse(@as(*const IESFileExpiryDateEvent, @ptrCast(self)), pfExpireAfterFirstUse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventService_Value = Guid.initString("ed89a619-4c06-4b2f-99eb-c7669b13047c");
pub const IID_IESEventService = &IID_IESEventService_Value;
pub const IESEventService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireESEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventService,
                pESEvent: ?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventService,
                pESEvent: ?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventService_FireESEvent(self: *const T, pESEvent: ?*IESEvent) callconv(.Inline) HRESULT {
            return @as(*const IESEventService.VTable, @ptrCast(self.vtable)).FireESEvent(@as(*const IESEventService, @ptrCast(self)), pESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEventServiceConfiguration_Value = Guid.initString("33b9daae-9309-491d-a051-bcad2a70cd66");
pub const IID_IESEventServiceConfiguration = &IID_IESEventServiceConfiguration_Value;
pub const IESEventServiceConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
                pEventService: ?*IESEventService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
                pEventService: ?*IESEventService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
                pESEvents: ?*IESEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
                pESEvents: ?*IESEvents,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
                pGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
                pGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEventServiceConfiguration,
                pGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEventServiceConfiguration,
                pGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetParent(self: *const T, pEventService: ?*IESEventService) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetParent(@as(*const IESEventServiceConfiguration, @ptrCast(self)), pEventService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveParent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveParent(@as(*const IESEventServiceConfiguration, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetOwner(self: *const T, pESEvents: ?*IESEvents) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetOwner(@as(*const IESEventServiceConfiguration, @ptrCast(self)), pESEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveOwner(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveOwner(@as(*const IESEventServiceConfiguration, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_SetGraph(self: *const T, pGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).SetGraph(@as(*const IESEventServiceConfiguration, @ptrCast(self)), pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEventServiceConfiguration_RemoveGraph(self: *const T, pGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @as(*const IESEventServiceConfiguration.VTable, @ptrCast(self.vtable)).RemoveGraph(@as(*const IESEventServiceConfiguration, @ptrCast(self)), pGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterTuner_Value = Guid.initString("359b3901-572c-4854-bb49-cdef66606a25");
pub const IID_IRegisterTuner = &IID_IRegisterTuner_Value;
pub const IRegisterTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisterTuner,
                pTuner: ?*ITuner,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisterTuner,
                pTuner: ?*ITuner,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unregister: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisterTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisterTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterTuner_Register(self: *const T, pTuner: ?*ITuner, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IRegisterTuner.VTable, @ptrCast(self.vtable)).Register(@as(*const IRegisterTuner, @ptrCast(self)), pTuner, pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterTuner_Unregister(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRegisterTuner.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IRegisterTuner, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDAComparable_Value = Guid.initString("b34505e0-2f0e-497b-80bc-d43f3b24ed7f");
pub const IID_IBDAComparable = &IID_IBDAComparable_Value;
pub const IBDAComparable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareExact: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                CompareTo: ?*IDispatch,
                Result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                CompareTo: ?*IDispatch,
                Result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareEquivalent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                CompareTo: ?*IDispatch,
                dwFlags: u32,
                Result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                CompareTo: ?*IDispatch,
                dwFlags: u32,
                Result: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HashExact: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HashExactIncremental: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                PartialResult: i64,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                PartialResult: i64,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HashEquivalent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                dwFlags: u32,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                dwFlags: u32,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HashEquivalentIncremental: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDAComparable,
                PartialResult: i64,
                dwFlags: u32,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDAComparable,
                PartialResult: i64,
                dwFlags: u32,
                Result: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_CompareExact(self: *const T, CompareTo: ?*IDispatch, Result: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).CompareExact(@as(*const IBDAComparable, @ptrCast(self)), CompareTo, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_CompareEquivalent(self: *const T, CompareTo: ?*IDispatch, dwFlags: u32, Result: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).CompareEquivalent(@as(*const IBDAComparable, @ptrCast(self)), CompareTo, dwFlags, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashExact(self: *const T, Result: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashExact(@as(*const IBDAComparable, @ptrCast(self)), Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashExactIncremental(self: *const T, PartialResult: i64, Result: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashExactIncremental(@as(*const IBDAComparable, @ptrCast(self)), PartialResult, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashEquivalent(self: *const T, dwFlags: u32, Result: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashEquivalent(@as(*const IBDAComparable, @ptrCast(self)), dwFlags, Result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDAComparable_HashEquivalentIncremental(self: *const T, PartialResult: i64, dwFlags: u32, Result: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IBDAComparable.VTable, @ptrCast(self.vtable)).HashEquivalentIncremental(@as(*const IBDAComparable, @ptrCast(self)), PartialResult, dwFlags, Result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXml_Value = Guid.initString("0754cd31-8d15-47a9-8215-d20064157244");
pub const IID_IPersistTuneXml = &IID_IPersistTuneXml_Value;
pub const IPersistTuneXml = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistTuneXml,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistTuneXml,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistTuneXml,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistTuneXml,
                varValue: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistTuneXml,
                pvarFragment: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistTuneXml,
                pvarFragment: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistTuneXml, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_Load(self: *const T, varValue: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistTuneXml, @ptrCast(self)), varValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXml_Save(self: *const T, pvarFragment: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IPersistTuneXml.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistTuneXml, @ptrCast(self)), pvarFragment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility_Value = Guid.initString("990237ae-ac11-4614-be8f-dd217a4cb4cb");
pub const IID_IPersistTuneXmlUtility = &IID_IPersistTuneXmlUtility_Value;
pub const IPersistTuneXmlUtility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Deserialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistTuneXmlUtility,
                varValue: VARIANT,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistTuneXmlUtility,
                varValue: VARIANT,
                ppObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXmlUtility_Deserialize(self: *const T, varValue: VARIANT, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPersistTuneXmlUtility.VTable, @ptrCast(self.vtable)).Deserialize(@as(*const IPersistTuneXmlUtility, @ptrCast(self)), varValue, ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPersistTuneXmlUtility2_Value = Guid.initString("992e165f-ea24-4b2f-9a1d-009d92120451");
pub const IID_IPersistTuneXmlUtility2 = &IID_IPersistTuneXmlUtility2_Value;
pub const IPersistTuneXmlUtility2 = extern struct {
    pub const VTable = extern struct {
        base: IPersistTuneXmlUtility.VTable,
        Serialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistTuneXmlUtility2,
                piTuneRequest: ?*ITuneRequest,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistTuneXmlUtility2,
                piTuneRequest: ?*ITuneRequest,
                pString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistTuneXmlUtility.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistTuneXmlUtility2_Serialize(self: *const T, piTuneRequest: ?*ITuneRequest, pString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IPersistTuneXmlUtility2.VTable, @ptrCast(self.vtable)).Serialize(@as(*const IPersistTuneXmlUtility2, @ptrCast(self)), piTuneRequest, pString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDACreateTuneRequestEx_Value = Guid.initString("c0a4a1d4-2b3c-491a-ba22-499fbadd4d12");
pub const IID_IBDACreateTuneRequestEx = &IID_IBDACreateTuneRequestEx_Value;
pub const IBDACreateTuneRequestEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTuneRequestEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDACreateTuneRequestEx,
                TuneRequestIID: ?*const Guid,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDACreateTuneRequestEx,
                TuneRequestIID: ?*const Guid,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDACreateTuneRequestEx_CreateTuneRequestEx(self: *const T, TuneRequestIID: ?*const Guid, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const IBDACreateTuneRequestEx.VTable, @ptrCast(self.vtable)).CreateTuneRequestEx(@as(*const IBDACreateTuneRequestEx, @ptrCast(self)), TuneRequestIID, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SystemTuningSpaces_Value = Guid.initString("d02aac50-027e-11d3-9d8e-00c04f72d980");
pub const CLSID_SystemTuningSpaces = &CLSID_SystemTuningSpaces_Value;

const CLSID_TuningSpace_Value = Guid.initString("5ffdc5e6-b83a-4b55-b6e8-c69e765fe9db");
pub const CLSID_TuningSpace = &CLSID_TuningSpace_Value;

const CLSID_ChannelIDTuningSpace_Value = Guid.initString("cc829a2f-3365-463f-af13-81dbb6f3a555");
pub const CLSID_ChannelIDTuningSpace = &CLSID_ChannelIDTuningSpace_Value;

const CLSID_ATSCTuningSpace_Value = Guid.initString("a2e30750-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_ATSCTuningSpace = &CLSID_ATSCTuningSpace_Value;

const CLSID_DigitalCableTuningSpace_Value = Guid.initString("d9bb4cee-b87a-47f1-ac92-b08d9c7813fc");
pub const CLSID_DigitalCableTuningSpace = &CLSID_DigitalCableTuningSpace_Value;

const CLSID_AnalogRadioTuningSpace_Value = Guid.initString("8a674b4c-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogRadioTuningSpace = &CLSID_AnalogRadioTuningSpace_Value;

const CLSID_AuxInTuningSpace_Value = Guid.initString("f9769a06-7aca-4e39-9cfb-97bb35f0e77e");
pub const CLSID_AuxInTuningSpace = &CLSID_AuxInTuningSpace_Value;

const CLSID_AnalogTVTuningSpace_Value = Guid.initString("8a674b4d-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_AnalogTVTuningSpace = &CLSID_AnalogTVTuningSpace_Value;

const CLSID_DVBTuningSpace_Value = Guid.initString("c6b14b32-76aa-4a86-a7ac-5c79aaf58da7");
pub const CLSID_DVBTuningSpace = &CLSID_DVBTuningSpace_Value;

const CLSID_DVBSTuningSpace_Value = Guid.initString("b64016f3-c9a2-4066-96f0-bd9563314726");
pub const CLSID_DVBSTuningSpace = &CLSID_DVBSTuningSpace_Value;

const CLSID_ComponentTypes_Value = Guid.initString("a1a2b1c4-0e3a-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentTypes = &CLSID_ComponentTypes_Value;

const CLSID_ComponentType_Value = Guid.initString("823535a0-0318-11d3-9d8e-00c04f72d980");
pub const CLSID_ComponentType = &CLSID_ComponentType_Value;

const CLSID_LanguageComponentType_Value = Guid.initString("1be49f30-0e1b-11d3-9d8e-00c04f72d980");
pub const CLSID_LanguageComponentType = &CLSID_LanguageComponentType_Value;

const CLSID_MPEG2ComponentType_Value = Guid.initString("418008f3-cf67-4668-9628-10dc52be1d08");
pub const CLSID_MPEG2ComponentType = &CLSID_MPEG2ComponentType_Value;

const CLSID_ATSCComponentType_Value = Guid.initString("a8dcf3d5-0780-4ef4-8a83-2cffaacb8ace");
pub const CLSID_ATSCComponentType = &CLSID_ATSCComponentType_Value;

const CLSID_Components_Value = Guid.initString("809b6661-94c4-49e6-b6ec-3f0f862215aa");
pub const CLSID_Components = &CLSID_Components_Value;

const CLSID_Component_Value = Guid.initString("59dc47a8-116c-11d3-9d8e-00c04f72d980");
pub const CLSID_Component = &CLSID_Component_Value;

const CLSID_MPEG2Component_Value = Guid.initString("055cb2d7-2969-45cd-914b-76890722f112");
pub const CLSID_MPEG2Component = &CLSID_MPEG2Component_Value;

const CLSID_AnalogAudioComponentType_Value = Guid.initString("28ab0005-e845-4ffa-aa9b-f4665236141c");
pub const CLSID_AnalogAudioComponentType = &CLSID_AnalogAudioComponentType_Value;

const CLSID_TuneRequest_Value = Guid.initString("b46e0d38-ab35-4a06-a137-70576b01b39f");
pub const CLSID_TuneRequest = &CLSID_TuneRequest_Value;

const CLSID_ChannelIDTuneRequest_Value = Guid.initString("3a9428a7-31a4-45e9-9efb-e055bf7bb3db");
pub const CLSID_ChannelIDTuneRequest = &CLSID_ChannelIDTuneRequest_Value;

const CLSID_ChannelTuneRequest_Value = Guid.initString("0369b4e5-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ChannelTuneRequest = &CLSID_ChannelTuneRequest_Value;

const CLSID_ATSCChannelTuneRequest_Value = Guid.initString("0369b4e6-45b6-11d3-b650-00c04f79498e");
pub const CLSID_ATSCChannelTuneRequest = &CLSID_ATSCChannelTuneRequest_Value;

const CLSID_DigitalCableTuneRequest_Value = Guid.initString("26ec0b63-aa90-458a-8df4-5659f2c8a18a");
pub const CLSID_DigitalCableTuneRequest = &CLSID_DigitalCableTuneRequest_Value;

const CLSID_MPEG2TuneRequest_Value = Guid.initString("0955ac62-bf2e-4cba-a2b9-a63f772d46cf");
pub const CLSID_MPEG2TuneRequest = &CLSID_MPEG2TuneRequest_Value;

const CLSID_MPEG2TuneRequestFactory_Value = Guid.initString("2c63e4eb-4cea-41b8-919c-e947ea19a77c");
pub const CLSID_MPEG2TuneRequestFactory = &CLSID_MPEG2TuneRequestFactory_Value;

const CLSID_Locator_Value = Guid.initString("0888c883-ac4f-4943-b516-2c38d9b34562");
pub const CLSID_Locator = &CLSID_Locator_Value;

const CLSID_DigitalLocator_Value = Guid.initString("6e50cc0d-c19b-4bf6-810b-5bd60761f5cc");
pub const CLSID_DigitalLocator = &CLSID_DigitalLocator_Value;

const CLSID_AnalogLocator_Value = Guid.initString("49638b91-48ab-48b7-a47a-7d0e75a08ede");
pub const CLSID_AnalogLocator = &CLSID_AnalogLocator_Value;

const CLSID_ATSCLocator_Value = Guid.initString("8872ff1b-98fa-4d7a-8d93-c9f1055f85bb");
pub const CLSID_ATSCLocator = &CLSID_ATSCLocator_Value;

const CLSID_DigitalCableLocator_Value = Guid.initString("03c06416-d127-407a-ab4c-fdd279abbe5d");
pub const CLSID_DigitalCableLocator = &CLSID_DigitalCableLocator_Value;

const CLSID_DVBTLocator_Value = Guid.initString("9cd64701-bdf3-4d14-8e03-f12983d86664");
pub const CLSID_DVBTLocator = &CLSID_DVBTLocator_Value;

const CLSID_DVBTLocator2_Value = Guid.initString("efe3fa02-45d7-4920-be96-53fa7f35b0e6");
pub const CLSID_DVBTLocator2 = &CLSID_DVBTLocator2_Value;

const CLSID_DVBSLocator_Value = Guid.initString("1df7d126-4050-47f0-a7cf-4c4ca9241333");
pub const CLSID_DVBSLocator = &CLSID_DVBSLocator_Value;

const CLSID_DVBCLocator_Value = Guid.initString("c531d9fd-9685-4028-8b68-6e1232079f1e");
pub const CLSID_DVBCLocator = &CLSID_DVBCLocator_Value;

const CLSID_ISDBSLocator_Value = Guid.initString("6504afed-a629-455c-a7f1-04964dea5cc4");
pub const CLSID_ISDBSLocator = &CLSID_ISDBSLocator_Value;

const CLSID_DVBTuneRequest_Value = Guid.initString("15d6504a-5494-499c-886c-973c9e53b9f1");
pub const CLSID_DVBTuneRequest = &CLSID_DVBTuneRequest_Value;

const CLSID_CreatePropBagOnRegKey_Value = Guid.initString("8a674b49-1f63-11d3-b64c-00c04f79498e");
pub const CLSID_CreatePropBagOnRegKey = &CLSID_CreatePropBagOnRegKey_Value;

const CLSID_BroadcastEventService_Value = Guid.initString("0b3ffb92-0919-4934-9d5b-619c719d0202");
pub const CLSID_BroadcastEventService = &CLSID_BroadcastEventService_Value;

const CLSID_TunerMarshaler_Value = Guid.initString("6438570b-0c08-4a25-9504-8012bb4d50cf");
pub const CLSID_TunerMarshaler = &CLSID_TunerMarshaler_Value;

const CLSID_PersistTuneXmlUtility_Value = Guid.initString("e77026b0-b97f-4cbb-b7fb-f4f03ad69f11");
pub const CLSID_PersistTuneXmlUtility = &CLSID_PersistTuneXmlUtility_Value;

const CLSID_ESEventService_Value = Guid.initString("c20447fc-ec60-475e-813f-d2b0a6decefe");
pub const CLSID_ESEventService = &CLSID_ESEventService_Value;

const CLSID_ESEventFactory_Value = Guid.initString("8e8a07da-71f8-40c1-a929-5e3a868ac2c6");
pub const CLSID_ESEventFactory = &CLSID_ESEventFactory_Value;

pub const EnTvRat_System = enum(i32) {
    MPAA = 0,
    US_TV = 1,
    Canadian_English = 2,
    Canadian_French = 3,
    Reserved4 = 4,
    System5 = 5,
    System6 = 6,
    Reserved7 = 7,
    PBDA = 8,
    AgeBased = 9,
    TvRat_kSystems = 10,
    TvRat_SystemDontKnow = 255,
};
pub const MPAA = EnTvRat_System.MPAA;
pub const US_TV = EnTvRat_System.US_TV;
pub const Canadian_English = EnTvRat_System.Canadian_English;
pub const Canadian_French = EnTvRat_System.Canadian_French;
pub const Reserved4 = EnTvRat_System.Reserved4;
pub const System5 = EnTvRat_System.System5;
pub const System6 = EnTvRat_System.System6;
pub const Reserved7 = EnTvRat_System.Reserved7;
pub const PBDA = EnTvRat_System.PBDA;
pub const AgeBased = EnTvRat_System.AgeBased;
pub const TvRat_kSystems = EnTvRat_System.TvRat_kSystems;
pub const TvRat_SystemDontKnow = EnTvRat_System.TvRat_SystemDontKnow;

pub const EnTvRat_GenericLevel = enum(i32) {
    @"0" = 0,
    @"1" = 1,
    @"2" = 2,
    @"3" = 3,
    @"4" = 4,
    @"5" = 5,
    @"6" = 6,
    @"7" = 7,
    @"8" = 8,
    @"9" = 9,
    @"10" = 10,
    @"11" = 11,
    @"12" = 12,
    @"13" = 13,
    @"14" = 14,
    @"15" = 15,
    @"16" = 16,
    @"17" = 17,
    @"18" = 18,
    @"19" = 19,
    @"20" = 20,
    @"21" = 21,
    kLevels = 22,
    Unblock = -1,
    LevelDontKnow = 255,
};
pub const TvRat_0 = EnTvRat_GenericLevel.@"0";
pub const TvRat_1 = EnTvRat_GenericLevel.@"1";
pub const TvRat_2 = EnTvRat_GenericLevel.@"2";
pub const TvRat_3 = EnTvRat_GenericLevel.@"3";
pub const TvRat_4 = EnTvRat_GenericLevel.@"4";
pub const TvRat_5 = EnTvRat_GenericLevel.@"5";
pub const TvRat_6 = EnTvRat_GenericLevel.@"6";
pub const TvRat_7 = EnTvRat_GenericLevel.@"7";
pub const TvRat_8 = EnTvRat_GenericLevel.@"8";
pub const TvRat_9 = EnTvRat_GenericLevel.@"9";
pub const TvRat_10 = EnTvRat_GenericLevel.@"10";
pub const TvRat_11 = EnTvRat_GenericLevel.@"11";
pub const TvRat_12 = EnTvRat_GenericLevel.@"12";
pub const TvRat_13 = EnTvRat_GenericLevel.@"13";
pub const TvRat_14 = EnTvRat_GenericLevel.@"14";
pub const TvRat_15 = EnTvRat_GenericLevel.@"15";
pub const TvRat_16 = EnTvRat_GenericLevel.@"16";
pub const TvRat_17 = EnTvRat_GenericLevel.@"17";
pub const TvRat_18 = EnTvRat_GenericLevel.@"18";
pub const TvRat_19 = EnTvRat_GenericLevel.@"19";
pub const TvRat_20 = EnTvRat_GenericLevel.@"20";
pub const TvRat_21 = EnTvRat_GenericLevel.@"21";
pub const TvRat_kLevels = EnTvRat_GenericLevel.kLevels;
pub const TvRat_Unblock = EnTvRat_GenericLevel.Unblock;
pub const TvRat_LevelDontKnow = EnTvRat_GenericLevel.LevelDontKnow;

pub const EnTvRat_MPAA = enum(i32) {
    NotApplicable = 0,
    G = 1,
    PG = 2,
    PG13 = 3,
    R = 4,
    NC17 = 5,
    X = 6,
    NotRated = 7,
};
pub const MPAA_NotApplicable = EnTvRat_MPAA.NotApplicable;
pub const MPAA_G = EnTvRat_MPAA.G;
pub const MPAA_PG = EnTvRat_MPAA.PG;
pub const MPAA_PG13 = EnTvRat_MPAA.PG13;
pub const MPAA_R = EnTvRat_MPAA.R;
pub const MPAA_NC17 = EnTvRat_MPAA.NC17;
pub const MPAA_X = EnTvRat_MPAA.X;
pub const MPAA_NotRated = EnTvRat_MPAA.NotRated;

pub const EnTvRat_US_TV = enum(i32) {
    None = 0,
    Y = 1,
    Y7 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    MA = 6,
    None7 = 7,
};
pub const US_TV_None = EnTvRat_US_TV.None;
pub const US_TV_Y = EnTvRat_US_TV.Y;
pub const US_TV_Y7 = EnTvRat_US_TV.Y7;
pub const US_TV_G = EnTvRat_US_TV.G;
pub const US_TV_PG = EnTvRat_US_TV.PG;
pub const US_TV_14 = EnTvRat_US_TV.@"14";
pub const US_TV_MA = EnTvRat_US_TV.MA;
pub const US_TV_None7 = EnTvRat_US_TV.None7;

pub const EnTvRat_CAE_TV = enum(i32) {
    Exempt = 0,
    C = 1,
    C8 = 2,
    G = 3,
    PG = 4,
    @"14" = 5,
    @"18" = 6,
    Reserved = 7,
};
pub const CAE_TV_Exempt = EnTvRat_CAE_TV.Exempt;
pub const CAE_TV_C = EnTvRat_CAE_TV.C;
pub const CAE_TV_C8 = EnTvRat_CAE_TV.C8;
pub const CAE_TV_G = EnTvRat_CAE_TV.G;
pub const CAE_TV_PG = EnTvRat_CAE_TV.PG;
pub const CAE_TV_14 = EnTvRat_CAE_TV.@"14";
pub const CAE_TV_18 = EnTvRat_CAE_TV.@"18";
pub const CAE_TV_Reserved = EnTvRat_CAE_TV.Reserved;

pub const EnTvRat_CAF_TV = enum(i32) {
    Exempt = 0,
    G = 1,
    @"8" = 2,
    @"13" = 3,
    @"16" = 4,
    @"18" = 5,
    Reserved6 = 6,
    Reserved = 7,
};
pub const CAF_TV_Exempt = EnTvRat_CAF_TV.Exempt;
pub const CAF_TV_G = EnTvRat_CAF_TV.G;
pub const CAF_TV_8 = EnTvRat_CAF_TV.@"8";
pub const CAF_TV_13 = EnTvRat_CAF_TV.@"13";
pub const CAF_TV_16 = EnTvRat_CAF_TV.@"16";
pub const CAF_TV_18 = EnTvRat_CAF_TV.@"18";
pub const CAF_TV_Reserved6 = EnTvRat_CAF_TV.Reserved6;
pub const CAF_TV_Reserved = EnTvRat_CAF_TV.Reserved;

pub const BfEnTvRat_GenericAttributes = enum(i32) {
    AttrNone = 0,
    IsBlocked = 1,
    IsAttr_1 = 2,
    IsAttr_2 = 4,
    IsAttr_3 = 8,
    IsAttr_4 = 16,
    IsAttr_5 = 32,
    IsAttr_6 = 64,
    IsAttr_7 = 128,
    ValidAttrSubmask = 255,
};
pub const BfAttrNone = BfEnTvRat_GenericAttributes.AttrNone;
pub const BfIsBlocked = BfEnTvRat_GenericAttributes.IsBlocked;
pub const BfIsAttr_1 = BfEnTvRat_GenericAttributes.IsAttr_1;
pub const BfIsAttr_2 = BfEnTvRat_GenericAttributes.IsAttr_2;
pub const BfIsAttr_3 = BfEnTvRat_GenericAttributes.IsAttr_3;
pub const BfIsAttr_4 = BfEnTvRat_GenericAttributes.IsAttr_4;
pub const BfIsAttr_5 = BfEnTvRat_GenericAttributes.IsAttr_5;
pub const BfIsAttr_6 = BfEnTvRat_GenericAttributes.IsAttr_6;
pub const BfIsAttr_7 = BfEnTvRat_GenericAttributes.IsAttr_7;
pub const BfValidAttrSubmask = BfEnTvRat_GenericAttributes.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_US_TV = enum(i32) {
    IsBlocked = 1,
    IsViolent = 2,
    IsSexualSituation = 4,
    IsAdultLanguage = 8,
    IsSexuallySuggestiveDialog = 16,
    ValidAttrSubmask = 31,
};
pub const US_TV_IsBlocked = BfEnTvRat_Attributes_US_TV.IsBlocked;
pub const US_TV_IsViolent = BfEnTvRat_Attributes_US_TV.IsViolent;
pub const US_TV_IsSexualSituation = BfEnTvRat_Attributes_US_TV.IsSexualSituation;
pub const US_TV_IsAdultLanguage = BfEnTvRat_Attributes_US_TV.IsAdultLanguage;
pub const US_TV_IsSexuallySuggestiveDialog = BfEnTvRat_Attributes_US_TV.IsSexuallySuggestiveDialog;
pub const US_TV_ValidAttrSubmask = BfEnTvRat_Attributes_US_TV.ValidAttrSubmask;

pub const BfEnTvRat_Attributes_MPAA = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const MPAA_IsBlocked = BfEnTvRat_Attributes_MPAA.IsBlocked;
pub const MPAA_ValidAttrSubmask = BfEnTvRat_Attributes_MPAA.IsBlocked;

pub const BfEnTvRat_Attributes_CAE_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAE_IsBlocked = BfEnTvRat_Attributes_CAE_TV.IsBlocked;
pub const CAE_ValidAttrSubmask = BfEnTvRat_Attributes_CAE_TV.IsBlocked;

pub const BfEnTvRat_Attributes_CAF_TV = enum(i32) {
    IsBlocked = 1,
    // ValidAttrSubmask = 1, this enum value conflicts with IsBlocked
};
pub const CAF_IsBlocked = BfEnTvRat_Attributes_CAF_TV.IsBlocked;
pub const CAF_ValidAttrSubmask = BfEnTvRat_Attributes_CAF_TV.IsBlocked;

pub const FormatNotSupportedEvents = enum(i32) {
    CLEAR = 0,
    NOTSUPPORTED = 1,
};
pub const FORMATNOTSUPPORTED_CLEAR = FormatNotSupportedEvents.CLEAR;
pub const FORMATNOTSUPPORTED_NOTSUPPORTED = FormatNotSupportedEvents.NOTSUPPORTED;

pub const WMDRMProtectionInfo = extern struct {
    wszKID: [25]u16 align(1),
    qwCounter: u64 align(1),
    qwIndex: u64 align(1),
    bOffset: u8 align(1),
};

pub const BadSampleInfo = extern struct {
    hrReason: HRESULT align(1),
};

pub const ProtType = enum(i32) {
    FREE = 1,
    ONCE = 2,
    NEVER = 3,
    NEVER_REALLY = 4,
    NO_MORE = 5,
    FREE_CIT = 6,
    BF = 7,
    CN_RECORDING_STOP = 8,
    FREE_SECURE = 9,
    INVALID = 50,
};
pub const PROT_COPY_FREE = ProtType.FREE;
pub const PROT_COPY_ONCE = ProtType.ONCE;
pub const PROT_COPY_NEVER = ProtType.NEVER;
pub const PROT_COPY_NEVER_REALLY = ProtType.NEVER_REALLY;
pub const PROT_COPY_NO_MORE = ProtType.NO_MORE;
pub const PROT_COPY_FREE_CIT = ProtType.FREE_CIT;
pub const PROT_COPY_BF = ProtType.BF;
pub const PROT_COPY_CN_RECORDING_STOP = ProtType.CN_RECORDING_STOP;
pub const PROT_COPY_FREE_SECURE = ProtType.FREE_SECURE;
pub const PROT_COPY_INVALID = ProtType.INVALID;

pub const EncDecEvents = enum(i32) {
    CPEVENT = 0,
    RECORDING_STATUS = 1,
};
pub const ENCDEC_CPEVENT = EncDecEvents.CPEVENT;
pub const ENCDEC_RECORDING_STATUS = EncDecEvents.RECORDING_STATUS;

pub const CPRecordingStatus = enum(i32) {
    OPPED = 0,
    ARTED = 1,
};
pub const RECORDING_STOPPED = CPRecordingStatus.OPPED;
pub const RECORDING_STARTED = CPRecordingStatus.ARTED;

pub const CPEventBitShift = enum(i32) {
    RATINGS = 0,
    COPP = 1,
    LICENSE = 2,
    ROLLBACK = 3,
    SAC = 4,
    DOWNRES = 5,
    STUBLIB = 6,
    UNTRUSTEDGRAPH = 7,
    PENDING_CERTIFICATE = 8,
    NO_PLAYREADY = 9,
};
pub const CPEVENT_BITSHIFT_RATINGS = CPEventBitShift.RATINGS;
pub const CPEVENT_BITSHIFT_COPP = CPEventBitShift.COPP;
pub const CPEVENT_BITSHIFT_LICENSE = CPEventBitShift.LICENSE;
pub const CPEVENT_BITSHIFT_ROLLBACK = CPEventBitShift.ROLLBACK;
pub const CPEVENT_BITSHIFT_SAC = CPEventBitShift.SAC;
pub const CPEVENT_BITSHIFT_DOWNRES = CPEventBitShift.DOWNRES;
pub const CPEVENT_BITSHIFT_STUBLIB = CPEventBitShift.STUBLIB;
pub const CPEVENT_BITSHIFT_UNTRUSTEDGRAPH = CPEventBitShift.UNTRUSTEDGRAPH;
pub const CPEVENT_BITSHIFT_PENDING_CERTIFICATE = CPEventBitShift.PENDING_CERTIFICATE;
pub const CPEVENT_BITSHIFT_NO_PLAYREADY = CPEventBitShift.NO_PLAYREADY;

pub const CPEvents = enum(i32) {
    NONE = 0,
    RATINGS = 1,
    COPP = 2,
    LICENSE = 3,
    ROLLBACK = 4,
    SAC = 5,
    DOWNRES = 6,
    STUBLIB = 7,
    UNTRUSTEDGRAPH = 8,
    PROTECTWINDOWED = 9,
};
pub const CPEVENT_NONE = CPEvents.NONE;
pub const CPEVENT_RATINGS = CPEvents.RATINGS;
pub const CPEVENT_COPP = CPEvents.COPP;
pub const CPEVENT_LICENSE = CPEvents.LICENSE;
pub const CPEVENT_ROLLBACK = CPEvents.ROLLBACK;
pub const CPEVENT_SAC = CPEvents.SAC;
pub const CPEVENT_DOWNRES = CPEvents.DOWNRES;
pub const CPEVENT_STUBLIB = CPEvents.STUBLIB;
pub const CPEVENT_UNTRUSTEDGRAPH = CPEvents.UNTRUSTEDGRAPH;
pub const CPEVENT_PROTECTWINDOWED = CPEvents.PROTECTWINDOWED;

pub const RevokedComponent = enum(i32) {
    COPP = 0,
    SAC = 1,
    APP_STUB = 2,
    SECURE_PIPELINE = 3,
    MAX_TYPES = 4,
};
pub const REVOKED_COPP = RevokedComponent.COPP;
pub const REVOKED_SAC = RevokedComponent.SAC;
pub const REVOKED_APP_STUB = RevokedComponent.APP_STUB;
pub const REVOKED_SECURE_PIPELINE = RevokedComponent.SECURE_PIPELINE;
pub const REVOKED_MAX_TYPES = RevokedComponent.MAX_TYPES;

pub const EnTag_Mode = enum(i32) {
    Remove = 0,
    Once = 1,
    Repeat = 2,
};
pub const EnTag_Remove = EnTag_Mode.Remove;
pub const EnTag_Once = EnTag_Mode.Once;
pub const EnTag_Repeat = EnTag_Mode.Repeat;

pub const COPPEventBlockReason = enum(i32) {
    Unknown = -1,
    BadDriver = 0,
    NoCardHDCPSupport = 1,
    NoMonitorHDCPSupport = 2,
    BadCertificate = 3,
    InvalidBusProtection = 4,
    AeroGlassOff = 5,
    RogueApp = 6,
    ForbiddenVideo = 7,
    Activate = 8,
    DigitalAudioUnprotected = 9,
};
pub const COPP_Unknown = COPPEventBlockReason.Unknown;
pub const COPP_BadDriver = COPPEventBlockReason.BadDriver;
pub const COPP_NoCardHDCPSupport = COPPEventBlockReason.NoCardHDCPSupport;
pub const COPP_NoMonitorHDCPSupport = COPPEventBlockReason.NoMonitorHDCPSupport;
pub const COPP_BadCertificate = COPPEventBlockReason.BadCertificate;
pub const COPP_InvalidBusProtection = COPPEventBlockReason.InvalidBusProtection;
pub const COPP_AeroGlassOff = COPPEventBlockReason.AeroGlassOff;
pub const COPP_RogueApp = COPPEventBlockReason.RogueApp;
pub const COPP_ForbiddenVideo = COPPEventBlockReason.ForbiddenVideo;
pub const COPP_Activate = COPPEventBlockReason.Activate;
pub const COPP_DigitalAudioUnprotected = COPPEventBlockReason.DigitalAudioUnprotected;

pub const LicenseEventBlockReason = enum(i32) {
    BadLicense = 0,
    NeedIndiv = 1,
    Expired = 2,
    NeedActivation = 3,
    ExtenderBlocked = 4,
};
pub const LIC_BadLicense = LicenseEventBlockReason.BadLicense;
pub const LIC_NeedIndiv = LicenseEventBlockReason.NeedIndiv;
pub const LIC_Expired = LicenseEventBlockReason.Expired;
pub const LIC_NeedActivation = LicenseEventBlockReason.NeedActivation;
pub const LIC_ExtenderBlocked = LicenseEventBlockReason.ExtenderBlocked;

pub const DownResEventParam = enum(i32) {
    Always = 0,
    InWindowOnly = 1,
    Undefined = 2,
};
pub const DOWNRES_Always = DownResEventParam.Always;
pub const DOWNRES_InWindowOnly = DownResEventParam.InWindowOnly;
pub const DOWNRES_Undefined = DownResEventParam.Undefined;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilterConfig_Value = Guid.initString("c4c4c4d1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterConfig = &IID_IETFilterConfig_Value;
pub const IETFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilterConfig,
                LicenseId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilterConfig,
                LicenseId: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecureChannelObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilterConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilterConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilterConfig_InitLicense(self: *const T, LicenseId: i32) callconv(.Inline) HRESULT {
            return @as(*const IETFilterConfig.VTable, @ptrCast(self.vtable)).InitLicense(@as(*const IETFilterConfig, @ptrCast(self)), LicenseId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilterConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IETFilterConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IETFilterConfig, @ptrCast(self)), ppUnkDRMSecureChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilterConfig_Value = Guid.initString("c4c4c4d2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterConfig = &IID_IDTFilterConfig_Value;
pub const IDTFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilterConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilterConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilterConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDTFilterConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IDTFilterConfig, @ptrCast(self)), ppUnkDRMSecureChannel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecConfig_Value = Guid.initString("c4c4c4d3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecConfig = &IID_IXDSCodecConfig_Value;
pub const IXDSCodecConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSecureChannelObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodecConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodecConfig,
                ppUnkDRMSecureChannel: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPauseBufferTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodecConfig,
                dwPauseBufferTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodecConfig,
                dwPauseBufferTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodecConfig_GetSecureChannelObject(self: *const T, ppUnkDRMSecureChannel: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodecConfig.VTable, @ptrCast(self.vtable)).GetSecureChannelObject(@as(*const IXDSCodecConfig, @ptrCast(self)), ppUnkDRMSecureChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodecConfig_SetPauseBufferTime(self: *const T, dwPauseBufferTime: u32) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodecConfig.VTable, @ptrCast(self.vtable)).SetPauseBufferTime(@as(*const IXDSCodecConfig, @ptrCast(self)), dwPauseBufferTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterLicenseRenewal_Value = Guid.initString("8a78b317-e405-4a43-994a-620d8f5ce25e");
pub const IID_IDTFilterLicenseRenewal = &IID_IDTFilterLicenseRenewal_Value;
pub const IDTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLicenseRenewalData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilterLicenseRenewal,
                ppwszFileName: ?*?PWSTR,
                ppwszExpiredKid: ?*?PWSTR,
                ppwszTunerId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilterLicenseRenewal,
                ppwszFileName: ?*?PWSTR,
                ppwszExpiredKid: ?*?PWSTR,
                ppwszTunerId: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilterLicenseRenewal_GetLicenseRenewalData(self: *const T, ppwszFileName: ?*?PWSTR, ppwszExpiredKid: ?*?PWSTR, ppwszTunerId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IDTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).GetLicenseRenewalData(@as(*const IDTFilterLicenseRenewal, @ptrCast(self)), ppwszFileName, ppwszExpiredKid, ppwszTunerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPTFilterLicenseRenewal_Value = Guid.initString("26d836a5-0c15-44c7-ac59-b0da8728f240");
pub const IID_IPTFilterLicenseRenewal = &IID_IPTFilterLicenseRenewal_Value;
pub const IPTFilterLicenseRenewal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenewLicenses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPTFilterLicenseRenewal,
                wszFileName: ?PWSTR,
                wszExpiredKid: ?PWSTR,
                dwCallersId: u32,
                bHighPriority: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPTFilterLicenseRenewal,
                wszFileName: ?PWSTR,
                wszExpiredKid: ?PWSTR,
                dwCallersId: u32,
                bHighPriority: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelLicenseRenewal: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPTFilterLicenseRenewal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPTFilterLicenseRenewal,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPTFilterLicenseRenewal_RenewLicenses(self: *const T, wszFileName: ?PWSTR, wszExpiredKid: ?PWSTR, dwCallersId: u32, bHighPriority: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IPTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).RenewLicenses(@as(*const IPTFilterLicenseRenewal, @ptrCast(self)), wszFileName, wszExpiredKid, dwCallersId, bHighPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPTFilterLicenseRenewal_CancelLicenseRenewal(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPTFilterLicenseRenewal.VTable, @ptrCast(self.vtable)).CancelLicenseRenewal(@as(*const IPTFilterLicenseRenewal, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMceBurnerControl_Value = Guid.initString("5a86b91a-e71e-46c1-88a9-9bb338710552");
pub const IID_IMceBurnerControl = &IID_IMceBurnerControl_Value;
pub const IMceBurnerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBurnerNoDecryption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMceBurnerControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMceBurnerControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMceBurnerControl_GetBurnerNoDecryption(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMceBurnerControl.VTable, @ptrCast(self.vtable)).GetBurnerNoDecryption(@as(*const IMceBurnerControl, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IETFilter_Value = Guid.initString("c4c4c4b1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilter = &IID_IETFilter_Value;
pub const IETFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IETFilter,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IETFilter,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilter,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilter,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrLicenseExpDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilter,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilter,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRecordingOn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IETFilter,
                fRecState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IETFilter,
                fRecState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_get_EvalRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).get_EvalRatObjOK(@as(*const IETFilter, @ptrCast(self)), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetCurrRating(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetCurrRating(@as(*const IETFilter, @ptrCast(self)), pEnSystem, pEnRating, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IETFilter, @ptrCast(self)), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IETFilter, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IETFilter_SetRecordingOn(self: *const T, fRecState: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IETFilter.VTable, @ptrCast(self.vtable)).SetRecordingOn(@as(*const IETFilter, @ptrCast(self)), fRecState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IETFilterEvents_Value = Guid.initString("c4c4c4c1-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IETFilterEvents = &IID_IETFilterEvents_Value;
pub const IETFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ETFilter_Value = Guid.initString("c4c4c4f1-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_ETFilter = &CLSID_ETFilter_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter_Value = Guid.initString("c4c4c4b2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter = &IID_IDTFilter_Value;
pub const IDTFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EvalRatObjOK: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_BlockedRatingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_BlockedRatingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                lbfAttrs: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                lbfAttrs: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter,
                pfBlockUnRatedShows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter,
                pfBlockUnRatedShows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter,
                fBlockUnRatedShows: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter,
                fBlockUnRatedShows: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRatedDelay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter,
                pmsecsDelayBeforeBlock: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter,
                pmsecsDelayBeforeBlock: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRatedDelay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter,
                msecsDelayBeforeBlock: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter,
                msecsDelayBeforeBlock: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_EvalRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_EvalRatObjOK(@as(*const IDTFilter, @ptrCast(self)), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_GetCurrRating(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).GetCurrRating(@as(*const IDTFilter, @ptrCast(self)), pEnSystem, pEnRating, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockedRatingAttributes(@as(*const IDTFilter, @ptrCast(self)), enSystem, enLevel, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, lbfAttrs: i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockedRatingAttributes(@as(*const IDTFilter, @ptrCast(self)), enSystem, enLevel, lbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockUnRated(self: *const T, pfBlockUnRatedShows: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockUnRated(@as(*const IDTFilter, @ptrCast(self)), pfBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockUnRated(self: *const T, fBlockUnRatedShows: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockUnRated(@as(*const IDTFilter, @ptrCast(self)), fBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_get_BlockUnRatedDelay(self: *const T, pmsecsDelayBeforeBlock: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).get_BlockUnRatedDelay(@as(*const IDTFilter, @ptrCast(self)), pmsecsDelayBeforeBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter_put_BlockUnRatedDelay(self: *const T, msecsDelayBeforeBlock: i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter.VTable, @ptrCast(self.vtable)).put_BlockUnRatedDelay(@as(*const IDTFilter, @ptrCast(self)), msecsDelayBeforeBlock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDTFilter2_Value = Guid.initString("c4c4c4b4-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilter2 = &IID_IDTFilter2_Value;
pub const IDTFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChallengeUrl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDTFilter2,
                pbstrChallengeUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDTFilter2,
                pbstrChallengeUrl: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrLicenseExpDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter2,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter2,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDTFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_get_ChallengeUrl(self: *const T, pbstrChallengeUrl: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).get_ChallengeUrl(@as(*const IDTFilter2, @ptrCast(self)), pbstrChallengeUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IDTFilter2, @ptrCast(self)), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter2_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter2.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IDTFilter2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IDTFilter3_Value = Guid.initString("513998cc-e929-4cdf-9fbd-bad1e0314866");
pub const IID_IDTFilter3 = &IID_IDTFilter3_Value;
pub const IDTFilter3 = extern struct {
    pub const VTable = extern struct {
        base: IDTFilter2.VTable,
        GetProtectionType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter3,
                pProtectionType: ?*ProtType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter3,
                pProtectionType: ?*ProtType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LicenseHasExpirationDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter3,
                pfLicenseHasExpirationDate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter3,
                pfLicenseHasExpirationDate: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRights: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDTFilter3,
                bstrRights: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDTFilter3,
                bstrRights: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDTFilter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_GetProtectionType(self: *const T, pProtectionType: ?*ProtType) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).GetProtectionType(@as(*const IDTFilter3, @ptrCast(self)), pProtectionType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_LicenseHasExpirationDate(self: *const T, pfLicenseHasExpirationDate: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).LicenseHasExpirationDate(@as(*const IDTFilter3, @ptrCast(self)), pfLicenseHasExpirationDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDTFilter3_SetRights(self: *const T, bstrRights: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDTFilter3.VTable, @ptrCast(self.vtable)).SetRights(@as(*const IDTFilter3, @ptrCast(self)), bstrRights);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDTFilterEvents_Value = Guid.initString("c4c4c4c2-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IDTFilterEvents = &IID_IDTFilterEvents_Value;
pub const IDTFilterEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_DTFilter_Value = Guid.initString("c4c4c4f2-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_DTFilter = &CLSID_DTFilter_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSCodec_Value = Guid.initString("c4c4c4b3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodec = &IID_IXDSCodec_Value;
pub const IXDSCodec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_XDSToRatObjOK: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXDSCodec,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXDSCodec,
                pHrCoCreateRetVal: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCSubstreamService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXDSCodec,
                SubstreamMask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXDSCodec,
                SubstreamMask: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCSubstreamService: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IXDSCodec,
                pSubstreamMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IXDSCodec,
                pSubstreamMask: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContentAdvisoryRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodec,
                pRat: ?*i32,
                pPktSeqID: ?*i32,
                pCallSeqID: ?*i32,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodec,
                pRat: ?*i32,
                pPktSeqID: ?*i32,
                pCallSeqID: ?*i32,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXDSPacket: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodec,
                pXDSClassPkt: ?*i32,
                pXDSTypePkt: ?*i32,
                pBstrXDSPkt: ?*?BSTR,
                pPktSeqID: ?*i32,
                pCallSeqID: ?*i32,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodec,
                pXDSClassPkt: ?*i32,
                pXDSTypePkt: ?*i32,
                pBstrXDSPkt: ?*?BSTR,
                pPktSeqID: ?*i32,
                pCallSeqID: ?*i32,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrLicenseExpDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodec,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodec,
                protType: ?*ProtType,
                lpDateTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastErrorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSCodec,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSCodec,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_get_XDSToRatObjOK(self: *const T, pHrCoCreateRetVal: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).get_XDSToRatObjOK(@as(*const IXDSCodec, @ptrCast(self)), pHrCoCreateRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_put_CCSubstreamService(self: *const T, SubstreamMask: i32) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).put_CCSubstreamService(@as(*const IXDSCodec, @ptrCast(self)), SubstreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_get_CCSubstreamService(self: *const T, pSubstreamMask: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).get_CCSubstreamService(@as(*const IXDSCodec, @ptrCast(self)), pSubstreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetContentAdvisoryRating(self: *const T, pRat: ?*i32, pPktSeqID: ?*i32, pCallSeqID: ?*i32, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetContentAdvisoryRating(@as(*const IXDSCodec, @ptrCast(self)), pRat, pPktSeqID, pCallSeqID, pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetXDSPacket(self: *const T, pXDSClassPkt: ?*i32, pXDSTypePkt: ?*i32, pBstrXDSPkt: ?*?BSTR, pPktSeqID: ?*i32, pCallSeqID: ?*i32, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetXDSPacket(@as(*const IXDSCodec, @ptrCast(self)), pXDSClassPkt, pXDSTypePkt, pBstrXDSPkt, pPktSeqID, pCallSeqID, pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetCurrLicenseExpDate(self: *const T, protType: ?*ProtType, lpDateTime: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetCurrLicenseExpDate(@as(*const IXDSCodec, @ptrCast(self)), protType, lpDateTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSCodec_GetLastErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXDSCodec.VTable, @ptrCast(self.vtable)).GetLastErrorCode(@as(*const IXDSCodec, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXDSCodecEvents_Value = Guid.initString("c4c4c4c3-0049-4e2b-98fb-9537f6ce516d");
pub const IID_IXDSCodecEvents = &IID_IXDSCodecEvents_Value;
pub const IXDSCodecEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_XDSCodec_Value = Guid.initString("c4c4c4f3-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_XDSCodec = &CLSID_XDSCodec_Value;

const CLSID_CXDSData_Value = Guid.initString("c4c4c4f4-0049-4e2b-98fb-9537f6ce516d");
pub const CLSID_CXDSData = &CLSID_CXDSData_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IXDSToRat_Value = Guid.initString("c5c5c5b0-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IXDSToRat = &IID_IXDSToRat_Value;
pub const IXDSToRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSToRat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSToRat,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParseXDSBytePair: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IXDSToRat,
                byte1: u8,
                byte2: u8,
                pEnSystem: ?*EnTvRat_System,
                pEnLevel: ?*EnTvRat_GenericLevel,
                plBfEnAttributes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IXDSToRat,
                byte1: u8,
                byte2: u8,
                pEnSystem: ?*EnTvRat_System,
                pEnLevel: ?*EnTvRat_GenericLevel,
                plBfEnAttributes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSToRat_Init(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IXDSToRat.VTable, @ptrCast(self.vtable)).Init(@as(*const IXDSToRat, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXDSToRat_ParseXDSBytePair(self: *const T, byte1: u8, byte2: u8, pEnSystem: ?*EnTvRat_System, pEnLevel: ?*EnTvRat_GenericLevel, plBfEnAttributes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IXDSToRat.VTable, @ptrCast(self.vtable)).ParseXDSBytePair(@as(*const IXDSToRat, @ptrCast(self)), byte1, byte2, pEnSystem, pEnLevel, plBfEnAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEvalRat_Value = Guid.initString("c5c5c5b1-3abc-11d6-b25b-00c04fa0c026");
pub const IID_IEvalRat = &IID_IEvalRat_Value;
pub const IEvalRat = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_BlockedRatingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEvalRat,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                plbfAttrs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEvalRat,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                plbfAttrs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_BlockedRatingAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEvalRat,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                lbfAttrs: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEvalRat,
                enSystem: EnTvRat_System,
                enLevel: EnTvRat_GenericLevel,
                lbfAttrs: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BlockUnRated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IEvalRat,
                pfBlockUnRatedShows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IEvalRat,
                pfBlockUnRatedShows: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnRated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IEvalRat,
                fBlockUnRatedShows: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IEvalRat,
                fBlockUnRatedShows: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MostRestrictiveRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEvalRat,
                enSystem1: EnTvRat_System,
                enEnLevel1: EnTvRat_GenericLevel,
                lbfEnAttr1: i32,
                enSystem2: EnTvRat_System,
                enEnLevel2: EnTvRat_GenericLevel,
                lbfEnAttr2: i32,
                penSystem: ?*EnTvRat_System,
                penEnLevel: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEvalRat,
                enSystem1: EnTvRat_System,
                enEnLevel1: EnTvRat_GenericLevel,
                lbfEnAttr1: i32,
                enSystem2: EnTvRat_System,
                enEnLevel2: EnTvRat_GenericLevel,
                lbfEnAttr2: i32,
                penSystem: ?*EnTvRat_System,
                penEnLevel: ?*EnTvRat_GenericLevel,
                plbfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TestRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEvalRat,
                enShowSystem: EnTvRat_System,
                enShowLevel: EnTvRat_GenericLevel,
                lbfEnShowAttributes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEvalRat,
                enShowSystem: EnTvRat_System,
                enShowLevel: EnTvRat_GenericLevel,
                lbfEnShowAttributes: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_get_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, plbfAttrs: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).get_BlockedRatingAttributes(@as(*const IEvalRat, @ptrCast(self)), enSystem, enLevel, plbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_put_BlockedRatingAttributes(self: *const T, enSystem: EnTvRat_System, enLevel: EnTvRat_GenericLevel, lbfAttrs: i32) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).put_BlockedRatingAttributes(@as(*const IEvalRat, @ptrCast(self)), enSystem, enLevel, lbfAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_get_BlockUnRated(self: *const T, pfBlockUnRatedShows: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).get_BlockUnRated(@as(*const IEvalRat, @ptrCast(self)), pfBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_put_BlockUnRated(self: *const T, fBlockUnRatedShows: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).put_BlockUnRated(@as(*const IEvalRat, @ptrCast(self)), fBlockUnRatedShows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_MostRestrictiveRating(self: *const T, enSystem1: EnTvRat_System, enEnLevel1: EnTvRat_GenericLevel, lbfEnAttr1: i32, enSystem2: EnTvRat_System, enEnLevel2: EnTvRat_GenericLevel, lbfEnAttr2: i32, penSystem: ?*EnTvRat_System, penEnLevel: ?*EnTvRat_GenericLevel, plbfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).MostRestrictiveRating(@as(*const IEvalRat, @ptrCast(self)), enSystem1, enEnLevel1, lbfEnAttr1, enSystem2, enEnLevel2, lbfEnAttr2, penSystem, penEnLevel, plbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEvalRat_TestRating(self: *const T, enShowSystem: EnTvRat_System, enShowLevel: EnTvRat_GenericLevel, lbfEnShowAttributes: i32) callconv(.Inline) HRESULT {
            return @as(*const IEvalRat.VTable, @ptrCast(self.vtable)).TestRating(@as(*const IEvalRat, @ptrCast(self)), enShowSystem, enShowLevel, lbfEnShowAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_XDSToRat_Value = Guid.initString("c5c5c5f0-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_XDSToRat = &CLSID_XDSToRat_Value;

const CLSID_EvalRat_Value = Guid.initString("c5c5c5f1-3abc-11d6-b25b-00c04fa0c026");
pub const CLSID_EvalRat = &CLSID_EvalRat_Value;

pub const SegDispidList = enum(i32) {
    dispidName = 0,
    dispidStatus = 1,
    dispidDevImageSourceWidth = 2,
    dispidDevImageSourceHeight = 3,
    dispidDevCountryCode = 4,
    dispidDevOverScan = 5,
    dispidSegment = 6,
    dispidDevVolume = 7,
    dispidDevBalance = 8,
    dispidDevPower = 9,
    dispidTuneChan = 10,
    dispidDevVideoSubchannel = 11,
    dispidDevAudioSubchannel = 12,
    dispidChannelAvailable = 13,
    dispidDevVideoFrequency = 14,
    dispidDevAudioFrequency = 15,
    dispidCount = 16,
    dispidDevFileName = 17,
    dispidVisible = 18,
    dispidOwner = 19,
    dispidMessageDrain = 20,
    dispidViewable = 21,
    dispidDevView = 22,
    dispidKSCat = 23,
    dispidCLSID = 24,
    dispid_KSCat = 25,
    dispid_CLSID = 26,
    dispidTune = 27,
    dispidTS = 28,
    dispidDevSAP = 29,
    dispidClip = 30,
    dispidRequestedClipRect = 31,
    dispidClippedSourceRect = 32,
    dispidAvailableSourceRect = 33,
    dispidMediaPosition = 34,
    dispidDevRun = 35,
    dispidDevPause = 36,
    dispidDevStop = 37,
    dispidCCEnable = 38,
    dispidDevStep = 39,
    dispidDevCanStep = 40,
    dispidSourceSize = 41,
    dispid_playtitle = 42,
    dispid_playchapterintitle = 43,
    dispid_playchapter = 44,
    dispid_playchaptersautostop = 45,
    dispid_playattime = 46,
    dispid_playattimeintitle = 47,
    dispid_playperiodintitleautostop = 48,
    dispid_replaychapter = 49,
    dispid_playprevchapter = 50,
    dispid_playnextchapter = 51,
    dispid_playforwards = 52,
    dispid_playbackwards = 53,
    dispid_stilloff = 54,
    dispid_audiolanguage = 55,
    dispid_showmenu = 56,
    dispid_resume = 57,
    dispid_returnfromsubmenu = 58,
    dispid_buttonsavailable = 59,
    dispid_currentbutton = 60,
    dispid_SelectAndActivateButton = 61,
    dispid_ActivateButton = 62,
    dispid_SelectRightButton = 63,
    dispid_SelectLeftButton = 64,
    dispid_SelectLowerButton = 65,
    dispid_SelectUpperButton = 66,
    dispid_ActivateAtPosition = 67,
    dispid_SelectAtPosition = 68,
    dispid_ButtonAtPosition = 69,
    dispid_NumberOfChapters = 70,
    dispid_TotalTitleTime = 71,
    dispid_TitlesAvailable = 72,
    dispid_VolumesAvailable = 73,
    dispid_CurrentVolume = 74,
    dispid_CurrentDiscSide = 75,
    dispid_CurrentDomain = 76,
    dispid_CurrentChapter = 77,
    dispid_CurrentTitle = 78,
    dispid_CurrentTime = 79,
    dispid_FramesPerSecond = 80,
    dispid_DVDTimeCode2bstr = 81,
    dispid_DVDDirectory = 82,
    dispid_IsSubpictureStreamEnabled = 83,
    dispid_IsAudioStreamEnabled = 84,
    dispid_CurrentSubpictureStream = 85,
    dispid_SubpictureLanguage = 86,
    dispid_CurrentAudioStream = 87,
    dispid_AudioStreamsAvailable = 88,
    dispid_AnglesAvailable = 89,
    dispid_CurrentAngle = 90,
    dispid_CCActive = 91,
    dispid_CurrentCCService = 92,
    dispid_SubpictureStreamsAvailable = 93,
    dispid_SubpictureOn = 94,
    dispid_DVDUniqueID = 95,
    dispid_EnableResetOnStop = 96,
    dispid_AcceptParentalLevelChange = 97,
    dispid_NotifyParentalLevelChange = 98,
    dispid_SelectParentalCountry = 99,
    dispid_SelectParentalLevel = 100,
    dispid_TitleParentalLevels = 101,
    dispid_PlayerParentalCountry = 102,
    dispid_PlayerParentalLevel = 103,
    dispid_Eject = 104,
    dispid_UOPValid = 105,
    dispid_SPRM = 106,
    dispid_GPRM = 107,
    dispid_DVDTextStringType = 108,
    dispid_DVDTextString = 109,
    dispid_DVDTextNumberOfStrings = 110,
    dispid_DVDTextNumberOfLanguages = 111,
    dispid_DVDTextLanguageLCID = 112,
    dispid_RegionChange = 113,
    dispid_DVDAdm = 114,
    dispid_DeleteBookmark = 115,
    dispid_RestoreBookmark = 116,
    dispid_SaveBookmark = 117,
    dispid_SelectDefaultAudioLanguage = 118,
    dispid_SelectDefaultSubpictureLanguage = 119,
    dispid_PreferredSubpictureStream = 120,
    dispid_DefaultMenuLanguage = 121,
    dispid_DefaultSubpictureLanguage = 122,
    dispid_DefaultAudioLanguage = 123,
    dispid_DefaultSubpictureLanguageExt = 124,
    dispid_DefaultAudioLanguageExt = 125,
    dispid_LanguageFromLCID = 126,
    dispid_KaraokeAudioPresentationMode = 127,
    dispid_KaraokeChannelContent = 128,
    dispid_KaraokeChannelAssignment = 129,
    dispid_RestorePreferredSettings = 130,
    dispid_ButtonRect = 131,
    dispid_DVDScreenInMouseCoordinates = 132,
    dispid_CustomCompositorClass = 133,
    dispidCustomCompositorClass = 134,
    dispid_CustomCompositor = 135,
    dispidMixerBitmap = 136,
    dispid_MixerBitmap = 137,
    dispidMixerBitmapOpacity = 138,
    dispidMixerBitmapRect = 139,
    dispidSetupMixerBitmap = 140,
    dispidUsingOverlay = 141,
    dispidDisplayChange = 142,
    dispidRePaint = 143,
    dispid_IsEqualDevice = 144,
    dispidrate = 145,
    dispidposition = 146,
    dispidpositionmode = 147,
    dispidlength = 148,
    dispidChangePassword = 149,
    dispidSaveParentalLevel = 150,
    dispidSaveParentalCountry = 151,
    dispidConfirmPassword = 152,
    dispidGetParentalLevel = 153,
    dispidGetParentalCountry = 154,
    dispidDefaultAudioLCID = 155,
    dispidDefaultSubpictureLCID = 156,
    dispidDefaultMenuLCID = 157,
    dispidBookmarkOnStop = 158,
    dispidMaxVidRect = 159,
    dispidMinVidRect = 160,
    dispidCapture = 161,
    dispid_DecimateInput = 162,
    dispidAlloctor = 163,
    dispid_Allocator = 164,
    dispidAllocPresentID = 165,
    dispidSetAllocator = 166,
    dispid_SetAllocator = 167,
    dispidStreamBufferSinkName = 168,
    dispidStreamBufferSourceName = 169,
    dispidStreamBufferContentRecording = 170,
    dispidStreamBufferReferenceRecording = 171,
    dispidstarttime = 172,
    dispidstoptime = 173,
    dispidrecordingstopped = 174,
    dispidrecordingstarted = 175,
    dispidNameSetLock = 176,
    dispidrecordingtype = 177,
    dispidstart = 178,
    dispidRecordingAttribute = 179,
    dispid_RecordingAttribute = 180,
    dispidSBEConfigure = 181,
    dispid_CurrentRatings = 182,
    dispid_MaxRatingsLevel = 183,
    dispid_audioencoderint = 184,
    dispid_videoencoderint = 185,
    dispidService = 186,
    dispid_BlockUnrated = 187,
    dispid_UnratedDelay = 188,
    dispid_SuppressEffects = 189,
    dispidsbesource = 190,
    dispidSetSinkFilter = 191,
    dispid_SinkStreams = 192,
    dispidTVFormats = 193,
    dispidModes = 194,
    dispidAuxInputs = 195,
    dispidTeleTextFilter = 196,
    dispid_channelchangeint = 197,
    dispidUnlockProfile = 198,
    dispid_AddFilter = 199,
    dispidSetMinSeek = 200,
    dispidRateEx = 201,
    dispidaudiocounter = 202,
    dispidvideocounter = 203,
    dispidcccounter = 204,
    dispidwstcounter = 205,
    dispid_audiocounter = 206,
    dispid_videocounter = 207,
    dispid_cccounter = 208,
    dispid_wstcounter = 209,
    dispidaudioanalysis = 210,
    dispidvideoanalysis = 211,
    dispiddataanalysis = 212,
    dispidaudio_analysis = 213,
    dispidvideo_analysis = 214,
    dispiddata_analysis = 215,
    dispid_resetFilterList = 216,
    dispidDevicePath = 217,
    dispid_SourceFilter = 218,
    dispid__SourceFilter = 219,
    dispidUserEvent = 220,
    dispid_Bookmark = 221,
    LastReservedDeviceDispid = 16383,
};
pub const dispidName = SegDispidList.dispidName;
pub const dispidStatus = SegDispidList.dispidStatus;
pub const dispidDevImageSourceWidth = SegDispidList.dispidDevImageSourceWidth;
pub const dispidDevImageSourceHeight = SegDispidList.dispidDevImageSourceHeight;
pub const dispidDevCountryCode = SegDispidList.dispidDevCountryCode;
pub const dispidDevOverScan = SegDispidList.dispidDevOverScan;
pub const dispidSegment = SegDispidList.dispidSegment;
pub const dispidDevVolume = SegDispidList.dispidDevVolume;
pub const dispidDevBalance = SegDispidList.dispidDevBalance;
pub const dispidDevPower = SegDispidList.dispidDevPower;
pub const dispidTuneChan = SegDispidList.dispidTuneChan;
pub const dispidDevVideoSubchannel = SegDispidList.dispidDevVideoSubchannel;
pub const dispidDevAudioSubchannel = SegDispidList.dispidDevAudioSubchannel;
pub const dispidChannelAvailable = SegDispidList.dispidChannelAvailable;
pub const dispidDevVideoFrequency = SegDispidList.dispidDevVideoFrequency;
pub const dispidDevAudioFrequency = SegDispidList.dispidDevAudioFrequency;
pub const dispidCount = SegDispidList.dispidCount;
pub const dispidDevFileName = SegDispidList.dispidDevFileName;
pub const dispidVisible = SegDispidList.dispidVisible;
pub const dispidOwner = SegDispidList.dispidOwner;
pub const dispidMessageDrain = SegDispidList.dispidMessageDrain;
pub const dispidViewable = SegDispidList.dispidViewable;
pub const dispidDevView = SegDispidList.dispidDevView;
pub const dispidKSCat = SegDispidList.dispidKSCat;
pub const dispidCLSID = SegDispidList.dispidCLSID;
pub const dispid_KSCat = SegDispidList.dispid_KSCat;
pub const dispid_CLSID = SegDispidList.dispid_CLSID;
pub const dispidTune = SegDispidList.dispidTune;
pub const dispidTS = SegDispidList.dispidTS;
pub const dispidDevSAP = SegDispidList.dispidDevSAP;
pub const dispidClip = SegDispidList.dispidClip;
pub const dispidRequestedClipRect = SegDispidList.dispidRequestedClipRect;
pub const dispidClippedSourceRect = SegDispidList.dispidClippedSourceRect;
pub const dispidAvailableSourceRect = SegDispidList.dispidAvailableSourceRect;
pub const dispidMediaPosition = SegDispidList.dispidMediaPosition;
pub const dispidDevRun = SegDispidList.dispidDevRun;
pub const dispidDevPause = SegDispidList.dispidDevPause;
pub const dispidDevStop = SegDispidList.dispidDevStop;
pub const dispidCCEnable = SegDispidList.dispidCCEnable;
pub const dispidDevStep = SegDispidList.dispidDevStep;
pub const dispidDevCanStep = SegDispidList.dispidDevCanStep;
pub const dispidSourceSize = SegDispidList.dispidSourceSize;
pub const dispid_playtitle = SegDispidList.dispid_playtitle;
pub const dispid_playchapterintitle = SegDispidList.dispid_playchapterintitle;
pub const dispid_playchapter = SegDispidList.dispid_playchapter;
pub const dispid_playchaptersautostop = SegDispidList.dispid_playchaptersautostop;
pub const dispid_playattime = SegDispidList.dispid_playattime;
pub const dispid_playattimeintitle = SegDispidList.dispid_playattimeintitle;
pub const dispid_playperiodintitleautostop = SegDispidList.dispid_playperiodintitleautostop;
pub const dispid_replaychapter = SegDispidList.dispid_replaychapter;
pub const dispid_playprevchapter = SegDispidList.dispid_playprevchapter;
pub const dispid_playnextchapter = SegDispidList.dispid_playnextchapter;
pub const dispid_playforwards = SegDispidList.dispid_playforwards;
pub const dispid_playbackwards = SegDispidList.dispid_playbackwards;
pub const dispid_stilloff = SegDispidList.dispid_stilloff;
pub const dispid_audiolanguage = SegDispidList.dispid_audiolanguage;
pub const dispid_showmenu = SegDispidList.dispid_showmenu;
pub const dispid_resume = SegDispidList.dispid_resume;
pub const dispid_returnfromsubmenu = SegDispidList.dispid_returnfromsubmenu;
pub const dispid_buttonsavailable = SegDispidList.dispid_buttonsavailable;
pub const dispid_currentbutton = SegDispidList.dispid_currentbutton;
pub const dispid_SelectAndActivateButton = SegDispidList.dispid_SelectAndActivateButton;
pub const dispid_ActivateButton = SegDispidList.dispid_ActivateButton;
pub const dispid_SelectRightButton = SegDispidList.dispid_SelectRightButton;
pub const dispid_SelectLeftButton = SegDispidList.dispid_SelectLeftButton;
pub const dispid_SelectLowerButton = SegDispidList.dispid_SelectLowerButton;
pub const dispid_SelectUpperButton = SegDispidList.dispid_SelectUpperButton;
pub const dispid_ActivateAtPosition = SegDispidList.dispid_ActivateAtPosition;
pub const dispid_SelectAtPosition = SegDispidList.dispid_SelectAtPosition;
pub const dispid_ButtonAtPosition = SegDispidList.dispid_ButtonAtPosition;
pub const dispid_NumberOfChapters = SegDispidList.dispid_NumberOfChapters;
pub const dispid_TotalTitleTime = SegDispidList.dispid_TotalTitleTime;
pub const dispid_TitlesAvailable = SegDispidList.dispid_TitlesAvailable;
pub const dispid_VolumesAvailable = SegDispidList.dispid_VolumesAvailable;
pub const dispid_CurrentVolume = SegDispidList.dispid_CurrentVolume;
pub const dispid_CurrentDiscSide = SegDispidList.dispid_CurrentDiscSide;
pub const dispid_CurrentDomain = SegDispidList.dispid_CurrentDomain;
pub const dispid_CurrentChapter = SegDispidList.dispid_CurrentChapter;
pub const dispid_CurrentTitle = SegDispidList.dispid_CurrentTitle;
pub const dispid_CurrentTime = SegDispidList.dispid_CurrentTime;
pub const dispid_FramesPerSecond = SegDispidList.dispid_FramesPerSecond;
pub const dispid_DVDTimeCode2bstr = SegDispidList.dispid_DVDTimeCode2bstr;
pub const dispid_DVDDirectory = SegDispidList.dispid_DVDDirectory;
pub const dispid_IsSubpictureStreamEnabled = SegDispidList.dispid_IsSubpictureStreamEnabled;
pub const dispid_IsAudioStreamEnabled = SegDispidList.dispid_IsAudioStreamEnabled;
pub const dispid_CurrentSubpictureStream = SegDispidList.dispid_CurrentSubpictureStream;
pub const dispid_SubpictureLanguage = SegDispidList.dispid_SubpictureLanguage;
pub const dispid_CurrentAudioStream = SegDispidList.dispid_CurrentAudioStream;
pub const dispid_AudioStreamsAvailable = SegDispidList.dispid_AudioStreamsAvailable;
pub const dispid_AnglesAvailable = SegDispidList.dispid_AnglesAvailable;
pub const dispid_CurrentAngle = SegDispidList.dispid_CurrentAngle;
pub const dispid_CCActive = SegDispidList.dispid_CCActive;
pub const dispid_CurrentCCService = SegDispidList.dispid_CurrentCCService;
pub const dispid_SubpictureStreamsAvailable = SegDispidList.dispid_SubpictureStreamsAvailable;
pub const dispid_SubpictureOn = SegDispidList.dispid_SubpictureOn;
pub const dispid_DVDUniqueID = SegDispidList.dispid_DVDUniqueID;
pub const dispid_EnableResetOnStop = SegDispidList.dispid_EnableResetOnStop;
pub const dispid_AcceptParentalLevelChange = SegDispidList.dispid_AcceptParentalLevelChange;
pub const dispid_NotifyParentalLevelChange = SegDispidList.dispid_NotifyParentalLevelChange;
pub const dispid_SelectParentalCountry = SegDispidList.dispid_SelectParentalCountry;
pub const dispid_SelectParentalLevel = SegDispidList.dispid_SelectParentalLevel;
pub const dispid_TitleParentalLevels = SegDispidList.dispid_TitleParentalLevels;
pub const dispid_PlayerParentalCountry = SegDispidList.dispid_PlayerParentalCountry;
pub const dispid_PlayerParentalLevel = SegDispidList.dispid_PlayerParentalLevel;
pub const dispid_Eject = SegDispidList.dispid_Eject;
pub const dispid_UOPValid = SegDispidList.dispid_UOPValid;
pub const dispid_SPRM = SegDispidList.dispid_SPRM;
pub const dispid_GPRM = SegDispidList.dispid_GPRM;
pub const dispid_DVDTextStringType = SegDispidList.dispid_DVDTextStringType;
pub const dispid_DVDTextString = SegDispidList.dispid_DVDTextString;
pub const dispid_DVDTextNumberOfStrings = SegDispidList.dispid_DVDTextNumberOfStrings;
pub const dispid_DVDTextNumberOfLanguages = SegDispidList.dispid_DVDTextNumberOfLanguages;
pub const dispid_DVDTextLanguageLCID = SegDispidList.dispid_DVDTextLanguageLCID;
pub const dispid_RegionChange = SegDispidList.dispid_RegionChange;
pub const dispid_DVDAdm = SegDispidList.dispid_DVDAdm;
pub const dispid_DeleteBookmark = SegDispidList.dispid_DeleteBookmark;
pub const dispid_RestoreBookmark = SegDispidList.dispid_RestoreBookmark;
pub const dispid_SaveBookmark = SegDispidList.dispid_SaveBookmark;
pub const dispid_SelectDefaultAudioLanguage = SegDispidList.dispid_SelectDefaultAudioLanguage;
pub const dispid_SelectDefaultSubpictureLanguage = SegDispidList.dispid_SelectDefaultSubpictureLanguage;
pub const dispid_PreferredSubpictureStream = SegDispidList.dispid_PreferredSubpictureStream;
pub const dispid_DefaultMenuLanguage = SegDispidList.dispid_DefaultMenuLanguage;
pub const dispid_DefaultSubpictureLanguage = SegDispidList.dispid_DefaultSubpictureLanguage;
pub const dispid_DefaultAudioLanguage = SegDispidList.dispid_DefaultAudioLanguage;
pub const dispid_DefaultSubpictureLanguageExt = SegDispidList.dispid_DefaultSubpictureLanguageExt;
pub const dispid_DefaultAudioLanguageExt = SegDispidList.dispid_DefaultAudioLanguageExt;
pub const dispid_LanguageFromLCID = SegDispidList.dispid_LanguageFromLCID;
pub const dispid_KaraokeAudioPresentationMode = SegDispidList.dispid_KaraokeAudioPresentationMode;
pub const dispid_KaraokeChannelContent = SegDispidList.dispid_KaraokeChannelContent;
pub const dispid_KaraokeChannelAssignment = SegDispidList.dispid_KaraokeChannelAssignment;
pub const dispid_RestorePreferredSettings = SegDispidList.dispid_RestorePreferredSettings;
pub const dispid_ButtonRect = SegDispidList.dispid_ButtonRect;
pub const dispid_DVDScreenInMouseCoordinates = SegDispidList.dispid_DVDScreenInMouseCoordinates;
pub const dispid_CustomCompositorClass = SegDispidList.dispid_CustomCompositorClass;
pub const dispidCustomCompositorClass = SegDispidList.dispidCustomCompositorClass;
pub const dispid_CustomCompositor = SegDispidList.dispid_CustomCompositor;
pub const dispidMixerBitmap = SegDispidList.dispidMixerBitmap;
pub const dispid_MixerBitmap = SegDispidList.dispid_MixerBitmap;
pub const dispidMixerBitmapOpacity = SegDispidList.dispidMixerBitmapOpacity;
pub const dispidMixerBitmapRect = SegDispidList.dispidMixerBitmapRect;
pub const dispidSetupMixerBitmap = SegDispidList.dispidSetupMixerBitmap;
pub const dispidUsingOverlay = SegDispidList.dispidUsingOverlay;
pub const dispidDisplayChange = SegDispidList.dispidDisplayChange;
pub const dispidRePaint = SegDispidList.dispidRePaint;
pub const dispid_IsEqualDevice = SegDispidList.dispid_IsEqualDevice;
pub const dispidrate = SegDispidList.dispidrate;
pub const dispidposition = SegDispidList.dispidposition;
pub const dispidpositionmode = SegDispidList.dispidpositionmode;
pub const dispidlength = SegDispidList.dispidlength;
pub const dispidChangePassword = SegDispidList.dispidChangePassword;
pub const dispidSaveParentalLevel = SegDispidList.dispidSaveParentalLevel;
pub const dispidSaveParentalCountry = SegDispidList.dispidSaveParentalCountry;
pub const dispidConfirmPassword = SegDispidList.dispidConfirmPassword;
pub const dispidGetParentalLevel = SegDispidList.dispidGetParentalLevel;
pub const dispidGetParentalCountry = SegDispidList.dispidGetParentalCountry;
pub const dispidDefaultAudioLCID = SegDispidList.dispidDefaultAudioLCID;
pub const dispidDefaultSubpictureLCID = SegDispidList.dispidDefaultSubpictureLCID;
pub const dispidDefaultMenuLCID = SegDispidList.dispidDefaultMenuLCID;
pub const dispidBookmarkOnStop = SegDispidList.dispidBookmarkOnStop;
pub const dispidMaxVidRect = SegDispidList.dispidMaxVidRect;
pub const dispidMinVidRect = SegDispidList.dispidMinVidRect;
pub const dispidCapture = SegDispidList.dispidCapture;
pub const dispid_DecimateInput = SegDispidList.dispid_DecimateInput;
pub const dispidAlloctor = SegDispidList.dispidAlloctor;
pub const dispid_Allocator = SegDispidList.dispid_Allocator;
pub const dispidAllocPresentID = SegDispidList.dispidAllocPresentID;
pub const dispidSetAllocator = SegDispidList.dispidSetAllocator;
pub const dispid_SetAllocator = SegDispidList.dispid_SetAllocator;
pub const dispidStreamBufferSinkName = SegDispidList.dispidStreamBufferSinkName;
pub const dispidStreamBufferSourceName = SegDispidList.dispidStreamBufferSourceName;
pub const dispidStreamBufferContentRecording = SegDispidList.dispidStreamBufferContentRecording;
pub const dispidStreamBufferReferenceRecording = SegDispidList.dispidStreamBufferReferenceRecording;
pub const dispidstarttime = SegDispidList.dispidstarttime;
pub const dispidstoptime = SegDispidList.dispidstoptime;
pub const dispidrecordingstopped = SegDispidList.dispidrecordingstopped;
pub const dispidrecordingstarted = SegDispidList.dispidrecordingstarted;
pub const dispidNameSetLock = SegDispidList.dispidNameSetLock;
pub const dispidrecordingtype = SegDispidList.dispidrecordingtype;
pub const dispidstart = SegDispidList.dispidstart;
pub const dispidRecordingAttribute = SegDispidList.dispidRecordingAttribute;
pub const dispid_RecordingAttribute = SegDispidList.dispid_RecordingAttribute;
pub const dispidSBEConfigure = SegDispidList.dispidSBEConfigure;
pub const dispid_CurrentRatings = SegDispidList.dispid_CurrentRatings;
pub const dispid_MaxRatingsLevel = SegDispidList.dispid_MaxRatingsLevel;
pub const dispid_audioencoderint = SegDispidList.dispid_audioencoderint;
pub const dispid_videoencoderint = SegDispidList.dispid_videoencoderint;
pub const dispidService = SegDispidList.dispidService;
pub const dispid_BlockUnrated = SegDispidList.dispid_BlockUnrated;
pub const dispid_UnratedDelay = SegDispidList.dispid_UnratedDelay;
pub const dispid_SuppressEffects = SegDispidList.dispid_SuppressEffects;
pub const dispidsbesource = SegDispidList.dispidsbesource;
pub const dispidSetSinkFilter = SegDispidList.dispidSetSinkFilter;
pub const dispid_SinkStreams = SegDispidList.dispid_SinkStreams;
pub const dispidTVFormats = SegDispidList.dispidTVFormats;
pub const dispidModes = SegDispidList.dispidModes;
pub const dispidAuxInputs = SegDispidList.dispidAuxInputs;
pub const dispidTeleTextFilter = SegDispidList.dispidTeleTextFilter;
pub const dispid_channelchangeint = SegDispidList.dispid_channelchangeint;
pub const dispidUnlockProfile = SegDispidList.dispidUnlockProfile;
pub const dispid_AddFilter = SegDispidList.dispid_AddFilter;
pub const dispidSetMinSeek = SegDispidList.dispidSetMinSeek;
pub const dispidRateEx = SegDispidList.dispidRateEx;
pub const dispidaudiocounter = SegDispidList.dispidaudiocounter;
pub const dispidvideocounter = SegDispidList.dispidvideocounter;
pub const dispidcccounter = SegDispidList.dispidcccounter;
pub const dispidwstcounter = SegDispidList.dispidwstcounter;
pub const dispid_audiocounter = SegDispidList.dispid_audiocounter;
pub const dispid_videocounter = SegDispidList.dispid_videocounter;
pub const dispid_cccounter = SegDispidList.dispid_cccounter;
pub const dispid_wstcounter = SegDispidList.dispid_wstcounter;
pub const dispidaudioanalysis = SegDispidList.dispidaudioanalysis;
pub const dispidvideoanalysis = SegDispidList.dispidvideoanalysis;
pub const dispiddataanalysis = SegDispidList.dispiddataanalysis;
pub const dispidaudio_analysis = SegDispidList.dispidaudio_analysis;
pub const dispidvideo_analysis = SegDispidList.dispidvideo_analysis;
pub const dispiddata_analysis = SegDispidList.dispiddata_analysis;
pub const dispid_resetFilterList = SegDispidList.dispid_resetFilterList;
pub const dispidDevicePath = SegDispidList.dispidDevicePath;
pub const dispid_SourceFilter = SegDispidList.dispid_SourceFilter;
pub const dispid__SourceFilter = SegDispidList.dispid__SourceFilter;
pub const dispidUserEvent = SegDispidList.dispidUserEvent;
pub const dispid_Bookmark = SegDispidList.dispid_Bookmark;
pub const LastReservedDeviceDispid = SegDispidList.LastReservedDeviceDispid;

pub const SegEventidList = enum(i32) {
    eventidStateChange = 0,
    eventidOnTuneChanged = 1,
    eventidEndOfMedia = 2,
    eventidDVDNotify = 3,
    eventidPlayForwards = 4,
    eventidPlayBackwards = 5,
    eventidShowMenu = 6,
    eventidResume = 7,
    eventidSelectOrActivateButton = 8,
    eventidStillOff = 9,
    eventidPauseOn = 10,
    eventidChangeCurrentAudioStream = 11,
    eventidChangeCurrentSubpictureStream = 12,
    eventidChangeCurrentAngle = 13,
    eventidPlayAtTimeInTitle = 14,
    eventidPlayAtTime = 15,
    eventidPlayChapterInTitle = 16,
    eventidPlayChapter = 17,
    eventidReplayChapter = 18,
    eventidPlayNextChapter = 19,
    eventidStop = 20,
    eventidReturnFromSubmenu = 21,
    eventidPlayTitle = 22,
    eventidPlayPrevChapter = 23,
    eventidChangeKaraokePresMode = 24,
    eventidChangeVideoPresMode = 25,
    eventidOverlayUnavailable = 26,
    eventidSinkCertificateFailure = 27,
    eventidSinkCertificateSuccess = 28,
    eventidSourceCertificateFailure = 29,
    eventidSourceCertificateSuccess = 30,
    eventidRatingsBlocked = 31,
    eventidRatingsUnlocked = 32,
    eventidRatingsChanged = 33,
    eventidWriteFailure = 34,
    eventidTimeHole = 35,
    eventidStaleDataRead = 36,
    eventidContentBecomingStale = 37,
    eventidStaleFileDeleted = 38,
    eventidEncryptionOn = 39,
    eventidEncryptionOff = 40,
    eventidRateChange = 41,
    eventidLicenseChange = 42,
    eventidCOPPBlocked = 43,
    eventidCOPPUnblocked = 44,
    dispidlicenseerrorcode = 45,
    eventidBroadcastEvent = 46,
    eventidBroadcastEventEx = 47,
    eventidContentPrimarilyAudio = 48,
    dispidAVDecAudioDualMonoEvent = 49,
    dispidAVAudioSampleRateEvent = 50,
    dispidAVAudioChannelConfigEvent = 51,
    dispidAVAudioChannelCountEvent = 52,
    dispidAVDecCommonMeanBitRateEvent = 53,
    dispidAVDDSurroundModeEvent = 54,
    dispidAVDecCommonInputFormatEvent = 55,
    dispidAVDecCommonOutputFormatEvent = 56,
    eventidWriteFailureClear = 57,
    LastReservedDeviceEvent = 16383,
};
pub const eventidStateChange = SegEventidList.eventidStateChange;
pub const eventidOnTuneChanged = SegEventidList.eventidOnTuneChanged;
pub const eventidEndOfMedia = SegEventidList.eventidEndOfMedia;
pub const eventidDVDNotify = SegEventidList.eventidDVDNotify;
pub const eventidPlayForwards = SegEventidList.eventidPlayForwards;
pub const eventidPlayBackwards = SegEventidList.eventidPlayBackwards;
pub const eventidShowMenu = SegEventidList.eventidShowMenu;
pub const eventidResume = SegEventidList.eventidResume;
pub const eventidSelectOrActivateButton = SegEventidList.eventidSelectOrActivateButton;
pub const eventidStillOff = SegEventidList.eventidStillOff;
pub const eventidPauseOn = SegEventidList.eventidPauseOn;
pub const eventidChangeCurrentAudioStream = SegEventidList.eventidChangeCurrentAudioStream;
pub const eventidChangeCurrentSubpictureStream = SegEventidList.eventidChangeCurrentSubpictureStream;
pub const eventidChangeCurrentAngle = SegEventidList.eventidChangeCurrentAngle;
pub const eventidPlayAtTimeInTitle = SegEventidList.eventidPlayAtTimeInTitle;
pub const eventidPlayAtTime = SegEventidList.eventidPlayAtTime;
pub const eventidPlayChapterInTitle = SegEventidList.eventidPlayChapterInTitle;
pub const eventidPlayChapter = SegEventidList.eventidPlayChapter;
pub const eventidReplayChapter = SegEventidList.eventidReplayChapter;
pub const eventidPlayNextChapter = SegEventidList.eventidPlayNextChapter;
pub const eventidStop = SegEventidList.eventidStop;
pub const eventidReturnFromSubmenu = SegEventidList.eventidReturnFromSubmenu;
pub const eventidPlayTitle = SegEventidList.eventidPlayTitle;
pub const eventidPlayPrevChapter = SegEventidList.eventidPlayPrevChapter;
pub const eventidChangeKaraokePresMode = SegEventidList.eventidChangeKaraokePresMode;
pub const eventidChangeVideoPresMode = SegEventidList.eventidChangeVideoPresMode;
pub const eventidOverlayUnavailable = SegEventidList.eventidOverlayUnavailable;
pub const eventidSinkCertificateFailure = SegEventidList.eventidSinkCertificateFailure;
pub const eventidSinkCertificateSuccess = SegEventidList.eventidSinkCertificateSuccess;
pub const eventidSourceCertificateFailure = SegEventidList.eventidSourceCertificateFailure;
pub const eventidSourceCertificateSuccess = SegEventidList.eventidSourceCertificateSuccess;
pub const eventidRatingsBlocked = SegEventidList.eventidRatingsBlocked;
pub const eventidRatingsUnlocked = SegEventidList.eventidRatingsUnlocked;
pub const eventidRatingsChanged = SegEventidList.eventidRatingsChanged;
pub const eventidWriteFailure = SegEventidList.eventidWriteFailure;
pub const eventidTimeHole = SegEventidList.eventidTimeHole;
pub const eventidStaleDataRead = SegEventidList.eventidStaleDataRead;
pub const eventidContentBecomingStale = SegEventidList.eventidContentBecomingStale;
pub const eventidStaleFileDeleted = SegEventidList.eventidStaleFileDeleted;
pub const eventidEncryptionOn = SegEventidList.eventidEncryptionOn;
pub const eventidEncryptionOff = SegEventidList.eventidEncryptionOff;
pub const eventidRateChange = SegEventidList.eventidRateChange;
pub const eventidLicenseChange = SegEventidList.eventidLicenseChange;
pub const eventidCOPPBlocked = SegEventidList.eventidCOPPBlocked;
pub const eventidCOPPUnblocked = SegEventidList.eventidCOPPUnblocked;
pub const dispidlicenseerrorcode = SegEventidList.dispidlicenseerrorcode;
pub const eventidBroadcastEvent = SegEventidList.eventidBroadcastEvent;
pub const eventidBroadcastEventEx = SegEventidList.eventidBroadcastEventEx;
pub const eventidContentPrimarilyAudio = SegEventidList.eventidContentPrimarilyAudio;
pub const dispidAVDecAudioDualMonoEvent = SegEventidList.dispidAVDecAudioDualMonoEvent;
pub const dispidAVAudioSampleRateEvent = SegEventidList.dispidAVAudioSampleRateEvent;
pub const dispidAVAudioChannelConfigEvent = SegEventidList.dispidAVAudioChannelConfigEvent;
pub const dispidAVAudioChannelCountEvent = SegEventidList.dispidAVAudioChannelCountEvent;
pub const dispidAVDecCommonMeanBitRateEvent = SegEventidList.dispidAVDecCommonMeanBitRateEvent;
pub const dispidAVDDSurroundModeEvent = SegEventidList.dispidAVDDSurroundModeEvent;
pub const dispidAVDecCommonInputFormatEvent = SegEventidList.dispidAVDecCommonInputFormatEvent;
pub const dispidAVDecCommonOutputFormatEvent = SegEventidList.dispidAVDecCommonOutputFormatEvent;
pub const eventidWriteFailureClear = SegEventidList.eventidWriteFailureClear;
pub const LastReservedDeviceEvent = SegEventidList.LastReservedDeviceEvent;

pub const PositionModeList = enum(i32) {
    FrameMode = 0,
    TenthsSecondsMode = 1,
};
pub const FrameMode = PositionModeList.FrameMode;
pub const TenthsSecondsMode = PositionModeList.TenthsSecondsMode;

pub const RecordingType = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const CONTENT = RecordingType.CONTENT;
pub const REFERENCE = RecordingType.REFERENCE;

pub const MSVidCCService = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
};
// NOTE: not creating aliases because this enum is 'Scoped'

pub const MSVidSinkStreams = enum(i32) {
    Video = 1,
    Audio = 2,
    Other = 4,
};
pub const MSVidSink_Video = MSVidSinkStreams.Video;
pub const MSVidSink_Audio = MSVidSinkStreams.Audio;
pub const MSVidSink_Other = MSVidSinkStreams.Other;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidRect_Value = Guid.initString("7f5000a6-a440-47ca-8acc-c0e75531a2c2");
pub const IID_IMSVidRect = &IID_IMSVidRect_Value;
pub const IMSVidRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                TopVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                TopVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                TopVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                TopVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                LeftVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                LeftVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                LeftVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                LeftVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                WidthVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                WidthVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                WidthVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                WidthVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                HeightVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                HeightVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                HeightVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                HeightVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                HWndVal: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                HWndVal: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HWnd: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                HWndVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                HWndVal: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidRect,
                RectVal: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidRect,
                RectVal: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Top(self: *const T, TopVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IMSVidRect, @ptrCast(self)), TopVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Top(self: *const T, TopVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IMSVidRect, @ptrCast(self)), TopVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Left(self: *const T, LeftVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IMSVidRect, @ptrCast(self)), LeftVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Left(self: *const T, LeftVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IMSVidRect, @ptrCast(self)), LeftVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Width(self: *const T, WidthVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IMSVidRect, @ptrCast(self)), WidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Width(self: *const T, WidthVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IMSVidRect, @ptrCast(self)), WidthVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_Height(self: *const T, HeightVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IMSVidRect, @ptrCast(self)), HeightVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Height(self: *const T, HeightVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IMSVidRect, @ptrCast(self)), HeightVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_get_HWnd(self: *const T, HWndVal: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).get_HWnd(@as(*const IMSVidRect, @ptrCast(self)), HWndVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_HWnd(self: *const T, HWndVal: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_HWnd(@as(*const IMSVidRect, @ptrCast(self)), HWndVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidRect_put_Rect(self: *const T, RectVal: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidRect.VTable, @ptrCast(self.vtable)).put_Rect(@as(*const IMSVidRect, @ptrCast(self)), RectVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidGraphSegmentContainer_Value = Guid.initString("3dd2903d-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidGraphSegmentContainer = &IID_IMSVidGraphSegmentContainer_Value;
pub const IMSVidGraphSegmentContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Graph: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppGraph: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppGraph: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Input: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppInput: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppInput: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Outputs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppOutputs: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppOutputs: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppVR: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppVR: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppAR: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppAR: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Features: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppFeatures: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppFeatures: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Composites: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppComposites: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppComposites: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ParentContainer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                ppContainer: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                ppContainer: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Decompose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
                pSegment: ?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
                pSegment: ?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsWindowless: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Graph(self: *const T, ppGraph: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Graph(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Input(self: *const T, ppInput: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Input(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Outputs(self: *const T, ppOutputs: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Outputs(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppOutputs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_VideoRenderer(self: *const T, ppVR: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_VideoRenderer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppVR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_AudioRenderer(self: *const T, ppAR: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_AudioRenderer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppAR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Features(self: *const T, ppFeatures: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Features(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppFeatures);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_Composites(self: *const T, ppComposites: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_Composites(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppComposites);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_get_ParentContainer(self: *const T, ppContainer: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).get_ParentContainer(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_Decompose(self: *const T, pSegment: ?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)), pSegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_IsWindowless(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).IsWindowless(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentContainer_GetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentContainer.VTable, @ptrCast(self.vtable)).GetFocus(@as(*const IMSVidGraphSegmentContainer, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidSegmentType = enum(i32) {
    SOURCE = 0,
    XFORM = 1,
    DEST = 2,
};
pub const MSVidSEG_SOURCE = MSVidSegmentType.SOURCE;
pub const MSVidSEG_XFORM = MSVidSegmentType.XFORM;
pub const MSVidSEG_DEST = MSVidSegmentType.DEST;

const IID_IMSVidGraphSegment_Value = Guid.initString("238dec54-adeb-4005-a349-f772b9afebc4");
pub const IID_IMSVidGraphSegment = &IID_IMSVidGraphSegment_Value;
pub const IMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Init: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pInit: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pInit: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Init: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pInit: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pInit: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pNewEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pNewEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Container: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                ppCtl: ?*?*IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                ppCtl: ?*?*IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Container: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pCtl: ?*IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pCtl: ?*IMSVidGraphSegmentContainer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pType: ?*MSVidSegmentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pType: ?*MSVidSegmentType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGraphSegment,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Build: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostBuild: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostRun: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PreStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PostStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnEventNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
                lEventCode: i32,
                lEventParm1: isize,
                lEventParm2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
                lEventCode: i32,
                lEventParm1: isize,
                lEventParm2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Decompose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Init(self: *const T, pInit: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Init(@as(*const IMSVidGraphSegment, @ptrCast(self)), pInit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_put_Init(self: *const T, pInit: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).put_Init(@as(*const IMSVidGraphSegment, @ptrCast(self)), pInit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_EnumFilters(self: *const T, pNewEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).EnumFilters(@as(*const IMSVidGraphSegment, @ptrCast(self)), pNewEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Container(self: *const T, ppCtl: ?*?*IMSVidGraphSegmentContainer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Container(@as(*const IMSVidGraphSegment, @ptrCast(self)), ppCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_put_Container(self: *const T, pCtl: ?*IMSVidGraphSegmentContainer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).put_Container(@as(*const IMSVidGraphSegment, @ptrCast(self)), pCtl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Type(self: *const T, pType: ?*MSVidSegmentType) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IMSVidGraphSegment, @ptrCast(self)), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_get_Category(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IMSVidGraphSegment, @ptrCast(self)), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_Build(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Build(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostBuild(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostBuild(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PreRun(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PreRun(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostRun(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostRun(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PreStop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PreStop(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_PostStop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).PostStop(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_OnEventNotify(self: *const T, lEventCode: i32, lEventParm1: isize, lEventParm2: isize) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).OnEventNotify(@as(*const IMSVidGraphSegment, @ptrCast(self)), lEventCode, lEventParm1, lEventParm2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegment_Decompose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidGraphSegment, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSVidCtlButtonstate = enum(i32) {
    LEFT_BUTTON = 1,
    RIGHT_BUTTON = 2,
    MIDDLE_BUTTON = 4,
    X_BUTTON1 = 8,
    X_BUTTON2 = 16,
    // SHIFT = 1, this enum value conflicts with LEFT_BUTTON
    // CTRL = 2, this enum value conflicts with RIGHT_BUTTON
    // ALT = 4, this enum value conflicts with MIDDLE_BUTTON
};
pub const MSVIDCTL_LEFT_BUTTON = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_RIGHT_BUTTON = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_MIDDLE_BUTTON = MSVidCtlButtonstate.MIDDLE_BUTTON;
pub const MSVIDCTL_X_BUTTON1 = MSVidCtlButtonstate.X_BUTTON1;
pub const MSVIDCTL_X_BUTTON2 = MSVidCtlButtonstate.X_BUTTON2;
pub const MSVIDCTL_SHIFT = MSVidCtlButtonstate.LEFT_BUTTON;
pub const MSVIDCTL_CTRL = MSVidCtlButtonstate.RIGHT_BUTTON;
pub const MSVIDCTL_ALT = MSVidCtlButtonstate.MIDDLE_BUTTON;

const IID_IMSVidGraphSegmentUserInput_Value = Guid.initString("301c060e-20d9-4587-9b03-f82ed9a9943c");
pub const IID_IMSVidGraphSegmentUserInput = &IID_IMSVidGraphSegmentUserInput_Value;
pub const IMSVidGraphSegmentUserInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Click: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DblClick: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyCode: ?*i16,
                ShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyCode: ?*i16,
                ShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyPress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyAscii: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyAscii: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeyUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyCode: ?*i16,
                ShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                KeyCode: ?*i16,
                ShiftState: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MouseDown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MouseMove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MouseUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGraphSegmentUserInput,
                ButtonState: i16,
                ShiftState: i16,
                x: i32,
                y: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_Click(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).Click(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_DblClick(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).DblClick(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyDown(self: *const T, KeyCode: ?*i16, ShiftState: i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyDown(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), KeyCode, ShiftState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyPress(self: *const T, KeyAscii: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyPress(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), KeyAscii);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_KeyUp(self: *const T, KeyCode: ?*i16, ShiftState: i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).KeyUp(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), KeyCode, ShiftState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseDown(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseDown(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), ButtonState, ShiftState, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseMove(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseMove(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), ButtonState, ShiftState, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGraphSegmentUserInput_MouseUp(self: *const T, ButtonState: i16, ShiftState: i16, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGraphSegmentUserInput.VTable, @ptrCast(self.vtable)).MouseUp(@as(*const IMSVidGraphSegmentUserInput, @ptrCast(self)), ButtonState, ShiftState, x, y);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidCompositionSegment_Value = Guid.initString("1c15d483-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidCompositionSegment = &IID_IMSVidCompositionSegment_Value;
pub const IMSVidCompositionSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        Compose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCompositionSegment,
                upstream: ?*IMSVidGraphSegment,
                downstream: ?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCompositionSegment,
                upstream: ?*IMSVidGraphSegment,
                downstream: ?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Up: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCompositionSegment,
                upstream: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCompositionSegment,
                upstream: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Down: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCompositionSegment,
                downstream: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCompositionSegment,
                downstream: ?*?*IMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_Compose(self: *const T, upstream: ?*IMSVidGraphSegment, downstream: ?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).Compose(@as(*const IMSVidCompositionSegment, @ptrCast(self)), upstream, downstream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_get_Up(self: *const T, upstream: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).get_Up(@as(*const IMSVidCompositionSegment, @ptrCast(self)), upstream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCompositionSegment_get_Down(self: *const T, downstream: ?*?*IMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCompositionSegment.VTable, @ptrCast(self.vtable)).get_Down(@as(*const IMSVidCompositionSegment, @ptrCast(self)), downstream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMSVidGraphSegment_Value = Guid.initString("3dd2903e-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IEnumMSVidGraphSegment = &IID_IEnumMSVidGraphSegment_Value;
pub const IEnumMSVidGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMSVidGraphSegment,
                celt: u32,
                rgelt: ?*?*IMSVidGraphSegment,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMSVidGraphSegment,
                celt: u32,
                rgelt: ?*?*IMSVidGraphSegment,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMSVidGraphSegment,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMSVidGraphSegment,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMSVidGraphSegment,
                ppenum: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMSVidGraphSegment,
                ppenum: ?*?*IEnumMSVidGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Next(self: *const T, celt: u32, rgelt: ?*?*IMSVidGraphSegment, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMSVidGraphSegment_Clone(self: *const T, ppenum: ?*?*IEnumMSVidGraphSegment) callconv(.Inline) HRESULT {
            return @as(*const IEnumMSVidGraphSegment.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMSVidGraphSegment, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVRGraphSegment_Value = Guid.initString("dd47de3f-9874-4f7b-8b22-7cb2688461e7");
pub const IID_IMSVidVRGraphSegment = &IID_IMSVidVRGraphSegment_Value;
pub const IMSVidVRGraphSegment = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGraphSegment.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VMRendererMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                dwMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                dwMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                Window: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                Window: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                Window: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                Window: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseOverlay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                UseOverlayVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                UseOverlayVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseOverlay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                UseOverlayVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                UseOverlayVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                Visible: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                Visible: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                Visible: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                Visible: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                ColorKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                ColorKey: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                ColorKey: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                ColorKey: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Source: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                r: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                r: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Source: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                r: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                r: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Destination: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                r: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                r: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Destination: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                r: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                r: RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_NativeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                sizeval: ?*SIZE,
                aspectratio: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                sizeval: ?*SIZE,
                aspectratio: ?*SIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                color: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                color: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                color: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                fMaintain: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                fMaintain: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                fMaintain: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                fMaintain: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RePaint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVRGraphSegment,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVRGraphSegment,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGraphSegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put__VMRendererMode(self: *const T, dwMode: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put__VMRendererMode(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), dwMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Owner(self: *const T, Window: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Owner(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), Window);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Owner(self: *const T, Window: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Owner(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), Window);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_UseOverlay(self: *const T, UseOverlayVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_UseOverlay(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_UseOverlay(self: *const T, UseOverlayVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_UseOverlay(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Visible(self: *const T, Visible: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Visible(self: *const T, Visible: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_ColorKey(self: *const T, ColorKey: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_ColorKey(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), ColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_ColorKey(self: *const T, ColorKey: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_ColorKey(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), ColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Source(self: *const T, r: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Source(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Source(self: *const T, r: RECT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Source(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_Destination(self: *const T, r: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_Destination(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_Destination(self: *const T, r: RECT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_Destination(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), r);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_NativeSize(self: *const T, sizeval: ?*SIZE, aspectratio: ?*SIZE) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_NativeSize(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), sizeval, aspectratio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_BorderColor(self: *const T, color: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_BorderColor(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_BorderColor(self: *const T, color: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_BorderColor(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_get_MaintainAspectRatio(self: *const T, fMaintain: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).get_MaintainAspectRatio(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), fMaintain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_put_MaintainAspectRatio(self: *const T, fMaintain: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).put_MaintainAspectRatio(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), fMaintain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IMSVidVRGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_DisplayChange(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).DisplayChange(@as(*const IMSVidVRGraphSegment, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVRGraphSegment_RePaint(self: *const T, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVRGraphSegment.VTable, @ptrCast(self.vtable)).RePaint(@as(*const IMSVidVRGraphSegment, @ptrCast(self)), hdc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDevice_Value = Guid.initString("1c15d47c-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDevice = &IID_IMSVidDevice_Value;
pub const IMSVidDevice = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Status: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Status: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Status: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Power: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Power: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Power: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Power: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Power: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Power: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Guid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClassID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Clsid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Clsid: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Category: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__ClassID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice,
                Clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice,
                Clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidDevice,
                Device: ?*IMSVidDevice,
                IsEqual: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidDevice,
                Device: ?*IMSVidDevice,
                IsEqual: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Name(self: *const T, Name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IMSVidDevice, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Status(self: *const T, Status: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Status(@as(*const IMSVidDevice, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_put_Power(self: *const T, Power: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).put_Power(@as(*const IMSVidDevice, @ptrCast(self)), Power);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Power(self: *const T, Power: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Power(@as(*const IMSVidDevice, @ptrCast(self)), Power);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_Category(self: *const T, _param_Guid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_Category(@as(*const IMSVidDevice, @ptrCast(self)), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get_ClassID(self: *const T, Clsid: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get_ClassID(@as(*const IMSVidDevice, @ptrCast(self)), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get__Category(self: *const T, _param_Guid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get__Category(@as(*const IMSVidDevice, @ptrCast(self)), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_get__ClassID(self: *const T, Clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).get__ClassID(@as(*const IMSVidDevice, @ptrCast(self)), Clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice_IsEqualDevice(self: *const T, Device: ?*IMSVidDevice, IsEqual: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice.VTable, @ptrCast(self.vtable)).IsEqualDevice(@as(*const IMSVidDevice, @ptrCast(self)), Device, IsEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDevice2_Value = Guid.initString("87bd2783-ebc0-478c-b4a0-e8e7f43ab78e");
pub const IID_IMSVidDevice2 = &IID_IMSVidDevice2_Value;
pub const IMSVidDevice2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePath: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidDevice2,
                DevPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidDevice2,
                DevPath: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDevice2_get_DevicePath(self: *const T, DevPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDevice2.VTable, @ptrCast(self.vtable)).get_DevicePath(@as(*const IMSVidDevice2, @ptrCast(self)), DevPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevice_Value = Guid.initString("37b0353d-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDevice = &IID_IMSVidInputDevice_Value;
pub const IMSVidInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
        IsViewable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidInputDevice,
                v: ?*VARIANT,
                pfViewable: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidInputDevice,
                v: ?*VARIANT,
                pfViewable: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        View: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidInputDevice,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidInputDevice,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevice_IsViewable(self: *const T, v: ?*VARIANT, pfViewable: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevice.VTable, @ptrCast(self.vtable)).IsViewable(@as(*const IMSVidInputDevice, @ptrCast(self)), v, pfViewable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevice_View(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevice.VTable, @ptrCast(self.vtable)).View(@as(*const IMSVidInputDevice, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDeviceEvent_Value = Guid.initString("1c15d480-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidDeviceEvent = &IID_IMSVidDeviceEvent_Value;
pub const IMSVidDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        StateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidDeviceEvent,
                lpd: ?*IMSVidDevice,
                oldState: i32,
                newState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidDeviceEvent,
                lpd: ?*IMSVidDevice,
                oldState: i32,
                newState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidDeviceEvent_StateChange(self: *const T, lpd: ?*IMSVidDevice, oldState: i32, newState: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidDeviceEvent.VTable, @ptrCast(self.vtable)).StateChange(@as(*const IMSVidDeviceEvent, @ptrCast(self)), lpd, oldState, newState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidInputDeviceEvent_Value = Guid.initString("37b0353e-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidInputDeviceEvent = &IID_IMSVidInputDeviceEvent_Value;
pub const IMSVidInputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoInputDevice_Value = Guid.initString("1c15d47f-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidVideoInputDevice = &IID_IMSVidVideoInputDevice_Value;
pub const IMSVidVideoInputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidPlayback_Value = Guid.initString("37b03538-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlayback = &IID_IMSVidPlayback_Value;
pub const IMSVidPlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableResetOnStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableResetOnStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_CanStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlayback,
                fBackwards: VARIANT_BOOL,
                pfCan: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlayback,
                fBackwards: VARIANT_BOOL,
                pfCan: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Step: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lStep: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlayback,
                lStep: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                plRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                plRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                plRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                plRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                lPosition: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                lPosition: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PositionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lPositionMode: PositionModeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                lPositionMode: PositionModeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PositionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lPositionMode: ?*PositionModeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                lPositionMode: ?*PositionModeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidPlayback,
                lLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidPlayback,
                lLength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_EnableResetOnStop(self: *const T, pVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_EnableResetOnStop(@as(*const IMSVidPlayback, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_EnableResetOnStop(self: *const T, newVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_EnableResetOnStop(@as(*const IMSVidPlayback, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Run(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Run(@as(*const IMSVidPlayback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMSVidPlayback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidPlayback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_CanStep(self: *const T, fBackwards: VARIANT_BOOL, pfCan: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_CanStep(@as(*const IMSVidPlayback, @ptrCast(self)), fBackwards, pfCan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_Step(self: *const T, lStep: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).Step(@as(*const IMSVidPlayback, @ptrCast(self)), lStep);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_Rate(self: *const T, plRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IMSVidPlayback, @ptrCast(self)), plRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_Rate(self: *const T, plRate: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IMSVidPlayback, @ptrCast(self)), plRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_CurrentPosition(self: *const T, lPosition: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_CurrentPosition(@as(*const IMSVidPlayback, @ptrCast(self)), lPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_CurrentPosition(self: *const T, lPosition: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_CurrentPosition(@as(*const IMSVidPlayback, @ptrCast(self)), lPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_put_PositionMode(self: *const T, lPositionMode: PositionModeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).put_PositionMode(@as(*const IMSVidPlayback, @ptrCast(self)), lPositionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_PositionMode(self: *const T, lPositionMode: ?*PositionModeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_PositionMode(@as(*const IMSVidPlayback, @ptrCast(self)), lPositionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlayback_get_Length(self: *const T, lLength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlayback.VTable, @ptrCast(self.vtable)).get_Length(@as(*const IMSVidPlayback, @ptrCast(self)), lLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidPlaybackEvent_Value = Guid.initString("37b0353b-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidPlaybackEvent = &IID_IMSVidPlaybackEvent_Value;
pub const IMSVidPlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        EndOfMedia: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidPlaybackEvent,
                lpd: ?*IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidPlaybackEvent,
                lpd: ?*IMSVidPlayback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidPlaybackEvent_EndOfMedia(self: *const T, lpd: ?*IMSVidPlayback) callconv(.Inline) HRESULT {
            return @as(*const IMSVidPlaybackEvent.VTable, @ptrCast(self.vtable)).EndOfMedia(@as(*const IMSVidPlaybackEvent, @ptrCast(self)), lpd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidTuner_Value = Guid.initString("1c15d47d-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTuner = &IID_IMSVidTuner_Value;
pub const IMSVidTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoInputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Tune: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidTuner,
                ppTR: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidTuner,
                ppTR: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Tune: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidTuner,
                pTR: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidTuner,
                pTR: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidTuner,
                plTS: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidTuner,
                plTS: ?*?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidTuner,
                plTS: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidTuner,
                plTS: ?*ITuningSpace,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoInputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_get_Tune(self: *const T, ppTR: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).get_Tune(@as(*const IMSVidTuner, @ptrCast(self)), ppTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_put_Tune(self: *const T, pTR: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).put_Tune(@as(*const IMSVidTuner, @ptrCast(self)), pTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_get_TuningSpace(self: *const T, plTS: ?*?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const IMSVidTuner, @ptrCast(self)), plTS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTuner_put_TuningSpace(self: *const T, plTS: ?*ITuningSpace) callconv(.Inline) HRESULT {
            return @as(*const IMSVidTuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const IMSVidTuner, @ptrCast(self)), plTS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidTunerEvent_Value = Guid.initString("1c15d485-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidTunerEvent = &IID_IMSVidTunerEvent_Value;
pub const IMSVidTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidInputDeviceEvent.VTable,
        TuneChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidTunerEvent,
                lpd: ?*IMSVidTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidTunerEvent,
                lpd: ?*IMSVidTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidInputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidTunerEvent_TuneChanged(self: *const T, lpd: ?*IMSVidTuner) callconv(.Inline) HRESULT {
            return @as(*const IMSVidTunerEvent.VTable, @ptrCast(self.vtable)).TuneChanged(@as(*const IMSVidTunerEvent, @ptrCast(self)), lpd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAnalogTuner_Value = Guid.initString("1c15d47e-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTuner = &IID_IMSVidAnalogTuner_Value;
pub const IMSVidAnalogTuner = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Channel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                Channel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                Channel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Channel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                Channel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                Channel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                lcc: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                lcc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                lcc: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SAP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                pfSapOn: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                pfSapOn: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SAP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                fSapOn: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                fSapOn: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChannelAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAnalogTuner,
                nChannel: i32,
                SignalStrength: ?*i32,
                fSignalPresent: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAnalogTuner,
                nChannel: i32,
                SignalStrength: ?*i32,
                fSignalPresent: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_Channel(self: *const T, Channel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IMSVidAnalogTuner, @ptrCast(self)), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_Channel(self: *const T, Channel: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IMSVidAnalogTuner, @ptrCast(self)), Channel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_VideoFrequency(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_VideoFrequency(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_AudioFrequency(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_AudioFrequency(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_CountryCode(self: *const T, lcc: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_CountryCode(self: *const T, lcc: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IMSVidAnalogTuner, @ptrCast(self)), lcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_get_SAP(self: *const T, pfSapOn: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).get_SAP(@as(*const IMSVidAnalogTuner, @ptrCast(self)), pfSapOn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_put_SAP(self: *const T, fSapOn: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).put_SAP(@as(*const IMSVidAnalogTuner, @ptrCast(self)), fSapOn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner_ChannelAvailable(self: *const T, nChannel: i32, SignalStrength: ?*i32, fSignalPresent: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner.VTable, @ptrCast(self.vtable)).ChannelAvailable(@as(*const IMSVidAnalogTuner, @ptrCast(self)), nChannel, SignalStrength, fSignalPresent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTuner2_Value = Guid.initString("37647bf7-3dde-4cc8-a4dc-0d534d3d0037");
pub const IID_IMSVidAnalogTuner2 = &IID_IMSVidAnalogTuner2_Value;
pub const IMSVidAnalogTuner2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAnalogTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormats: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner2,
                Formats: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner2,
                Formats: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TunerModes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner2,
                Modes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner2,
                Modes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumAuxInputs: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAnalogTuner2,
                Inputs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAnalogTuner2,
                Inputs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidAnalogTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_TVFormats(self: *const T, Formats: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_TVFormats(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), Formats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_TunerModes(self: *const T, Modes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_TunerModes(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), Modes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAnalogTuner2_get_NumAuxInputs(self: *const T, Inputs: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAnalogTuner2.VTable, @ptrCast(self.vtable)).get_NumAuxInputs(@as(*const IMSVidAnalogTuner2, @ptrCast(self)), Inputs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAnalogTunerEvent_Value = Guid.initString("1c15d486-911d-11d2-b632-00c04f79498e");
pub const IID_IMSVidAnalogTunerEvent = &IID_IMSVidAnalogTunerEvent_Value;
pub const IMSVidAnalogTunerEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidTunerEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidTunerEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFilePlayback_Value = Guid.initString("37b03539-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlayback = &IID_IMSVidFilePlayback_Value;
pub const IMSVidFilePlayback = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFilePlayback,
                FileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFilePlayback,
                FileName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FileName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFilePlayback,
                FileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFilePlayback,
                FileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback_get_FileName(self: *const T, FileName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFilePlayback.VTable, @ptrCast(self.vtable)).get_FileName(@as(*const IMSVidFilePlayback, @ptrCast(self)), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback_put_FileName(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFilePlayback.VTable, @ptrCast(self.vtable)).put_FileName(@as(*const IMSVidFilePlayback, @ptrCast(self)), FileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlayback2_Value = Guid.initString("2f7e44af-6e52-4660-bc08-d8d542587d72");
pub const IID_IMSVidFilePlayback2 = &IID_IMSVidFilePlayback2_Value;
pub const IMSVidFilePlayback2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__SourceFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFilePlayback2,
                FileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFilePlayback2,
                FileName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put___SourceFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFilePlayback2,
                FileName: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFilePlayback2,
                FileName: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback2_put__SourceFilter(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFilePlayback2.VTable, @ptrCast(self.vtable)).put__SourceFilter(@as(*const IMSVidFilePlayback2, @ptrCast(self)), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFilePlayback2_put___SourceFilter(self: *const T, FileName: Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFilePlayback2.VTable, @ptrCast(self.vtable)).put___SourceFilter(@as(*const IMSVidFilePlayback2, @ptrCast(self)), FileName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFilePlaybackEvent_Value = Guid.initString("37b0353a-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFilePlaybackEvent = &IID_IMSVidFilePlaybackEvent_Value;
pub const IMSVidFilePlaybackEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVDMenuIDConstants = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const dvdMenu_Title = DVDMenuIDConstants.Title;
pub const dvdMenu_Root = DVDMenuIDConstants.Root;
pub const dvdMenu_Subpicture = DVDMenuIDConstants.Subpicture;
pub const dvdMenu_Audio = DVDMenuIDConstants.Audio;
pub const dvdMenu_Angle = DVDMenuIDConstants.Angle;
pub const dvdMenu_Chapter = DVDMenuIDConstants.Chapter;

pub const DVDFilterState = enum(i32) {
    Undefined = -2,
    Unitialized = -1,
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const dvdState_Undefined = DVDFilterState.Undefined;
pub const dvdState_Unitialized = DVDFilterState.Unitialized;
pub const dvdState_Stopped = DVDFilterState.Stopped;
pub const dvdState_Paused = DVDFilterState.Paused;
pub const dvdState_Running = DVDFilterState.Running;

pub const DVDTextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const dvdStruct_Volume = DVDTextStringType.Struct_Volume;
pub const dvdStruct_Title = DVDTextStringType.Struct_Title;
pub const dvdStruct_ParentalID = DVDTextStringType.Struct_ParentalID;
pub const dvdStruct_PartOfTitle = DVDTextStringType.Struct_PartOfTitle;
pub const dvdStruct_Cell = DVDTextStringType.Struct_Cell;
pub const dvdStream_Audio = DVDTextStringType.Stream_Audio;
pub const dvdStream_Subpicture = DVDTextStringType.Stream_Subpicture;
pub const dvdStream_Angle = DVDTextStringType.Stream_Angle;
pub const dvdChannel_Audio = DVDTextStringType.Channel_Audio;
pub const dvdGeneral_Name = DVDTextStringType.General_Name;
pub const dvdGeneral_Comments = DVDTextStringType.General_Comments;
pub const dvdTitle_Series = DVDTextStringType.Title_Series;
pub const dvdTitle_Movie = DVDTextStringType.Title_Movie;
pub const dvdTitle_Video = DVDTextStringType.Title_Video;
pub const dvdTitle_Album = DVDTextStringType.Title_Album;
pub const dvdTitle_Song = DVDTextStringType.Title_Song;
pub const dvdTitle_Other = DVDTextStringType.Title_Other;
pub const dvdTitle_Sub_Series = DVDTextStringType.Title_Sub_Series;
pub const dvdTitle_Sub_Movie = DVDTextStringType.Title_Sub_Movie;
pub const dvdTitle_Sub_Video = DVDTextStringType.Title_Sub_Video;
pub const dvdTitle_Sub_Album = DVDTextStringType.Title_Sub_Album;
pub const dvdTitle_Sub_Song = DVDTextStringType.Title_Sub_Song;
pub const dvdTitle_Sub_Other = DVDTextStringType.Title_Sub_Other;
pub const dvdTitle_Orig_Series = DVDTextStringType.Title_Orig_Series;
pub const dvdTitle_Orig_Movie = DVDTextStringType.Title_Orig_Movie;
pub const dvdTitle_Orig_Video = DVDTextStringType.Title_Orig_Video;
pub const dvdTitle_Orig_Album = DVDTextStringType.Title_Orig_Album;
pub const dvdTitle_Orig_Song = DVDTextStringType.Title_Orig_Song;
pub const dvdTitle_Orig_Other = DVDTextStringType.Title_Orig_Other;
pub const dvdOther_Scene = DVDTextStringType.Other_Scene;
pub const dvdOther_Cut = DVDTextStringType.Other_Cut;
pub const dvdOther_Take = DVDTextStringType.Other_Take;

pub const DVDSPExt = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const dvdSPExt_NotSpecified = DVDSPExt.NotSpecified;
pub const dvdSPExt_Caption_Normal = DVDSPExt.Caption_Normal;
pub const dvdSPExt_Caption_Big = DVDSPExt.Caption_Big;
pub const dvdSPExt_Caption_Children = DVDSPExt.Caption_Children;
pub const dvdSPExt_CC_Normal = DVDSPExt.CC_Normal;
pub const dvdSPExt_CC_Big = DVDSPExt.CC_Big;
pub const dvdSPExt_CC_Children = DVDSPExt.CC_Children;
pub const dvdSPExt_Forced = DVDSPExt.Forced;
pub const dvdSPExt_DirectorComments_Normal = DVDSPExt.DirectorComments_Normal;
pub const dvdSPExt_DirectorComments_Big = DVDSPExt.DirectorComments_Big;
pub const dvdSPExt_DirectorComments_Children = DVDSPExt.DirectorComments_Children;

const IID_IMSVidWebDVD_Value = Guid.initString("cf45f88b-ac56-4ee2-a73a-ed04e2885d3c");
pub const IID_IMSVidWebDVD = &IID_IMSVidWebDVD_Value;
pub const IMSVidWebDVD = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlayback.VTable,
        OnDVDEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lEvent: i32,
                lParam1: isize,
                lParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lEvent: i32,
                lParam1: isize,
                lParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapterInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                lChapter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                lChapter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lChapter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lChapter: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChaptersAutoStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                lstrChapter: i32,
                lChapterCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                lstrChapter: i32,
                lChapterCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                strTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                strTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTimeInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                strTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                strTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayPeriodInTitleAutoStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                strStartTime: ?BSTR,
                strEndTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                strStartTime: ?BSTR,
                strEndTime: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayPrevChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayNextChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StillOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_AudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                fFormat: VARIANT_BOOL,
                strAudioLang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                fFormat: VARIANT_BOOL,
                strAudioLang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                MenuID: DVDMenuIDConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                MenuID: DVDMenuIDConstants,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnFromSubmenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ButtonsAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentButton: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAndActivateButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lButton: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lButton: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectRightButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectLeftButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectLowerButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectUpperButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ButtonAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
                plButton: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                xPos: i32,
                yPos: i32,
                plButton: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_NumberOfChapters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TotalTitleTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TitlesAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VolumesAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentVolume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDiscSide: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentDomain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentChapter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTitle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DVDTimeCode2bstr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                timeCode: i32,
                pTimeStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                timeCode: i32,
                pTimeStr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDDirectory: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubpictureStreamEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lstream: i32,
                fEnabled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lstream: i32,
                fEnabled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAudioStreamEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lstream: i32,
                fEnabled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lstream: i32,
                fEnabled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentSubpictureStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentSubpictureStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                strLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                strLanguage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAudioStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAudioStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioStreamsAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AnglesAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentAngle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentAngle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureStreamsAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubpictureOn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubpictureOn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDUniqueID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcceptParentalLevelChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                fAccept: VARIANT_BOOL,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                fAccept: VARIANT_BOOL,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyParentalLevelChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectParentalCountry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lCountry: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lCountry: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lParentalLevel: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lParentalLevel: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_TitleParentalLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                plParentalLevels: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lTitle: i32,
                plParentalLevels: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalCountry: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlayerParentalLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                plParentalLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                plParentalLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Eject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UOPValid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lUOP: i32,
                pfValid: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lUOP: i32,
                pfValid: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SPRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                psSPRM: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                psSPRM: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_GPRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                psSPRM: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                psSPRM: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_GPRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                sValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lIndex: i32,
                sValue: i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DVDTextStringType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lStringIndex: i32,
                pType: ?*DVDTextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lStringIndex: i32,
                pType: ?*DVDTextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DVDTextString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lStringIndex: i32,
                pstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lStringIndex: i32,
                pstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DVDTextNumberOfStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                plNumOfStrings: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                plNumOfStrings: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDTextNumberOfLanguages: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                plNumOfLangs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                plNumOfLangs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DVDTextLanguageLCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lcid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lLangIndex: i32,
                lcid: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDAdm: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveBookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectDefaultAudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: i32,
                ext: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: i32,
                ext: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectDefaultSubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: i32,
                ext: DVDSPExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: i32,
                ext: DVDSPExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PreferredSubpictureStream: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                lang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLanguageExt: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                ext: ?*DVDSPExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                ext: ?*DVDSPExt,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLanguageExt: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                ext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                ext: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_LanguageFromLCID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lcid: i32,
                lang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lcid: i32,
                lang: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KaraokeAudioPresentationMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KaraokeAudioPresentationMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_KaraokeChannelContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                lChan: i32,
                lContent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                lChan: i32,
                lContent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_KaraokeChannelAssignment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                lChannelAssignment: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lStream: i32,
                lChannelAssignment: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestorePreferredSettings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ButtonRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                lButton: i32,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD,
                lButton: i32,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DVDScreenInMouseCoordinates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                ppRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                ppRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DVDScreenInMouseCoordinates: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVD,
                pRect: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVD,
                pRect: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_OnDVDEvent(self: *const T, lEvent: i32, lParam1: isize, lParam2: isize) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).OnDVDEvent(@as(*const IMSVidWebDVD, @ptrCast(self)), lEvent, lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayTitle(self: *const T, lTitle: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChapterInTitle(self: *const T, lTitle: i32, lChapter: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, lChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChapter(self: *const T, lChapter: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IMSVidWebDVD, @ptrCast(self)), lChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayChaptersAutoStop(self: *const T, lTitle: i32, lstrChapter: i32, lChapterCount: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayChaptersAutoStop(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, lstrChapter, lChapterCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayAtTime(self: *const T, strTime: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IMSVidWebDVD, @ptrCast(self)), strTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayAtTimeInTitle(self: *const T, lTitle: i32, strTime: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, strTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayPeriodInTitleAutoStop(self: *const T, lTitle: i32, strStartTime: ?BSTR, strEndTime: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayPeriodInTitleAutoStop(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, strStartTime, strEndTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ReplayChapter(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayPrevChapter(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_PlayNextChapter(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AudioLanguage(self: *const T, lStream: i32, fFormat: VARIANT_BOOL, strAudioLang: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lStream, fFormat, strAudioLang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ShowMenu(self: *const T, MenuID: DVDMenuIDConstants) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IMSVidWebDVD, @ptrCast(self)), MenuID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).Resume(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ReturnFromSubmenu(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentButton(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentButton(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectAndActivateButton(self: *const T, lButton: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectAndActivateButton(@as(*const IMSVidWebDVD, @ptrCast(self)), lButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ActivateButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ActivateButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectRightButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectRightButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectLeftButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectLeftButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectLowerButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectLowerButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectUpperButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectUpperButton(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_ActivateAtPosition(self: *const T, xPos: i32, yPos: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).ActivateAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), xPos, yPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectAtPosition(self: *const T, xPos: i32, yPos: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), xPos, yPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonAtPosition(self: *const T, xPos: i32, yPos: i32, plButton: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonAtPosition(@as(*const IMSVidWebDVD, @ptrCast(self)), xPos, yPos, plButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_NumberOfChapters(self: *const T, lTitle: i32, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_NumberOfChapters(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TotalTitleTime(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TotalTitleTime(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TitlesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TitlesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_VolumesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_VolumesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentVolume(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentVolume(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentDiscSide(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentDiscSide(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentDomain(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentDomain(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentChapter(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentChapter(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentTitle(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentTitle(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentTime(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentTime(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_DVDTimeCode2bstr(self: *const T, timeCode: i32, pTimeStr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).DVDTimeCode2bstr(@as(*const IMSVidWebDVD, @ptrCast(self)), timeCode, pTimeStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDDirectory(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDDirectory(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DVDDirectory(self: *const T, newVal: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DVDDirectory(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_IsSubpictureStreamEnabled(self: *const T, lstream: i32, fEnabled: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).IsSubpictureStreamEnabled(@as(*const IMSVidWebDVD, @ptrCast(self)), lstream, fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_IsAudioStreamEnabled(self: *const T, lstream: i32, fEnabled: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).IsAudioStreamEnabled(@as(*const IMSVidWebDVD, @ptrCast(self)), lstream, fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentSubpictureStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentSubpictureStream(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureLanguage(self: *const T, lStream: i32, strLanguage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lStream, strLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentAudioStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentAudioStream(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentAudioStream(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentAudioStream(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AudioStreamsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AudioStreamsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_AnglesAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_AnglesAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_CurrentAngle(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_CurrentAngle(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_CurrentAngle(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_CurrentAngle(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureStreamsAvailable(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureStreamsAvailable(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SubpictureOn(self: *const T, pVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SubpictureOn(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_SubpictureOn(self: *const T, newVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_SubpictureOn(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDUniqueID(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDUniqueID(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_AcceptParentalLevelChange(self: *const T, fAccept: VARIANT_BOOL, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).AcceptParentalLevelChange(@as(*const IMSVidWebDVD, @ptrCast(self)), fAccept, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_NotifyParentalLevelChange(self: *const T, newVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).NotifyParentalLevelChange(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectParentalCountry(self: *const T, lCountry: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectParentalCountry(@as(*const IMSVidWebDVD, @ptrCast(self)), lCountry, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectParentalLevel(self: *const T, lParentalLevel: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectParentalLevel(@as(*const IMSVidWebDVD, @ptrCast(self)), lParentalLevel, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_TitleParentalLevels(self: *const T, lTitle: i32, plParentalLevels: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_TitleParentalLevels(@as(*const IMSVidWebDVD, @ptrCast(self)), lTitle, plParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PlayerParentalCountry(self: *const T, plCountryCode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PlayerParentalCountry(@as(*const IMSVidWebDVD, @ptrCast(self)), plCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PlayerParentalLevel(self: *const T, plParentalLevel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PlayerParentalLevel(@as(*const IMSVidWebDVD, @ptrCast(self)), plParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_Eject(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).Eject(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_UOPValid(self: *const T, lUOP: i32, pfValid: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).UOPValid(@as(*const IMSVidWebDVD, @ptrCast(self)), lUOP, pfValid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_SPRM(self: *const T, lIndex: i32, psSPRM: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_SPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), lIndex, psSPRM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_GPRM(self: *const T, lIndex: i32, psSPRM: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_GPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), lIndex, psSPRM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_GPRM(self: *const T, lIndex: i32, sValue: i16) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_GPRM(@as(*const IMSVidWebDVD, @ptrCast(self)), lIndex, sValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextStringType(self: *const T, lLangIndex: i32, lStringIndex: i32, pType: ?*DVDTextStringType) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextStringType(@as(*const IMSVidWebDVD, @ptrCast(self)), lLangIndex, lStringIndex, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextString(self: *const T, lLangIndex: i32, lStringIndex: i32, pstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextString(@as(*const IMSVidWebDVD, @ptrCast(self)), lLangIndex, lStringIndex, pstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextNumberOfStrings(self: *const T, lLangIndex: i32, plNumOfStrings: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextNumberOfStrings(@as(*const IMSVidWebDVD, @ptrCast(self)), lLangIndex, plNumOfStrings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextNumberOfLanguages(self: *const T, plNumOfLangs: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextNumberOfLanguages(@as(*const IMSVidWebDVD, @ptrCast(self)), plNumOfLangs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDTextLanguageLCID(self: *const T, lLangIndex: i32, lcid: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDTextLanguageLCID(@as(*const IMSVidWebDVD, @ptrCast(self)), lLangIndex, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RegionChange(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RegionChange(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDAdm(self: *const T, pVal: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDAdm(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_DeleteBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).DeleteBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RestoreBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RestoreBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SaveBookmark(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SaveBookmark(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectDefaultAudioLanguage(self: *const T, lang: i32, ext: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectDefaultAudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang, ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_SelectDefaultSubpictureLanguage(self: *const T, lang: i32, ext: DVDSPExt) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).SelectDefaultSubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang, ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_PreferredSubpictureStream(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_PreferredSubpictureStream(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultMenuLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultMenuLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DefaultMenuLanguage(self: *const T, lang: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DefaultMenuLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultSubpictureLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultAudioLanguage(self: *const T, lang: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultAudioLanguage(@as(*const IMSVidWebDVD, @ptrCast(self)), lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultSubpictureLanguageExt(self: *const T, ext: ?*DVDSPExt) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLanguageExt(@as(*const IMSVidWebDVD, @ptrCast(self)), ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DefaultAudioLanguageExt(self: *const T, ext: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DefaultAudioLanguageExt(@as(*const IMSVidWebDVD, @ptrCast(self)), ext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_LanguageFromLCID(self: *const T, lcid: i32, lang: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_LanguageFromLCID(@as(*const IMSVidWebDVD, @ptrCast(self)), lcid, lang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeAudioPresentationMode(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeAudioPresentationMode(@as(*const IMSVidWebDVD, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_KaraokeAudioPresentationMode(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_KaraokeAudioPresentationMode(@as(*const IMSVidWebDVD, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeChannelContent(self: *const T, lStream: i32, lChan: i32, lContent: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeChannelContent(@as(*const IMSVidWebDVD, @ptrCast(self)), lStream, lChan, lContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_KaraokeChannelAssignment(self: *const T, lStream: i32, lChannelAssignment: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_KaraokeChannelAssignment(@as(*const IMSVidWebDVD, @ptrCast(self)), lStream, lChannelAssignment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_RestorePreferredSettings(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).RestorePreferredSettings(@as(*const IMSVidWebDVD, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_ButtonRect(self: *const T, lButton: i32, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_ButtonRect(@as(*const IMSVidWebDVD, @ptrCast(self)), lButton, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_get_DVDScreenInMouseCoordinates(self: *const T, ppRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).get_DVDScreenInMouseCoordinates(@as(*const IMSVidWebDVD, @ptrCast(self)), ppRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD_put_DVDScreenInMouseCoordinates(self: *const T, pRect: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD.VTable, @ptrCast(self.vtable)).put_DVDScreenInMouseCoordinates(@as(*const IMSVidWebDVD, @ptrCast(self)), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidWebDVD2_Value = Guid.initString("7027212f-ee9a-4a7c-8b67-f023714cdaff");
pub const IID_IMSVidWebDVD2 = &IID_IMSVidWebDVD2_Value;
pub const IMSVidWebDVD2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidWebDVD.VTable,
        get_Bookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD2,
                ppData: [*]?*u8,
                pDataLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD2,
                ppData: [*]?*u8,
                pDataLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Bookmark: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVD2,
                pData: ?*u8,
                dwDataLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVD2,
                pData: ?*u8,
                dwDataLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidWebDVD.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD2_get_Bookmark(self: *const T, ppData: [*]?*u8, pDataLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD2.VTable, @ptrCast(self.vtable)).get_Bookmark(@as(*const IMSVidWebDVD2, @ptrCast(self)), ppData, pDataLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVD2_put_Bookmark(self: *const T, pData: ?*u8, dwDataLength: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVD2.VTable, @ptrCast(self.vtable)).put_Bookmark(@as(*const IMSVidWebDVD2, @ptrCast(self)), pData, dwDataLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDEvent_Value = Guid.initString("b4f7a674-9b83-49cb-a357-c63b871be958");
pub const IID_IMSVidWebDVDEvent = &IID_IMSVidWebDVDEvent_Value;
pub const IMSVidWebDVDEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidPlaybackEvent.VTable,
        DVDNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                lEventCode: i32,
                lParam1: VARIANT,
                lParam2: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                lEventCode: i32,
                lParam1: VARIANT,
                lParam2: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayForwards: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayBackwards: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                MenuID: DVDMenuIDConstants,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                MenuID: DVDMenuIDConstants,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectOrActivateButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StillOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseOn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCurrentAudioStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCurrentSubpictureStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeCurrentAngle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTimeInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapterInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayNextChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnFromSubmenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayPrevChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeKaraokePresMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeVideoPresMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDEvent,
                bEnabled: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidPlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_DVDNotify(self: *const T, lEventCode: i32, lParam1: VARIANT, lParam2: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).DVDNotify(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), lEventCode, lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayForwards(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayForwards(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayBackwards(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayBackwards(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ShowMenu(self: *const T, MenuID: DVDMenuIDConstants, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), MenuID, bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_Resume(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).Resume(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_SelectOrActivateButton(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).SelectOrActivateButton(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_StillOff(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PauseOn(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PauseOn(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentAudioStream(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentAudioStream(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentSubpictureStream(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentSubpictureStream(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeCurrentAngle(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeCurrentAngle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayAtTimeInTitle(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayAtTime(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayChapterInTitle(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayChapter(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ReplayChapter(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayNextChapter(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_Stop(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ReturnFromSubmenu(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayTitle(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_PlayPrevChapter(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeKaraokePresMode(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeKaraokePresMode(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDEvent_ChangeVideoPresMode(self: *const T, bEnabled: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDEvent.VTable, @ptrCast(self.vtable)).ChangeVideoPresMode(@as(*const IMSVidWebDVDEvent, @ptrCast(self)), bEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidWebDVDAdm_Value = Guid.initString("b8be681a-eb2c-47f0-b415-94d5452f0e05");
pub const IID_IMSVidWebDVDAdm = &IID_IMSVidWebDVDAdm_Value;
pub const IMSVidWebDVDAdm = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ChangePassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                strUserName: ?BSTR,
                strOld: ?BSTR,
                strNew: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                strUserName: ?BSTR,
                strOld: ?BSTR,
                strNew: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                level: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                level: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SaveParentalCountry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                country: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                country: i32,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfirmPassword: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                strUserName: ?BSTR,
                strPassword: ?BSTR,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                lLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                lLevel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentalCountry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                lCountry: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                lCountry: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultAudioLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultAudioLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultSubpictureLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultSubpictureLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DefaultMenuLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DefaultMenuLCID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                newVal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BookmarkOnStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                pVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BookmarkOnStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidWebDVDAdm,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidWebDVDAdm,
                newVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_ChangePassword(self: *const T, strUserName: ?BSTR, strOld: ?BSTR, strNew: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).ChangePassword(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), strUserName, strOld, strNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_SaveParentalLevel(self: *const T, level: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).SaveParentalLevel(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), level, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_SaveParentalCountry(self: *const T, country: i32, strUserName: ?BSTR, strPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).SaveParentalCountry(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), country, strUserName, strPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_ConfirmPassword(self: *const T, strUserName: ?BSTR, strPassword: ?BSTR, pVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).ConfirmPassword(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), strUserName, strPassword, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_GetParentalLevel(self: *const T, lLevel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).GetParentalLevel(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), lLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_GetParentalCountry(self: *const T, lCountry: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).GetParentalCountry(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), lCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultAudioLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultAudioLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultAudioLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultAudioLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultSubpictureLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultSubpictureLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultSubpictureLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultSubpictureLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_DefaultMenuLCID(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_DefaultMenuLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_DefaultMenuLCID(self: *const T, newVal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_DefaultMenuLCID(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), newVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_get_BookmarkOnStop(self: *const T, pVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).get_BookmarkOnStop(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidWebDVDAdm_put_BookmarkOnStop(self: *const T, newVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidWebDVDAdm.VTable, @ptrCast(self.vtable)).put_BookmarkOnStop(@as(*const IMSVidWebDVDAdm, @ptrCast(self)), newVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevice_Value = Guid.initString("37b03546-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidOutputDevice = &IID_IMSVidOutputDevice_Value;
pub const IMSVidOutputDevice = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidOutputDeviceEvent_Value = Guid.initString("2e6a14e2-571c-11d3-b652-00c04f79498e");
pub const IID_IMSVidOutputDeviceEvent = &IID_IMSVidOutputDeviceEvent_Value;
pub const IMSVidOutputDeviceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeature_Value = Guid.initString("37b03547-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidFeature = &IID_IMSVidFeature_Value;
pub const IMSVidFeature = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDevice.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDevice.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidFeatureEvent_Value = Guid.initString("3dd2903c-e0aa-11d2-b63a-00c04f79498e");
pub const IID_IMSVidFeatureEvent = &IID_IMSVidFeatureEvent_Value;
pub const IMSVidFeatureEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidEncoder_Value = Guid.initString("c0020fd4-bee7-43d9-a495-9f213117103d");
pub const IID_IMSVidEncoder = &IID_IMSVidEncoder_Value;
pub const IMSVidEncoder = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoEncoderInterface: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEncoder,
                ppEncInt: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEncoder,
                ppEncInt: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioEncoderInterface: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEncoder,
                ppEncInt: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEncoder,
                ppEncInt: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEncoder_get_VideoEncoderInterface(self: *const T, ppEncInt: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEncoder.VTable, @ptrCast(self.vtable)).get_VideoEncoderInterface(@as(*const IMSVidEncoder, @ptrCast(self)), ppEncInt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEncoder_get_AudioEncoderInterface(self: *const T, ppEncInt: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEncoder.VTable, @ptrCast(self.vtable)).get_AudioEncoderInterface(@as(*const IMSVidEncoder, @ptrCast(self)), ppEncInt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning_Value = Guid.initString("99652ea1-c1f7-414f-bb7b-1c967de75983");
pub const IID_IMSVidClosedCaptioning = &IID_IMSVidClosedCaptioning_Value;
pub const IMSVidClosedCaptioning = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidClosedCaptioning,
                On: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidClosedCaptioning,
                On: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidClosedCaptioning,
                On: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidClosedCaptioning,
                On: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning_get_Enable(self: *const T, On: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidClosedCaptioning.VTable, @ptrCast(self.vtable)).get_Enable(@as(*const IMSVidClosedCaptioning, @ptrCast(self)), On);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning_put_Enable(self: *const T, On: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidClosedCaptioning.VTable, @ptrCast(self.vtable)).put_Enable(@as(*const IMSVidClosedCaptioning, @ptrCast(self)), On);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidClosedCaptioning2_Value = Guid.initString("e00cb864-a029-4310-9987-a873f5887d97");
pub const IID_IMSVidClosedCaptioning2 = &IID_IMSVidClosedCaptioning2_Value;
pub const IMSVidClosedCaptioning2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Service: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidClosedCaptioning2,
                On: ?*MSVidCCService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidClosedCaptioning2,
                On: ?*MSVidCCService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Service: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidClosedCaptioning2,
                On: MSVidCCService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidClosedCaptioning2,
                On: MSVidCCService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidClosedCaptioning.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning2_get_Service(self: *const T, On: ?*MSVidCCService) callconv(.Inline) HRESULT {
            return @as(*const IMSVidClosedCaptioning2.VTable, @ptrCast(self.vtable)).get_Service(@as(*const IMSVidClosedCaptioning2, @ptrCast(self)), On);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning2_put_Service(self: *const T, On: MSVidCCService) callconv(.Inline) HRESULT {
            return @as(*const IMSVidClosedCaptioning2.VTable, @ptrCast(self.vtable)).put_Service(@as(*const IMSVidClosedCaptioning2, @ptrCast(self)), On);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidClosedCaptioning3_Value = Guid.initString("c8638e8a-7625-4c51-9366-2f40a9831fc0");
pub const IID_IMSVidClosedCaptioning3 = &IID_IMSVidClosedCaptioning3_Value;
pub const IMSVidClosedCaptioning3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidClosedCaptioning2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TeleTextFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidClosedCaptioning3,
                punkTTFilter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidClosedCaptioning3,
                punkTTFilter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidClosedCaptioning2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidClosedCaptioning3_get_TeleTextFilter(self: *const T, punkTTFilter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidClosedCaptioning3.VTable, @ptrCast(self.vtable)).get_TeleTextFilter(@as(*const IMSVidClosedCaptioning3, @ptrCast(self)), punkTTFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDS_Value = Guid.initString("11ebc158-e712-4d1f-8bb3-01ed5274c4ce");
pub const IID_IMSVidXDS = &IID_IMSVidXDS_Value;
pub const IMSVidXDS = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelChangeInterface: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidXDS,
                punkCC: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidXDS,
                punkCC: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidXDS_get_ChannelChangeInterface(self: *const T, punkCC: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidXDS.VTable, @ptrCast(self.vtable)).get_ChannelChangeInterface(@as(*const IMSVidXDS, @ptrCast(self)), punkCC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidXDSEvent_Value = Guid.initString("6db2317d-3b23-41ec-ba4b-701f407eaf3a");
pub const IID_IMSVidXDSEvent = &IID_IMSVidXDSEvent_Value;
pub const IMSVidXDSEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeatureEvent.VTable,
        RatingChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidXDSEvent,
                PrevRatingSystem: EnTvRat_System,
                PrevLevel: EnTvRat_GenericLevel,
                PrevAttributes: BfEnTvRat_GenericAttributes,
                NewRatingSystem: EnTvRat_System,
                NewLevel: EnTvRat_GenericLevel,
                NewAttributes: BfEnTvRat_GenericAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidXDSEvent,
                PrevRatingSystem: EnTvRat_System,
                PrevLevel: EnTvRat_GenericLevel,
                PrevAttributes: BfEnTvRat_GenericAttributes,
                NewRatingSystem: EnTvRat_System,
                NewLevel: EnTvRat_GenericLevel,
                NewAttributes: BfEnTvRat_GenericAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeatureEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidXDSEvent_RatingChange(self: *const T, PrevRatingSystem: EnTvRat_System, PrevLevel: EnTvRat_GenericLevel, PrevAttributes: BfEnTvRat_GenericAttributes, NewRatingSystem: EnTvRat_System, NewLevel: EnTvRat_GenericLevel, NewAttributes: BfEnTvRat_GenericAttributes) callconv(.Inline) HRESULT {
            return @as(*const IMSVidXDSEvent.VTable, @ptrCast(self.vtable)).RatingChange(@as(*const IMSVidXDSEvent, @ptrCast(self)), PrevRatingSystem, PrevLevel, PrevAttributes, NewRatingSystem, NewLevel, NewAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidDataServices_Value = Guid.initString("334125c1-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServices = &IID_IMSVidDataServices_Value;
pub const IMSVidDataServices = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFeature.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFeature.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidDataServicesEvent_Value = Guid.initString("334125c2-77e5-11d3-b653-00c04f79498e");
pub const IID_IMSVidDataServicesEvent = &IID_IMSVidDataServicesEvent_Value;
pub const IMSVidDataServicesEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SourceSizeList = enum(i32) {
    FullSize = 0,
    ClipByOverScan = 1,
    ClipByClipRect = 2,
};
pub const sslFullSize = SourceSizeList.FullSize;
pub const sslClipByOverScan = SourceSizeList.ClipByOverScan;
pub const sslClipByClipRect = SourceSizeList.ClipByClipRect;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer_Value = Guid.initString("37b03540-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRenderer = &IID_IMSVidVideoRenderer_Value;
pub const IMSVidVideoRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CustomCompositorClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CustomCompositorClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositorClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositorClass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                CompositorCLSID: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__CustomCompositor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                Compositor: ?*?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                Compositor: ?*?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__CustomCompositor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                Compositor: ?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                Compositor: ?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmap: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__MixerBitmap: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                MixerPicture: ?*?*IVMRMixerBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                MixerPicture: ?*?*IVMRMixerBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmap: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__MixerBitmap: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                MixerPicture: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                MixerPicture: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapPositionRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                rDest: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                rDest: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapPositionRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                rDest: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                rDest: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixerBitmapOpacity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                opacity: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                opacity: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixerBitmapOpacity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                opacity: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                opacity: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetupMixerBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*IPictureDisp,
                Opacity: i32,
                rDest: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                MixerPictureDisp: ?*IPictureDisp,
                Opacity: i32,
                rDest: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                CurrentSize: ?*SourceSizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                CurrentSize: ?*SourceSizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                NewSize: SourceSizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                NewSize: SourceSizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OverScan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                plPercent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                plPercent: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OverScan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                lPercent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                lPercent: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableSourceRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaxVidRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                ppVidRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                ppVidRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MinVidRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                ppVidRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                ppVidRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ClippedSourceRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ClippedSourceRect: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pRect: ?*IMSVidRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UsingOverlay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                UseOverlayVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                UseOverlayVal: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UsingOverlay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                UseOverlayVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                UseOverlayVal: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Capture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                currentImage: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                currentImage: ?*?*IPictureDisp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesPerSecond: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pVal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecimateInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pDeci: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pDeci: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecimateInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer,
                pDeci: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer,
                pDeci: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_CustomCompositorClass(self: *const T, CompositorCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_CustomCompositorClass(self: *const T, CompositorCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__CustomCompositorClass(self: *const T, CompositorCLSID: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__CustomCompositorClass(self: *const T, CompositorCLSID: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__CustomCompositorClass(@as(*const IMSVidVideoRenderer, @ptrCast(self)), CompositorCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__CustomCompositor(self: *const T, Compositor: ?*?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__CustomCompositor(@as(*const IMSVidVideoRenderer, @ptrCast(self)), Compositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__CustomCompositor(self: *const T, Compositor: ?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__CustomCompositor(@as(*const IMSVidVideoRenderer, @ptrCast(self)), Compositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmap(self: *const T, MixerPictureDisp: ?*?*IPictureDisp) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), MixerPictureDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get__MixerBitmap(self: *const T, MixerPicture: ?*?*IVMRMixerBitmap) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get__MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), MixerPicture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmap(self: *const T, MixerPictureDisp: ?*IPictureDisp) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), MixerPictureDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put__MixerBitmap(self: *const T, MixerPicture: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put__MixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), MixerPicture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmapPositionRect(self: *const T, rDest: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmapPositionRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmapPositionRect(self: *const T, rDest: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmapPositionRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MixerBitmapOpacity(self: *const T, opacity: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MixerBitmapOpacity(@as(*const IMSVidVideoRenderer, @ptrCast(self)), opacity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_MixerBitmapOpacity(self: *const T, opacity: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_MixerBitmapOpacity(@as(*const IMSVidVideoRenderer, @ptrCast(self)), opacity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_SetupMixerBitmap(self: *const T, MixerPictureDisp: ?*IPictureDisp, Opacity: i32, rDest: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).SetupMixerBitmap(@as(*const IMSVidVideoRenderer, @ptrCast(self)), MixerPictureDisp, Opacity, rDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_SourceSize(self: *const T, CurrentSize: ?*SourceSizeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_SourceSize(@as(*const IMSVidVideoRenderer, @ptrCast(self)), CurrentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_SourceSize(self: *const T, NewSize: SourceSizeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_SourceSize(@as(*const IMSVidVideoRenderer, @ptrCast(self)), NewSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_OverScan(self: *const T, plPercent: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_OverScan(@as(*const IMSVidVideoRenderer, @ptrCast(self)), plPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_OverScan(self: *const T, lPercent: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_OverScan(@as(*const IMSVidVideoRenderer, @ptrCast(self)), lPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_AvailableSourceRect(self: *const T, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_AvailableSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MaxVidRect(self: *const T, ppVidRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MaxVidRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), ppVidRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_MinVidRect(self: *const T, ppVidRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_MinVidRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), ppVidRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_ClippedSourceRect(self: *const T, pRect: ?*?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_ClippedSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_ClippedSourceRect(self: *const T, pRect: ?*IMSVidRect) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_ClippedSourceRect(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_UsingOverlay(self: *const T, UseOverlayVal: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_UsingOverlay(@as(*const IMSVidVideoRenderer, @ptrCast(self)), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_UsingOverlay(self: *const T, UseOverlayVal: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_UsingOverlay(@as(*const IMSVidVideoRenderer, @ptrCast(self)), UseOverlayVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_Capture(self: *const T, currentImage: ?*?*IPictureDisp) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).Capture(@as(*const IMSVidVideoRenderer, @ptrCast(self)), currentImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_FramesPerSecond(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_FramesPerSecond(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_get_DecimateInput(self: *const T, pDeci: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).get_DecimateInput(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pDeci);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer_put_DecimateInput(self: *const T, pDeci: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer.VTable, @ptrCast(self.vtable)).put_DecimateInput(@as(*const IMSVidVideoRenderer, @ptrCast(self)), pDeci);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent_Value = Guid.initString("37b03545-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidVideoRendererEvent = &IID_IMSVidVideoRendererEvent_Value;
pub const IMSVidVideoRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRendererEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRendererEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererEvent_OverlayUnavailable(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererEvent.VTable, @ptrCast(self.vtable)).OverlayUnavailable(@as(*const IMSVidVideoRendererEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink_Value = Guid.initString("6c29b41d-455b-4c33-963a-0d28e5e555ea");
pub const IID_IMSVidGenericSink = &IID_IMSVidGenericSink_Value;
pub const IMSVidGenericSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        SetSinkFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGenericSink,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGenericSink,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkStreams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGenericSink,
                pStreams: ?*MSVidSinkStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGenericSink,
                pStreams: ?*MSVidSinkStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkStreams: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidGenericSink,
                Streams: MSVidSinkStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidGenericSink,
                Streams: MSVidSinkStreams,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_SetSinkFilter(self: *const T, bstrName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).SetSinkFilter(@as(*const IMSVidGenericSink, @ptrCast(self)), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_get_SinkStreams(self: *const T, pStreams: ?*MSVidSinkStreams) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).get_SinkStreams(@as(*const IMSVidGenericSink, @ptrCast(self)), pStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink_put_SinkStreams(self: *const T, Streams: MSVidSinkStreams) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGenericSink.VTable, @ptrCast(self.vtable)).put_SinkStreams(@as(*const IMSVidGenericSink, @ptrCast(self)), Streams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidGenericSink2_Value = Guid.initString("6b5a28f3-47f1-4092-b168-60cabec08f1c");
pub const IID_IMSVidGenericSink2 = &IID_IMSVidGenericSink2_Value;
pub const IMSVidGenericSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidGenericSink.VTable,
        AddFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGenericSink2,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGenericSink2,
                bstrName: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetFilterList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidGenericSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidGenericSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidGenericSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink2_AddFilter(self: *const T, bstrName: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGenericSink2.VTable, @ptrCast(self.vtable)).AddFilter(@as(*const IMSVidGenericSink2, @ptrCast(self)), bstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidGenericSink2_ResetFilterList(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidGenericSink2.VTable, @ptrCast(self.vtable)).ResetFilterList(@as(*const IMSVidGenericSink2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferRecordingControl_Value = Guid.initString("160621aa-bbbc-4326-a824-c395aebc6e74");
pub const IID_IMSVidStreamBufferRecordingControl = &IID_IMSVidStreamBufferRecordingControl_Value;
pub const IMSVidStreamBufferRecordingControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StartTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStart: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                rtStop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStopped: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                phResult: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                phResult: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingStarted: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                phResult: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                phResult: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                dwType: ?*RecordingType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                dwType: ?*RecordingType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferRecordingControl,
                pRecordingAttribute: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferRecordingControl,
                pRecordingAttribute: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_StartTime(self: *const T, rtStart: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_StartTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_put_StartTime(self: *const T, rtStart: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).put_StartTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_StopTime(self: *const T, rtStop: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_StopTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_put_StopTime(self: *const T, rtStop: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).put_StopTime(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingStopped(self: *const T, phResult: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingStopped(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), phResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingStarted(self: *const T, phResult: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingStarted(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), phResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingType(self: *const T, dwType: ?*RecordingType) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingType(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), dwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferRecordingControl_get_RecordingAttribute(self: *const T, pRecordingAttribute: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferRecordingControl.VTable, @ptrCast(self.vtable)).get_RecordingAttribute(@as(*const IMSVidStreamBufferRecordingControl, @ptrCast(self)), pRecordingAttribute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSink_Value = Guid.initString("159dbb45-cd1b-4dab-83ea-5cb1f4f21d07");
pub const IID_IMSVidStreamBufferSink = &IID_IMSVidStreamBufferSink_Value;
pub const IMSVidStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        get_ContentRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
                pszFilename: ?BSTR,
                pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
                pszFilename: ?BSTR,
                pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ReferenceRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
                pszFilename: ?BSTR,
                pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
                pszFilename: ?BSTR,
                pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SinkName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SinkName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
                Name: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NameSetLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink,
                sbeConfig: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink,
                sbeConfig: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_ContentRecorder(self: *const T, pszFilename: ?BSTR, pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_ContentRecorder(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), pszFilename, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_ReferenceRecorder(self: *const T, pszFilename: ?BSTR, pRecordingIUnknown: ?*?*IMSVidStreamBufferRecordingControl) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_ReferenceRecorder(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), pszFilename, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_SinkName(self: *const T, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_SinkName(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_put_SinkName(self: *const T, Name: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).put_SinkName(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_NameSetLock(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).NameSetLock(@as(*const IMSVidStreamBufferSink, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink_get_SBESink(self: *const T, sbeConfig: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink.VTable, @ptrCast(self.vtable)).get_SBESink(@as(*const IMSVidStreamBufferSink, @ptrCast(self)), sbeConfig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink2_Value = Guid.initString("2ca9fc63-c131-4e5a-955a-544a47c67146");
pub const IID_IMSVidStreamBufferSink2 = &IID_IMSVidStreamBufferSink2_Value;
pub const IMSVidStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink.VTable,
        UnlockProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink2_UnlockProfile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink2.VTable, @ptrCast(self.vtable)).UnlockProfile(@as(*const IMSVidStreamBufferSink2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSink3_Value = Guid.initString("4f8721d7-7d59-4d8b-99f5-a77775586bd5");
pub const IID_IMSVidStreamBufferSink3 = &IID_IMSVidStreamBufferSink3_Value;
pub const IMSVidStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSink2.VTable,
        SetMinSeek: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pdwMin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pdwMin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__AudioAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__AudioAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__VideoAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__VideoAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DataAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                szCLSID: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DataAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pszCLSID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put__DataAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                guid: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__DataAnalysisFilter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                pGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LicenseErrorCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSink3,
                hres: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSink3,
                hres: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSink2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_SetMinSeek(self: *const T, pdwMin: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).SetMinSeek(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pdwMin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_AudioCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_AudioCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_VideoCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_VideoCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_CCCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_CCCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_WSTCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_WSTCounter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_AudioAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_AudioAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__AudioAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__AudioAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__AudioAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_VideoAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_VideoAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__VideoAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__VideoAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__VideoAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put_DataAnalysisFilter(self: *const T, szCLSID: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put_DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), szCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_DataAnalysisFilter(self: *const T, pszCLSID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pszCLSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_put__DataAnalysisFilter(self: *const T, guid: Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).put__DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get__DataAnalysisFilter(self: *const T, pGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get__DataAnalysisFilter(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), pGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSink3_get_LicenseErrorCode(self: *const T, hres: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSink3.VTable, @ptrCast(self.vtable)).get_LicenseErrorCode(@as(*const IMSVidStreamBufferSink3, @ptrCast(self)), hres);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent_Value = Guid.initString("f798a36b-b05b-4bbe-9703-eaea7d61cd51");
pub const IID_IMSVidStreamBufferSinkEvent = &IID_IMSVidStreamBufferSinkEvent_Value;
pub const IMSVidStreamBufferSinkEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        CertificateFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CertificateSuccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_CertificateFailure(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).CertificateFailure(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_CertificateSuccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).CertificateSuccess(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent_WriteFailure(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent.VTable, @ptrCast(self.vtable)).WriteFailure(@as(*const IMSVidStreamBufferSinkEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent2_Value = Guid.initString("3d7a5166-72d7-484b-a06f-286187b80ca1");
pub const IID_IMSVidStreamBufferSinkEvent2 = &IID_IMSVidStreamBufferSinkEvent2_Value;
pub const IMSVidStreamBufferSinkEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent.VTable,
        EncryptionOn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EncryptionOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent2_EncryptionOn(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent2.VTable, @ptrCast(self.vtable)).EncryptionOn(@as(*const IMSVidStreamBufferSinkEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent2_EncryptionOff(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent2.VTable, @ptrCast(self.vtable)).EncryptionOff(@as(*const IMSVidStreamBufferSinkEvent2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSinkEvent3_Value = Guid.initString("735ad8d5-c259-48e9-81e7-d27953665b23");
pub const IID_IMSVidStreamBufferSinkEvent3 = &IID_IMSVidStreamBufferSinkEvent3_Value;
pub const IMSVidStreamBufferSinkEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent2.VTable,
        LicenseChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent3,
                dwProt: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent3,
                dwProt: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent3_LicenseChange(self: *const T, dwProt: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent3.VTable, @ptrCast(self.vtable)).LicenseChange(@as(*const IMSVidStreamBufferSinkEvent3, @ptrCast(self)), dwProt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferSinkEvent4_Value = Guid.initString("1b01dcb0-daf0-412c-a5d1-590c7f62e2b8");
pub const IID_IMSVidStreamBufferSinkEvent4 = &IID_IMSVidStreamBufferSinkEvent4_Value;
pub const IMSVidStreamBufferSinkEvent4 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSinkEvent3.VTable,
        WriteFailureClear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSinkEvent4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSinkEvent4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSinkEvent3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSinkEvent4_WriteFailureClear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSinkEvent4.VTable, @ptrCast(self.vtable)).WriteFailureClear(@as(*const IMSVidStreamBufferSinkEvent4, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidStreamBufferSource_Value = Guid.initString("eb0c8cf9-6950-4772-87b1-47d11cf3a02f");
pub const IID_IMSVidStreamBufferSource = &IID_IMSVidStreamBufferSource_Value;
pub const IMSVidStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlayback.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Start: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                lStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                lStart: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecordingAttribute: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                pRecordingAttribute: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                pRecordingAttribute: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CurrentRatings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                pBfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                pEnSystem: ?*EnTvRat_System,
                pEnRating: ?*EnTvRat_GenericLevel,
                pBfEnAttr: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MaxRatingsLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                enSystem: EnTvRat_System,
                enRating: EnTvRat_GenericLevel,
                lbfEnAttr: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                enSystem: EnTvRat_System,
                enRating: EnTvRat_GenericLevel,
                lbfEnAttr: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BlockUnrated: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                bBlock: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                bBlock: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UnratedDelay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                dwDelay: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                dwDelay: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SBESource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource,
                sbeFilter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource,
                sbeFilter: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlayback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_Start(self: *const T, lStart: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_Start(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), lStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_RecordingAttribute(self: *const T, pRecordingAttribute: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_RecordingAttribute(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), pRecordingAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_CurrentRatings(self: *const T, pEnSystem: ?*EnTvRat_System, pEnRating: ?*EnTvRat_GenericLevel, pBfEnAttr: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).CurrentRatings(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), pEnSystem, pEnRating, pBfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_MaxRatingsLevel(self: *const T, enSystem: EnTvRat_System, enRating: EnTvRat_GenericLevel, lbfEnAttr: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).MaxRatingsLevel(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), enSystem, enRating, lbfEnAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_put_BlockUnrated(self: *const T, bBlock: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).put_BlockUnrated(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), bBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_put_UnratedDelay(self: *const T, dwDelay: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).put_UnratedDelay(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), dwDelay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource_get_SBESource(self: *const T, sbeFilter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource.VTable, @ptrCast(self.vtable)).get_SBESource(@as(*const IMSVidStreamBufferSource, @ptrCast(self)), sbeFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSource2_Value = Guid.initString("e4ba9059-b1ce-40d8-b9a0-d4ea4a9989d3");
pub const IID_IMSVidStreamBufferSource2 = &IID_IMSVidStreamBufferSource2_Value;
pub const IMSVidStreamBufferSource2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSource.VTable,
        put_RateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource2,
                dwRate: f64,
                dwFramesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSource2,
                dwRate: f64,
                dwFramesPerSecond: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WSTCounter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidStreamBufferSource2,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_put_RateEx(self: *const T, dwRate: f64, dwFramesPerSecond: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).put_RateEx(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), dwRate, dwFramesPerSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_AudioCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_AudioCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_VideoCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_VideoCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_CCCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_CCCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSource2_get_WSTCounter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSource2.VTable, @ptrCast(self.vtable)).get_WSTCounter(@as(*const IMSVidStreamBufferSource2, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent_Value = Guid.initString("50ce8a7d-9c28-4da8-9042-cdfa7116f979");
pub const IID_IMSVidStreamBufferSourceEvent = &IID_IMSVidStreamBufferSourceEvent_Value;
pub const IMSVidStreamBufferSourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        CertificateFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CertificateSuccess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RatingsBlocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RatingsUnblocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RatingsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TimeHole: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
                StreamOffsetMS: i32,
                SizeMS: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
                StreamOffsetMS: i32,
                SizeMS: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StaleDataRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContentBecomingStale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StaleFileDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_CertificateFailure(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).CertificateFailure(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_CertificateSuccess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).CertificateSuccess(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsBlocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsBlocked(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsUnblocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsUnblocked(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_RatingsChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).RatingsChanged(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_TimeHole(self: *const T, StreamOffsetMS: i32, SizeMS: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).TimeHole(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)), StreamOffsetMS, SizeMS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_StaleDataRead(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).StaleDataRead(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_ContentBecomingStale(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).ContentBecomingStale(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent_StaleFileDeleted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent.VTable, @ptrCast(self.vtable)).StaleFileDeleted(@as(*const IMSVidStreamBufferSourceEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent2_Value = Guid.initString("7aef50ce-8e22-4ba8-bc06-a92a458b4ef2");
pub const IID_IMSVidStreamBufferSourceEvent2 = &IID_IMSVidStreamBufferSourceEvent2_Value;
pub const IMSVidStreamBufferSourceEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent.VTable,
        RateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent2,
                qwNewRate: f64,
                qwOldRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent2,
                qwNewRate: f64,
                qwOldRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSourceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent2_RateChange(self: *const T, qwNewRate: f64, qwOldRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent2.VTable, @ptrCast(self.vtable)).RateChange(@as(*const IMSVidStreamBufferSourceEvent2, @ptrCast(self)), qwNewRate, qwOldRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidStreamBufferSourceEvent3_Value = Guid.initString("ceabd6ab-9b90-4570-adf1-3ce76e00a763");
pub const IID_IMSVidStreamBufferSourceEvent3 = &IID_IMSVidStreamBufferSourceEvent3_Value;
pub const IMSVidStreamBufferSourceEvent3 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidStreamBufferSourceEvent2.VTable,
        BroadcastEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent3,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent3,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BroadcastEventEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent3,
                Guid: ?BSTR,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent3,
                Guid: ?BSTR,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        COPPBlocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        COPPUnblocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContentPrimarilyAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferSourceEvent3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidStreamBufferSourceEvent2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_BroadcastEvent(self: *const T, _param_Guid: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).BroadcastEvent(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_BroadcastEventEx(self: *const T, _param_Guid: ?BSTR, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).BroadcastEventEx(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)), _param_Guid, Param1, Param2, Param3, Param4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_COPPBlocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).COPPBlocked(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_COPPUnblocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).COPPUnblocked(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferSourceEvent3_ContentPrimarilyAudio(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferSourceEvent3.VTable, @ptrCast(self.vtable)).ContentPrimarilyAudio(@as(*const IMSVidStreamBufferSourceEvent3, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidStreamBufferV2SourceEvent_Value = Guid.initString("49c771f9-41b2-4cf7-9f9a-a313a8f6027e");
pub const IID_IMSVidStreamBufferV2SourceEvent = &IID_IMSVidStreamBufferV2SourceEvent_Value;
pub const IMSVidStreamBufferV2SourceEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidFilePlaybackEvent.VTable,
        RatingsChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TimeHole: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                StreamOffsetMS: i32,
                SizeMS: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                StreamOffsetMS: i32,
                SizeMS: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StaleDataRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContentBecomingStale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StaleFileDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RateChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                qwNewRate: f64,
                qwOldRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                qwNewRate: f64,
                qwOldRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BroadcastEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                Guid: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BroadcastEventEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                Guid: ?BSTR,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
                Guid: ?BSTR,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ContentPrimarilyAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidStreamBufferV2SourceEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidFilePlaybackEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_RatingsChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).RatingsChanged(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_TimeHole(self: *const T, StreamOffsetMS: i32, SizeMS: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).TimeHole(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), StreamOffsetMS, SizeMS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_StaleDataRead(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).StaleDataRead(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_ContentBecomingStale(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).ContentBecomingStale(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_StaleFileDeleted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).StaleFileDeleted(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_RateChange(self: *const T, qwNewRate: f64, qwOldRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).RateChange(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), qwNewRate, qwOldRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_BroadcastEvent(self: *const T, _param_Guid: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).BroadcastEvent(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), _param_Guid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_BroadcastEventEx(self: *const T, _param_Guid: ?BSTR, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).BroadcastEventEx(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)), _param_Guid, Param1, Param2, Param3, Param4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidStreamBufferV2SourceEvent_ContentPrimarilyAudio(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidStreamBufferV2SourceEvent.VTable, @ptrCast(self.vtable)).ContentPrimarilyAudio(@as(*const IMSVidStreamBufferV2SourceEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRenderer2_Value = Guid.initString("6bdd5c1e-2810-4159-94bc-05511ae8549b");
pub const IID_IMSVidVideoRenderer2 = &IID_IMSVidVideoRenderer2_Value;
pub const IMSVidVideoRenderer2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__Allocator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*?*IVMRSurfaceAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*?*IVMRSurfaceAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*IUnknown,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*IUnknown,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        _SetAllocator2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*IVMRSurfaceAllocator,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                AllocPresent: ?*IVMRSurfaceAllocator,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRenderer2,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRenderer2,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_Allocator(self: *const T, AllocPresent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_Allocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), AllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get__Allocator(self: *const T, AllocPresent: ?*?*IVMRSurfaceAllocator) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get__Allocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), AllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_Allocator_ID(self: *const T, ID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_Allocator_ID(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_SetAllocator(self: *const T, AllocPresent: ?*IUnknown, ID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).SetAllocator(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2__SetAllocator2(self: *const T, AllocPresent: ?*IVMRSurfaceAllocator, ID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable))._SetAllocator2(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_put_SuppressEffects(self: *const T, bSuppress: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRenderer2_get_SuppressEffects(self: *const T, bSuppress: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRenderer2.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidVideoRenderer2, @ptrCast(self)), bSuppress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVideoRendererEvent2_Value = Guid.initString("7145ed66-4730-4fdb-8a53-fde7508d3e5e");
pub const IID_IMSVidVideoRendererEvent2 = &IID_IMSVidVideoRendererEvent2_Value;
pub const IMSVidVideoRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OverlayUnavailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererEvent2_OverlayUnavailable(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererEvent2.VTable, @ptrCast(self.vtable)).OverlayUnavailable(@as(*const IMSVidVideoRendererEvent2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidVMR9_Value = Guid.initString("d58b0015-ebef-44bb-bbdd-3f3699d76ea1");
pub const IID_IMSVidVMR9 = &IID_IMSVidVMR9_Value;
pub const IMSVidVMR9 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator_ID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVMR9,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVMR9,
                ID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVMR9,
                AllocPresent: ?*IUnknown,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVMR9,
                AllocPresent: ?*IUnknown,
                ID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVMR9,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVMR9,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVMR9,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVMR9,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Allocator: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVMR9,
                AllocPresent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVMR9,
                AllocPresent: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_Allocator_ID(self: *const T, ID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_Allocator_ID(@as(*const IMSVidVMR9, @ptrCast(self)), ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_SetAllocator(self: *const T, AllocPresent: ?*IUnknown, ID: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).SetAllocator(@as(*const IMSVidVMR9, @ptrCast(self)), AllocPresent, ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_put_SuppressEffects(self: *const T, bSuppress: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidVMR9, @ptrCast(self)), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_SuppressEffects(self: *const T, bSuppress: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidVMR9, @ptrCast(self)), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVMR9_get_Allocator(self: *const T, AllocPresent: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVMR9.VTable, @ptrCast(self.vtable)).get_Allocator(@as(*const IMSVidVMR9, @ptrCast(self)), AllocPresent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMSVidEVR_Value = Guid.initString("15e496ae-82a8-4cf9-a6b6-c561dc60398f");
pub const IID_IMSVidEVR = &IID_IMSVidEVR_Value;
pub const IMSVidEVR = extern struct {
    pub const VTable = extern struct {
        base: IMSVidVideoRenderer.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Presenter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEVR,
                ppAllocPresent: ?*?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEVR,
                ppAllocPresent: ?*?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Presenter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEVR,
                pAllocPresent: ?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEVR,
                pAllocPresent: ?*IMFVideoPresenter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEVR,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEVR,
                bSuppress: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SuppressEffects: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidEVR,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidEVR,
                bSuppress: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidVideoRenderer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_get_Presenter(self: *const T, ppAllocPresent: ?*?*IMFVideoPresenter) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).get_Presenter(@as(*const IMSVidEVR, @ptrCast(self)), ppAllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_put_Presenter(self: *const T, pAllocPresent: ?*IMFVideoPresenter) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).put_Presenter(@as(*const IMSVidEVR, @ptrCast(self)), pAllocPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_put_SuppressEffects(self: *const T, bSuppress: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).put_SuppressEffects(@as(*const IMSVidEVR, @ptrCast(self)), bSuppress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVR_get_SuppressEffects(self: *const T, bSuppress: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEVR.VTable, @ptrCast(self.vtable)).get_SuppressEffects(@as(*const IMSVidEVR, @ptrCast(self)), bSuppress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidEVREvent_Value = Guid.initString("349abb10-883c-4f22-8714-cecaeee45d62");
pub const IID_IMSVidEVREvent = &IID_IMSVidEVREvent_Value;
pub const IMSVidEVREvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
        OnUserEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidEVREvent,
                lEventCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidEVREvent,
                lEventCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidEVREvent_OnUserEvent(self: *const T, lEventCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidEVREvent.VTable, @ptrCast(self.vtable)).OnUserEvent(@as(*const IMSVidEVREvent, @ptrCast(self)), lEventCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRenderer_Value = Guid.initString("37b0353f-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRenderer = &IID_IMSVidAudioRenderer_Value;
pub const IMSVidAudioRenderer = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDevice.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRenderer,
                lVol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRenderer,
                lVol: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRenderer,
                lVol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRenderer,
                lVol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRenderer,
                lBal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRenderer,
                lBal: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRenderer,
                lBal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRenderer,
                lBal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_put_Volume(self: *const T, lVol: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const IMSVidAudioRenderer, @ptrCast(self)), lVol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_get_Volume(self: *const T, lVol: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const IMSVidAudioRenderer, @ptrCast(self)), lVol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_put_Balance(self: *const T, lBal: i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).put_Balance(@as(*const IMSVidAudioRenderer, @ptrCast(self)), lBal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRenderer_get_Balance(self: *const T, lBal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRenderer.VTable, @ptrCast(self.vtable)).get_Balance(@as(*const IMSVidAudioRenderer, @ptrCast(self)), lBal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSVidAudioRendererEvent_Value = Guid.initString("37b03541-a4c8-11d2-b634-00c04f79498e");
pub const IID_IMSVidAudioRendererEvent = &IID_IMSVidAudioRendererEvent_Value;
pub const IMSVidAudioRendererEvent = extern struct {
    pub const VTable = extern struct {
        base: IMSVidOutputDeviceEvent.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidOutputDeviceEvent.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IMSVidAudioRendererEvent2_Value = Guid.initString("e3f55729-353b-4c43-a028-50f79aa9a907");
pub const IID_IMSVidAudioRendererEvent2 = &IID_IMSVidAudioRendererEvent2_Value;
pub const IMSVidAudioRendererEvent2 = extern struct {
    pub const VTable = extern struct {
        base: IMSVidAudioRendererEvent.VTable,
        AVDecAudioDualMono: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVAudioSampleRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVAudioChannelConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVAudioChannelCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVDecCommonMeanBitRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVDDSurroundMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVDecCommonInputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AVDecCommonOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererEvent2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMSVidAudioRendererEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecAudioDualMono(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecAudioDualMono(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioSampleRate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioSampleRate(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioChannelConfig(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioChannelConfig(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVAudioChannelCount(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVAudioChannelCount(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonMeanBitRate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonMeanBitRate(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDDSurroundMode(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDDSurroundMode(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonInputFormat(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonInputFormat(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererEvent2_AVDecCommonOutputFormat(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererEvent2.VTable, @ptrCast(self.vtable)).AVDecCommonOutputFormat(@as(*const IMSVidAudioRendererEvent2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidInputDevices_Value = Guid.initString("c5702cd1-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidInputDevices = &IID_IMSVidInputDevices_Value;
pub const IMSVidInputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidInputDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidInputDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidInputDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidInputDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidInputDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidInputDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidInputDevices,
                pDB: ?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidInputDevices,
                pDB: ?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidInputDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidInputDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidInputDevices, @ptrCast(self)), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidInputDevices, @ptrCast(self)), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidInputDevices, @ptrCast(self)), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_Add(self: *const T, pDB: ?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidInputDevices, @ptrCast(self)), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidInputDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidInputDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidInputDevices, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidOutputDevices_Value = Guid.initString("c5702cd2-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidOutputDevices = &IID_IMSVidOutputDevices_Value;
pub const IMSVidOutputDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidOutputDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidOutputDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidOutputDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidOutputDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidOutputDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidOutputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidOutputDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidOutputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidOutputDevices,
                pDB: ?*IMSVidOutputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidOutputDevices,
                pDB: ?*IMSVidOutputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidOutputDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidOutputDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidOutputDevices, @ptrCast(self)), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidOutputDevices, @ptrCast(self)), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidOutputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidOutputDevices, @ptrCast(self)), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_Add(self: *const T, pDB: ?*IMSVidOutputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidOutputDevices, @ptrCast(self)), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidOutputDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidOutputDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidOutputDevices, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidVideoRendererDevices_Value = Guid.initString("c5702cd3-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidVideoRendererDevices = &IID_IMSVidVideoRendererDevices_Value;
pub const IMSVidVideoRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRendererDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRendererDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidVideoRendererDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidVideoRendererDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRendererDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRendererDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRendererDevices,
                pDB: ?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRendererDevices,
                pDB: ?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidVideoRendererDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidVideoRendererDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_Add(self: *const T, pDB: ?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidVideoRendererDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidVideoRendererDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidVideoRendererDevices, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidAudioRendererDevices_Value = Guid.initString("c5702cd4-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidAudioRendererDevices = &IID_IMSVidAudioRendererDevices_Value;
pub const IMSVidAudioRendererDevices = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRendererDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRendererDevices,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidAudioRendererDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidAudioRendererDevices,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererDevices,
                v: VARIANT,
                pDB: ?*?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererDevices,
                pDB: ?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererDevices,
                pDB: ?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidAudioRendererDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidAudioRendererDevices,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_Add(self: *const T, pDB: ?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidAudioRendererDevices_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidAudioRendererDevices.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidAudioRendererDevices, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidFeatures_Value = Guid.initString("c5702cd5-9b79-11d3-b654-00c04f79498e");
pub const IID_IMSVidFeatures = &IID_IMSVidFeatures_Value;
pub const IMSVidFeatures = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFeatures,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFeatures,
                lCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidFeatures,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidFeatures,
                pD: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidFeatures,
                v: VARIANT,
                pDB: ?*?*IMSVidFeature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidFeatures,
                v: VARIANT,
                pDB: ?*?*IMSVidFeature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Add: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidFeatures,
                pDB: ?*IMSVidFeature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidFeatures,
                pDB: ?*IMSVidFeature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidFeatures,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidFeatures,
                v: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get_Count(self: *const T, lCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IMSVidFeatures, @ptrCast(self)), lCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get__NewEnum(self: *const T, pD: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IMSVidFeatures, @ptrCast(self)), pD);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_get_Item(self: *const T, v: VARIANT, pDB: ?*?*IMSVidFeature) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).get_Item(@as(*const IMSVidFeatures, @ptrCast(self)), v, pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_Add(self: *const T, pDB: ?*IMSVidFeature) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).Add(@as(*const IMSVidFeatures, @ptrCast(self)), pDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidFeatures_Remove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidFeatures.VTable, @ptrCast(self.vtable)).Remove(@as(*const IMSVidFeatures, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSViddispidList = enum(i32) {
    Inputs = 0,
    Outputs = 1,
    _Inputs = 2,
    _Outputs = 3,
    VideoRenderers = 4,
    AudioRenderers = 5,
    Features = 6,
    Input = 7,
    Output = 8,
    VideoRenderer = 9,
    AudioRenderer = 10,
    SelectedFeatures = 11,
    View = 12,
    Build = 13,
    Pause = 14,
    Run = 15,
    Stop = 16,
    Decompose = 17,
    DisplaySize = 18,
    MaintainAspectRatio = 19,
    ColorKey = 20,
    StateChange = 21,
    getState = 22,
    unbind = 23,
    bind = 24,
    DisableVideo = 25,
    DisableAudio = 26,
    ViewNext = 27,
    ServiceP = 28,
};
pub const dispidInputs = MSViddispidList.Inputs;
pub const dispidOutputs = MSViddispidList.Outputs;
pub const dispid_Inputs = MSViddispidList._Inputs;
pub const dispid_Outputs = MSViddispidList._Outputs;
pub const dispidVideoRenderers = MSViddispidList.VideoRenderers;
pub const dispidAudioRenderers = MSViddispidList.AudioRenderers;
pub const dispidFeatures = MSViddispidList.Features;
pub const dispidInput = MSViddispidList.Input;
pub const dispidOutput = MSViddispidList.Output;
pub const dispidVideoRenderer = MSViddispidList.VideoRenderer;
pub const dispidAudioRenderer = MSViddispidList.AudioRenderer;
pub const dispidSelectedFeatures = MSViddispidList.SelectedFeatures;
pub const dispidView = MSViddispidList.View;
pub const dispidBuild = MSViddispidList.Build;
pub const dispidPause = MSViddispidList.Pause;
pub const dispidRun = MSViddispidList.Run;
pub const dispidStop = MSViddispidList.Stop;
pub const dispidDecompose = MSViddispidList.Decompose;
pub const dispidDisplaySize = MSViddispidList.DisplaySize;
pub const dispidMaintainAspectRatio = MSViddispidList.MaintainAspectRatio;
pub const dispidColorKey = MSViddispidList.ColorKey;
pub const dispidStateChange = MSViddispidList.StateChange;
pub const dispidgetState = MSViddispidList.getState;
pub const dispidunbind = MSViddispidList.unbind;
pub const dispidbind = MSViddispidList.bind;
pub const dispidDisableVideo = MSViddispidList.DisableVideo;
pub const dispidDisableAudio = MSViddispidList.DisableAudio;
pub const dispidViewNext = MSViddispidList.ViewNext;
pub const dispidServiceP = MSViddispidList.ServiceP;

pub const DisplaySizeList = enum(i32) {
    DefaultSize = 0,
    // SourceSize = 0, this enum value conflicts with DefaultSize
    HalfSourceSize = 1,
    DoubleSourceSize = 2,
    FullScreen = 3,
    HalfScreen = 4,
    QuarterScreen = 5,
    SixteenthScreen = 6,
};
pub const dslDefaultSize = DisplaySizeList.DefaultSize;
pub const dslSourceSize = DisplaySizeList.DefaultSize;
pub const dslHalfSourceSize = DisplaySizeList.HalfSourceSize;
pub const dslDoubleSourceSize = DisplaySizeList.DoubleSourceSize;
pub const dslFullScreen = DisplaySizeList.FullScreen;
pub const dslHalfScreen = DisplaySizeList.HalfScreen;
pub const dslQuarterScreen = DisplaySizeList.QuarterScreen;
pub const dslSixteenthScreen = DisplaySizeList.SixteenthScreen;

pub const MSVidCtlStateList = enum(i32) {
    UNBUILT = -1,
    STOP = 0,
    PAUSE = 1,
    PLAY = 2,
};
pub const STATE_UNBUILT = MSVidCtlStateList.UNBUILT;
pub const STATE_STOP = MSVidCtlStateList.STOP;
pub const STATE_PAUSE = MSVidCtlStateList.PAUSE;
pub const STATE_PLAY = MSVidCtlStateList.PLAY;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMSVidCtl_Value = Guid.initString("b0edf162-910a-11d2-b632-00c04f79498e");
pub const IID_IMSVidCtl = &IID_IMSVidCtl_Value;
pub const IMSVidCtl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                backcolor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                backcolor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                backcolor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                backcolor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enabled: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TabStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pbool: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TabStop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                vbool: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Window: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                phwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Refresh: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DisplaySize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*DisplaySizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*DisplaySizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DisplaySize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                NewValue: DisplaySizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                NewValue: DisplaySizeList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MaintainAspectRatio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MaintainAspectRatio: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                NewValue: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                NewValue: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ColorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                CurrentValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ColorKey: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                NewValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                NewValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_InputsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?BSTR,
                pVal: ?*?*IMSVidInputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?BSTR,
                pVal: ?*?*IMSVidInputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_OutputsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?BSTR,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?BSTR,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get__InputsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?*const Guid,
                pVal: ?*?*IMSVidInputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?*const Guid,
                pVal: ?*?*IMSVidInputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get__OutputsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?*const Guid,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                CategoryGuid: ?*const Guid,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRenderersAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidVideoRendererDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidVideoRendererDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRenderersAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidAudioRendererDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidAudioRendererDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesAvailable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InputActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InputActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidInputDevice,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputsActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputsActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidOutputDevices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoRendererActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VideoRendererActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidVideoRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioRendererActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AudioRendererActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidAudioRenderer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FeaturesActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FeaturesActive: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                pVal: ?*IMSVidFeatures,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_State: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMSVidCtl,
                lState: ?*MSVidCtlStateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMSVidCtl,
                lState: ?*MSVidCtlStateList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        View: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Build: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Decompose: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisableAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ViewNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSVidCtl,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSVidCtl,
                v: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AutoSize(self: *const T, pbool: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AutoSize(@as(*const IMSVidCtl, @ptrCast(self)), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_AutoSize(self: *const T, vbool: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_AutoSize(@as(*const IMSVidCtl, @ptrCast(self)), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_BackColor(self: *const T, backcolor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_BackColor(@as(*const IMSVidCtl, @ptrCast(self)), backcolor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_BackColor(self: *const T, backcolor: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_BackColor(@as(*const IMSVidCtl, @ptrCast(self)), backcolor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_Enabled(self: *const T, pbool: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_Enabled(@as(*const IMSVidCtl, @ptrCast(self)), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_Enabled(self: *const T, vbool: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_Enabled(@as(*const IMSVidCtl, @ptrCast(self)), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_TabStop(self: *const T, pbool: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_TabStop(@as(*const IMSVidCtl, @ptrCast(self)), pbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_TabStop(self: *const T, vbool: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_TabStop(@as(*const IMSVidCtl, @ptrCast(self)), vbool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_Window(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_Window(@as(*const IMSVidCtl, @ptrCast(self)), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Refresh(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_DisplaySize(self: *const T, CurrentValue: ?*DisplaySizeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_DisplaySize(@as(*const IMSVidCtl, @ptrCast(self)), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_DisplaySize(self: *const T, NewValue: DisplaySizeList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_DisplaySize(@as(*const IMSVidCtl, @ptrCast(self)), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_MaintainAspectRatio(self: *const T, CurrentValue: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_MaintainAspectRatio(@as(*const IMSVidCtl, @ptrCast(self)), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_MaintainAspectRatio(self: *const T, NewValue: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_MaintainAspectRatio(@as(*const IMSVidCtl, @ptrCast(self)), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_ColorKey(self: *const T, CurrentValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_ColorKey(@as(*const IMSVidCtl, @ptrCast(self)), CurrentValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_ColorKey(self: *const T, NewValue: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_ColorKey(@as(*const IMSVidCtl, @ptrCast(self)), NewValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_InputsAvailable(self: *const T, CategoryGuid: ?BSTR, pVal: ?*?*IMSVidInputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_InputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_OutputsAvailable(self: *const T, CategoryGuid: ?BSTR, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_OutputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get__InputsAvailable(self: *const T, CategoryGuid: ?*const Guid, pVal: ?*?*IMSVidInputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get__InputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get__OutputsAvailable(self: *const T, CategoryGuid: ?*const Guid, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get__OutputsAvailable(@as(*const IMSVidCtl, @ptrCast(self)), CategoryGuid, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_VideoRenderersAvailable(self: *const T, pVal: ?*?*IMSVidVideoRendererDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_VideoRenderersAvailable(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AudioRenderersAvailable(self: *const T, pVal: ?*?*IMSVidAudioRendererDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AudioRenderersAvailable(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_FeaturesAvailable(self: *const T, pVal: ?*?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_FeaturesAvailable(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_InputActive(self: *const T, pVal: ?*?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_InputActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_InputActive(self: *const T, pVal: ?*IMSVidInputDevice) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_InputActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_OutputsActive(self: *const T, pVal: ?*?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_OutputsActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_OutputsActive(self: *const T, pVal: ?*IMSVidOutputDevices) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_OutputsActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_VideoRendererActive(self: *const T, pVal: ?*?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_VideoRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_VideoRendererActive(self: *const T, pVal: ?*IMSVidVideoRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_VideoRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_AudioRendererActive(self: *const T, pVal: ?*?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_AudioRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_AudioRendererActive(self: *const T, pVal: ?*IMSVidAudioRenderer) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_AudioRendererActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_FeaturesActive(self: *const T, pVal: ?*?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_FeaturesActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_put_FeaturesActive(self: *const T, pVal: ?*IMSVidFeatures) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).put_FeaturesActive(@as(*const IMSVidCtl, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_get_State(self: *const T, lState: ?*MSVidCtlStateList) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).get_State(@as(*const IMSVidCtl, @ptrCast(self)), lState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_View(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).View(@as(*const IMSVidCtl, @ptrCast(self)), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Build(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Build(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Run(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Run(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_Decompose(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).Decompose(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_DisableVideo(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).DisableVideo(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_DisableAudio(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).DisableAudio(@as(*const IMSVidCtl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSVidCtl_ViewNext(self: *const T, v: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMSVidCtl.VTable, @ptrCast(self.vtable)).ViewNext(@as(*const IMSVidCtl, @ptrCast(self)), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMSEventBinder_Value = Guid.initString("c3a9f406-2222-436d-86d5-ba3229279efb");
pub const IID_IMSEventBinder = &IID_IMSEventBinder_Value;
pub const IMSEventBinder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Bind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSEventBinder,
                pEventObject: ?*IDispatch,
                EventName: ?BSTR,
                EventHandler: ?BSTR,
                CancelID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSEventBinder,
                pEventObject: ?*IDispatch,
                EventName: ?BSTR,
                EventHandler: ?BSTR,
                CancelID: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unbind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMSEventBinder,
                CancelCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMSEventBinder,
                CancelCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSEventBinder_Bind(self: *const T, pEventObject: ?*IDispatch, EventName: ?BSTR, EventHandler: ?BSTR, CancelID: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMSEventBinder.VTable, @ptrCast(self.vtable)).Bind(@as(*const IMSEventBinder, @ptrCast(self)), pEventObject, EventName, EventHandler, CancelID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSEventBinder_Unbind(self: *const T, CancelCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IMSEventBinder.VTable, @ptrCast(self.vtable)).Unbind(@as(*const IMSEventBinder, @ptrCast(self)), CancelCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID__IMSVidCtlEvents_Value = Guid.initString("b0edf164-910a-11d2-b632-00c04f79498e");
pub const IID__IMSVidCtlEvents = &IID__IMSVidCtlEvents_Value;
pub const _IMSVidCtlEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MSVidAnalogTunerDevice_Value = Guid.initString("1c15d484-911d-11d2-b632-00c04f79498e");
pub const CLSID_MSVidAnalogTunerDevice = &CLSID_MSVidAnalogTunerDevice_Value;

const CLSID_MSVidBDATunerDevice_Value = Guid.initString("a2e3074e-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_MSVidBDATunerDevice = &CLSID_MSVidBDATunerDevice_Value;

const CLSID_MSVidFilePlaybackDevice_Value = Guid.initString("37b0353c-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidFilePlaybackDevice = &CLSID_MSVidFilePlaybackDevice_Value;

const CLSID_MSVidWebDVD_Value = Guid.initString("011b3619-fe63-4814-8a84-15a194ce9ce3");
pub const CLSID_MSVidWebDVD = &CLSID_MSVidWebDVD_Value;

const CLSID_MSVidWebDVDAdm_Value = Guid.initString("fa7c375b-66a7-4280-879d-fd459c84bb02");
pub const CLSID_MSVidWebDVDAdm = &CLSID_MSVidWebDVDAdm_Value;

const CLSID_MSVidVideoRenderer_Value = Guid.initString("37b03543-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidVideoRenderer = &CLSID_MSVidVideoRenderer_Value;

const CLSID_MSVidVMR9_Value = Guid.initString("24dc3975-09bf-4231-8655-3ee71f43837d");
pub const CLSID_MSVidVMR9 = &CLSID_MSVidVMR9_Value;

const CLSID_MSVidEVR_Value = Guid.initString("c45268a2-fa81-4e19-b1e3-72edbd60aeda");
pub const CLSID_MSVidEVR = &CLSID_MSVidEVR_Value;

const CLSID_MSVidAudioRenderer_Value = Guid.initString("37b03544-a4c8-11d2-b634-00c04f79498e");
pub const CLSID_MSVidAudioRenderer = &CLSID_MSVidAudioRenderer_Value;

const CLSID_MSVidGenericSink_Value = Guid.initString("4a5869cf-929d-4040-ae03-fcafc5b9cd42");
pub const CLSID_MSVidGenericSink = &CLSID_MSVidGenericSink_Value;

const CLSID_MSVidStreamBufferSink_Value = Guid.initString("9e77aac4-35e5-42a1-bdc2-8f3ff399847c");
pub const CLSID_MSVidStreamBufferSink = &CLSID_MSVidStreamBufferSink_Value;

const CLSID_MSVidStreamBufferSource_Value = Guid.initString("ad8e510d-217f-409b-8076-29c5e73b98e8");
pub const CLSID_MSVidStreamBufferSource = &CLSID_MSVidStreamBufferSource_Value;

const CLSID_MSVidStreamBufferV2Source_Value = Guid.initString("fd351ea1-4173-4af4-821d-80d4ae979048");
pub const CLSID_MSVidStreamBufferV2Source = &CLSID_MSVidStreamBufferV2Source_Value;

const CLSID_MSVidEncoder_Value = Guid.initString("bb530c63-d9df-4b49-9439-63453962e598");
pub const CLSID_MSVidEncoder = &CLSID_MSVidEncoder_Value;

const CLSID_MSVidITVCapture_Value = Guid.initString("5740a302-ef0b-45ce-bf3b-4470a14a8980");
pub const CLSID_MSVidITVCapture = &CLSID_MSVidITVCapture_Value;

const CLSID_MSVidITVPlayback_Value = Guid.initString("9e797ed0-5253-4243-a9b7-bd06c58f8ef3");
pub const CLSID_MSVidITVPlayback = &CLSID_MSVidITVPlayback_Value;

const CLSID_MSVidCCA_Value = Guid.initString("86151827-e47b-45ee-8421-d10e6e690979");
pub const CLSID_MSVidCCA = &CLSID_MSVidCCA_Value;

const CLSID_MSVidClosedCaptioning_Value = Guid.initString("7f9cb14d-48e4-43b6-9346-1aebc39c64d3");
pub const CLSID_MSVidClosedCaptioning = &CLSID_MSVidClosedCaptioning_Value;

const CLSID_MSVidClosedCaptioningSI_Value = Guid.initString("92ed88bf-879e-448f-b6b6-a385bceb846d");
pub const CLSID_MSVidClosedCaptioningSI = &CLSID_MSVidClosedCaptioningSI_Value;

const CLSID_MSVidDataServices_Value = Guid.initString("334125c0-77e5-11d3-b653-00c04f79498e");
pub const CLSID_MSVidDataServices = &CLSID_MSVidDataServices_Value;

const CLSID_MSVidXDS_Value = Guid.initString("0149eedf-d08f-4142-8d73-d23903d21e90");
pub const CLSID_MSVidXDS = &CLSID_MSVidXDS_Value;

const CLSID_MSVidAnalogCaptureToDataServices_Value = Guid.initString("c5702cd6-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToDataServices = &CLSID_MSVidAnalogCaptureToDataServices_Value;

const CLSID_MSVidDataServicesToStreamBufferSink_Value = Guid.initString("38f03426-e83b-4e68-b65b-dcae73304838");
pub const CLSID_MSVidDataServicesToStreamBufferSink = &CLSID_MSVidDataServicesToStreamBufferSink_Value;

const CLSID_MSVidDataServicesToXDS_Value = Guid.initString("0429ec6e-1144-4bed-b88b-2fb9899a4a3d");
pub const CLSID_MSVidDataServicesToXDS = &CLSID_MSVidDataServicesToXDS_Value;

const CLSID_MSVidAnalogCaptureToXDS_Value = Guid.initString("3540d440-5b1d-49cb-821a-e84b8cf065a7");
pub const CLSID_MSVidAnalogCaptureToXDS = &CLSID_MSVidAnalogCaptureToXDS_Value;

const CLSID_MSVidCtl_Value = Guid.initString("b0edf163-910a-11d2-b632-00c04f79498e");
pub const CLSID_MSVidCtl = &CLSID_MSVidCtl_Value;

const CLSID_MSVidInputDevices_Value = Guid.initString("c5702ccc-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidInputDevices = &CLSID_MSVidInputDevices_Value;

const CLSID_MSVidOutputDevices_Value = Guid.initString("c5702ccd-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidOutputDevices = &CLSID_MSVidOutputDevices_Value;

const CLSID_MSVidVideoRendererDevices_Value = Guid.initString("c5702cce-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidVideoRendererDevices = &CLSID_MSVidVideoRendererDevices_Value;

const CLSID_MSVidAudioRendererDevices_Value = Guid.initString("c5702ccf-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidAudioRendererDevices = &CLSID_MSVidAudioRendererDevices_Value;

const CLSID_MSVidFeatures_Value = Guid.initString("c5702cd0-9b79-11d3-b654-00c04f79498e");
pub const CLSID_MSVidFeatures = &CLSID_MSVidFeatures_Value;

const CLSID_MSVidGenericComposite_Value = Guid.initString("2764bce5-cc39-11d2-b639-00c04f79498e");
pub const CLSID_MSVidGenericComposite = &CLSID_MSVidGenericComposite_Value;

const CLSID_MSVidAnalogCaptureToOverlayMixer_Value = Guid.initString("e18af75a-08af-11d3-b64a-00c04f79498e");
pub const CLSID_MSVidAnalogCaptureToOverlayMixer = &CLSID_MSVidAnalogCaptureToOverlayMixer_Value;

const CLSID_MSVidWebDVDToVideoRenderer_Value = Guid.initString("267db0b3-55e3-4902-949b-df8f5cec0191");
pub const CLSID_MSVidWebDVDToVideoRenderer = &CLSID_MSVidWebDVDToVideoRenderer_Value;

const CLSID_MSVidWebDVDToAudioRenderer_Value = Guid.initString("8d04238e-9fd1-41c6-8de3-9e1ee309e935");
pub const CLSID_MSVidWebDVDToAudioRenderer = &CLSID_MSVidWebDVDToAudioRenderer_Value;

const CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value = Guid.initString("6ad28ee1-5002-4e71-aaf7-bd077907b1a4");
pub const CLSID_MSVidMPEG2DecoderToClosedCaptioning = &CLSID_MSVidMPEG2DecoderToClosedCaptioning_Value;

const CLSID_MSVidAnalogCaptureToStreamBufferSink_Value = Guid.initString("9f50e8b1-9530-4ddc-825e-1af81d47aed6");
pub const CLSID_MSVidAnalogCaptureToStreamBufferSink = &CLSID_MSVidAnalogCaptureToStreamBufferSink_Value;

const CLSID_MSVidDigitalCaptureToStreamBufferSink_Value = Guid.initString("abe40035-27c3-4a2f-8153-6624471608af");
pub const CLSID_MSVidDigitalCaptureToStreamBufferSink = &CLSID_MSVidDigitalCaptureToStreamBufferSink_Value;

const CLSID_MSVidITVToStreamBufferSink_Value = Guid.initString("92b94828-1af7-4e6e-9ebf-770657f77af5");
pub const CLSID_MSVidITVToStreamBufferSink = &CLSID_MSVidITVToStreamBufferSink_Value;

const CLSID_MSVidCCAToStreamBufferSink_Value = Guid.initString("3ef76d68-8661-4843-8b8f-c37163d8c9ce");
pub const CLSID_MSVidCCAToStreamBufferSink = &CLSID_MSVidCCAToStreamBufferSink_Value;

const CLSID_MSVidEncoderToStreamBufferSink_Value = Guid.initString("a0b9b497-afbc-45ad-a8a6-9b077c40d4f2");
pub const CLSID_MSVidEncoderToStreamBufferSink = &CLSID_MSVidEncoderToStreamBufferSink_Value;

const CLSID_MSVidFilePlaybackToVideoRenderer_Value = Guid.initString("b401c5eb-8457-427f-84ea-a4d2363364b0");
pub const CLSID_MSVidFilePlaybackToVideoRenderer = &CLSID_MSVidFilePlaybackToVideoRenderer_Value;

const CLSID_MSVidFilePlaybackToAudioRenderer_Value = Guid.initString("cc23f537-18d4-4ece-93bd-207a84726979");
pub const CLSID_MSVidFilePlaybackToAudioRenderer = &CLSID_MSVidFilePlaybackToAudioRenderer_Value;

const CLSID_MSVidAnalogTVToEncoder_Value = Guid.initString("28953661-0231-41db-8986-21ff4388ee9b");
pub const CLSID_MSVidAnalogTVToEncoder = &CLSID_MSVidAnalogTVToEncoder_Value;

const CLSID_MSVidStreamBufferSourceToVideoRenderer_Value = Guid.initString("3c4708dc-b181-46a8-8da8-4ab0371758cd");
pub const CLSID_MSVidStreamBufferSourceToVideoRenderer = &CLSID_MSVidStreamBufferSourceToVideoRenderer_Value;

const CLSID_MSVidAnalogCaptureToCCA_Value = Guid.initString("942b7909-a28e-49a1-a207-34ebcbcb4b3b");
pub const CLSID_MSVidAnalogCaptureToCCA = &CLSID_MSVidAnalogCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToCCA_Value = Guid.initString("73d14237-b9db-4efa-a6dd-84350421fb2f");
pub const CLSID_MSVidDigitalCaptureToCCA = &CLSID_MSVidDigitalCaptureToCCA_Value;

const CLSID_MSVidDigitalCaptureToITV_Value = Guid.initString("5d8e73f7-4989-4ac8-8a98-39ba0d325302");
pub const CLSID_MSVidDigitalCaptureToITV = &CLSID_MSVidDigitalCaptureToITV_Value;

const CLSID_MSVidSBESourceToITV_Value = Guid.initString("2291478c-5ee3-4bef-ab5d-b5ff2cf58352");
pub const CLSID_MSVidSBESourceToITV = &CLSID_MSVidSBESourceToITV_Value;

const CLSID_MSVidSBESourceToCC_Value = Guid.initString("9193a8f9-0cba-400e-aa97-eb4709164576");
pub const CLSID_MSVidSBESourceToCC = &CLSID_MSVidSBESourceToCC_Value;

const CLSID_MSVidSBESourceToGenericSink_Value = Guid.initString("991da7e5-953f-435b-be5e-b92a05edfc42");
pub const CLSID_MSVidSBESourceToGenericSink = &CLSID_MSVidSBESourceToGenericSink_Value;

const CLSID_MSVidCCToVMR_Value = Guid.initString("c4bf2784-ae00-41ba-9828-9c953bd3c54a");
pub const CLSID_MSVidCCToVMR = &CLSID_MSVidCCToVMR_Value;

const CLSID_MSVidCCToAR_Value = Guid.initString("d76334ca-d89e-4baf-86ab-ddb59372afc2");
pub const CLSID_MSVidCCToAR = &CLSID_MSVidCCToAR_Value;

const CLSID_MSEventBinder_Value = Guid.initString("577faa18-4518-445e-8f70-1473f8cf4ba4");
pub const CLSID_MSEventBinder = &CLSID_MSEventBinder_Value;

const CLSID_MSVidStreamBufferRecordingControl_Value = Guid.initString("caafdd83-cefc-4e3d-ba03-175f17a24f91");
pub const CLSID_MSVidStreamBufferRecordingControl = &CLSID_MSVidStreamBufferRecordingControl_Value;

const CLSID_MSVidRect_Value = Guid.initString("cb4276e6-7d5f-4cf1-9727-629c5e6db6ae");
pub const CLSID_MSVidRect = &CLSID_MSVidRect_Value;

const CLSID_MSVidDevice_Value = Guid.initString("6e40476f-9c49-4c3e-8bb9-8587958eff74");
pub const CLSID_MSVidDevice = &CLSID_MSVidDevice_Value;

const CLSID_MSVidDevice2_Value = Guid.initString("30997f7d-b3b5-4a1c-983a-1fe8098cb77d");
pub const CLSID_MSVidDevice2 = &CLSID_MSVidDevice2_Value;

const CLSID_MSVidInputDevice_Value = Guid.initString("ac1972f2-138a-4ca3-90da-ae51112eda28");
pub const CLSID_MSVidInputDevice = &CLSID_MSVidInputDevice_Value;

const CLSID_MSVidVideoInputDevice_Value = Guid.initString("95f4820b-bb3a-4e2d-bc64-5b817bc2c30e");
pub const CLSID_MSVidVideoInputDevice = &CLSID_MSVidVideoInputDevice_Value;

const CLSID_MSVidVideoPlaybackDevice_Value = Guid.initString("1990d634-1a5e-4071-a34a-53aaffce9f36");
pub const CLSID_MSVidVideoPlaybackDevice = &CLSID_MSVidVideoPlaybackDevice_Value;

const CLSID_MSVidFeature_Value = Guid.initString("7748530b-c08a-47ea-b24c-be8695ff405f");
pub const CLSID_MSVidFeature = &CLSID_MSVidFeature_Value;

const CLSID_MSVidOutput_Value = Guid.initString("87eb890d-03ad-4e9d-9866-376e5ec572ed");
pub const CLSID_MSVidOutput = &CLSID_MSVidOutput_Value;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferInitialize_Value = Guid.initString("9ce50f2d-6ba7-40fb-a034-50b1a674ec78");
pub const IID_IStreamBufferInitialize = &IID_IStreamBufferInitialize_Value;
pub const IStreamBufferInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHKEY: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferInitialize,
                hkeyRoot: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferInitialize,
                hkeyRoot: ?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferInitialize,
                cSIDs: u32,
                ppSID: ?*?PSID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferInitialize,
                cSIDs: u32,
                ppSID: ?*?PSID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferInitialize_SetHKEY(self: *const T, hkeyRoot: ?HKEY) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferInitialize.VTable, @ptrCast(self.vtable)).SetHKEY(@as(*const IStreamBufferInitialize, @ptrCast(self)), hkeyRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferInitialize_SetSIDs(self: *const T, cSIDs: u32, ppSID: ?*?PSID) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferInitialize.VTable, @ptrCast(self.vtable)).SetSIDs(@as(*const IStreamBufferInitialize, @ptrCast(self)), cSIDs, ppSID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RECORDING_TYPE = enum(i32) {
    CONTENT = 0,
    REFERENCE = 1,
};
pub const RECORDING_TYPE_CONTENT = RECORDING_TYPE.CONTENT;
pub const RECORDING_TYPE_REFERENCE = RECORDING_TYPE.REFERENCE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink_Value = Guid.initString("afd1f242-7efd-45ee-ba4e-407a25c9a77a");
pub const IID_IStreamBufferSink = &IID_IStreamBufferSink_Value;
pub const IStreamBufferSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSink,
                pszStreamBufferFilename: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSink,
                pszStreamBufferFilename: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRecorder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSink,
                pszFilename: ?[*:0]align(1) const u16,
                dwRecordType: u32,
                pRecordingIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSink,
                pszFilename: ?[*:0]align(1) const u16,
                dwRecordType: u32,
                pRecordingIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsProfileLocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_LockProfile(self: *const T, pszStreamBufferFilename: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).LockProfile(@as(*const IStreamBufferSink, @ptrCast(self)), pszStreamBufferFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_CreateRecorder(self: *const T, pszFilename: ?[*:0]align(1) const u16, dwRecordType: u32, pRecordingIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).CreateRecorder(@as(*const IStreamBufferSink, @ptrCast(self)), pszFilename, dwRecordType, pRecordingIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink_IsProfileLocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSink.VTable, @ptrCast(self.vtable)).IsProfileLocked(@as(*const IStreamBufferSink, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink2_Value = Guid.initString("db94a660-f4fb-4bfa-bcc6-fe159a4eea93");
pub const IID_IStreamBufferSink2 = &IID_IStreamBufferSink2_Value;
pub const IStreamBufferSink2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink.VTable,
        UnlockProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSink2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink2_UnlockProfile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSink2.VTable, @ptrCast(self.vtable)).UnlockProfile(@as(*const IStreamBufferSink2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSink3_Value = Guid.initString("974723f2-887a-4452-9366-2cff3057bc8f");
pub const IID_IStreamBufferSink3 = &IID_IStreamBufferSink3_Value;
pub const IStreamBufferSink3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferSink2.VTable,
        SetAvailableFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSink3,
                prtMin: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSink3,
                prtMin: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferSink2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSink3_SetAvailableFilter(self: *const T, prtMin: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSink3.VTable, @ptrCast(self.vtable)).SetAvailableFilter(@as(*const IStreamBufferSink3, @ptrCast(self)), prtMin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferSource_Value = Guid.initString("1c5bd776-6ced-4f44-8164-5eab0e98db12");
pub const IID_IStreamBufferSource = &IID_IStreamBufferSource_Value;
pub const IStreamBufferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferSource,
                pIStreamBufferSink: ?*IStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferSource,
                pIStreamBufferSink: ?*IStreamBufferSink,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferSource_SetStreamSink(self: *const T, pIStreamBufferSink: ?*IStreamBufferSink) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferSource.VTable, @ptrCast(self.vtable)).SetStreamSink(@as(*const IStreamBufferSource, @ptrCast(self)), pIStreamBufferSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordControl_Value = Guid.initString("ba9b6c99-f3c7-4ff2-92db-cfdd4851bf31");
pub const IID_IStreamBufferRecordControl = &IID_IStreamBufferRecordControl_Value;
pub const IStreamBufferRecordControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordControl,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordControl,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordControl,
                rtStop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordControl,
                rtStop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordingStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordControl,
                phResult: ?*HRESULT,
                pbStarted: ?*BOOL,
                pbStopped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordControl,
                phResult: ?*HRESULT,
                pbStarted: ?*BOOL,
                pbStopped: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_Start(self: *const T, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).Start(@as(*const IStreamBufferRecordControl, @ptrCast(self)), prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_Stop(self: *const T, rtStop: i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IStreamBufferRecordControl, @ptrCast(self)), rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordControl_GetRecordingStatus(self: *const T, phResult: ?*HRESULT, pbStarted: ?*BOOL, pbStopped: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordControl.VTable, @ptrCast(self.vtable)).GetRecordingStatus(@as(*const IStreamBufferRecordControl, @ptrCast(self)), phResult, pbStarted, pbStopped);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecComp_Value = Guid.initString("9e259a9b-8815-42ae-b09f-221970b154fd");
pub const IID_IStreamBufferRecComp = &IID_IStreamBufferRecComp_Value;
pub const IStreamBufferRecComp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
                pszTargetFilename: ?[*:0]align(1) const u16,
                pszSBRecProfileRef: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
                pszTargetFilename: ?[*:0]align(1) const u16,
                pszSBRecProfileRef: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Append: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
                pszSBRecording: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
                pszSBRecording: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
                pszSBRecording: ?[*:0]align(1) const u16,
                rtStart: i64,
                rtStop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
                pszSBRecording: ?[*:0]align(1) const u16,
                rtStart: i64,
                rtStop: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
                pcSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
                pcSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecComp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Initialize(self: *const T, pszTargetFilename: ?[*:0]align(1) const u16, pszSBRecProfileRef: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IStreamBufferRecComp, @ptrCast(self)), pszTargetFilename, pszSBRecProfileRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Append(self: *const T, pszSBRecording: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Append(@as(*const IStreamBufferRecComp, @ptrCast(self)), pszSBRecording);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_AppendEx(self: *const T, pszSBRecording: ?[*:0]align(1) const u16, rtStart: i64, rtStop: i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).AppendEx(@as(*const IStreamBufferRecComp, @ptrCast(self)), pszSBRecording, rtStart, rtStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_GetCurrentLength(self: *const T, pcSeconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).GetCurrentLength(@as(*const IStreamBufferRecComp, @ptrCast(self)), pcSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Close(@as(*const IStreamBufferRecComp, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecComp_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecComp.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IStreamBufferRecComp, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTR_DATATYPE = enum(i32) {
    DWORD = 0,
    STRING = 1,
    BINARY = 2,
    BOOL = 3,
    QWORD = 4,
    WORD = 5,
    GUID = 6,
};
pub const STREAMBUFFER_TYPE_DWORD = STREAMBUFFER_ATTR_DATATYPE.DWORD;
pub const STREAMBUFFER_TYPE_STRING = STREAMBUFFER_ATTR_DATATYPE.STRING;
pub const STREAMBUFFER_TYPE_BINARY = STREAMBUFFER_ATTR_DATATYPE.BINARY;
pub const STREAMBUFFER_TYPE_BOOL = STREAMBUFFER_ATTR_DATATYPE.BOOL;
pub const STREAMBUFFER_TYPE_QWORD = STREAMBUFFER_ATTR_DATATYPE.QWORD;
pub const STREAMBUFFER_TYPE_WORD = STREAMBUFFER_ATTR_DATATYPE.WORD;
pub const STREAMBUFFER_TYPE_GUID = STREAMBUFFER_ATTR_DATATYPE.GUID;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferRecordingAttribute_Value = Guid.initString("16ca4e03-fe69-4705-bd41-5b7dfc0c95f3");
pub const IID_IStreamBufferRecordingAttribute = &IID_IStreamBufferRecordingAttribute_Value;
pub const IStreamBufferRecordingAttribute = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttribute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordingAttribute,
                ulReserved: u32,
                pszAttributeName: ?[*:0]align(1) const u16,
                StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                cbAttributeLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordingAttribute,
                ulReserved: u32,
                pszAttributeName: ?[*:0]align(1) const u16,
                StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                cbAttributeLength: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordingAttribute,
                ulReserved: u32,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordingAttribute,
                ulReserved: u32,
                pcAttributes: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordingAttribute,
                pszAttributeName: ?[*:0]align(1) const u16,
                pulReserved: ?*u32,
                pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordingAttribute,
                pszAttributeName: ?[*:0]align(1) const u16,
                pulReserved: ?*u32,
                pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordingAttribute,
                wIndex: u16,
                pulReserved: ?*u32,
                pszAttributeName: ?PWSTR,
                pcchNameLength: ?*u16,
                pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordingAttribute,
                wIndex: u16,
                pulReserved: ?*u32,
                pszAttributeName: ?PWSTR,
                pcchNameLength: ?*u16,
                pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE,
                pbAttribute: [*:0]u8,
                pcbLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferRecordingAttribute,
                ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferRecordingAttribute,
                ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_SetAttribute(self: *const T, ulReserved: u32, pszAttributeName: ?[*:0]align(1) const u16, StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, cbAttributeLength: u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).SetAttribute(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), ulReserved, pszAttributeName, StreamBufferAttributeType, pbAttribute, cbAttributeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeCount(self: *const T, ulReserved: u32, pcAttributes: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeCount(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), ulReserved, pcAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeByName(self: *const T, pszAttributeName: ?[*:0]align(1) const u16, pulReserved: ?*u32, pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, pcbLength: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeByName(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), pszAttributeName, pulReserved, pStreamBufferAttributeType, pbAttribute, pcbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_GetAttributeByIndex(self: *const T, wIndex: u16, pulReserved: ?*u32, pszAttributeName: ?PWSTR, pcchNameLength: ?*u16, pStreamBufferAttributeType: ?*STREAMBUFFER_ATTR_DATATYPE, pbAttribute: [*:0]u8, pcbLength: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).GetAttributeByIndex(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), wIndex, pulReserved, pszAttributeName, pcchNameLength, pStreamBufferAttributeType, pbAttribute, pcbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferRecordingAttribute_EnumAttributes(self: *const T, ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferRecordingAttribute.VTable, @ptrCast(self.vtable)).EnumAttributes(@as(*const IStreamBufferRecordingAttribute, @ptrCast(self)), ppIEnumStreamBufferAttrib);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAMBUFFER_ATTRIBUTE = extern struct {
    pszName: ?PWSTR,
    StreamBufferAttributeType: STREAMBUFFER_ATTR_DATATYPE,
    pbAttribute: ?*u8,
    cbLength: u16,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamBufferRecordingAttrib_Value = Guid.initString("c18a9162-1e82-4142-8c73-5690fa62fe33");
pub const IID_IEnumStreamBufferRecordingAttrib = &IID_IEnumStreamBufferRecordingAttrib_Value;
pub const IEnumStreamBufferRecordingAttrib = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                cRequest: u32,
                pStreamBufferAttribute: [*]STREAMBUFFER_ATTRIBUTE,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                cRequest: u32,
                pStreamBufferAttribute: [*]STREAMBUFFER_ATTRIBUTE,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamBufferRecordingAttrib,
                ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Next(self: *const T, cRequest: u32, pStreamBufferAttribute: [*]STREAMBUFFER_ATTRIBUTE, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), cRequest, pStreamBufferAttribute, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamBufferRecordingAttrib_Clone(self: *const T, ppIEnumStreamBufferAttrib: ?*?*IEnumStreamBufferRecordingAttrib) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamBufferRecordingAttrib.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumStreamBufferRecordingAttrib, @ptrCast(self)), ppIEnumStreamBufferAttrib);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure_Value = Guid.initString("ce14dfae-4098-4af7-bbf7-d6511f835414");
pub const IID_IStreamBufferConfigure = &IID_IStreamBufferConfigure_Value;
pub const IStreamBufferConfigure = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                pszDirectoryName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                pszDirectoryName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                ppszDirectoryName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                ppszDirectoryName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackingFileCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                dwMin: u32,
                dwMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                dwMin: u32,
                dwMax: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingFileCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                pdwMin: ?*u32,
                pdwMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                pdwMin: ?*u32,
                pdwMax: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackingFileDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                dwSeconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                dwSeconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackingFileDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure,
                pdwSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure,
                pdwSeconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetDirectory(self: *const T, pszDirectoryName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetDirectory(@as(*const IStreamBufferConfigure, @ptrCast(self)), pszDirectoryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetDirectory(self: *const T, ppszDirectoryName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetDirectory(@as(*const IStreamBufferConfigure, @ptrCast(self)), ppszDirectoryName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetBackingFileCount(self: *const T, dwMin: u32, dwMax: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetBackingFileCount(@as(*const IStreamBufferConfigure, @ptrCast(self)), dwMin, dwMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetBackingFileCount(self: *const T, pdwMin: ?*u32, pdwMax: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetBackingFileCount(@as(*const IStreamBufferConfigure, @ptrCast(self)), pdwMin, pdwMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_SetBackingFileDuration(self: *const T, dwSeconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).SetBackingFileDuration(@as(*const IStreamBufferConfigure, @ptrCast(self)), dwSeconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure_GetBackingFileDuration(self: *const T, pdwSeconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure.VTable, @ptrCast(self.vtable)).GetBackingFileDuration(@as(*const IStreamBufferConfigure, @ptrCast(self)), pdwSeconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferConfigure2_Value = Guid.initString("53e037bf-3992-4282-ae34-2487b4dae06b");
pub const IID_IStreamBufferConfigure2 = &IID_IStreamBufferConfigure2_Value;
pub const IStreamBufferConfigure2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure.VTable,
        SetMultiplexedPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure2,
                cbBytesPerPacket: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure2,
                cbBytesPerPacket: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMultiplexedPacketSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure2,
                pcbBytesPerPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure2,
                pcbBytesPerPacket: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFFTransitionRates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure2,
                dwMaxFullFrameRate: u32,
                dwMaxNonSkippingRate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure2,
                dwMaxFullFrameRate: u32,
                dwMaxNonSkippingRate: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFFTransitionRates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure2,
                pdwMaxFullFrameRate: ?*u32,
                pdwMaxNonSkippingRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure2,
                pdwMaxFullFrameRate: ?*u32,
                pdwMaxNonSkippingRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferConfigure.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_SetMultiplexedPacketSize(self: *const T, cbBytesPerPacket: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).SetMultiplexedPacketSize(@as(*const IStreamBufferConfigure2, @ptrCast(self)), cbBytesPerPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_GetMultiplexedPacketSize(self: *const T, pcbBytesPerPacket: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).GetMultiplexedPacketSize(@as(*const IStreamBufferConfigure2, @ptrCast(self)), pcbBytesPerPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_SetFFTransitionRates(self: *const T, dwMaxFullFrameRate: u32, dwMaxNonSkippingRate: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).SetFFTransitionRates(@as(*const IStreamBufferConfigure2, @ptrCast(self)), dwMaxFullFrameRate, dwMaxNonSkippingRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure2_GetFFTransitionRates(self: *const T, pdwMaxFullFrameRate: ?*u32, pdwMaxNonSkippingRate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure2.VTable, @ptrCast(self.vtable)).GetFFTransitionRates(@as(*const IStreamBufferConfigure2, @ptrCast(self)), pdwMaxFullFrameRate, pdwMaxNonSkippingRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IStreamBufferConfigure3_Value = Guid.initString("7e2d2a1e-7192-4bd7-80c1-061fd1d10402");
pub const IID_IStreamBufferConfigure3 = &IID_IStreamBufferConfigure3_Value;
pub const IStreamBufferConfigure3 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferConfigure2.VTable,
        SetStartRecConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure3,
                fStartStopsCur: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure3,
                fStartStopsCur: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartRecConfig: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure3,
                pfStartStopsCur: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure3,
                pfStartStopsCur: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure3,
                pszNamespace: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure3,
                pszNamespace: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferConfigure3,
                ppszNamespace: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferConfigure3,
                ppszNamespace: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferConfigure2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_SetStartRecConfig(self: *const T, fStartStopsCur: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).SetStartRecConfig(@as(*const IStreamBufferConfigure3, @ptrCast(self)), fStartStopsCur);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_GetStartRecConfig(self: *const T, pfStartStopsCur: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).GetStartRecConfig(@as(*const IStreamBufferConfigure3, @ptrCast(self)), pfStartStopsCur);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_SetNamespace(self: *const T, pszNamespace: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).SetNamespace(@as(*const IStreamBufferConfigure3, @ptrCast(self)), pszNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferConfigure3_GetNamespace(self: *const T, ppszNamespace: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferConfigure3.VTable, @ptrCast(self.vtable)).GetNamespace(@as(*const IStreamBufferConfigure3, @ptrCast(self)), ppszNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking_Value = Guid.initString("f61f5c26-863d-4afa-b0ba-2f81dc978596");
pub const IID_IStreamBufferMediaSeeking = &IID_IStreamBufferMediaSeeking_Value;
pub const IStreamBufferMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IMediaSeeking.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaSeeking.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferMediaSeeking2_Value = Guid.initString("3a439ab0-155f-470a-86a6-9ea54afd6eaf");
pub const IID_IStreamBufferMediaSeeking2 = &IID_IStreamBufferMediaSeeking2_Value;
pub const IStreamBufferMediaSeeking2 = extern struct {
    pub const VTable = extern struct {
        base: IStreamBufferMediaSeeking.VTable,
        SetRateEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferMediaSeeking2,
                dRate: f64,
                dwFramesPerSec: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferMediaSeeking2,
                dRate: f64,
                dwFramesPerSec: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamBufferMediaSeeking.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferMediaSeeking2_SetRateEx(self: *const T, dRate: f64, dwFramesPerSec: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferMediaSeeking2.VTable, @ptrCast(self.vtable)).SetRateEx(@as(*const IStreamBufferMediaSeeking2, @ptrCast(self)), dRate, dwFramesPerSec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SBE_PIN_DATA = extern struct {
    cDataBytes: u64,
    cSamplesProcessed: u64,
    cDiscontinuities: u64,
    cSyncPoints: u64,
    cTimestamps: u64,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IStreamBufferDataCounters_Value = Guid.initString("9d2a2563-31ab-402e-9a6b-adb903489440");
pub const IID_IStreamBufferDataCounters = &IID_IStreamBufferDataCounters_Value;
pub const IStreamBufferDataCounters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferDataCounters,
                pPinData: ?*SBE_PIN_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferDataCounters,
                pPinData: ?*SBE_PIN_DATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBufferDataCounters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBufferDataCounters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferDataCounters_GetData(self: *const T, pPinData: ?*SBE_PIN_DATA) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferDataCounters.VTable, @ptrCast(self.vtable)).GetData(@as(*const IStreamBufferDataCounters, @ptrCast(self)), pPinData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBufferDataCounters_ResetData(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IStreamBufferDataCounters.VTable, @ptrCast(self.vtable)).ResetData(@as(*const IStreamBufferDataCounters, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CROSSBAR_DEFAULT_FLAGS = enum(i32) {
    PROFILE = 1,
    STREAMS = 2,
};
pub const DEF_MODE_PROFILE = CROSSBAR_DEFAULT_FLAGS.PROFILE;
pub const DEF_MODE_STREAMS = CROSSBAR_DEFAULT_FLAGS.STREAMS;

pub const SBE2_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: u32,
    Reserved: u32,
};

pub const DVR_STREAM_DESC = extern struct {
    Version: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
    guidSubMediaType: Guid,
    guidFormatType: Guid,
    MediaType: AM_MEDIA_TYPE,
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent_Value = Guid.initString("caede759-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2GlobalEvent = &IID_ISBE2GlobalEvent_Value;
pub const ISBE2GlobalEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2GlobalEvent,
                idEvt: ?*const Guid,
                param1: u32,
                param2: u32,
                param3: u32,
                param4: u32,
                pSpanning: ?*BOOL,
                pcb: ?*u32,
                pb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2GlobalEvent,
                idEvt: ?*const Guid,
                param1: u32,
                param2: u32,
                param3: u32,
                param4: u32,
                pSpanning: ?*BOOL,
                pcb: ?*u32,
                pb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2GlobalEvent_GetEvent(self: *const T, idEvt: ?*const Guid, param1: u32, param2: u32, param3: u32, param4: u32, pSpanning: ?*BOOL, pcb: ?*u32, pb: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISBE2GlobalEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ISBE2GlobalEvent, @ptrCast(self)), idEvt, param1, param2, param3, param4, pSpanning, pcb, pb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2GlobalEvent2_Value = Guid.initString("6d8309bf-00fe-4506-8b03-f8c65b5c9b39");
pub const IID_ISBE2GlobalEvent2 = &IID_ISBE2GlobalEvent2_Value;
pub const ISBE2GlobalEvent2 = extern struct {
    pub const VTable = extern struct {
        base: ISBE2GlobalEvent.VTable,
        GetEventEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2GlobalEvent2,
                idEvt: ?*const Guid,
                param1: u32,
                param2: u32,
                param3: u32,
                param4: u32,
                pSpanning: ?*BOOL,
                pcb: ?*u32,
                pb: ?*u8,
                pStreamTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2GlobalEvent2,
                idEvt: ?*const Guid,
                param1: u32,
                param2: u32,
                param3: u32,
                param4: u32,
                pSpanning: ?*BOOL,
                pcb: ?*u32,
                pb: ?*u8,
                pStreamTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISBE2GlobalEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2GlobalEvent2_GetEventEx(self: *const T, idEvt: ?*const Guid, param1: u32, param2: u32, param3: u32, param4: u32, pSpanning: ?*BOOL, pcb: ?*u32, pb: ?*u8, pStreamTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const ISBE2GlobalEvent2.VTable, @ptrCast(self.vtable)).GetEventEx(@as(*const ISBE2GlobalEvent2, @ptrCast(self)), idEvt, param1, param2, param3, param4, pSpanning, pcb, pb, pStreamTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2SpanningEvent_Value = Guid.initString("caede760-b6b1-11db-a578-0018f3fa24c6");
pub const IID_ISBE2SpanningEvent = &IID_ISBE2SpanningEvent_Value;
pub const ISBE2SpanningEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2SpanningEvent,
                idEvt: ?*const Guid,
                streamId: u32,
                pcb: ?*u32,
                pb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2SpanningEvent,
                idEvt: ?*const Guid,
                streamId: u32,
                pcb: ?*u32,
                pb: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2SpanningEvent_GetEvent(self: *const T, idEvt: ?*const Guid, streamId: u32, pcb: ?*u32, pb: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISBE2SpanningEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const ISBE2SpanningEvent, @ptrCast(self)), idEvt, streamId, pcb, pb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2Crossbar_Value = Guid.initString("547b6d26-3226-487e-8253-8aa168749434");
pub const IID_ISBE2Crossbar = &IID_ISBE2Crossbar_Value;
pub const ISBE2Crossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnableDefaultMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2Crossbar,
                DefaultFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2Crossbar,
                DefaultFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInitialProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2Crossbar,
                ppProfile: ?*?*ISBE2MediaTypeProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2Crossbar,
                ppProfile: ?*?*ISBE2MediaTypeProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2Crossbar,
                pProfile: ?*ISBE2MediaTypeProfile,
                pcOutputPins: ?*u32,
                ppOutputPins: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2Crossbar,
                pProfile: ?*ISBE2MediaTypeProfile,
                pcOutputPins: ?*u32,
                ppOutputPins: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2Crossbar,
                ppStreams: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2Crossbar,
                ppStreams: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_EnableDefaultMode(self: *const T, DefaultFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).EnableDefaultMode(@as(*const ISBE2Crossbar, @ptrCast(self)), DefaultFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_GetInitialProfile(self: *const T, ppProfile: ?*?*ISBE2MediaTypeProfile) callconv(.Inline) HRESULT {
            return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).GetInitialProfile(@as(*const ISBE2Crossbar, @ptrCast(self)), ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_SetOutputProfile(self: *const T, pProfile: ?*ISBE2MediaTypeProfile, pcOutputPins: ?*u32, ppOutputPins: ?*?*IPin) callconv(.Inline) HRESULT {
            return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).SetOutputProfile(@as(*const ISBE2Crossbar, @ptrCast(self)), pProfile, pcOutputPins, ppOutputPins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2Crossbar_EnumStreams(self: *const T, ppStreams: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @as(*const ISBE2Crossbar.VTable, @ptrCast(self.vtable)).EnumStreams(@as(*const ISBE2Crossbar, @ptrCast(self)), ppStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2StreamMap_Value = Guid.initString("667c7745-85b1-4c55-ae55-4e25056159fc");
pub const IID_ISBE2StreamMap = &IID_ISBE2StreamMap_Value;
pub const ISBE2StreamMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2StreamMap,
                Stream: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2StreamMap,
                Stream: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnmapStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2StreamMap,
                Stream: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2StreamMap,
                Stream: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMappedStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2StreamMap,
                ppStreams: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2StreamMap,
                ppStreams: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_MapStream(self: *const T, Stream: u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).MapStream(@as(*const ISBE2StreamMap, @ptrCast(self)), Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_UnmapStream(self: *const T, Stream: u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).UnmapStream(@as(*const ISBE2StreamMap, @ptrCast(self)), Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2StreamMap_EnumMappedStreams(self: *const T, ppStreams: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @as(*const ISBE2StreamMap.VTable, @ptrCast(self.vtable)).EnumMappedStreams(@as(*const ISBE2StreamMap, @ptrCast(self)), ppStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2EnumStream_Value = Guid.initString("f7611092-9fbc-46ec-a7c7-548ea78b71a4");
pub const IID_ISBE2EnumStream = &IID_ISBE2EnumStream_Value;
pub const ISBE2EnumStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2EnumStream,
                cRequest: u32,
                pStreamDesc: [*]SBE2_STREAM_DESC,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2EnumStream,
                cRequest: u32,
                pStreamDesc: [*]SBE2_STREAM_DESC,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2EnumStream,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2EnumStream,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2EnumStream,
                ppIEnumStream: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2EnumStream,
                ppIEnumStream: ?*?*ISBE2EnumStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Next(self: *const T, cRequest: u32, pStreamDesc: [*]SBE2_STREAM_DESC, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Next(@as(*const ISBE2EnumStream, @ptrCast(self)), cRequest, pStreamDesc, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Skip(@as(*const ISBE2EnumStream, @ptrCast(self)), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Reset(@as(*const ISBE2EnumStream, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2EnumStream_Clone(self: *const T, ppIEnumStream: ?*?*ISBE2EnumStream) callconv(.Inline) HRESULT {
            return @as(*const ISBE2EnumStream.VTable, @ptrCast(self.vtable)).Clone(@as(*const ISBE2EnumStream, @ptrCast(self)), ppIEnumStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2MediaTypeProfile_Value = Guid.initString("f238267d-4671-40d7-997e-25dc32cfed2a");
pub const IID_ISBE2MediaTypeProfile = &IID_ISBE2MediaTypeProfile_Value;
pub const ISBE2MediaTypeProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2MediaTypeProfile,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2MediaTypeProfile,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2MediaTypeProfile,
                Index: u32,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2MediaTypeProfile,
                Index: u32,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2MediaTypeProfile,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2MediaTypeProfile,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2MediaTypeProfile,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2MediaTypeProfile,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_GetStreamCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).GetStreamCount(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_GetStream(self: *const T, Index: u32, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).GetStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), Index, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_AddStream(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).AddStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2MediaTypeProfile_DeleteStream(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const ISBE2MediaTypeProfile.VTable, @ptrCast(self.vtable)).DeleteStream(@as(*const ISBE2MediaTypeProfile, @ptrCast(self)), Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_ISBE2FileScan_Value = Guid.initString("3e2bf5a5-4f96-4899-a1a3-75e8be9a5ac0");
pub const IID_ISBE2FileScan = &IID_ISBE2FileScan_Value;
pub const ISBE2FileScan = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RepairFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISBE2FileScan,
                filename: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISBE2FileScan,
                filename: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISBE2FileScan_RepairFile(self: *const T, filename: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ISBE2FileScan.VTable, @ptrCast(self.vtable)).RepairFile(@as(*const ISBE2FileScan, @ptrCast(self)), filename);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PID_BITS_MIDL = extern struct {
    Bits: u16 align(1),
};

pub const MPEG_HEADER_BITS_MIDL = extern struct {
    Bits: u16 align(1),
};

pub const MPEG_HEADER_VERSION_BITS_MIDL = extern struct {
    Bits: u8,
};

pub const MPEG_CURRENT_NEXT_BIT = enum(i32) {
    NEXT = 0,
    CURRENT = 1,
};
pub const MPEG_SECTION_IS_NEXT = MPEG_CURRENT_NEXT_BIT.NEXT;
pub const MPEG_SECTION_IS_CURRENT = MPEG_CURRENT_NEXT_BIT.CURRENT;

pub const TID_EXTENSION = extern struct {
    wTidExt: u16 align(1),
    wCount: u16 align(1),
};

pub const SECTION = extern struct {
    TableId: u8 align(1),
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    } align(1),
    SectionData: [1]u8 align(1),
};

pub const LONG_SECTION = extern struct {
    TableId: u8 align(1),
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    } align(1),
    TableIdExtension: u16 align(1),
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    } align(1),
    SectionNumber: u8 align(1),
    LastSectionNumber: u8 align(1),
    RemainingData: [1]u8 align(1),
};

pub const DSMCC_SECTION = extern struct {
    TableId: u8 align(1),
    Header: extern union {
        S: MPEG_HEADER_BITS_MIDL align(1),
        W: u16 align(1),
    } align(1),
    TableIdExtension: u16 align(1),
    Version: extern union {
        S: MPEG_HEADER_VERSION_BITS_MIDL,
        B: u8,
    } align(1),
    SectionNumber: u8 align(1),
    LastSectionNumber: u8 align(1),
    ProtocolDiscriminator: u8 align(1),
    DsmccType: u8 align(1),
    MessageId: u16 align(1),
    TransactionId: u32 align(1),
    Reserved: u8 align(1),
    AdaptationLength: u8 align(1),
    MessageLength: u16 align(1),
    RemainingData: [1]u8 align(1),
};

pub const MPEG_RQST_PACKET = extern struct {
    dwLength: u32 align(1),
    pSection: ?*SECTION align(1),
};

pub const MPEG_PACKET_LIST = extern struct {
    wPacketCount: u16 align(1),
    PacketList: [1]?*MPEG_RQST_PACKET align(1),
};

pub const DSMCC_FILTER_OPTIONS = extern struct {
    fSpecifyProtocol: BOOL align(1),
    Protocol: u8 align(1),
    fSpecifyType: BOOL align(1),
    Type: u8 align(1),
    fSpecifyMessageId: BOOL align(1),
    MessageId: u16 align(1),
    fSpecifyTransactionId: BOOL align(1),
    fUseTrxIdMessageIdMask: BOOL align(1),
    TransactionId: u32 align(1),
    fSpecifyModuleVersion: BOOL align(1),
    ModuleVersion: u8 align(1),
    fSpecifyBlockNumber: BOOL align(1),
    BlockNumber: u16 align(1),
    fGetModuleCall: BOOL align(1),
    NumberOfBlocksInModule: u16 align(1),
};

pub const ATSC_FILTER_OPTIONS = extern struct {
    fSpecifyEtmId: BOOL align(1),
    EtmId: u32 align(1),
};

pub const DVB_EIT_FILTER_OPTIONS = extern struct {
    fSpecifySegment: BOOL align(1),
    bSegment: u8 align(1),
};

pub const MPEG2_FILTER = extern struct {
    bVersionNumber: u8 align(1),
    wFilterSize: u16 align(1),
    fUseRawFilteringBits: BOOL align(1),
    Filter: [16]u8 align(1),
    Mask: [16]u8 align(1),
    fSpecifyTableIdExtension: BOOL align(1),
    TableIdExtension: u16 align(1),
    fSpecifyVersion: BOOL align(1),
    Version: u8 align(1),
    fSpecifySectionNumber: BOOL align(1),
    SectionNumber: u8 align(1),
    fSpecifyCurrentNext: BOOL align(1),
    fNext: BOOL align(1),
    fSpecifyDsmccOptions: BOOL align(1),
    Dsmcc: DSMCC_FILTER_OPTIONS align(1),
    fSpecifyAtscOptions: BOOL align(1),
    Atsc: ATSC_FILTER_OPTIONS align(1),
};

pub const MPEG2_FILTER2 = extern struct {
    Anonymous: extern union {
        Anonymous: extern struct {
            bVersionNumber: u8 align(1),
            wFilterSize: u16 align(1),
            fUseRawFilteringBits: BOOL align(1),
            Filter: [16]u8 align(1),
            Mask: [16]u8 align(1),
            fSpecifyTableIdExtension: BOOL align(1),
            TableIdExtension: u16 align(1),
            fSpecifyVersion: BOOL align(1),
            Version: u8 align(1),
            fSpecifySectionNumber: BOOL align(1),
            SectionNumber: u8 align(1),
            fSpecifyCurrentNext: BOOL align(1),
            fNext: BOOL align(1),
            fSpecifyDsmccOptions: BOOL align(1),
            Dsmcc: DSMCC_FILTER_OPTIONS align(1),
            fSpecifyAtscOptions: BOOL align(1),
            Atsc: ATSC_FILTER_OPTIONS align(1),
        },
        bVersion1Bytes: [124]u8,
    } align(1),
    fSpecifyDvbEitOptions: BOOL align(1),
    DvbEit: DVB_EIT_FILTER_OPTIONS align(1),
};

pub const MPEG_STREAM_BUFFER = extern struct {
    hr: HRESULT align(1),
    dwDataBufferSize: u32 align(1),
    dwSizeOfDataRead: u32 align(1),
    pDataBuffer: ?*u8 align(1),
};

pub const MPEG_TIME = extern struct {
    Hours: u8 align(1),
    Minutes: u8 align(1),
    Seconds: u8 align(1),
};

pub const MPEG_DATE = extern struct {
    Date: u8 align(1),
    Month: u8 align(1),
    Year: u16 align(1),
};

pub const MPEG_DATE_AND_TIME = extern struct {
    D: MPEG_DATE align(1),
    T: MPEG_TIME align(1),
};

pub const MPEG_CONTEXT_TYPE = enum(i32) {
    BCS_DEMUX = 0,
    WINSOCK = 1,
};
pub const MPEG_CONTEXT_BCS_DEMUX = MPEG_CONTEXT_TYPE.BCS_DEMUX;
pub const MPEG_CONTEXT_WINSOCK = MPEG_CONTEXT_TYPE.WINSOCK;

pub const MPEG_BCS_DEMUX = extern struct {
    AVMGraphId: u32 align(1),
};

pub const MPEG_WINSOCK = extern struct {
    AVMGraphId: u32 align(1),
};

pub const MPEG_CONTEXT = extern struct {
    Type: MPEG_CONTEXT_TYPE align(1),
    U: extern union {
        Demux: MPEG_BCS_DEMUX,
        Winsock: MPEG_WINSOCK,
    } align(1),
};

pub const MPEG_REQUEST_TYPE = enum(i32) {
    UNKNOWN = 0,
    GET_SECTION = 1,
    GET_SECTION_ASYNC = 2,
    GET_TABLE = 3,
    GET_TABLE_ASYNC = 4,
    GET_SECTIONS_STREAM = 5,
    GET_PES_STREAM = 6,
    GET_TS_STREAM = 7,
    START_MPE_STREAM = 8,
};
pub const MPEG_RQST_UNKNOWN = MPEG_REQUEST_TYPE.UNKNOWN;
pub const MPEG_RQST_GET_SECTION = MPEG_REQUEST_TYPE.GET_SECTION;
pub const MPEG_RQST_GET_SECTION_ASYNC = MPEG_REQUEST_TYPE.GET_SECTION_ASYNC;
pub const MPEG_RQST_GET_TABLE = MPEG_REQUEST_TYPE.GET_TABLE;
pub const MPEG_RQST_GET_TABLE_ASYNC = MPEG_REQUEST_TYPE.GET_TABLE_ASYNC;
pub const MPEG_RQST_GET_SECTIONS_STREAM = MPEG_REQUEST_TYPE.GET_SECTIONS_STREAM;
pub const MPEG_RQST_GET_PES_STREAM = MPEG_REQUEST_TYPE.GET_PES_STREAM;
pub const MPEG_RQST_GET_TS_STREAM = MPEG_REQUEST_TYPE.GET_TS_STREAM;
pub const MPEG_RQST_START_MPE_STREAM = MPEG_REQUEST_TYPE.START_MPE_STREAM;

pub const MPEG_SERVICE_REQUEST = extern struct {
    Type: MPEG_REQUEST_TYPE align(1),
    Context: MPEG_CONTEXT align(1),
    Pid: u16 align(1),
    TableId: u8 align(1),
    Filter: MPEG2_FILTER align(1),
    Flags: u32 align(1),
};

pub const MPEG_SERVICE_RESPONSE = extern struct {
    IPAddress: u32 align(1),
    Port: u16 align(1),
};

pub const DSMCC_ELEMENT = extern struct {
    pid: u16 align(1),
    bComponentTag: u8 align(1),
    dwCarouselId: u32 align(1),
    dwTransactionId: u32 align(1),
    pNext: ?*DSMCC_ELEMENT align(1),
};

pub const MPE_ELEMENT = extern struct {
    pid: u16 align(1),
    bComponentTag: u8 align(1),
    pNext: ?*MPE_ELEMENT align(1),
};

pub const MPEG_STREAM_FILTER = extern struct {
    wPidValue: u16 align(1),
    dwFilterSize: u32 align(1),
    fCrcEnabled: BOOL align(1),
    rgchFilter: [16]u8 align(1),
    rgchMask: [16]u8 align(1),
};

const IID_IMpeg2TableFilter_Value = Guid.initString("bdcdd913-9ecd-4fb2-81ae-adf747ea75a5");
pub const IID_IMpeg2TableFilter = &IID_IMpeg2TableFilter_Value;
pub const IMpeg2TableFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
                e: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
                e: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
                e: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2TableFilter,
                p: u16,
                t: u8,
                e: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddPID(self: *const T, p: u16) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddPID(@as(*const IMpeg2TableFilter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddTable(self: *const T, p: u16, t: u8) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddTable(@as(*const IMpeg2TableFilter, @ptrCast(self)), p, t);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_AddExtension(self: *const T, p: u16, t: u8, e: u16) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IMpeg2TableFilter, @ptrCast(self)), p, t, e);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemovePID(self: *const T, p: u16) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemovePID(@as(*const IMpeg2TableFilter, @ptrCast(self)), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemoveTable(self: *const T, p: u16, t: u8) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemoveTable(@as(*const IMpeg2TableFilter, @ptrCast(self)), p, t);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2TableFilter_RemoveExtension(self: *const T, p: u16, t: u8, e: u16) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2TableFilter.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IMpeg2TableFilter, @ptrCast(self)), p, t, e);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Mpeg2TableSampleHdr = extern struct {
    SectionCount: u8 align(1),
    Reserved: [3]u8 align(1),
    SectionOffsets: [1]i32 align(1),
};

const CLSID_Mpeg2DataLib_Value = Guid.initString("dbaf6c1b-b6a4-4898-ae65-204f0d9509a1");
pub const CLSID_Mpeg2DataLib = &CLSID_Mpeg2DataLib_Value;

const IID_IMpeg2Data_Value = Guid.initString("9b396d40-f380-4e3c-a514-1a82bf6ebfe6");
pub const IID_IMpeg2Data = &IID_IMpeg2Data_Value;
pub const IMpeg2Data = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                dwTimeout: u32,
                ppSectionList: ?*?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                dwTimeout: u32,
                ppSectionList: ?*?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                dwTimeout: u32,
                ppSectionList: ?*?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                dwTimeout: u32,
                ppSectionList: ?*?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamOfSections: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                hDataReadyEvent: ?HANDLE,
                ppMpegStream: ?*?*IMpeg2Stream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Data,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                hDataReadyEvent: ?HANDLE,
                ppMpegStream: ?*?*IMpeg2Stream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetSection(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, dwTimeout: u32, ppSectionList: ?*?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetSection(@as(*const IMpeg2Data, @ptrCast(self)), pid, tid, pFilter, dwTimeout, ppSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetTable(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, dwTimeout: u32, ppSectionList: ?*?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetTable(@as(*const IMpeg2Data, @ptrCast(self)), pid, tid, pFilter, dwTimeout, ppSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Data_GetStreamOfSections(self: *const T, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, hDataReadyEvent: ?HANDLE, ppMpegStream: ?*?*IMpeg2Stream) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Data.VTable, @ptrCast(self.vtable)).GetStreamOfSections(@as(*const IMpeg2Data, @ptrCast(self)), pid, tid, pFilter, hDataReadyEvent, ppMpegStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISectionList_Value = Guid.initString("afec1eb5-2a64-46c6-bf4b-ae3ccb6afdb0");
pub const IID_ISectionList = &IID_ISectionList_Value;
pub const ISectionList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                requestType: MPEG_REQUEST_TYPE,
                pMpeg2Data: ?*IMpeg2Data,
                pContext: ?*MPEG_CONTEXT,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                timeout: u32,
                hDoneEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                requestType: MPEG_REQUEST_TYPE,
                pMpeg2Data: ?*IMpeg2Data,
                pContext: ?*MPEG_CONTEXT,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                timeout: u32,
                hDoneEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeWithRawSections: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                pmplSections: ?*MPEG_PACKET_LIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                pmplSections: ?*MPEG_PACKET_LIST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelPendingRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfSections: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                pCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                pCount: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSectionData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                sectionNumber: u16,
                pdwRawPacketLength: ?*u32,
                ppSection: ?*?*SECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                sectionNumber: u16,
                pdwRawPacketLength: ?*u32,
                ppSection: ?*?*SECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgramIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                pPid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                pPid: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISectionList,
                pTableId: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISectionList,
                pTableId: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_Initialize(self: *const T, requestType: MPEG_REQUEST_TYPE, pMpeg2Data: ?*IMpeg2Data, pContext: ?*MPEG_CONTEXT, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, timeout: u32, hDoneEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ISectionList, @ptrCast(self)), requestType, pMpeg2Data, pContext, pid, tid, pFilter, timeout, hDoneEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_InitializeWithRawSections(self: *const T, pmplSections: ?*MPEG_PACKET_LIST) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).InitializeWithRawSections(@as(*const ISectionList, @ptrCast(self)), pmplSections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_CancelPendingRequest(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).CancelPendingRequest(@as(*const ISectionList, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetNumberOfSections(self: *const T, pCount: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetNumberOfSections(@as(*const ISectionList, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetSectionData(self: *const T, sectionNumber: u16, pdwRawPacketLength: ?*u32, ppSection: ?*?*SECTION) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetSectionData(@as(*const ISectionList, @ptrCast(self)), sectionNumber, pdwRawPacketLength, ppSection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetProgramIdentifier(self: *const T, pPid: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetProgramIdentifier(@as(*const ISectionList, @ptrCast(self)), pPid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISectionList_GetTableIdentifier(self: *const T, pTableId: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISectionList.VTable, @ptrCast(self.vtable)).GetTableIdentifier(@as(*const ISectionList, @ptrCast(self)), pTableId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMpeg2Stream_Value = Guid.initString("400cc286-32a0-4ce4-9041-39571125a635");
pub const IID_IMpeg2Stream = &IID_IMpeg2Stream_Value;
pub const IMpeg2Stream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Stream,
                requestType: MPEG_REQUEST_TYPE,
                pMpeg2Data: ?*IMpeg2Data,
                pContext: ?*MPEG_CONTEXT,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                hDataReadyEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Stream,
                requestType: MPEG_REQUEST_TYPE,
                pMpeg2Data: ?*IMpeg2Data,
                pContext: ?*MPEG_CONTEXT,
                pid: u16,
                tid: u8,
                pFilter: ?*MPEG2_FILTER,
                hDataReadyEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SupplyDataBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Stream,
                pStreamBuffer: ?*MPEG_STREAM_BUFFER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Stream,
                pStreamBuffer: ?*MPEG_STREAM_BUFFER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Stream_Initialize(self: *const T, requestType: MPEG_REQUEST_TYPE, pMpeg2Data: ?*IMpeg2Data, pContext: ?*MPEG_CONTEXT, pid: u16, tid: u8, pFilter: ?*MPEG2_FILTER, hDataReadyEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Stream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IMpeg2Stream, @ptrCast(self)), requestType, pMpeg2Data, pContext, pid, tid, pFilter, hDataReadyEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Stream_SupplyDataBuffer(self: *const T, pStreamBuffer: ?*MPEG_STREAM_BUFFER) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Stream.VTable, @ptrCast(self.vtable)).SupplyDataBuffer(@as(*const IMpeg2Stream, @ptrCast(self)), pStreamBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SectionList_Value = Guid.initString("73da5d04-4347-45d3-a9dc-fae9ddbe558d");
pub const CLSID_SectionList = &CLSID_SectionList_Value;

const CLSID_Mpeg2Stream_Value = Guid.initString("f91d96c7-8509-4d0b-ab26-a0dd10904bb7");
pub const CLSID_Mpeg2Stream = &CLSID_Mpeg2Stream_Value;

const CLSID_Mpeg2Data_Value = Guid.initString("c666e115-bb62-4027-a113-82d643fe2d99");
pub const CLSID_Mpeg2Data = &CLSID_Mpeg2Data_Value;

const IID_IGenericDescriptor_Value = Guid.initString("6a5918f8-a77a-4f61-aed0-5702bdcda3e6");
pub const IID_IGenericDescriptor = &IID_IGenericDescriptor_Value;
pub const IGenericDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor,
                pbDesc: ?*u8,
                bCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor,
                pbDesc: ?*u8,
                bCount: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor,
                ppbVal: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor,
                ppbVal: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_Initialize(self: *const T, pbDesc: ?*u8, bCount: i32) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IGenericDescriptor, @ptrCast(self)), pbDesc, bCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IGenericDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IGenericDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor_GetBody(self: *const T, ppbVal: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor.VTable, @ptrCast(self.vtable)).GetBody(@as(*const IGenericDescriptor, @ptrCast(self)), ppbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGenericDescriptor2_Value = Guid.initString("bf02fb7e-9792-4e10-a68d-033a2cc246a5");
pub const IID_IGenericDescriptor2 = &IID_IGenericDescriptor2_Value;
pub const IGenericDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IGenericDescriptor.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor2,
                pbDesc: ?*u8,
                wCount: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor2,
                pbDesc: ?*u8,
                wCount: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGenericDescriptor2,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGenericDescriptor2,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IGenericDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor2_Initialize(self: *const T, pbDesc: ?*u8, wCount: u16) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor2.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IGenericDescriptor2, @ptrCast(self)), pbDesc, wCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGenericDescriptor2_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IGenericDescriptor2.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IGenericDescriptor2, @ptrCast(self)), pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ProgramElement = extern struct {
    wProgramNumber: u16,
    wProgramMapPID: u16,
};

const IID_IPAT_Value = Guid.initString("6623b511-4b5f-43c3-9a01-e8ff84188060");
pub const IID_IPAT = &IID_IPAT_Value;
pub const IPAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordProgramNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                dwIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                dwIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordProgramMapPid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                dwIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                dwIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindRecordProgramMapPid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                wProgramNumber: u16,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                wProgramNumber: u16,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPAT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IPAT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPAT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPAT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetRecordProgramNumber(self: *const T, dwIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetRecordProgramNumber(@as(*const IPAT, @ptrCast(self)), dwIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetRecordProgramMapPid(self: *const T, dwIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetRecordProgramMapPid(@as(*const IPAT, @ptrCast(self)), dwIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_FindRecordProgramMapPid(self: *const T, wProgramNumber: u16, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).FindRecordProgramMapPid(@as(*const IPAT, @ptrCast(self)), wProgramNumber, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IPAT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_GetNextTable(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IPAT, @ptrCast(self)), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IPAT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IPAT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICAT_Value = Guid.initString("7c6995fb-2a31-4bd7-953e-b1ad7fb7d31c");
pub const IID_ICAT = &IID_ICAT_Value;
pub const ICAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ICAT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ICAT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ICAT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ICAT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ICAT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const ICAT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_GetNextTable(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const ICAT, @ptrCast(self)), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const ICAT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const ICAT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPMT_Value = Guid.initString("01f3b398-9527-4736-94db-5195878e97a8");
pub const IID_IPMT = &IID_IPMT_Value;
pub const IPMT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgramNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPcrPid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pPidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pPidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordStreamType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordElementaryPid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pPidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pPidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                dwDescIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                dwDescIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryServiceGatewayInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                ppDSMCCList: ?*?*DSMCC_ELEMENT,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                ppDSMCCList: ?*?*DSMCC_ELEMENT,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryMPEInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                ppMPEList: ?*?*MPE_ELEMENT,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                ppMPEList: ?*?*MPE_ELEMENT,
                puiCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPMT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetProgramNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetProgramNumber(@as(*const IPMT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPMT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetPcrPid(self: *const T, pPidVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetPcrPid(@as(*const IPMT, @ptrCast(self)), pPidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IPMT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IPMT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IPMT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetCountOfRecords(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPMT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordStreamType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordStreamType(@as(*const IPMT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordElementaryPid(self: *const T, dwRecordIndex: u32, pPidVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordElementaryPid(@as(*const IPMT, @ptrCast(self)), dwRecordIndex, pPidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IPMT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwDescIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IPMT, @ptrCast(self)), dwRecordIndex, dwDescIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IPMT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_QueryServiceGatewayInfo(self: *const T, ppDSMCCList: ?*?*DSMCC_ELEMENT, puiCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).QueryServiceGatewayInfo(@as(*const IPMT, @ptrCast(self)), ppDSMCCList, puiCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_QueryMPEInfo(self: *const T, ppMPEList: ?*?*MPE_ELEMENT, puiCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).QueryMPEInfo(@as(*const IPMT, @ptrCast(self)), ppMPEList, puiCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IPMT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_GetNextTable(self: *const T, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IPMT, @ptrCast(self)), ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IPMT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPMT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPMT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IPMT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITSDT_Value = Guid.initString("d19bdb43-405b-4a7c-a791-c89110c33165");
pub const IID_ITSDT = &IID_ITSDT_Value;
pub const ITSDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ITSDT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ITSDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ITSDT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ITSDT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ITSDT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const ITSDT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_GetNextTable(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const ITSDT, @ptrCast(self)), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const ITSDT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITSDT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITSDT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const ITSDT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPSITables_Value = Guid.initString("919f24c5-7b14-42ac-a4b0-2ae08daf00ac");
pub const IID_IPSITables = &IID_IPSITables_Value;
pub const IPSITables = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPSITables,
                dwTSID: u32,
                dwTID_PID: u32,
                dwHashedVer: u32,
                dwPara4: u32,
                ppIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPSITables,
                dwTSID: u32,
                dwTID_PID: u32,
                dwHashedVer: u32,
                dwPara4: u32,
                ppIUnknown: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPSITables_GetTable(self: *const T, dwTSID: u32, dwTID_PID: u32, dwHashedVer: u32, dwPara4: u32, ppIUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPSITables.VTable, @ptrCast(self.vtable)).GetTable(@as(*const IPSITables, @ptrCast(self)), dwTSID, dwTID_PID, dwHashedVer, dwPara4, ppIUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscPsipParser_Value = Guid.initString("b2c98995-5eb2-4fb1-b406-f3e8e2026a9a");
pub const IID_IAtscPsipParser = &IID_IAtscPsipParser_Value;
pub const IAtscPsipParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                punkMpeg2Data: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                punkMpeg2Data: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPAT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCAT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPMT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                pid: u16,
                pwProgramNumber: ?*u16,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                pid: u16,
                pwProgramNumber: ?*u16,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTSDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMGT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                ppMGT: ?*?*IATSC_MGT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                ppMGT: ?*?*IATSC_MGT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVCT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                tableId: u8,
                fGetNextTable: BOOL,
                ppVCT: ?*?*IATSC_VCT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                tableId: u8,
                fGetNextTable: BOOL,
                ppVCT: ?*?*IATSC_VCT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                pid: u16,
                pwSourceId: ?*u16,
                dwTimeout: u32,
                ppEIT: ?*?*IATSC_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                pid: u16,
                pwSourceId: ?*u16,
                dwTimeout: u32,
                ppEIT: ?*?*IATSC_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetETT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                pid: u16,
                wSourceId: ?*u16,
                pwEventId: ?*u16,
                ppETT: ?*?*IATSC_ETT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                pid: u16,
                wSourceId: ?*u16,
                pwEventId: ?*u16,
                ppETT: ?*?*IATSC_ETT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSTT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                ppSTT: ?*?*IATSC_STT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                ppSTT: ?*?*IATSC_STT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEAS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscPsipParser,
                pid: u16,
                ppEAS: ?*?*ISCTE_EAS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscPsipParser,
                pid: u16,
                ppEAS: ?*?*ISCTE_EAS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_Initialize(self: *const T, punkMpeg2Data: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAtscPsipParser, @ptrCast(self)), punkMpeg2Data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetPAT(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetPAT(@as(*const IAtscPsipParser, @ptrCast(self)), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetCAT(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetCAT(@as(*const IAtscPsipParser, @ptrCast(self)), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetPMT(self: *const T, pid: u16, pwProgramNumber: ?*u16, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetPMT(@as(*const IAtscPsipParser, @ptrCast(self)), pid, pwProgramNumber, ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetTSDT(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetTSDT(@as(*const IAtscPsipParser, @ptrCast(self)), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetMGT(self: *const T, ppMGT: ?*?*IATSC_MGT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetMGT(@as(*const IAtscPsipParser, @ptrCast(self)), ppMGT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetVCT(self: *const T, tableId: u8, fGetNextTable: BOOL, ppVCT: ?*?*IATSC_VCT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetVCT(@as(*const IAtscPsipParser, @ptrCast(self)), tableId, fGetNextTable, ppVCT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetEIT(self: *const T, pid: u16, pwSourceId: ?*u16, dwTimeout: u32, ppEIT: ?*?*IATSC_EIT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IAtscPsipParser, @ptrCast(self)), pid, pwSourceId, dwTimeout, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetETT(self: *const T, pid: u16, wSourceId: ?*u16, pwEventId: ?*u16, ppETT: ?*?*IATSC_ETT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetETT(@as(*const IAtscPsipParser, @ptrCast(self)), pid, wSourceId, pwEventId, ppETT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetSTT(self: *const T, ppSTT: ?*?*IATSC_STT) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetSTT(@as(*const IAtscPsipParser, @ptrCast(self)), ppSTT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscPsipParser_GetEAS(self: *const T, pid: u16, ppEAS: ?*?*ISCTE_EAS) callconv(.Inline) HRESULT {
            return @as(*const IAtscPsipParser.VTable, @ptrCast(self.vtable)).GetEAS(@as(*const IAtscPsipParser, @ptrCast(self)), pid, ppEAS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_MGT_Value = Guid.initString("8877dabd-c137-4073-97e3-779407a5d87a");
pub const IID_IATSC_MGT = &IID_IATSC_MGT_Value;
pub const IATSC_MGT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTypePid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                ppidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                ppidVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_MGT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_MGT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_MGT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_MGT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_MGT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_MGT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordType(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordType(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordTypePid(self: *const T, dwRecordIndex: u32, ppidVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordTypePid(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, ppidVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordVersionNumber(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordVersionNumber(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_MGT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_MGT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_MGT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_MGT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_MGT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_MGT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_VCT_Value = Guid.initString("26879a18-32f9-46c6-91f0-fb6479270e8c");
pub const IID_IATSC_VCT = &IID_IATSC_VCT_Value;
pub const IATSC_VCT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwsName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwsName: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordMajorChannelNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordMinorChannelNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordModulationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCarrierFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordProgramNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEtmLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordIsAccessControlledBitSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordIsHiddenBitSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordIsPathSelectBitSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordIsOutOfBandBitSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordIsHideGuideBitSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordSourceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_VCT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_VCT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_VCT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_VCT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IATSC_VCT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_VCT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_VCT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordName(self: *const T, dwRecordIndex: u32, pwsName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordName(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwsName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordMajorChannelNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordMajorChannelNumber(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordMinorChannelNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordMinorChannelNumber(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordModulationMode(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordModulationMode(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordCarrierFrequency(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordCarrierFrequency(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordProgramNumber(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordProgramNumber(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordEtmLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordEtmLocation(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsAccessControlledBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsAccessControlledBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsHiddenBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsHiddenBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsPathSelectBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsPathSelectBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsOutOfBandBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsOutOfBandBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordIsHideGuideBitSet(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordIsHideGuideBitSet(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordServiceType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordServiceType(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordSourceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordSourceId(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_VCT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_VCT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_VCT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_VCT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_VCT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_VCT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_EIT_Value = Guid.initString("d7c212d7-76a2-4b4b-aa56-846879a80096");
pub const IID_IATSC_EIT = &IID_IATSC_EIT_Value;
pub const IATSC_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEventId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEtmLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTitleText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pdwLength: ?*u32,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pdwLength: ?*u32,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_EIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetSourceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetSourceId(@as(*const IATSC_EIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IATSC_EIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordEtmLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordEtmLocation(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordTitleText(self: *const T, dwRecordIndex: u32, pdwLength: ?*u32, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordTitleText(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pdwLength, ppText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IATSC_EIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_ETT_Value = Guid.initString("5a142cc9-b8cf-4a86-a040-e9cadf3ef3e7");
pub const IID_IATSC_ETT = &IID_IATSC_ETT_Value;
pub const IATSC_ETT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_ETT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_ETT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_ETT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_ETT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_ETT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_ETT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEtmId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_ETT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_ETT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtendedMessageText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_ETT,
                pdwLength: ?*u32,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_ETT,
                pdwLength: ?*u32,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_ETT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IATSC_ETT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_ETT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetEtmId(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetEtmId(@as(*const IATSC_ETT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_ETT_GetExtendedMessageText(self: *const T, pdwLength: ?*u32, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_ETT.VTable, @ptrCast(self.vtable)).GetExtendedMessageText(@as(*const IATSC_ETT, @ptrCast(self)), pdwLength, ppText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IATSC_STT_Value = Guid.initString("6bf42423-217d-4d6f-81e1-3a7b360ec896");
pub const IID_IATSC_STT = &IID_IATSC_STT_Value;
pub const IATSC_STT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pmdtSystemTime: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pmdtSystemTime: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGpsUtcOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDaylightSavings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IATSC_STT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IATSC_STT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IATSC_STT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const IATSC_STT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetSystemTime(self: *const T, pmdtSystemTime: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetSystemTime(@as(*const IATSC_STT, @ptrCast(self)), pmdtSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetGpsUtcOffset(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetGpsUtcOffset(@as(*const IATSC_STT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetDaylightSavings(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetDaylightSavings(@as(*const IATSC_STT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IATSC_STT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IATSC_STT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IATSC_STT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IATSC_STT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IATSC_STT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_ISCTE_EAS_Value = Guid.initString("1ff544d6-161d-4fae-9faa-4f9f492ae999");
pub const IID_ISCTE_EAS = &IID_ISCTE_EAS_Value;
pub const ISCTE_EAS = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSequencyNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProtocolVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEASEventID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginatorCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEASEventCodeLen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEASEventCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawNatureOfActivationTextLen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawNatureOfActivationText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNatureOfActivationText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                bstrIS0639code: ?BSTR,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                bstrIS0639code: ?BSTR,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeRemaining: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlertPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsOOBSourceID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsMajor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsMinor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDetailsAudioOOBSourceID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                bstrIS0639code: ?BSTR,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                bstrIS0639code: ?BSTR,
                pbstrString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawAlertTextLen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawAlertText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocationCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocationCodes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                bIndex: u8,
                pbState: ?*u8,
                pbCountySubdivision: ?*u8,
                pwCounty: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                bIndex: u8,
                pbState: ?*u8,
                pbCountySubdivision: ?*u8,
                pwCounty: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                bIndex: u8,
                pbIBRef: ?*u8,
                pwFirst: ?*u16,
                pwSecond: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                bIndex: u8,
                pbIBRef: ?*u8,
                pwFirst: ?*u16,
                pwSecond: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISCTE_EAS,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISCTE_EAS,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ISCTE_EAS, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetSequencyNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetSequencyNumber(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetProtocolVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetProtocolVersion(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventID(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetOriginatorCode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetOriginatorCode(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventCodeLen(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventCodeLen(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetEASEventCode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetEASEventCode(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawNatureOfActivationTextLen(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawNatureOfActivationTextLen(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawNatureOfActivationText(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawNatureOfActivationText(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetNatureOfActivationText(self: *const T, bstrIS0639code: ?BSTR, pbstrString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetNatureOfActivationText(@as(*const ISCTE_EAS, @ptrCast(self)), bstrIS0639code, pbstrString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTimeRemaining(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTimeRemaining(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetStartTime(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const ISCTE_EAS, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDuration(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetAlertPriority(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetAlertPriority(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsOOBSourceID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsOOBSourceID(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsMajor(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsMajor(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsMinor(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsMinor(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetDetailsAudioOOBSourceID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetDetailsAudioOOBSourceID(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetAlertText(self: *const T, bstrIS0639code: ?BSTR, pbstrString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetAlertText(@as(*const ISCTE_EAS, @ptrCast(self)), bstrIS0639code, pbstrString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawAlertTextLen(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawAlertTextLen(@as(*const ISCTE_EAS, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetRawAlertText(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetRawAlertText(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetLocationCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetLocationCount(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetLocationCodes(self: *const T, bIndex: u8, pbState: ?*u8, pbCountySubdivision: ?*u8, pwCounty: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetLocationCodes(@as(*const ISCTE_EAS, @ptrCast(self)), bIndex, pbState, pbCountySubdivision, pwCounty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetExceptionCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetExceptionCount(@as(*const ISCTE_EAS, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetExceptionService(self: *const T, bIndex: u8, pbIBRef: ?*u8, pwFirst: ?*u16, pwSecond: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetExceptionService(@as(*const ISCTE_EAS, @ptrCast(self)), bIndex, pbIBRef, pwFirst, pwSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const ISCTE_EAS, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const ISCTE_EAS, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISCTE_EAS_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const ISCTE_EAS.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const ISCTE_EAS, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAtscContentAdvisoryDescriptor_Value = Guid.initString("ff76e60c-0283-43ea-ba32-b422238547ee");
pub const IID_IAtscContentAdvisoryDescriptor = &IID_IAtscContentAdvisoryDescriptor_Value;
pub const IAtscContentAdvisoryDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRatingRegionCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRatingRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRatedDimensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRatingDimension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndexOuter: u8,
                bIndexInner: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndexOuter: u8,
                bIndexInner: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRatingValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndexOuter: u8,
                bIndexInner: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndexOuter: u8,
                bIndexInner: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRatingDescriptionText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbLength: ?*u8,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAtscContentAdvisoryDescriptor,
                bIndex: u8,
                pbLength: ?*u8,
                ppText: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRatingRegionCount(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRatingRegionCount(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingRegion(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingRegion(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatedDimensions(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatedDimensions(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingDimension(self: *const T, bIndexOuter: u8, bIndexInner: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingDimension(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), bIndexOuter, bIndexInner, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingValue(self: *const T, bIndexOuter: u8, bIndexInner: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingValue(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), bIndexOuter, bIndexInner, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAtscContentAdvisoryDescriptor_GetRecordRatingDescriptionText(self: *const T, bIndex: u8, pbLength: ?*u8, ppText: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAtscContentAdvisoryDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRatingDescriptionText(@as(*const IAtscContentAdvisoryDescriptor, @ptrCast(self)), bIndex, pbLength, ppText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptionServiceDescriptor_Value = Guid.initString("40834007-6834-46f0-bd45-d5f6a6be258c");
pub const IID_ICaptionServiceDescriptor = &IID_ICaptionServiceDescriptor_Value;
pub const ICaptionServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                LangCode: *[3]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                LangCode: *[3]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaptionServiceNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCCType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEasyReader: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWideAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptionServiceDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetNumberOfServices(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetNumberOfServices(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetLanguageCode(self: *const T, bIndex: u8, LangCode: *[3]u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), bIndex, LangCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetCaptionServiceNumber(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCaptionServiceNumber(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetCCType(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCCType(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetEasyReader(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetEasyReader(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptionServiceDescriptor_GetWideAspectRatio(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICaptionServiceDescriptor.VTable, @ptrCast(self.vtable)).GetWideAspectRatio(@as(*const ICaptionServiceDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IServiceLocationDescriptor_Value = Guid.initString("58c3c827-9d91-4215-bff3-820a49f0904c");
pub const IID_IServiceLocationDescriptor = &IID_IServiceLocationDescriptor_Value;
pub const IServiceLocationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPCR_PID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServiceLocationDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServiceLocationDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfElements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServiceLocationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServiceLocationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElementStreamType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElementPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetElementLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                LangCode: *[3]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IServiceLocationDescriptor,
                bIndex: u8,
                LangCode: *[3]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetPCR_PID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetPCR_PID(@as(*const IServiceLocationDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetNumberOfElements(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetNumberOfElements(@as(*const IServiceLocationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementStreamType(self: *const T, bIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementStreamType(@as(*const IServiceLocationDescriptor, @ptrCast(self)), bIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementPID(self: *const T, bIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementPID(@as(*const IServiceLocationDescriptor, @ptrCast(self)), bIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceLocationDescriptor_GetElementLanguageCode(self: *const T, bIndex: u8, LangCode: *[3]u8) callconv(.Inline) HRESULT {
            return @as(*const IServiceLocationDescriptor.VTable, @ptrCast(self.vtable)).GetElementLanguageCode(@as(*const IServiceLocationDescriptor, @ptrCast(self)), bIndex, LangCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeSet_Value = Guid.initString("583ec3cc-4960-4857-982b-41a33ea0a006");
pub const IID_IAttributeSet = &IID_IAttributeSet_Value;
pub const IAttributeSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAttrib: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAttributeSet,
                guidAttribute: Guid,
                pbAttribute: ?*u8,
                dwAttributeLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAttributeSet,
                guidAttribute: Guid,
                pbAttribute: ?*u8,
                dwAttributeLength: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeSet_SetAttrib(self: *const T, guidAttribute: Guid, pbAttribute: ?*u8, dwAttributeLength: u32) callconv(.Inline) HRESULT {
            return @as(*const IAttributeSet.VTable, @ptrCast(self.vtable)).SetAttrib(@as(*const IAttributeSet, @ptrCast(self)), guidAttribute, pbAttribute, dwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAttributeGet_Value = Guid.initString("52dbd1ec-e48f-4528-9232-f442a68f0ae1");
pub const IID_IAttributeGet = &IID_IAttributeGet_Value;
pub const IAttributeGet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAttributeGet,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAttributeGet,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttribIndexed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAttributeGet,
                lIndex: i32,
                pguidAttribute: ?*Guid,
                pbAttribute: ?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAttributeGet,
                lIndex: i32,
                pguidAttribute: ?*Guid,
                pbAttribute: ?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttrib: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAttributeGet,
                guidAttribute: Guid,
                pbAttribute: ?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAttributeGet,
                guidAttribute: Guid,
                pbAttribute: ?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetCount(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IAttributeGet, @ptrCast(self)), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetAttribIndexed(self: *const T, lIndex: i32, pguidAttribute: ?*Guid, pbAttribute: ?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetAttribIndexed(@as(*const IAttributeGet, @ptrCast(self)), lIndex, pguidAttribute, pbAttribute, pdwAttributeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAttributeGet_GetAttrib(self: *const T, guidAttribute: Guid, pbAttribute: ?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAttributeGet.VTable, @ptrCast(self.vtable)).GetAttrib(@as(*const IAttributeGet, @ptrCast(self)), guidAttribute, pbAttribute, pdwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const UDCR_TAG = extern struct {
    bVersion: u8,
    KID: [25]u8,
    ullBaseCounter: u64,
    ullBaseCounterRange: u64,
    fScrambled: BOOL,
    bStreamMark: u8,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const PIC_SEQ_SAMPLE = extern struct {
    _bitfield: u32,
};

pub const SAMPLE_SEQ_OFFSET = extern struct {
    _bitfield: u32,
};

pub const VA_VIDEO_FORMAT = enum(i32) {
    COMPONENT = 0,
    PAL = 1,
    NTSC = 2,
    SECAM = 3,
    MAC = 4,
    UNSPECIFIED = 5,
};
pub const VA_VIDEO_COMPONENT = VA_VIDEO_FORMAT.COMPONENT;
pub const VA_VIDEO_PAL = VA_VIDEO_FORMAT.PAL;
pub const VA_VIDEO_NTSC = VA_VIDEO_FORMAT.NTSC;
pub const VA_VIDEO_SECAM = VA_VIDEO_FORMAT.SECAM;
pub const VA_VIDEO_MAC = VA_VIDEO_FORMAT.MAC;
pub const VA_VIDEO_UNSPECIFIED = VA_VIDEO_FORMAT.UNSPECIFIED;

pub const VA_COLOR_PRIMARIES = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_GENERIC_FILM = 8,
};
pub const VA_PRIMARIES_ITU_R_BT_709 = VA_COLOR_PRIMARIES.ITU_R_BT_709;
pub const VA_PRIMARIES_UNSPECIFIED = VA_COLOR_PRIMARIES.UNSPECIFIED;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_M = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_M;
pub const VA_PRIMARIES_ITU_R_BT_470_SYSTEM_B_G = VA_COLOR_PRIMARIES.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_PRIMARIES_SMPTE_170M = VA_COLOR_PRIMARIES.SMPTE_170M;
pub const VA_PRIMARIES_SMPTE_240M = VA_COLOR_PRIMARIES.SMPTE_240M;
pub const VA_PRIMARIES_H264_GENERIC_FILM = VA_COLOR_PRIMARIES.H264_GENERIC_FILM;

pub const VA_TRANSFER_CHARACTERISTICS = enum(i32) {
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    ITU_R_BT_470_SYSTEM_M = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    LINEAR = 8,
    H264_LOG_100_TO_1 = 9,
    H264_LOG_316_TO_1 = 10,
};
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_709 = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_709;
pub const VA_TRANSFER_CHARACTERISTICS_UNSPECIFIED = VA_TRANSFER_CHARACTERISTICS.UNSPECIFIED;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_M = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_M;
pub const VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_B_G = VA_TRANSFER_CHARACTERISTICS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_170M = VA_TRANSFER_CHARACTERISTICS.SMPTE_170M;
pub const VA_TRANSFER_CHARACTERISTICS_SMPTE_240M = VA_TRANSFER_CHARACTERISTICS.SMPTE_240M;
pub const VA_TRANSFER_CHARACTERISTICS_LINEAR = VA_TRANSFER_CHARACTERISTICS.LINEAR;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_100_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_100_TO_1;
pub const VA_TRANSFER_CHARACTERISTICS_H264_LOG_316_TO_1 = VA_TRANSFER_CHARACTERISTICS.H264_LOG_316_TO_1;

pub const VA_MATRIX_COEFFICIENTS = enum(i32) {
    H264_RGB = 0,
    ITU_R_BT_709 = 1,
    UNSPECIFIED = 2,
    FCC = 4,
    ITU_R_BT_470_SYSTEM_B_G = 5,
    SMPTE_170M = 6,
    SMPTE_240M = 7,
    H264_YCgCo = 8,
};
pub const VA_MATRIX_COEFF_H264_RGB = VA_MATRIX_COEFFICIENTS.H264_RGB;
pub const VA_MATRIX_COEFF_ITU_R_BT_709 = VA_MATRIX_COEFFICIENTS.ITU_R_BT_709;
pub const VA_MATRIX_COEFF_UNSPECIFIED = VA_MATRIX_COEFFICIENTS.UNSPECIFIED;
pub const VA_MATRIX_COEFF_FCC = VA_MATRIX_COEFFICIENTS.FCC;
pub const VA_MATRIX_COEFF_ITU_R_BT_470_SYSTEM_B_G = VA_MATRIX_COEFFICIENTS.ITU_R_BT_470_SYSTEM_B_G;
pub const VA_MATRIX_COEFF_SMPTE_170M = VA_MATRIX_COEFFICIENTS.SMPTE_170M;
pub const VA_MATRIX_COEFF_SMPTE_240M = VA_MATRIX_COEFFICIENTS.SMPTE_240M;
pub const VA_MATRIX_COEFF_H264_YCgCo = VA_MATRIX_COEFFICIENTS.H264_YCgCo;

pub const VA_OPTIONAL_VIDEO_PROPERTIES = extern struct {
    dwPictureHeight: u16,
    dwPictureWidth: u16,
    dwAspectRatioX: u16,
    dwAspectRatioY: u16,
    VAVideoFormat: VA_VIDEO_FORMAT,
    VAColorPrimaries: VA_COLOR_PRIMARIES,
    VATransferCharacteristics: VA_TRANSFER_CHARACTERISTICS,
    VAMatrixCoefficients: VA_MATRIX_COEFFICIENTS,
};

pub const TRANSPORT_PROPERTIES = extern struct {
    PID: u32,
    PCR: i64,
    Fields: extern union {
        pub const _Others = extern struct {
            _bitfield: i64,
        };
        Others: _Others,
        Value: i64,
    },
};

pub const PBDA_TAG_ATTRIBUTE = extern struct {
    TableUUId: Guid,
    TableId: u8,
    VersionNo: u16,
    TableDataSize: u32,
    TableData: [1]u8,
};

pub const CAPTURE_STREAMTIME = extern struct {
    StreamTime: i64,
};

pub const DSHOW_STREAM_DESC = extern struct {
    VersionNo: u32,
    StreamId: u32,
    Default: BOOL,
    Creation: BOOL,
    Reserved: u32,
};

pub const SAMPLE_LIVE_STREAM_TIME = extern struct {
    qwStreamTime: u64,
    qwLiveTime: u64,
};

pub const DVB_STRCONV_MODE = enum(i32) {
    DVB = 0,
    DVB_EMPHASIS = 1,
    DVB_WITHOUT_EMPHASIS = 2,
    ISDB = 3,
};
pub const STRCONV_MODE_DVB = DVB_STRCONV_MODE.DVB;
pub const STRCONV_MODE_DVB_EMPHASIS = DVB_STRCONV_MODE.DVB_EMPHASIS;
pub const STRCONV_MODE_DVB_WITHOUT_EMPHASIS = DVB_STRCONV_MODE.DVB_WITHOUT_EMPHASIS;
pub const STRCONV_MODE_ISDB = DVB_STRCONV_MODE.ISDB;

const IID_IDvbSiParser_Value = Guid.initString("b758a7bd-14dc-449d-b828-35909acb3b1e");
pub const IID_IDvbSiParser = &IID_IDvbSiParser_Value;
pub const IDvbSiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                punkMpeg2Data: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                punkMpeg2Data: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPAT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                ppPAT: ?*?*IPAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCAT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppCAT: ?*?*ICAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPMT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                pid: u16,
                pwProgramNumber: ?*u16,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                pid: u16,
                pwProgramNumber: ?*u16,
                ppPMT: ?*?*IPMT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTSDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                ppTSDT: ?*?*ITSDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwNetworkId: ?*u16,
                ppNIT: ?*?*IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwNetworkId: ?*u16,
                ppNIT: ?*?*IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwTransportStreamId: ?*u16,
                ppSDT: ?*?*IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwTransportStreamId: ?*u16,
                ppSDT: ?*?*IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwServiceId: ?*u16,
                ppEIT: ?*?*IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                tableId: u8,
                pwServiceId: ?*u16,
                ppEIT: ?*?*IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBAT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                pwBouquetId: ?*u16,
                ppBAT: ?*?*IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                pwBouquetId: ?*u16,
                ppBAT: ?*?*IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRST: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppRST: ?*?*IDVB_RST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppRST: ?*?*IDVB_RST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetST: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                pid: u16,
                dwTimeout: u32,
                ppST: ?*?*IDVB_ST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                pid: u16,
                dwTimeout: u32,
                ppST: ?*?*IDVB_ST,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                ppTDT: ?*?*IDVB_TDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                ppTDT: ?*?*IDVB_TDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTOT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                ppTOT: ?*?*IDVB_TOT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                ppTOT: ?*?*IDVB_TOT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppDIT: ?*?*IDVB_DIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppDIT: ?*?*IDVB_DIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppSIT: ?*?*IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser,
                dwTimeout: u32,
                ppSIT: ?*?*IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_Initialize(self: *const T, punkMpeg2Data: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDvbSiParser, @ptrCast(self)), punkMpeg2Data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetPAT(self: *const T, ppPAT: ?*?*IPAT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetPAT(@as(*const IDvbSiParser, @ptrCast(self)), ppPAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetCAT(self: *const T, dwTimeout: u32, ppCAT: ?*?*ICAT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetCAT(@as(*const IDvbSiParser, @ptrCast(self)), dwTimeout, ppCAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetPMT(self: *const T, pid: u16, pwProgramNumber: ?*u16, ppPMT: ?*?*IPMT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetPMT(@as(*const IDvbSiParser, @ptrCast(self)), pid, pwProgramNumber, ppPMT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTSDT(self: *const T, ppTSDT: ?*?*ITSDT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTSDT(@as(*const IDvbSiParser, @ptrCast(self)), ppTSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetNIT(self: *const T, tableId: u8, pwNetworkId: ?*u16, ppNIT: ?*?*IDVB_NIT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetNIT(@as(*const IDvbSiParser, @ptrCast(self)), tableId, pwNetworkId, ppNIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetSDT(self: *const T, tableId: u8, pwTransportStreamId: ?*u16, ppSDT: ?*?*IDVB_SDT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetSDT(@as(*const IDvbSiParser, @ptrCast(self)), tableId, pwTransportStreamId, ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetEIT(self: *const T, tableId: u8, pwServiceId: ?*u16, ppEIT: ?*?*IDVB_EIT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IDvbSiParser, @ptrCast(self)), tableId, pwServiceId, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetBAT(self: *const T, pwBouquetId: ?*u16, ppBAT: ?*?*IDVB_BAT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetBAT(@as(*const IDvbSiParser, @ptrCast(self)), pwBouquetId, ppBAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetRST(self: *const T, dwTimeout: u32, ppRST: ?*?*IDVB_RST) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetRST(@as(*const IDvbSiParser, @ptrCast(self)), dwTimeout, ppRST);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetST(self: *const T, pid: u16, dwTimeout: u32, ppST: ?*?*IDVB_ST) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetST(@as(*const IDvbSiParser, @ptrCast(self)), pid, dwTimeout, ppST);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTDT(self: *const T, ppTDT: ?*?*IDVB_TDT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTDT(@as(*const IDvbSiParser, @ptrCast(self)), ppTDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetTOT(self: *const T, ppTOT: ?*?*IDVB_TOT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetTOT(@as(*const IDvbSiParser, @ptrCast(self)), ppTOT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetDIT(self: *const T, dwTimeout: u32, ppDIT: ?*?*IDVB_DIT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetDIT(@as(*const IDvbSiParser, @ptrCast(self)), dwTimeout, ppDIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser_GetSIT(self: *const T, dwTimeout: u32, ppSIT: ?*?*IDVB_SIT) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser.VTable, @ptrCast(self.vtable)).GetSIT(@as(*const IDvbSiParser, @ptrCast(self)), dwTimeout, ppSIT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSiParser2_Value = Guid.initString("0ac5525f-f816-42f4-93ba-4c0f32f46e54");
pub const IID_IDvbSiParser2 = &IID_IDvbSiParser2_Value;
pub const IDvbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser.VTable,
        GetEIT2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSiParser2,
                tableId: u8,
                pwServiceId: ?*u16,
                pbSegment: ?*u8,
                ppEIT: ?*?*IDVB_EIT2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSiParser2,
                tableId: u8,
                pwServiceId: ?*u16,
                pbSegment: ?*u8,
                ppEIT: ?*?*IDVB_EIT2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbSiParser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSiParser2_GetEIT2(self: *const T, tableId: u8, pwServiceId: ?*u16, pbSegment: ?*u8, ppEIT: ?*?*IDVB_EIT2) callconv(.Inline) HRESULT {
            return @as(*const IDvbSiParser2.VTable, @ptrCast(self.vtable)).GetEIT2(@as(*const IDvbSiParser2, @ptrCast(self)), tableId, pwServiceId, pbSegment, ppEIT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIsdbSiParser2_Value = Guid.initString("900e4bb7-18cd-453f-98be-3be6aa211772");
pub const IID_IIsdbSiParser2 = &IID_IIsdbSiParser2_Value;
pub const IIsdbSiParser2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbSiParser2.VTable,
        GetSDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwTransportStreamId: ?*u16,
                ppSDT: ?*?*IISDB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwTransportStreamId: ?*u16,
                ppSDT: ?*?*IISDB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalNetworkId: ?*u16,
                ppBIT: ?*?*IISDB_BIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalNetworkId: ?*u16,
                ppBIT: ?*?*IISDB_BIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNBIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalNetworkId: ?*u16,
                ppNBIT: ?*?*IISDB_NBIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalNetworkId: ?*u16,
                ppNBIT: ?*?*IISDB_NBIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalServiceId: ?*u16,
                ppLDT: ?*?*IISDB_LDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwOriginalServiceId: ?*u16,
                ppLDT: ?*?*IISDB_LDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSDTT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwTableIdExt: ?*u16,
                ppSDTT: ?*?*IISDB_SDTT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                pwTableIdExt: ?*u16,
                ppSDTT: ?*?*IISDB_SDTT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCDT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                bSectionNumber: u8,
                pwDownloadDataId: ?*u16,
                ppCDT: ?*?*IISDB_CDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                tableId: u8,
                bSectionNumber: u8,
                pwDownloadDataId: ?*u16,
                ppCDT: ?*?*IISDB_CDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEMM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSiParser2,
                pid: u16,
                wTableIdExt: u16,
                ppEMM: ?*?*IISDB_EMM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSiParser2,
                pid: u16,
                wTableIdExt: u16,
                ppEMM: ?*?*IISDB_EMM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbSiParser2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetSDT(self: *const T, tableId: u8, pwTransportStreamId: ?*u16, ppSDT: ?*?*IISDB_SDT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetSDT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, pwTransportStreamId, ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetBIT(self: *const T, tableId: u8, pwOriginalNetworkId: ?*u16, ppBIT: ?*?*IISDB_BIT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetBIT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, pwOriginalNetworkId, ppBIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetNBIT(self: *const T, tableId: u8, pwOriginalNetworkId: ?*u16, ppNBIT: ?*?*IISDB_NBIT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetNBIT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, pwOriginalNetworkId, ppNBIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetLDT(self: *const T, tableId: u8, pwOriginalServiceId: ?*u16, ppLDT: ?*?*IISDB_LDT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetLDT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, pwOriginalServiceId, ppLDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetSDTT(self: *const T, tableId: u8, pwTableIdExt: ?*u16, ppSDTT: ?*?*IISDB_SDTT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetSDTT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, pwTableIdExt, ppSDTT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetCDT(self: *const T, tableId: u8, bSectionNumber: u8, pwDownloadDataId: ?*u16, ppCDT: ?*?*IISDB_CDT) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetCDT(@as(*const IIsdbSiParser2, @ptrCast(self)), tableId, bSectionNumber, pwDownloadDataId, ppCDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSiParser2_GetEMM(self: *const T, pid: u16, wTableIdExt: u16, ppEMM: ?*?*IISDB_EMM) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSiParser2.VTable, @ptrCast(self.vtable)).GetEMM(@as(*const IIsdbSiParser2, @ptrCast(self)), pid, wTableIdExt, ppEMM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_NIT_Value = Guid.initString("c64935f4-29e4-4e22-911a-63f7f55cb097");
pub const IID_IDVB_NIT = &IID_IDVB_NIT_Value;
pub const IDVB_NIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                ppNIT: ?*?*IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                ppNIT: ?*?*IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_NIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_NIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_NIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_NIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetNetworkId(@as(*const IDVB_NIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_NIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_NIT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_NIT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_NIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_NIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_NIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_NIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_NIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_NIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_NIT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetNextTable(self: *const T, ppNIT: ?*?*IDVB_NIT) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_NIT, @ptrCast(self)), ppNIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_NIT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_NIT, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_NIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_NIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_NIT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SDT_Value = Guid.initString("02cad8d3-fe43-48e2-90bd-450ed9a8a5fd");
pub const IID_IDVB_SDT = &IID_IDVB_SDT_Value;
pub const IDVB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEITScheduleFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEITPresentFollowingFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRunningStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordFreeCAMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                ppSDT: ?*?*IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                ppSDT: ?*?*IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_SDT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_SDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IDVB_SDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IDVB_SDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_SDT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordEITScheduleFlag(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITScheduleFlag(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordEITPresentFollowingFlag(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITPresentFollowingFlag(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordFreeCAMode(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordFreeCAMode(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_SDT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_SDT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetNextTable(self: *const T, ppSDT: ?*?*IDVB_SDT) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_SDT, @ptrCast(self)), ppSDT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_SDT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_SDT, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_SDT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDT_Value = Guid.initString("3f3dc9a2-bb32-4fb9-ae9e-d856848927a3");
pub const IID_IISDB_SDT = &IID_IISDB_SDT_Value;
pub const IISDB_SDT = extern struct {
    pub const VTable = extern struct {
        base: IDVB_SDT.VTable,
        GetRecordEITUserDefinedFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVB_SDT.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDT_GetRecordEITUserDefinedFlags(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDT.VTable, @ptrCast(self.vtable)).GetRecordEITUserDefinedFlags(@as(*const IISDB_SDT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_EIT_Value = Guid.initString("442db029-02cb-4495-8b92-1c13375bce99");
pub const IID_IDVB_EIT = &IID_IDVB_EIT_Value;
pub const IDVB_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSegmentLastSectionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastTableId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEventId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRunningStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordFreeCAMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                ppEIT: ?*?*IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                ppEIT: ?*?*IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_EIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IDVB_EIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IDVB_EIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IDVB_EIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetSegmentLastSectionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetSegmentLastSectionNumber(@as(*const IDVB_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetLastTableId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetLastTableId(@as(*const IDVB_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_EIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordFreeCAMode(self: *const T, dwRecordIndex: u32, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordFreeCAMode(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_EIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_EIT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetNextTable(self: *const T, ppEIT: ?*?*IDVB_EIT) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_EIT, @ptrCast(self)), ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_EIT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_EIT, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IDVB_EIT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDVB_EIT2_Value = Guid.initString("61a389e0-9b9e-4ba0-aeea-5ddd159820ea");
pub const IID_IDVB_EIT2 = &IID_IDVB_EIT2_Value;
pub const IDVB_EIT2 = extern struct {
    pub const VTable = extern struct {
        base: IDVB_EIT.VTable,
        GetSegmentInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT2,
                pbTid: ?*u8,
                pbSegment: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT2,
                pbTid: ?*u8,
                pbSegment: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_EIT2,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_EIT2,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDVB_EIT.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT2_GetSegmentInfo(self: *const T, pbTid: ?*u8, pbSegment: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT2.VTable, @ptrCast(self.vtable)).GetSegmentInfo(@as(*const IDVB_EIT2, @ptrCast(self)), pbTid, pbSegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_EIT2_GetRecordSection(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_EIT2.VTable, @ptrCast(self.vtable)).GetRecordSection(@as(*const IDVB_EIT2, @ptrCast(self)), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_BAT_Value = Guid.initString("ece9bb0c-43b6-4558-a0ec-1812c34cd6ca");
pub const IID_IDVB_BAT = &IID_IDVB_BAT_Value;
pub const IDVB_BAT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBouquetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                ppBAT: ?*?*IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                ppBAT: ?*?*IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_BAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_BAT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_BAT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetBouquetId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetBouquetId(@as(*const IDVB_BAT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_BAT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_BAT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_BAT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_BAT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_BAT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_BAT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_BAT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_BAT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_BAT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_BAT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_GetNextTable(self: *const T, ppBAT: ?*?*IDVB_BAT) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_BAT, @ptrCast(self)), ppBAT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_BAT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_BAT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDVB_BAT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_BAT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_RST_Value = Guid.initString("f47dcd04-1e23-4fb7-9f96-b40eead10b2b");
pub const IID_IDVB_RST = &IID_IDVB_RST_Value;
pub const IDVB_RST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEventId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRunningStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_RST,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_RST, @ptrCast(self)), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_RST, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordTransportStreamId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordTransportStreamId(@as(*const IDVB_RST, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordOriginalNetworkId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordOriginalNetworkId(@as(*const IDVB_RST, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_RST, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordEventId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IDVB_RST, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_RST_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_RST.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_RST, @ptrCast(self)), dwRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_ST_Value = Guid.initString("4d5b9f23-2a02-45de-bcda-5d5dbfbfbe62");
pub const IID_IDVB_ST = &IID_IDVB_ST_Value;
pub const IDVB_ST = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_ST,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_ST,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_ST,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_ST,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_ST,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_ST,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_ST, @ptrCast(self)), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_GetDataLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).GetDataLength(@as(*const IDVB_ST, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_ST_GetData(self: *const T, ppData: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_ST.VTable, @ptrCast(self.vtable)).GetData(@as(*const IDVB_ST, @ptrCast(self)), ppData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TDT_Value = Guid.initString("0780dc7d-d55c-4aef-97e6-6b75906e2796");
pub const IID_IDVB_TDT = &IID_IDVB_TDT_Value;
pub const IDVB_TDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TDT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TDT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUTCTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TDT,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TDT,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TDT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_TDT, @ptrCast(self)), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TDT_GetUTCTime(self: *const T, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TDT.VTable, @ptrCast(self.vtable)).GetUTCTime(@as(*const IDVB_TDT, @ptrCast(self)), pmdtVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_TOT_Value = Guid.initString("83295d6a-faba-4ee1-9b15-8067696910ae");
pub const IID_IDVB_TOT = &IID_IDVB_TOT_Value;
pub const IDVB_TOT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TOT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TOT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUTCTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TOT,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TOT,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TOT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TOT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TOT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TOT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_TOT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_TOT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_TOT, @ptrCast(self)), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetUTCTime(self: *const T, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetUTCTime(@as(*const IDVB_TOT, @ptrCast(self)), pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_TOT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_TOT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_TOT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_TOT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_TOT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_DIT_Value = Guid.initString("91bffdf9-9432-410f-86ef-1c228ed0ad70");
pub const IID_IDVB_DIT = &IID_IDVB_DIT_Value;
pub const IDVB_DIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_DIT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_DIT,
                pSectionList: ?*ISectionList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransitionFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_DIT,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_DIT,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_DIT_Initialize(self: *const T, pSectionList: ?*ISectionList) callconv(.Inline) HRESULT {
            return @as(*const IDVB_DIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_DIT, @ptrCast(self)), pSectionList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_DIT_GetTransitionFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVB_DIT.VTable, @ptrCast(self.vtable)).GetTransitionFlag(@as(*const IDVB_DIT, @ptrCast(self)), pfVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDVB_SIT_Value = Guid.initString("68cdce53-8bea-45c2-9d9d-acf575a089b5");
pub const IID_IDVB_SIT = &IID_IDVB_SIT_Value;
pub const IDVB_SIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRunningStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                hNextTableAvailable: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                dwTimeout: u32,
                ppSIT: ?*?*IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                dwTimeout: u32,
                ppSIT: ?*?*IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterForWhenCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
                hNextTableIsCurrent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertNextToCurrent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVB_SIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IDVB_SIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IDVB_SIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IDVB_SIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IDVB_SIT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IDVB_SIT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDVB_SIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordServiceId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDVB_SIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordRunningStatus(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordRunningStatus(@as(*const IDVB_SIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IDVB_SIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IDVB_SIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IDVB_SIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_RegisterForNextTable(self: *const T, hNextTableAvailable: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).RegisterForNextTable(@as(*const IDVB_SIT, @ptrCast(self)), hNextTableAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_GetNextTable(self: *const T, dwTimeout: u32, ppSIT: ?*?*IDVB_SIT) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).GetNextTable(@as(*const IDVB_SIT, @ptrCast(self)), dwTimeout, ppSIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_RegisterForWhenCurrent(self: *const T, hNextTableIsCurrent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).RegisterForWhenCurrent(@as(*const IDVB_SIT, @ptrCast(self)), hNextTableIsCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVB_SIT_ConvertNextToCurrent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDVB_SIT.VTable, @ptrCast(self.vtable)).ConvertNextToCurrent(@as(*const IDVB_SIT, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_BIT_Value = Guid.initString("537cd71e-0e46-4173-9001-ba043f3e49e2");
pub const IID_IISDB_BIT = &IID_IISDB_BIT_Value;
pub const IISDB_BIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBroadcastViewPropriety: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordBroadcasterId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_BIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_BIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_BIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_BIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_BIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetBroadcastViewPropriety(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetBroadcastViewPropriety(@as(*const IISDB_BIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IISDB_BIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IISDB_BIT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IISDB_BIT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_BIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordBroadcasterId(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordBroadcasterId(@as(*const IISDB_BIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_BIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_BIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_BIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_BIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_BIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_BIT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_NBIT_Value = Guid.initString("1b1863ef-08f1-40b7-a559-3b1eff8cafa6");
pub const IID_IISDB_NBIT = &IID_IISDB_NBIT_Value;
pub const IISDB_NBIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordInformationId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordInformationType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptionBodyLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordMessageSectionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordUserDefined: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNumberOfKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbKeys: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pbKeys: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_NBIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_NBIT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_NBIT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_NBIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_NBIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_NBIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordInformationId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordInformationId(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordInformationType(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordInformationType(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptionBodyLocation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptionBodyLocation(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordMessageSectionNumber(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordMessageSectionNumber(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordUserDefined(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordUserDefined(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordNumberOfKeys(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordNumberOfKeys(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordKeys(self: *const T, dwRecordIndex: u32, pbKeys: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordKeys(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pbKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_NBIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_NBIT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_NBIT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_NBIT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_LDT_Value = Guid.initString("141a546b-02ff-4fb9-a3a3-2f074b74a9a9");
pub const IID_IISDB_LDT = &IID_IISDB_LDT_Value;
pub const IISDB_LDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptionId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_LDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_LDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_LDT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_LDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetOriginalServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetOriginalServiceId(@as(*const IISDB_LDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IISDB_LDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_LDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_LDT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptionId(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptionId(@as(*const IISDB_LDT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_LDT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_LDT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_LDT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_LDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_LDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_LDT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_SDTT_Value = Guid.initString("ee60ef2d-813a-4dc7-bf92-ea13dac85313");
pub const IID_IISDB_SDTT = &IID_IISDB_SDTT_Value;
pub const IISDB_SDTT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableIdExt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTargetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNewVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDownloadLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordVersionIndicator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordScheduleTimeShiftInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfSchedules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordStartTimeByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDurationByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_SDTT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_SDTT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_SDTT, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_SDTT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetTableIdExt(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetTableIdExt(@as(*const IISDB_SDTT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetTransportStreamId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetTransportStreamId(@as(*const IISDB_SDTT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_SDTT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IISDB_SDTT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IISDB_SDTT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordGroup(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordGroup(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordTargetVersion(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordTargetVersion(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordNewVersion(self: *const T, dwRecordIndex: u32, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordNewVersion(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDownloadLevel(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDownloadLevel(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordVersionIndicator(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordVersionIndicator(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordScheduleTimeShiftInformation(self: *const T, dwRecordIndex: u32, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordScheduleTimeShiftInformation(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordCountOfSchedules(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordCountOfSchedules(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordStartTimeByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordStartTimeByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, dwIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDurationByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDurationByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, dwIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IISDB_SDTT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_SDTT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_SDTT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_SDTT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_CDT_Value = Guid.initString("25fa92c2-8b80-4787-a841-3a0e8f17984b");
pub const IID_IISDB_CDT = &IID_IISDB_CDT_Value;
pub const IISDB_CDT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
                bSectionNumber: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
                bSectionNumber: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDownloadDataId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSectionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalNetworkId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfTableDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSizeOfDataModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_CDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_CDT,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data, bSectionNumber: u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_CDT, @ptrCast(self)), pSectionList, pMPEGData, bSectionNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_CDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDownloadDataId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDownloadDataId(@as(*const IISDB_CDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetSectionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetSectionNumber(@as(*const IISDB_CDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetOriginalNetworkId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetOriginalNetworkId(@as(*const IISDB_CDT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDataType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDataType(@as(*const IISDB_CDT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetCountOfTableDescriptors(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetCountOfTableDescriptors(@as(*const IISDB_CDT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetTableDescriptorByIndex(self: *const T, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByIndex(@as(*const IISDB_CDT, @ptrCast(self)), dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetTableDescriptorByTag(self: *const T, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetTableDescriptorByTag(@as(*const IISDB_CDT, @ptrCast(self)), bTag, pdwCookie, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetSizeOfDataModule(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetSizeOfDataModule(@as(*const IISDB_CDT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetDataModule(self: *const T, pbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetDataModule(@as(*const IISDB_CDT, @ptrCast(self)), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_CDT_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_CDT.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_CDT, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IISDB_EMM_Value = Guid.initString("0edb556d-43ad-4938-9668-321b2ffecfd3");
pub const IID_IISDB_EMM = &IID_IISDB_EMM_Value;
pub const IISDB_EMM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pSectionList: ?*ISectionList,
                pMPEGData: ?*IMpeg2Data,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableIdExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pwBufferLength: ?*u16,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pwBufferLength: ?*u16,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSharedEmmMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pwLength: ?*u16,
                ppbMessage: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pwLength: ?*u16,
                ppbMessage: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndividualEmmMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pUnknown: ?*IUnknown,
                pwLength: ?*u16,
                ppbMessage: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pUnknown: ?*IUnknown,
                pwLength: ?*u16,
                ppbMessage: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionHash: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IISDB_EMM,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IISDB_EMM,
                pdwVersionHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_Initialize(self: *const T, pSectionList: ?*ISectionList, pMPEGData: ?*IMpeg2Data) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IISDB_EMM, @ptrCast(self)), pSectionList, pMPEGData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetVersionNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IISDB_EMM, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetTableIdExtension(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetTableIdExtension(@as(*const IISDB_EMM, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetDataBytes(self: *const T, pwBufferLength: ?*u16, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetDataBytes(@as(*const IISDB_EMM, @ptrCast(self)), pwBufferLength, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetSharedEmmMessage(self: *const T, pwLength: ?*u16, ppbMessage: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetSharedEmmMessage(@as(*const IISDB_EMM, @ptrCast(self)), pwLength, ppbMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetIndividualEmmMessage(self: *const T, pUnknown: ?*IUnknown, pwLength: ?*u16, ppbMessage: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetIndividualEmmMessage(@as(*const IISDB_EMM, @ptrCast(self)), pUnknown, pwLength, ppbMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IISDB_EMM_GetVersionHash(self: *const T, pdwVersionHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IISDB_EMM.VTable, @ptrCast(self.vtable)).GetVersionHash(@as(*const IISDB_EMM, @ptrCast(self)), pdwVersionHash);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceAttributeDescriptor_Value = Guid.initString("0f37bd92-d6a1-4854-b950-3a969d27f30e");
pub const IID_IDvbServiceAttributeDescriptor = &IID_IDvbServiceAttributeDescriptor_Value;
pub const IDvbServiceAttributeDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNumericSelectionFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordVisibleServiceFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceAttributeDescriptor,
                bRecordIndex: u8,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordNumericSelectionFlag(self: *const T, bRecordIndex: u8, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumericSelectionFlag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), bRecordIndex, pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceAttributeDescriptor_GetRecordVisibleServiceFlag(self: *const T, bRecordIndex: u8, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceAttributeDescriptor.VTable, @ptrCast(self.vtable)).GetRecordVisibleServiceFlag(@as(*const IDvbServiceAttributeDescriptor, @ptrCast(self)), bRecordIndex, pfVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CRID_LOCATION = enum(i32) {
    IN_DESCRIPTOR = 0,
    IN_CIT = 1,
    DVB_RESERVED1 = 2,
    DVB_RESERVED2 = 3,
};
pub const CRID_LOCATION_IN_DESCRIPTOR = CRID_LOCATION.IN_DESCRIPTOR;
pub const CRID_LOCATION_IN_CIT = CRID_LOCATION.IN_CIT;
pub const CRID_LOCATION_DVB_RESERVED1 = CRID_LOCATION.DVB_RESERVED1;
pub const CRID_LOCATION_DVB_RESERVED2 = CRID_LOCATION.DVB_RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentIdentifierDescriptor_Value = Guid.initString("05e0c1ea-f661-4053-9fbf-d93b28359838");
pub const IID_IDvbContentIdentifierDescriptor = &IID_IDvbContentIdentifierDescriptor_Value;
pub const IDvbContentIdentifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentIdentifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCrid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentIdentifierDescriptor,
                bRecordIndex: u8,
                pbType: ?*u8,
                pbLocation: ?*u8,
                pbLength: ?*u8,
                ppbBytes: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentIdentifierDescriptor,
                bRecordIndex: u8,
                pbType: ?*u8,
                pbLocation: ?*u8,
                pbLength: ?*u8,
                ppbBytes: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentIdentifierDescriptor_GetRecordCrid(self: *const T, bRecordIndex: u8, pbType: ?*u8, pbLocation: ?*u8, pbLength: ?*u8, ppbBytes: [*]?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentIdentifierDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCrid(@as(*const IDvbContentIdentifierDescriptor, @ptrCast(self)), bRecordIndex, pbType, pbLocation, pbLength, ppbBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDefaultAuthorityDescriptor_Value = Guid.initString("05ec24d1-3a31-44e7-b408-67c60a352276");
pub const IID_IDvbDefaultAuthorityDescriptor = &IID_IDvbDefaultAuthorityDescriptor_Value;
pub const IDvbDefaultAuthorityDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultAuthority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbLength: ?*u8,
                ppbBytes: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDefaultAuthorityDescriptor,
                pbLength: ?*u8,
                ppbBytes: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDefaultAuthorityDescriptor_GetDefaultAuthority(self: *const T, pbLength: ?*u8, ppbBytes: [*]?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDefaultAuthorityDescriptor.VTable, @ptrCast(self.vtable)).GetDefaultAuthority(@as(*const IDvbDefaultAuthorityDescriptor, @ptrCast(self)), pbLength, ppbBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbSatelliteDeliverySystemDescriptor_Value = Guid.initString("02f2225a-805b-4ec5-a9a6-f9b5913cd470");
pub const IID_IDvbSatelliteDeliverySystemDescriptor = &IID_IDvbSatelliteDeliverySystemDescriptor_Value;
pub const IDvbSatelliteDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOrbitalPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWestEastFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPolarization: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModulation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFECInner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSatelliteDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetOrbitalPosition(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOrbitalPosition(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetWestEastFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetWestEastFlag(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetPolarization(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetPolarization(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetModulation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetModulation(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetSymbolRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetSymbolRate(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSatelliteDeliverySystemDescriptor_GetFECInner(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSatelliteDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECInner(@as(*const IDvbSatelliteDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbCableDeliverySystemDescriptor_Value = Guid.initString("dfb98e36-9e1a-4862-9946-993a4e59017b");
pub const IID_IDvbCableDeliverySystemDescriptor = &IID_IDvbCableDeliverySystemDescriptor_Value;
pub const IDvbCableDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFECOuter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModulation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFECInner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbCableDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFrequency(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFECOuter(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECOuter(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetModulation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetModulation(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetSymbolRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetSymbolRate(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbCableDeliverySystemDescriptor_GetFECInner(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbCableDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetFECInner(@as(*const IDvbCableDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrialDeliverySystemDescriptor_Value = Guid.initString("ed7e1b91-d12e-420c-b41d-a49d84fe1823");
pub const IID_IDvbTerrestrialDeliverySystemDescriptor = &IID_IDvbTerrestrialDeliverySystemDescriptor_Value;
pub const IDvbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCentreFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstellation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHierarchyInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeRateHPStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeRateLPStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuardInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransmissionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherFrequencyFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCentreFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCentreFrequency(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetBandwidth(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetBandwidth(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetConstellation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetConstellation(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetHierarchyInformation(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetHierarchyInformation(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateHPStream(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCodeRateHPStream(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateLPStream(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCodeRateLPStream(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrialDeliverySystemDescriptor_GetOtherFrequencyFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOtherFrequencyFlag(@as(*const IDvbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbTerrestrial2DeliverySystemDescriptor_Value = Guid.initString("20ee9be9-cd57-49ab-8f6e-1d07aeb8e482");
pub const IID_IDvbTerrestrial2DeliverySystemDescriptor = &IID_IDvbTerrestrial2DeliverySystemDescriptor_Value;
pub const IDvbTerrestrial2DeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTagExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCentreFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPLPId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetT2SystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMultipleInputMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBandwidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuardInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransmissionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCellId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherFrequencyFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTFSFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTerrestrial2DeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTagExtension(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTagExtension(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetCentreFrequency(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCentreFrequency(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetPLPId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetPLPId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetT2SystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetT2SystemId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetMultipleInputMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetMultipleInputMode(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetBandwidth(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetBandwidth(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetCellId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCellId(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetOtherFrequencyFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetOtherFrequencyFlag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTerrestrial2DeliverySystemDescriptor_GetTFSFlag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTerrestrial2DeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTFSFlag(@as(*const IDvbTerrestrial2DeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbFrequencyListDescriptor_Value = Guid.initString("1cadb613-e1dd-4512-afa8-bb7a007ef8b1");
pub const IID_IDvbFrequencyListDescriptor = &IID_IDvbFrequencyListDescriptor_Value;
pub const IDvbFrequencyListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodingType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbFrequencyListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCentreFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbFrequencyListDescriptor,
                bRecordIndex: u8,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbFrequencyListDescriptor,
                bRecordIndex: u8,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetCodingType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetCodingType(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbFrequencyListDescriptor_GetRecordCentreFrequency(self: *const T, bRecordIndex: u8, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbFrequencyListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCentreFrequency(@as(*const IDvbFrequencyListDescriptor, @ptrCast(self)), bRecordIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbPrivateDataSpecifierDescriptor_Value = Guid.initString("5660a019-e75a-4b82-9b4c-ed2256d165a2");
pub const IID_IDvbPrivateDataSpecifierDescriptor = &IID_IDvbPrivateDataSpecifierDescriptor_Value;
pub const IDvbPrivateDataSpecifierDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateDataSpecifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbPrivateDataSpecifierDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbPrivateDataSpecifierDescriptor_GetPrivateDataSpecifier(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbPrivateDataSpecifierDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataSpecifier(@as(*const IDvbPrivateDataSpecifierDescriptor, @ptrCast(self)), pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbLogicalChannelDescriptor_Value = Guid.initString("cf1edaff-3ffd-4cf7-8201-35756acbf85f");
pub const IID_IDvbLogicalChannelDescriptor = &IID_IDvbLogicalChannelDescriptor_Value;
pub const IDvbLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordLogicalChannelNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor_GetRecordLogicalChannelNumber(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLogicalChannelNumber(@as(*const IDvbLogicalChannelDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannelDescriptor2_Value = Guid.initString("43aca974-4be8-4b98-bc17-9eafd788b1d7");
pub const IID_IDvbLogicalChannelDescriptor2 = &IID_IDvbLogicalChannelDescriptor2_Value;
pub const IDvbLogicalChannelDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor.VTable,
        GetRecordLogicalChannelAndVisibility: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannelDescriptor2,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannelDescriptor2,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannelDescriptor2_GetRecordLogicalChannelAndVisibility(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannelDescriptor2.VTable, @ptrCast(self.vtable)).GetRecordLogicalChannelAndVisibility(@as(*const IDvbLogicalChannelDescriptor2, @ptrCast(self)), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLogicalChannel2Descriptor_Value = Guid.initString("f69c3747-8a30-4980-998c-01fe7f0ba35a");
pub const IID_IDvbLogicalChannel2Descriptor = &IID_IDvbLogicalChannel2Descriptor_Value;
pub const IDvbLogicalChannel2Descriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
        GetCountOfLists: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListCountryCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bChannelListIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bChannelListIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListRecordLogicalChannelNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetListRecordLogicalChannelAndVisibility: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLogicalChannel2Descriptor,
                bListIndex: u8,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetCountOfLists(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetCountOfLists(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListId(self: *const T, bListIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListId(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListNameW(self: *const T, bListIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListNameW(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListCountryCode(self: *const T, bListIndex: u8, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListCountryCode(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListCountOfRecords(self: *const T, bChannelListIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListCountOfRecords(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bChannelListIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordServiceId(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordServiceId(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelNumber(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordLogicalChannelNumber(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelAndVisibility(self: *const T, bListIndex: u8, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLogicalChannel2Descriptor.VTable, @ptrCast(self.vtable)).GetListRecordLogicalChannelAndVisibility(@as(*const IDvbLogicalChannel2Descriptor, @ptrCast(self)), bListIndex, bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbHDSimulcastLogicalChannelDescriptor_Value = Guid.initString("1ea8b738-a307-4680-9e26-d0a908c824f4");
pub const IID_IDvbHDSimulcastLogicalChannelDescriptor = &IID_IDvbHDSimulcastLogicalChannelDescriptor_Value;
pub const IDvbHDSimulcastLogicalChannelDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IDvbLogicalChannelDescriptor2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbLogicalChannelDescriptor2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastIDDescriptor_Value = Guid.initString("5f26f518-65c8-4048-91f2-9290f59f7b90");
pub const IID_IDvbDataBroadcastIDDescriptor = &IID_IDvbDataBroadcastIDDescriptor_Value;
pub const IDvbDataBroadcastIDDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataBroadcastID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIDSelectorBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastIDDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetDataBroadcastID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetDataBroadcastID(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastIDDescriptor_GetIDSelectorBytes(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastIDDescriptor.VTable, @ptrCast(self.vtable)).GetIDSelectorBytes(@as(*const IDvbDataBroadcastIDDescriptor, @ptrCast(self)), pbLen, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbDataBroadcastDescriptor_Value = Guid.initString("d1ebc1d6-8b60-4c20-9caf-e59382e7c400");
pub const IID_IDvbDataBroadcastDescriptor = &IID_IDvbDataBroadcastDescriptor_Value;
pub const IDvbDataBroadcastDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataBroadcastID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectorLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectorBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLangID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbDataBroadcastDescriptor,
                pbLen: ?*u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetDataBroadcastID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetDataBroadcastID(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetSelectorLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetSelectorBytes(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorBytes(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbLen, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetLangID(self: *const T, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetLangID(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetTextLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetTextLength(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbDataBroadcastDescriptor_GetText(self: *const T, pbLen: ?*u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbDataBroadcastDescriptor.VTable, @ptrCast(self.vtable)).GetText(@as(*const IDvbDataBroadcastDescriptor, @ptrCast(self)), pbLen, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DESC_LINKAGE_TYPE = enum(i32) {
    RESERVED0 = 0,
    INFORMATION = 1,
    EPG = 2,
    CA_REPLACEMENT = 3,
    COMPLETE_NET_BOUQUET_SI = 4,
    REPLACEMENT = 5,
    DATA = 6,
    RESERVED1 = 7,
    USER = 8,
    RESERVED2 = 255,
};
pub const DESC_LINKAGE_RESERVED0 = DESC_LINKAGE_TYPE.RESERVED0;
pub const DESC_LINKAGE_INFORMATION = DESC_LINKAGE_TYPE.INFORMATION;
pub const DESC_LINKAGE_EPG = DESC_LINKAGE_TYPE.EPG;
pub const DESC_LINKAGE_CA_REPLACEMENT = DESC_LINKAGE_TYPE.CA_REPLACEMENT;
pub const DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI = DESC_LINKAGE_TYPE.COMPLETE_NET_BOUQUET_SI;
pub const DESC_LINKAGE_REPLACEMENT = DESC_LINKAGE_TYPE.REPLACEMENT;
pub const DESC_LINKAGE_DATA = DESC_LINKAGE_TYPE.DATA;
pub const DESC_LINKAGE_RESERVED1 = DESC_LINKAGE_TYPE.RESERVED1;
pub const DESC_LINKAGE_USER = DESC_LINKAGE_TYPE.USER;
pub const DESC_LINKAGE_RESERVED2 = DESC_LINKAGE_TYPE.RESERVED2;

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbLinkageDescriptor_Value = Guid.initString("1cdf8b31-994a-46fc-acfd-6a6be8934dd5");
pub const IID_IDvbLinkageDescriptor = &IID_IDvbLinkageDescriptor_Value;
pub const IDvbLinkageDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTSId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetONId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkageType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbLinkageDescriptor,
                pbLen: ?*u8,
                pbData: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbLinkageDescriptor,
                pbLen: ?*u8,
                pbData: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetTSId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetTSId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetONId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetONId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetServiceId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetLinkageType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetLinkageType(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetPrivateDataLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataLength(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbLinkageDescriptor_GetPrivateData(self: *const T, pbLen: ?*u8, pbData: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbLinkageDescriptor.VTable, @ptrCast(self.vtable)).GetPrivateData(@as(*const IDvbLinkageDescriptor, @ptrCast(self)), pbLen, pbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbTeletextDescriptor_Value = Guid.initString("9cd29d47-69c6-4f92-98a9-210af1b7303a");
pub const IID_IDvbTeletextDescriptor = &IID_IDvbTeletextDescriptor_Value;
pub const IDvbTeletextDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTeletextType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordMagazineNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordPageNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbTeletextDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), bRecordIndex, pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordTeletextType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTeletextType(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordMagazineNumber(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordMagazineNumber(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbTeletextDescriptor_GetRecordPageNumber(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbTeletextDescriptor.VTable, @ptrCast(self.vtable)).GetRecordPageNumber(@as(*const IDvbTeletextDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbSubtitlingDescriptor_Value = Guid.initString("9b25fe1d-fa23-4e50-9784-6df8b26f8a49");
pub const IID_IDvbSubtitlingDescriptor = &IID_IDvbSubtitlingDescriptor_Value;
pub const IDvbSubtitlingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordSubtitlingType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCompositionPageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordAncillaryPageID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbSubtitlingDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, pulVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), bRecordIndex, pulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordSubtitlingType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordSubtitlingType(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordCompositionPageID(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCompositionPageID(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbSubtitlingDescriptor_GetRecordAncillaryPageID(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbSubtitlingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordAncillaryPageID(@as(*const IDvbSubtitlingDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvbServiceDescriptor_Value = Guid.initString("f9c7fbcf-e2d6-464d-b32d-2ef526e49290");
pub const IID_IDvbServiceDescriptor = &IID_IDvbServiceDescriptor_Value;
pub const IDvbServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceProviderName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceProviderNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessedServiceName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceNameEmphasized: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceType(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceProviderName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceProviderName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceProviderNameW(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceProviderNameW(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetProcessedServiceName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetProcessedServiceName(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor_GetServiceNameEmphasized(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceNameEmphasized(@as(*const IDvbServiceDescriptor, @ptrCast(self)), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceDescriptor2_Value = Guid.initString("d6c76506-85ab-487c-9b2b-36416511e4a2");
pub const IID_IDvbServiceDescriptor2 = &IID_IDvbServiceDescriptor2_Value;
pub const IDvbServiceDescriptor2 = extern struct {
    pub const VTable = extern struct {
        base: IDvbServiceDescriptor.VTable,
        GetServiceProviderNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor2,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor2,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceDescriptor2,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceDescriptor2,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDvbServiceDescriptor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor2_GetServiceProviderNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor2.VTable, @ptrCast(self.vtable)).GetServiceProviderNameW(@as(*const IDvbServiceDescriptor2, @ptrCast(self)), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceDescriptor2_GetServiceNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceDescriptor2.VTable, @ptrCast(self.vtable)).GetServiceNameW(@as(*const IDvbServiceDescriptor2, @ptrCast(self)), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbServiceListDescriptor_Value = Guid.initString("05db0d8f-6008-491a-acd3-7090952707d0");
pub const IID_IDvbServiceListDescriptor = &IID_IDvbServiceListDescriptor_Value;
pub const IDvbServiceListDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceListDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceListDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceListDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbServiceListDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbServiceListDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetRecordServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceId(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbServiceListDescriptor_GetRecordServiceType(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbServiceListDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceType(@as(*const IDvbServiceListDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbMultilingualServiceNameDescriptor_Value = Guid.initString("2d80433b-b32c-47ef-987f-e78ebb773e34");
pub const IID_IDvbMultilingualServiceNameDescriptor = &IID_IDvbMultilingualServiceNameDescriptor_Value;
pub const IDvbMultilingualServiceNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordLangId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                ulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                ulVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceProviderNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbMultilingualServiceNameDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordLangId(self: *const T, bRecordIndex: u8, ulVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordLangId(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), bRecordIndex, ulVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordServiceProviderNameW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceProviderNameW(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), bRecordIndex, convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbMultilingualServiceNameDescriptor_GetRecordServiceNameW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbMultilingualServiceNameDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceNameW(@as(*const IDvbMultilingualServiceNameDescriptor, @ptrCast(self)), bRecordIndex, convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbNetworkNameDescriptor_Value = Guid.initString("5b2a80cf-35b9-446c-b3e4-048b761dbc51");
pub const IID_IDvbNetworkNameDescriptor = &IID_IDvbNetworkNameDescriptor_Value;
pub const IDvbNetworkNameDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbNetworkNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbNetworkNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbNetworkNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbNetworkNameDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbNetworkNameDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbNetworkNameDescriptor,
                pszName: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbNetworkNameDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbNetworkNameDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetNetworkName(self: *const T, pszName: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetNetworkName(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbNetworkNameDescriptor_GetNetworkNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbNetworkNameDescriptor.VTable, @ptrCast(self.vtable)).GetNetworkNameW(@as(*const IDvbNetworkNameDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbShortEventDescriptor_Value = Guid.initString("b170be92-5b75-458e-9c6e-b0008231491a");
pub const IID_IDvbShortEventDescriptor = &IID_IDvbShortEventDescriptor_Value;
pub const IDvbShortEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbShortEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbShortEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbShortEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbShortEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbShortEventDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbShortEventDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbShortEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbShortEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbShortEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbShortEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetEventNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetEventNameW(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbShortEventDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbShortEventDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbShortEventDescriptor, @ptrCast(self)), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbExtendedEventDescriptor_Value = Guid.initString("c9b22eca-85f4-499f-b1db-efa93a91ee57");
pub const IID_IDvbExtendedEventDescriptor = &IID_IDvbExtendedEventDescriptor_Value;
pub const IDvbExtendedEventDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptorNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastDescriptorNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordItemW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrDesc: ?*?BSTR,
                pbstrItem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrDesc: ?*?BSTR,
                pbstrItem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConcatenatedItemW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                pFollowingDescriptor: ?*IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrDesc: ?*?BSTR,
                pbstrItem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                pFollowingDescriptor: ?*IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrDesc: ?*?BSTR,
                pbstrItem: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConcatenatedTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                FollowingDescriptor: ?*IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                FollowingDescriptor: ?*IDvbExtendedEventDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordItemRawBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbExtendedEventDescriptor,
                bRecordIndex: u8,
                ppbRawItem: ?*?*u8,
                pbItemLength: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbExtendedEventDescriptor,
                bRecordIndex: u8,
                ppbRawItem: ?*?*u8,
                pbItemLength: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetDescriptorNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetDescriptorNumber(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLastDescriptorNumber(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLastDescriptorNumber(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetRecordItemW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrDesc: ?*?BSTR, pbstrItem: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetRecordItemW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), bRecordIndex, convMode, pbstrDesc, pbstrItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetConcatenatedItemW(self: *const T, pFollowingDescriptor: ?*IDvbExtendedEventDescriptor, convMode: DVB_STRCONV_MODE, pbstrDesc: ?*?BSTR, pbstrItem: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetConcatenatedItemW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), pFollowingDescriptor, convMode, pbstrDesc, pbstrItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), convMode, pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetConcatenatedTextW(self: *const T, FollowingDescriptor: ?*IDvbExtendedEventDescriptor, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetConcatenatedTextW(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), FollowingDescriptor, convMode, pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbExtendedEventDescriptor_GetRecordItemRawBytes(self: *const T, bRecordIndex: u8, ppbRawItem: ?*?*u8, pbItemLength: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbExtendedEventDescriptor.VTable, @ptrCast(self.vtable)).GetRecordItemRawBytes(@as(*const IDvbExtendedEventDescriptor, @ptrCast(self)), bRecordIndex, ppbRawItem, pbItemLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbComponentDescriptor_Value = Guid.initString("91e405cf-80e7-457f-9096-1b9d1ce32141");
pub const IID_IDvbComponentDescriptor = &IID_IDvbComponentDescriptor_Value;
pub const IDvbComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbComponentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbComponentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetStreamContent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamContent(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetComponentType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentType(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IDvbComponentDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbComponentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDvbComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IDvbComponentDescriptor, @ptrCast(self)), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbContentDescriptor_Value = Guid.initString("2e883881-a467-412a-9d63-6f2b6da05bf0");
pub const IID_IDvbContentDescriptor = &IID_IDvbContentDescriptor_Value;
pub const IDvbContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordContentNibbles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentDescriptor,
                bRecordIndex: u8,
                pbValLevel1: ?*u8,
                pbValLevel2: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentDescriptor,
                bRecordIndex: u8,
                pbValLevel1: ?*u8,
                pbValLevel2: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordUserNibbles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbContentDescriptor,
                bRecordIndex: u8,
                pbVal1: ?*u8,
                pbVal2: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbContentDescriptor,
                bRecordIndex: u8,
                pbVal1: ?*u8,
                pbVal2: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetRecordContentNibbles(self: *const T, bRecordIndex: u8, pbValLevel1: ?*u8, pbValLevel2: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordContentNibbles(@as(*const IDvbContentDescriptor, @ptrCast(self)), bRecordIndex, pbValLevel1, pbValLevel2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbContentDescriptor_GetRecordUserNibbles(self: *const T, bRecordIndex: u8, pbVal1: ?*u8, pbVal2: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordUserNibbles(@as(*const IDvbContentDescriptor, @ptrCast(self)), bRecordIndex, pbVal1, pbVal2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IDvbParentalRatingDescriptor_Value = Guid.initString("3ad9dde1-fb1b-4186-937f-22e6b5a72a10");
pub const IID_IDvbParentalRatingDescriptor = &IID_IDvbParentalRatingDescriptor_Value;
pub const IDvbParentalRatingDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbParentalRatingDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordRating: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvbParentalRatingDescriptor,
                bRecordIndex: u8,
                pszCountryCode: *[4]u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvbParentalRatingDescriptor,
                bRecordIndex: u8,
                pszCountryCode: *[4]u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvbParentalRatingDescriptor_GetRecordRating(self: *const T, bRecordIndex: u8, pszCountryCode: *[4]u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvbParentalRatingDescriptor.VTable, @ptrCast(self.vtable)).GetRecordRating(@as(*const IDvbParentalRatingDescriptor, @ptrCast(self)), bRecordIndex, pszCountryCode, pbVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTerrestrialDeliverySystemDescriptor_Value = Guid.initString("39fae0a6-d151-44dd-a28a-765de5991670");
pub const IID_IIsdbTerrestrialDeliverySystemDescriptor = &IID_IIsdbTerrestrialDeliverySystemDescriptor_Value;
pub const IIsdbTerrestrialDeliverySystemDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAreaCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuardInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransmissionMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                bRecordIndex: u8,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTerrestrialDeliverySystemDescriptor,
                bRecordIndex: u8,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetAreaCode(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetAreaCode(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetGuardInterval(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetGuardInterval(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetTransmissionMode(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTerrestrialDeliverySystemDescriptor_GetRecordFrequency(self: *const T, bRecordIndex: u8, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTerrestrialDeliverySystemDescriptor.VTable, @ptrCast(self.vtable)).GetRecordFrequency(@as(*const IIsdbTerrestrialDeliverySystemDescriptor, @ptrCast(self)), bRecordIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbTSInformationDescriptor_Value = Guid.initString("d7ad183e-38f5-4210-b55f-ec8d601bbd47");
pub const IID_IIsdbTSInformationDescriptor = &IID_IIsdbTSInformationDescriptor_Value;
pub const IIsdbTSInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRemoteControlKeyId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTSNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTransmissionTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNumberOfServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordServiceIdByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                bServiceIndex: u8,
                pdwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbTSInformationDescriptor,
                bRecordIndex: u8,
                bServiceIndex: u8,
                pdwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRemoteControlKeyId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRemoteControlKeyId(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetTSNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTSNameW(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordTransmissionTypeInfo(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTransmissionTypeInfo(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordNumberOfServices(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfServices(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbTSInformationDescriptor_GetRecordServiceIdByIndex(self: *const T, bRecordIndex: u8, bServiceIndex: u8, pdwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbTSInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordServiceIdByIndex(@as(*const IIsdbTSInformationDescriptor, @ptrCast(self)), bRecordIndex, bServiceIndex, pdwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDigitalCopyControlDescriptor_Value = Guid.initString("1a28417e-266a-4bb8-a4bd-d782bcfb8161");
pub const IID_IIsdbDigitalCopyControlDescriptor = &IID_IIsdbDigitalCopyControlDescriptor_Value;
pub const IIsdbDigitalCopyControlDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCopyControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbDigitalRecordingControlData: ?*u8,
                pbCopyControlType: ?*u8,
                pbAPSControlData: ?*u8,
                pbMaximumBitrate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbDigitalRecordingControlData: ?*u8,
                pbCopyControlType: ?*u8,
                pbAPSControlData: ?*u8,
                pbMaximumBitrate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCopyControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                bRecordIndex: u8,
                pbComponentTag: ?*u8,
                pbDigitalRecordingControlData: ?*u8,
                pbCopyControlType: ?*u8,
                pbAPSControlData: ?*u8,
                pbMaximumBitrate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDigitalCopyControlDescriptor,
                bRecordIndex: u8,
                pbComponentTag: ?*u8,
                pbDigitalRecordingControlData: ?*u8,
                pbCopyControlType: ?*u8,
                pbAPSControlData: ?*u8,
                pbMaximumBitrate: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetCopyControl(self: *const T, pbDigitalRecordingControlData: ?*u8, pbCopyControlType: ?*u8, pbAPSControlData: ?*u8, pbMaximumBitrate: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetCopyControl(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pbDigitalRecordingControlData, pbCopyControlType, pbAPSControlData, pbMaximumBitrate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDigitalCopyControlDescriptor_GetRecordCopyControl(self: *const T, bRecordIndex: u8, pbComponentTag: ?*u8, pbDigitalRecordingControlData: ?*u8, pbCopyControlType: ?*u8, pbAPSControlData: ?*u8, pbMaximumBitrate: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDigitalCopyControlDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCopyControl(@as(*const IIsdbDigitalCopyControlDescriptor, @ptrCast(self)), bRecordIndex, pbComponentTag, pbDigitalRecordingControlData, pbCopyControlType, pbAPSControlData, pbMaximumBitrate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbAudioComponentDescriptor_Value = Guid.initString("679d2002-2425-4be4-a4c7-d6632a574f4d");
pub const IID_IIsdbAudioComponentDescriptor = &IID_IIsdbAudioComponentDescriptor_Value;
pub const IIsdbAudioComponentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSimulcastGroupTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetESMultiLingualFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMainComponentFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pfVal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQualityIndicator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSamplingRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbAudioComponentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbAudioComponentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetStreamContent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamContent(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetComponentType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentType(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetStreamType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetStreamType(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetSimulcastGroupTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetSimulcastGroupTag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetESMultiLingualFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetESMultiLingualFlag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetMainComponentFlag(self: *const T, pfVal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetMainComponentFlag(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pfVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetQualityIndicator(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetQualityIndicator(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetSamplingRate(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetSamplingRate(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetLanguageCode2(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode2(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbAudioComponentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbAudioComponentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbAudioComponentDescriptor, @ptrCast(self)), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDataContentDescriptor_Value = Guid.initString("a428100a-e646-4bd6-aa14-6087bdc08cd5");
pub const IID_IIsdbDataContentDescriptor = &IID_IIsdbDataContentDescriptor_Value;
pub const IIsdbDataContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataComponentId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEntryComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectorLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSelectorBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                bBufLength: u8,
                pbBuf: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                bBufLength: u8,
                pbBuf: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordComponentRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                pszCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDataContentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDataContentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetDataComponentId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetDataComponentId(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetEntryComponent(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetEntryComponent(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetSelectorLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorLength(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetSelectorBytes(self: *const T, bBufLength: u8, pbBuf: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetSelectorBytes(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), bBufLength, pbBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetRecordComponentRef(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordComponentRef(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetLanguageCode(self: *const T, pszCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetLanguageCode(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), pszCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDataContentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDataContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbDataContentDescriptor, @ptrCast(self)), convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAContractInformationDescriptor_Value = Guid.initString("08e18b25-a28f-4e92-821e-4fced5cc2291");
pub const IID_IIsdbCAContractInformationDescriptor = &IID_IIsdbCAContractInformationDescriptor_Value;
pub const IIsdbCAContractInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCASystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCAUnitId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContractVerificationInfoLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContractVerificationInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                bBufLength: u8,
                pbBuf: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                bBufLength: u8,
                pbBuf: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFeeNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAContractInformationDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAContractInformationDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCAUnitId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCAUnitId(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetRecordComponentTag(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetRecordComponentTag(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetContractVerificationInfoLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetContractVerificationInfoLength(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetContractVerificationInfo(self: *const T, bBufLength: u8, pbBuf: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetContractVerificationInfo(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), bBufLength, pbBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAContractInformationDescriptor_GetFeeNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAContractInformationDescriptor.VTable, @ptrCast(self.vtable)).GetFeeNameW(@as(*const IIsdbCAContractInformationDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEventGroupDescriptor_Value = Guid.initString("94b06780-2e2a-44dc-a966-cc56fdabc6c2");
pub const IID_IIsdbEventGroupDescriptor = &IID_IIsdbEventGroupDescriptor_Value;
pub const IIsdbEventGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGroupType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                bRecordIndex: u8,
                pwServiceId: ?*u16,
                pwEventId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                bRecordIndex: u8,
                pwServiceId: ?*u16,
                pwEventId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRefRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRefRecordEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEventGroupDescriptor,
                bRecordIndex: u8,
                pwOriginalNetworkId: ?*u16,
                pwTransportStreamId: ?*u16,
                pwServiceId: ?*u16,
                pwEventId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEventGroupDescriptor,
                bRecordIndex: u8,
                pwOriginalNetworkId: ?*u16,
                pwTransportStreamId: ?*u16,
                pwServiceId: ?*u16,
                pwEventId: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetGroupType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetGroupType(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetRecordEvent(self: *const T, bRecordIndex: u8, pwServiceId: ?*u16, pwEventId: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordEvent(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), bRecordIndex, pwServiceId, pwEventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetCountOfRefRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRefRecords(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEventGroupDescriptor_GetRefRecordEvent(self: *const T, bRecordIndex: u8, pwOriginalNetworkId: ?*u16, pwTransportStreamId: ?*u16, pwServiceId: ?*u16, pwEventId: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEventGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRefRecordEvent(@as(*const IIsdbEventGroupDescriptor, @ptrCast(self)), bRecordIndex, pwOriginalNetworkId, pwTransportStreamId, pwServiceId, pwEventId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbComponentGroupDescriptor_Value = Guid.initString("a494f17f-c592-47d8-8943-64c9a34be7b9");
pub const IID_IIsdbComponentGroupDescriptor = &IID_IIsdbComponentGroupDescriptor_Value;
pub const IIsdbComponentGroupDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentGroupType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordGroupId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNumberOfCAUnit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCAUnitCAUnitId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCAUnitNumberOfComponents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCAUnitComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                bComponentIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                bCAUnitIndex: u8,
                bComponentIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTotalBitRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbComponentGroupDescriptor,
                bRecordIndex: u8,
                convMode: DVB_STRCONV_MODE,
                pbstrText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetComponentGroupType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetComponentGroupType(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordGroupId(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordGroupId(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordNumberOfCAUnit(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfCAUnit(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitCAUnitId(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitCAUnitId(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, bCAUnitIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitNumberOfComponents(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitNumberOfComponents(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, bCAUnitIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordCAUnitComponentTag(self: *const T, bRecordIndex: u8, bCAUnitIndex: u8, bComponentIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordCAUnitComponentTag(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, bCAUnitIndex, bComponentIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordTotalBitRate(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTotalBitRate(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbComponentGroupDescriptor_GetRecordTextW(self: *const T, bRecordIndex: u8, convMode: DVB_STRCONV_MODE, pbstrText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbComponentGroupDescriptor.VTable, @ptrCast(self.vtable)).GetRecordTextW(@as(*const IIsdbComponentGroupDescriptor, @ptrCast(self)), bRecordIndex, convMode, pbstrText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSeriesDescriptor_Value = Guid.initString("07ef6370-1660-4f26-87fc-614adab24b11");
pub const IID_IIsdbSeriesDescriptor = &IID_IIsdbSeriesDescriptor_Value;
pub const IIsdbSeriesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSeriesId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRepeatLabel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgramPattern: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpireDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pfValid: ?*BOOL,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pfValid: ?*BOOL,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEpisodeNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEpisodeNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSeriesNameW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSeriesDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSeriesDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetSeriesId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetSeriesId(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetRepeatLabel(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetRepeatLabel(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetProgramPattern(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetProgramPattern(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetExpireDate(self: *const T, pfValid: ?*BOOL, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetExpireDate(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pfValid, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetEpisodeNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetEpisodeNumber(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetLastEpisodeNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetLastEpisodeNumber(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSeriesDescriptor_GetSeriesNameW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSeriesDescriptor.VTable, @ptrCast(self.vtable)).GetSeriesNameW(@as(*const IIsdbSeriesDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbDownloadContentDescriptor_Value = Guid.initString("5298661e-cb88-4f5f-a1de-5f440c185b92");
pub const IID_IIsdbDownloadContentDescriptor = &IID_IIsdbDownloadContentDescriptor_Value;
pub const IIsdbDownloadContentDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pfReboot: ?*BOOL,
                pfAddOn: ?*BOOL,
                pfCompatibility: ?*BOOL,
                pfModuleInfo: ?*BOOL,
                pfTextInfo: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pfReboot: ?*BOOL,
                pfAddOn: ?*BOOL,
                pfCompatibility: ?*BOOL,
                pfModuleInfo: ?*BOOL,
                pfTextInfo: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDownloadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeOutValueDII: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLeakRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompatiblityDescriptorLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pwLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pwLength: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompatiblityDescriptor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                ppbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                ppbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordModuleId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordModuleSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordModuleInfoLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordModuleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                ppbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                wRecordIndex: u16,
                ppbData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextLanguageCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                szCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                szCode: *[4]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbDownloadContentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbDownloadContentDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetFlags(self: *const T, pfReboot: ?*BOOL, pfAddOn: ?*BOOL, pfCompatibility: ?*BOOL, pfModuleInfo: ?*BOOL, pfTextInfo: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pfReboot, pfAddOn, pfCompatibility, pfModuleInfo, pfTextInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetComponentSize(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentSize(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetDownloadId(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetDownloadId(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTimeOutValueDII(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTimeOutValueDII(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetLeakRate(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetLeakRate(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetComponentTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetComponentTag(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCompatiblityDescriptorLength(self: *const T, pwLength: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCompatiblityDescriptorLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCompatiblityDescriptor(self: *const T, ppbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCompatiblityDescriptor(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), ppbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetCountOfRecords(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleId(self: *const T, wRecordIndex: u16, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleId(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), wRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleSize(self: *const T, wRecordIndex: u16, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleSize(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), wRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleInfoLength(self: *const T, wRecordIndex: u16, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleInfoLength(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), wRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetRecordModuleInfo(self: *const T, wRecordIndex: u16, ppbData: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetRecordModuleInfo(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), wRecordIndex, ppbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTextLanguageCode(self: *const T, szCode: *[4]u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextLanguageCode(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), szCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbDownloadContentDescriptor_GetTextW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbDownloadContentDescriptor.VTable, @ptrCast(self.vtable)).GetTextW(@as(*const IIsdbDownloadContentDescriptor, @ptrCast(self)), convMode, pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbLogoTransmissionDescriptor_Value = Guid.initString("e0103f49-4ae1-4f07-9098-756db1fa88cd");
pub const IID_IIsdbLogoTransmissionDescriptor = &IID_IIsdbLogoTransmissionDescriptor_Value;
pub const IIsdbLogoTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogoTransmissionType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogoId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogoVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDownloadDataId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogoCharW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrChar: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbLogoTransmissionDescriptor,
                convMode: DVB_STRCONV_MODE,
                pbstrChar: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoTransmissionType(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoTransmissionType(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoId(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoVersion(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoVersion(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetDownloadDataId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetDownloadDataId(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbLogoTransmissionDescriptor_GetLogoCharW(self: *const T, convMode: DVB_STRCONV_MODE, pbstrChar: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IIsdbLogoTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLogoCharW(@as(*const IIsdbLogoTransmissionDescriptor, @ptrCast(self)), convMode, pbstrChar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbSIParameterDescriptor_Value = Guid.initString("f837dc36-867c-426a-9111-f62093951a45");
pub const IID_IIsdbSIParameterDescriptor = &IID_IIsdbSIParameterDescriptor_Value;
pub const IIsdbSIParameterDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameterVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUpdateTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                pVal: ?*MPEG_DATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                pVal: ?*MPEG_DATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordNumberOfTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptionLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableDescriptionBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbBufferLength: ?*u8,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbSIParameterDescriptor,
                bRecordIndex: u8,
                pbBufferLength: ?*u8,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetParameterVersion(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetParameterVersion(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetUpdateTime(self: *const T, pVal: ?*MPEG_DATE) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetUpdateTime(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetRecordNumberOfTable(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetRecordNumberOfTable(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableId(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableId(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableDescriptionLength(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableDescriptionLength(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbSIParameterDescriptor_GetTableDescriptionBytes(self: *const T, bRecordIndex: u8, pbBufferLength: ?*u8, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbSIParameterDescriptor.VTable, @ptrCast(self.vtable)).GetTableDescriptionBytes(@as(*const IIsdbSIParameterDescriptor, @ptrCast(self)), bRecordIndex, pbBufferLength, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbEmergencyInformationDescriptor_Value = Guid.initString("ba6fa681-b973-4da1-9207-ac3e7f0341eb");
pub const IID_IIsdbEmergencyInformationDescriptor = &IID_IIsdbEmergencyInformationDescriptor_Value;
pub const IIsdbEmergencyInformationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartEndFlag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAreaCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                ppwVal: ?*?*u16,
                pbNumAreaCodes: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbEmergencyInformationDescriptor,
                bRecordIndex: u8,
                ppwVal: ?*?*u16,
                pbNumAreaCodes: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetCountOfRecords(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetServiceId(self: *const T, bRecordIndex: u8, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetServiceId(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), bRecordIndex, pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetStartEndFlag(self: *const T, bRecordIndex: u8, pVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetStartEndFlag(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), bRecordIndex, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetSignalLevel(self: *const T, bRecordIndex: u8, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetSignalLevel(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), bRecordIndex, pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbEmergencyInformationDescriptor_GetAreaCode(self: *const T, bRecordIndex: u8, ppwVal: ?*?*u16, pbNumAreaCodes: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbEmergencyInformationDescriptor.VTable, @ptrCast(self.vtable)).GetAreaCode(@as(*const IIsdbEmergencyInformationDescriptor, @ptrCast(self)), bRecordIndex, ppwVal, pbNumAreaCodes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCADescriptor_Value = Guid.initString("0570aa47-52bc-42ae-8ca5-969f41e81aea");
pub const IID_IIsdbCADescriptor = &IID_IIsdbCADescriptor_Value;
pub const IIsdbCADescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCASystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReservedBits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCAPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrivateDataBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCADescriptor,
                pbBufferLength: ?*u8,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCADescriptor,
                pbBufferLength: ?*u8,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCADescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCADescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCADescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetReservedBits(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetReservedBits(@as(*const IIsdbCADescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetCAPID(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetCAPID(@as(*const IIsdbCADescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCADescriptor_GetPrivateDataBytes(self: *const T, pbBufferLength: ?*u8, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCADescriptor.VTable, @ptrCast(self.vtable)).GetPrivateDataBytes(@as(*const IIsdbCADescriptor, @ptrCast(self)), pbBufferLength, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbCAServiceDescriptor_Value = Guid.initString("39cbeb97-ff0b-42a7-9ab9-7b9cfe70a77a");
pub const IID_IIsdbCAServiceDescriptor = &IID_IIsdbCAServiceDescriptor_Value;
pub const IIsdbCAServiceDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCASystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCABroadcasterGroupId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMessageControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbCAServiceDescriptor,
                pbNumServiceIds: ?*u8,
                pwServiceIds: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbCAServiceDescriptor,
                pbNumServiceIds: ?*u8,
                pwServiceIds: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetCASystemId(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCASystemId(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetCABroadcasterGroupId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetCABroadcasterGroupId(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetMessageControl(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetMessageControl(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbCAServiceDescriptor_GetServiceIds(self: *const T, pbNumServiceIds: ?*u8, pwServiceIds: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbCAServiceDescriptor.VTable, @ptrCast(self.vtable)).GetServiceIds(@as(*const IIsdbCAServiceDescriptor, @ptrCast(self)), pbNumServiceIds, pwServiceIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IIsdbHierarchicalTransmissionDescriptor_Value = Guid.initString("b7b3ae90-ee0b-446d-8769-f7e2aa266aa6");
pub const IID_IIsdbHierarchicalTransmissionDescriptor = &IID_IIsdbHierarchicalTransmissionDescriptor_Value;
pub const IIsdbHierarchicalTransmissionDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFutureUse1: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQualityLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFutureUse2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferencePid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIsdbHierarchicalTransmissionDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetLength(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetFutureUse1(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetFutureUse1(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetQualityLevel(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetQualityLevel(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetFutureUse2(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetFutureUse2(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsdbHierarchicalTransmissionDescriptor_GetReferencePid(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IIsdbHierarchicalTransmissionDescriptor.VTable, @ptrCast(self.vtable)).GetReferencePid(@as(*const IIsdbHierarchicalTransmissionDescriptor, @ptrCast(self)), pwVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDASiParser_Value = Guid.initString("9de49a74-aba2-4a18-93e1-21f17f95c3c3");
pub const IID_IPBDASiParser = &IID_IPBDASiParser_Value;
pub const IPBDASiParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDASiParser,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDASiParser,
                punk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDASiParser,
                dwSize: u32,
                pBuffer: ?*u8,
                ppEIT: ?*?*IPBDA_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDASiParser,
                dwSize: u32,
                pBuffer: ?*u8,
                ppEIT: ?*?*IPBDA_EIT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDASiParser,
                dwSize: u32,
                pBuffer: ?*const u8,
                ppServices: ?*?*IPBDA_Services,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDASiParser,
                dwSize: u32,
                pBuffer: ?*const u8,
                ppServices: ?*?*IPBDA_Services,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_Initialize(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDASiParser, @ptrCast(self)), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_GetEIT(self: *const T, dwSize: u32, pBuffer: ?*u8, ppEIT: ?*?*IPBDA_EIT) callconv(.Inline) HRESULT {
            return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).GetEIT(@as(*const IPBDASiParser, @ptrCast(self)), dwSize, pBuffer, ppEIT);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDASiParser_GetServices(self: *const T, dwSize: u32, pBuffer: ?*const u8, ppServices: ?*?*IPBDA_Services) callconv(.Inline) HRESULT {
            return @as(*const IPBDASiParser.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IPBDASiParser, @ptrCast(self)), dwSize, pBuffer, ppServices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_EIT_Value = Guid.initString("a35f2dea-098f-4ebd-984c-2bd4c3c8ce0a");
pub const IID_IPBDA_EIT = &IID_IPBDA_EIT_Value;
pub const IPBDA_EIT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                size: u32,
                pBuffer: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                size: u32,
                pBuffer: [*:0]const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceIdx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                plwVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                plwVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordEventId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                plwVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                plwVal: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pmdtVal: ?*MPEG_DATE_AND_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pmdVal: ?*MPEG_TIME,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordCountOfDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                dwIndex: u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordDescriptorByTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_EIT,
                dwRecordIndex: u32,
                bTag: u8,
                pdwCookie: ?*u32,
                ppDescriptor: ?*?*IGenericDescriptor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_Initialize(self: *const T, size: u32, pBuffer: [*:0]const u8) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDA_EIT, @ptrCast(self)), size, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetTableId(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetTableId(@as(*const IPBDA_EIT, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetVersionNumber(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetVersionNumber(@as(*const IPBDA_EIT, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetServiceIdx(self: *const T, plwVal: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetServiceIdx(@as(*const IPBDA_EIT, @ptrCast(self)), plwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPBDA_EIT, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordEventId(self: *const T, dwRecordIndex: u32, plwVal: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordEventId(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, plwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordStartTime(self: *const T, dwRecordIndex: u32, pmdtVal: ?*MPEG_DATE_AND_TIME) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordStartTime(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, pmdtVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDuration(self: *const T, dwRecordIndex: u32, pmdVal: ?*MPEG_TIME) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDuration(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, pmdVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordCountOfDescriptors(self: *const T, dwRecordIndex: u32, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordCountOfDescriptors(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDescriptorByIndex(self: *const T, dwRecordIndex: u32, dwIndex: u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByIndex(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, dwIndex, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_EIT_GetRecordDescriptorByTag(self: *const T, dwRecordIndex: u32, bTag: u8, pdwCookie: ?*u32, ppDescriptor: ?*?*IGenericDescriptor) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_EIT.VTable, @ptrCast(self.vtable)).GetRecordDescriptorByTag(@as(*const IPBDA_EIT, @ptrCast(self)), dwRecordIndex, bTag, pdwCookie, ppDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDA_Services_Value = Guid.initString("944eab37-eed4-4850-afd2-77e7efeb4427");
pub const IID_IPBDA_Services = &IID_IPBDA_Services_Value;
pub const IPBDA_Services = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_Services,
                size: u32,
                pBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_Services,
                size: u32,
                pBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCountOfRecords: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_Services,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_Services,
                pdwVal: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRecordByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDA_Services,
                dwRecordIndex: u32,
                pul64ServiceIdx: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDA_Services,
                dwRecordIndex: u32,
                pul64ServiceIdx: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_Initialize(self: *const T, size: u32, pBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IPBDA_Services, @ptrCast(self)), size, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_GetCountOfRecords(self: *const T, pdwVal: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).GetCountOfRecords(@as(*const IPBDA_Services, @ptrCast(self)), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDA_Services_GetRecordByIndex(self: *const T, dwRecordIndex: u32, pul64ServiceIdx: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IPBDA_Services.VTable, @ptrCast(self.vtable)).GetRecordByIndex(@as(*const IPBDA_Services, @ptrCast(self)), dwRecordIndex, pul64ServiceIdx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAEntitlementDescriptor_Value = Guid.initString("22632497-0de3-4587-aadc-d8d99017e760");
pub const IID_IPBDAEntitlementDescriptor = &IID_IPBDAEntitlementDescriptor_Value;
pub const IPBDAEntitlementDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAEntitlementDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAEntitlementDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAEntitlementDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAEntitlementDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAEntitlementDescriptor,
                ppbTokenBuffer: ?*?*u8,
                pdwTokenLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAEntitlementDescriptor,
                ppbTokenBuffer: ?*?*u8,
                pdwTokenLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAEntitlementDescriptor_GetToken(self: *const T, ppbTokenBuffer: ?*?*u8, pdwTokenLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPBDAEntitlementDescriptor.VTable, @ptrCast(self.vtable)).GetToken(@as(*const IPBDAEntitlementDescriptor, @ptrCast(self)), ppbTokenBuffer, pdwTokenLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IPBDAAttributesDescriptor_Value = Guid.initString("313b3620-3263-45a6-9533-968befbeac03");
pub const IID_IPBDAAttributesDescriptor = &IID_IPBDAAttributesDescriptor_Value;
pub const IPBDAAttributesDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTag: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAAttributesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAAttributesDescriptor,
                pbVal: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAAttributesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAAttributesDescriptor,
                pwVal: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAttributePayload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPBDAAttributesDescriptor,
                ppbAttributeBuffer: ?*?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPBDAAttributesDescriptor,
                ppbAttributeBuffer: ?*?*u8,
                pdwAttributeLength: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetTag(self: *const T, pbVal: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetTag(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), pbVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetLength(self: *const T, pwVal: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetLength(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), pwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPBDAAttributesDescriptor_GetAttributePayload(self: *const T, ppbAttributeBuffer: ?*?*u8, pdwAttributeLength: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPBDAAttributesDescriptor.VTable, @ptrCast(self.vtable)).GetAttributePayload(@as(*const IPBDAAttributesDescriptor, @ptrCast(self)), ppbAttributeBuffer, pdwAttributeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TIF_REGISTRATION_Value = Guid.initString("dfef4a68-ee61-415f-9ccb-cd95f2f98a3a");
pub const IID_IBDA_TIF_REGISTRATION = &IID_IBDA_TIF_REGISTRATION_Value;
pub const IBDA_TIF_REGISTRATION = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIFEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_TIF_REGISTRATION,
                pTIFInputPin: ?*IPin,
                ppvRegistrationContext: ?*u32,
                ppMpeg2DataControl: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_TIF_REGISTRATION,
                pTIFInputPin: ?*IPin,
                ppvRegistrationContext: ?*u32,
                ppMpeg2DataControl: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterTIF: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_TIF_REGISTRATION,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_TIF_REGISTRATION,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TIF_REGISTRATION_RegisterTIFEx(self: *const T, pTIFInputPin: ?*IPin, ppvRegistrationContext: ?*u32, ppMpeg2DataControl: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IBDA_TIF_REGISTRATION.VTable, @ptrCast(self.vtable)).RegisterTIFEx(@as(*const IBDA_TIF_REGISTRATION, @ptrCast(self)), pTIFInputPin, ppvRegistrationContext, ppMpeg2DataControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TIF_REGISTRATION_UnregisterTIF(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_TIF_REGISTRATION.VTable, @ptrCast(self.vtable)).UnregisterTIF(@as(*const IBDA_TIF_REGISTRATION, @ptrCast(self)), pvRegistrationContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMPEG2_TIF_CONTROL_Value = Guid.initString("f9bac2f9-4149-4916-b2ef-faa202326862");
pub const IID_IMPEG2_TIF_CONTROL = &IID_IMPEG2_TIF_CONTROL_Value;
pub const IMPEG2_TIF_CONTROL = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterTIF: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                pUnkTIF: ?*IUnknown,
                ppvRegistrationContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                pUnkTIF: ?*IUnknown,
                ppvRegistrationContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterTIF: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                ulcPIDs: u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                ulcPIDs: u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                ulcPIDs: u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                ulcPIDs: u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPIDCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                pulcPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                pulcPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2_TIF_CONTROL,
                pulcPIDs: ?*u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2_TIF_CONTROL,
                pulcPIDs: ?*u32,
                pulPIDs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_RegisterTIF(self: *const T, pUnkTIF: ?*IUnknown, ppvRegistrationContext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).RegisterTIF(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pUnkTIF, ppvRegistrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_UnregisterTIF(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).UnregisterTIF(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pvRegistrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_AddPIDs(self: *const T, ulcPIDs: u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).AddPIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), ulcPIDs, pulPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_DeletePIDs(self: *const T, ulcPIDs: u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).DeletePIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), ulcPIDs, pulPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_GetPIDCount(self: *const T, pulcPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).GetPIDCount(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pulcPIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2_TIF_CONTROL_GetPIDs(self: *const T, pulcPIDs: ?*u32, pulPIDs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2_TIF_CONTROL.VTable, @ptrCast(self.vtable)).GetPIDs(@as(*const IMPEG2_TIF_CONTROL, @ptrCast(self)), pulcPIDs, pulPIDs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfo_Value = Guid.initString("a3b152df-7a90-4218-ac54-9830bee8c0b6");
pub const IID_ITuneRequestInfo = &IID_ITuneRequestInfo_Value;
pub const ITuneRequestInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocatorData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                Request: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                Request: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetComponentData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateComponentList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreviousLocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfo,
                CurrentRequest: ?*ITuneRequest,
                TuneRequest: ?*?*ITuneRequest,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetLocatorData(self: *const T, Request: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetLocatorData(@as(*const ITuneRequestInfo, @ptrCast(self)), Request);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetComponentData(self: *const T, CurrentRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetComponentData(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_CreateComponentList(self: *const T, CurrentRequest: ?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).CreateComponentList(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetNextProgram(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetNextProgram(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetPreviousProgram(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetPreviousProgram(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetNextLocator(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetNextLocator(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest, TuneRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfo_GetPreviousLocator(self: *const T, CurrentRequest: ?*ITuneRequest, TuneRequest: ?*?*ITuneRequest) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfo.VTable, @ptrCast(self.vtable)).GetPreviousLocator(@as(*const ITuneRequestInfo, @ptrCast(self)), CurrentRequest, TuneRequest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITuneRequestInfoEx_Value = Guid.initString("ee957c52-b0d0-4e78-8dd1-b87a08bfd893");
pub const IID_ITuneRequestInfoEx = &IID_ITuneRequestInfoEx_Value;
pub const ITuneRequestInfoEx = extern struct {
    pub const VTable = extern struct {
        base: ITuneRequestInfo.VTable,
        CreateComponentListEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITuneRequestInfoEx,
                CurrentRequest: ?*ITuneRequest,
                ppCurPMT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITuneRequestInfoEx,
                CurrentRequest: ?*ITuneRequest,
                ppCurPMT: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITuneRequestInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITuneRequestInfoEx_CreateComponentListEx(self: *const T, CurrentRequest: ?*ITuneRequest, ppCurPMT: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ITuneRequestInfoEx.VTable, @ptrCast(self.vtable)).CreateComponentListEx(@as(*const ITuneRequestInfoEx, @ptrCast(self)), CurrentRequest, ppCurPMT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPGEvent_Value = Guid.initString("7e47913a-5a89-423d-9a2b-e15168858934");
pub const IID_ISIInbandEPGEvent = &IID_ISIInbandEPGEvent_Value;
pub const ISIInbandEPGEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SIObjectEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISIInbandEPGEvent,
                pIDVB_EIT: ?*IDVB_EIT2,
                dwTable_ID: u32,
                dwService_ID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISIInbandEPGEvent,
                pIDVB_EIT: ?*IDVB_EIT2,
                dwTable_ID: u32,
                dwService_ID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPGEvent_SIObjectEvent(self: *const T, pIDVB_EIT: ?*IDVB_EIT2, dwTable_ID: u32, dwService_ID: u32) callconv(.Inline) HRESULT {
            return @as(*const ISIInbandEPGEvent.VTable, @ptrCast(self.vtable)).SIObjectEvent(@as(*const ISIInbandEPGEvent, @ptrCast(self)), pIDVB_EIT, dwTable_ID, dwService_ID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISIInbandEPG_Value = Guid.initString("f90ad9d0-b854-4b68-9cc1-b2cc96119d85");
pub const IID_ISIInbandEPG = &IID_ISIInbandEPG_Value;
pub const ISIInbandEPG = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartSIEPGScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISIInbandEPG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISIInbandEPG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopSIEPGScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISIInbandEPG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISIInbandEPG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSIEPGScanRunning: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISIInbandEPG,
                bRunning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISIInbandEPG,
                bRunning: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_StartSIEPGScan(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).StartSIEPGScan(@as(*const ISIInbandEPG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_StopSIEPGScan(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).StopSIEPGScan(@as(*const ISIInbandEPG, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISIInbandEPG_IsSIEPGScanRunning(self: *const T, bRunning: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ISIInbandEPG.VTable, @ptrCast(self.vtable)).IsSIEPGScanRunning(@as(*const ISIInbandEPG, @ptrCast(self)), bRunning);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataEvent_Value = Guid.initString("efda0c80-f395-42c3-9b3c-56b37dec7bb7");
pub const IID_IGuideDataEvent = &IID_IGuideDataEvent_Value;
pub const IGuideDataEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GuideDataAcquired: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgramChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varProgramDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varProgramDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varServiceDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varServiceDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScheduleEntryChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varScheduleEntryDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varScheduleEntryDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProgramDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varProgramDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varProgramDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ServiceDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varServiceDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varServiceDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ScheduleDeleted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataEvent,
                varScheduleEntryDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataEvent,
                varScheduleEntryDescriptionID: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_GuideDataAcquired(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).GuideDataAcquired(@as(*const IGuideDataEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ProgramChanged(self: *const T, varProgramDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ProgramChanged(@as(*const IGuideDataEvent, @ptrCast(self)), varProgramDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ServiceChanged(self: *const T, varServiceDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ServiceChanged(@as(*const IGuideDataEvent, @ptrCast(self)), varServiceDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ScheduleEntryChanged(self: *const T, varScheduleEntryDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ScheduleEntryChanged(@as(*const IGuideDataEvent, @ptrCast(self)), varScheduleEntryDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ProgramDeleted(self: *const T, varProgramDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ProgramDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), varProgramDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ServiceDeleted(self: *const T, varServiceDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ServiceDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), varServiceDescriptionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataEvent_ScheduleDeleted(self: *const T, varScheduleEntryDescriptionID: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataEvent.VTable, @ptrCast(self.vtable)).ScheduleDeleted(@as(*const IGuideDataEvent, @ptrCast(self)), varScheduleEntryDescriptionID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataProperty_Value = Guid.initString("88ec5e58-bb73-41d6-99ce-66c524b8b591");
pub const IID_IGuideDataProperty = &IID_IGuideDataProperty_Value;
pub const IGuideDataProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGuideDataProperty,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGuideDataProperty,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGuideDataProperty,
                idLang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGuideDataProperty,
                idLang: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Value: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IGuideDataProperty,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IGuideDataProperty,
                pvar: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Name(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IGuideDataProperty, @ptrCast(self)), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Language(self: *const T, idLang: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Language(@as(*const IGuideDataProperty, @ptrCast(self)), idLang);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataProperty_get_Value(self: *const T, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataProperty.VTable, @ptrCast(self.vtable)).get_Value(@as(*const IGuideDataProperty, @ptrCast(self)), pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumGuideDataProperties_Value = Guid.initString("ae44423b-4571-475c-ad2c-f40a771d80ef");
pub const IID_IEnumGuideDataProperties = &IID_IEnumGuideDataProperties_Value;
pub const IEnumGuideDataProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumGuideDataProperties,
                celt: u32,
                ppprop: ?*?*IGuideDataProperty,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumGuideDataProperties,
                celt: u32,
                ppprop: ?*?*IGuideDataProperty,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumGuideDataProperties,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumGuideDataProperties,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumGuideDataProperties,
                ppenum: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumGuideDataProperties,
                ppenum: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Next(self: *const T, celt: u32, ppprop: ?*?*IGuideDataProperty, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumGuideDataProperties, @ptrCast(self)), celt, ppprop, pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumGuideDataProperties, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumGuideDataProperties, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumGuideDataProperties_Clone(self: *const T, ppenum: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @as(*const IEnumGuideDataProperties.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumGuideDataProperties, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumTuneRequests_Value = Guid.initString("1993299c-ced6-4788-87a3-420067dce0c7");
pub const IID_IEnumTuneRequests = &IID_IEnumTuneRequests_Value;
pub const IEnumTuneRequests = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuneRequests,
                celt: u32,
                ppprop: ?*?*ITuneRequest,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuneRequests,
                celt: u32,
                ppprop: ?*?*ITuneRequest,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuneRequests,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuneRequests,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumTuneRequests,
                ppenum: ?*?*IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumTuneRequests,
                ppenum: ?*?*IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Next(self: *const T, celt: u32, ppprop: ?*?*ITuneRequest, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumTuneRequests, @ptrCast(self)), celt, ppprop, pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumTuneRequests, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumTuneRequests, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumTuneRequests_Clone(self: *const T, ppenum: ?*?*IEnumTuneRequests) callconv(.Inline) HRESULT {
            return @as(*const IEnumTuneRequests.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumTuneRequests, @ptrCast(self)), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideData_Value = Guid.initString("61571138-5b01-43cd-aeaf-60b784a0bf93");
pub const IID_IGuideData = &IID_IGuideData_Value;
pub const IGuideData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                ppEnumTuneRequests: ?*?*IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                ppEnumTuneRequests: ?*?*IEnumTuneRequests,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                pTuneRequest: ?*ITuneRequest,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                pTuneRequest: ?*ITuneRequest,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideProgramIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                pEnumPrograms: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                pEnumPrograms: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProgramProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                varProgramDescriptionID: VARIANT,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                varProgramDescriptionID: VARIANT,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScheduleEntryIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                pEnumScheduleEntries: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                pEnumScheduleEntries: ?*?*IEnumVARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScheduleEntryProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideData,
                varScheduleEntryDescriptionID: VARIANT,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideData,
                varScheduleEntryDescriptionID: VARIANT,
                ppEnumProperties: ?*?*IEnumGuideDataProperties,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetServices(self: *const T, ppEnumTuneRequests: ?*?*IEnumTuneRequests) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IGuideData, @ptrCast(self)), ppEnumTuneRequests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetServiceProperties(self: *const T, pTuneRequest: ?*ITuneRequest, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetServiceProperties(@as(*const IGuideData, @ptrCast(self)), pTuneRequest, ppEnumProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetGuideProgramIDs(self: *const T, pEnumPrograms: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetGuideProgramIDs(@as(*const IGuideData, @ptrCast(self)), pEnumPrograms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetProgramProperties(self: *const T, varProgramDescriptionID: VARIANT, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetProgramProperties(@as(*const IGuideData, @ptrCast(self)), varProgramDescriptionID, ppEnumProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetScheduleEntryIDs(self: *const T, pEnumScheduleEntries: ?*?*IEnumVARIANT) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetScheduleEntryIDs(@as(*const IGuideData, @ptrCast(self)), pEnumScheduleEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideData_GetScheduleEntryProperties(self: *const T, varScheduleEntryDescriptionID: VARIANT, ppEnumProperties: ?*?*IEnumGuideDataProperties) callconv(.Inline) HRESULT {
            return @as(*const IGuideData.VTable, @ptrCast(self.vtable)).GetScheduleEntryProperties(@as(*const IGuideData, @ptrCast(self)), varScheduleEntryDescriptionID, ppEnumProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGuideDataLoader_Value = Guid.initString("4764ff7c-fa95-4525-af4d-d32236db9e38");
pub const IID_IGuideDataLoader = &IID_IGuideDataLoader_Value;
pub const IGuideDataLoader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataLoader,
                pGuideStore: ?*IGuideData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataLoader,
                pGuideStore: ?*IGuideData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Terminate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGuideDataLoader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGuideDataLoader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataLoader_Init(self: *const T, pGuideStore: ?*IGuideData) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataLoader.VTable, @ptrCast(self.vtable)).Init(@as(*const IGuideDataLoader, @ptrCast(self)), pGuideStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGuideDataLoader_Terminate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGuideDataLoader.VTable, @ptrCast(self.vtable)).Terminate(@as(*const IGuideDataLoader, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_TIFLoad_Value = Guid.initString("14eb8748-1753-4393-95ae-4f7e7a87aad6");
pub const CLSID_TIFLoad = &CLSID_TIFLoad_Value;

pub const KSP_BDA_NODE_PIN = extern struct {
    Property: KSIDENTIFIER,
    ulNodeType: u32,
    ulInputPinId: u32,
    ulOutputPinId: u32,
};

pub const KSM_BDA_PIN = extern struct {
    Method: KSIDENTIFIER,
    Anonymous: extern union {
        PinId: u32,
        PinType: u32,
    },
    Reserved: u32,
};

pub const KSM_BDA_PIN_PAIR = extern struct {
    Method: KSIDENTIFIER,
    Anonymous1: extern union {
        InputPinId: u32,
        InputPinType: u32,
    },
    Anonymous2: extern union {
        OutputPinId: u32,
        OutputPinType: u32,
    },
};

pub const KSP_NODE_ESPID = extern struct {
    Property: KSP_NODE,
    EsPid: u32,
};

pub const KSM_BDA_DEBUG_LEVEL = extern struct {
    Method: KSIDENTIFIER,
    ucDebugLevel: u8,
    ulDebugStringSize: u32,
    argbDebugString: [1]u8,
};

pub const BDA_DEBUG_DATA = extern struct {
    lResult: i32,
    uuidDebugDataType: Guid,
    ulDataSize: u32,
    argbDebugData: [1]u8,
};

pub const BDA_EVENT_DATA = extern struct {
    lResult: i32,
    ulEventID: u32,
    uuidEventType: Guid,
    ulEventDataLength: u32,
    argbEventData: [1]u8,
};

pub const KSM_BDA_EVENT_COMPLETE = extern struct {
    Method: KSIDENTIFIER,
    ulEventID: u32,
    ulEventResult: u32,
};

pub const KSM_BDA_DRM_SETDRM = extern struct {
    NodeMethod: KSM_NODE,
    NewDRMuuid: Guid,
};

pub const KSM_BDA_BUFFER = extern struct {
    NodeMethod: KSM_NODE,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const KSM_BDA_WMDRM_LICENSE = extern struct {
    NodeMethod: KSM_NODE,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRM_RENEWLICENSE = extern struct {
    NodeMethod: KSM_NODE,
    ulXMRLicenseLength: u32,
    ulEntitlementTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulPurchaseTokenLength: u32,
    argbDataBuffer: [1]u8,
};

pub const KSM_BDA_WMDRMTUNER_SETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
    uuidKeyID: Guid,
};

pub const KSM_BDA_WMDRMTUNER_GETPIDPROTECTION = extern struct {
    NodeMethod: KSM_NODE,
    ulPID: u32,
};

pub const KSM_BDA_WMDRMTUNER_SYNCVALUE = extern struct {
    NodeMethod: KSM_NODE,
    ulSyncValue: u32,
};

pub const KSM_BDA_TUNER_TUNEREQUEST = extern struct {
    Method: KSIDENTIFIER,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const KSM_BDA_GPNV_GETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulNameLength: u32,
    cLanguage: [12]CHAR,
    argbData: [1]u8,
};

pub const KSM_BDA_GPNV_SETVALUE = extern struct {
    Method: KSIDENTIFIER,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulNameLength: u32,
    ulValueLength: u32,
    argbName: [1]u8,
};

pub const KSM_BDA_GPNV_NAMEINDEX = extern struct {
    Method: KSIDENTIFIER,
    ulValueNameIndex: u32,
};

pub const KSM_BDA_SCAN_CAPABILTIES = extern struct {
    Method: KSIDENTIFIER,
    uuidBroadcastStandard: Guid,
};

pub const KSM_BDA_SCAN_FILTER = extern struct {
    Method: KSIDENTIFIER,
    ulScanModulationTypeSize: u32,
    AnalogVideoStandards: u64,
    argbScanModulationTypes: [1]u8,
};

pub const KSM_BDA_SCAN_START = extern struct {
    Method: KSIDENTIFIER,
    LowerFrequency: u32,
    HigherFrequency: u32,
};

pub const KSM_BDA_GDDS_TUNEXMLFROMIDX = extern struct {
    Method: KSIDENTIFIER,
    ulIdx: u64,
};

pub const KSM_BDA_GDDS_SERVICEFROMTUNEXML = extern struct {
    Method: KSIDENTIFIER,
    ulTuneXmlLength: u32,
    argbTuneXml: [1]u8,
};

pub const KSM_BDA_USERACTIVITY_USEREASON = extern struct {
    Method: KSIDENTIFIER,
    ulUseReason: u32,
};

pub const KSM_BDA_CAS_ENTITLEMENTTOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulRequestType: u32,
    ulEntitlementTokenLen: u32,
    argbEntitlementToken: [1]u8,
};

pub const KSM_BDA_CAS_CAPTURETOKEN = extern struct {
    NodeMethod: KSM_NODE,
    ulTokenLength: u32,
    argbToken: [1]u8,
};

pub const KSM_BDA_CAS_OPENBROADCASTMMI = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulEventId: u32,
};

pub const KSM_BDA_CAS_CLOSEMMIDIALOG = extern struct {
    NodeMethod: KSM_NODE,
    ulDialogRequest: u32,
    cLanguage: [12]CHAR,
    ulDialogNumber: u32,
    ulReason: u32,
};

pub const KSM_BDA_ISDBCAS_REQUEST = extern struct {
    NodeMethod: KSM_NODE,
    ulRequestID: u32,
    ulIsdbCommandSize: u32,
    argbIsdbCommandData: [1]u8,
};

pub const KSM_BDA_TS_SELECTOR_SETTSID = extern struct {
    NodeMethod: KSM_NODE,
    usTSID: u16,
};

pub const KS_DATARANGE_BDA_ANTENNA = extern struct {
    DataRange: KSDATAFORMAT,
};

pub const BDA_TRANSPORT_INFO = extern struct {
    ulcbPhyiscalPacket: u32,
    ulcbPhyiscalFrame: u32,
    ulcbPhyiscalFrameAlignment: u32,
    AvgTimePerFrame: i64,
};

pub const KS_DATARANGE_BDA_TRANSPORT = extern struct {
    DataRange: KSDATAFORMAT,
    BdaTransportInfo: BDA_TRANSPORT_INFO,
};

const CLSID_EVENTID_TuningChanging_Value = Guid.initString("83183c03-c09e-45c4-a719-807a94952bf9");
pub const CLSID_EVENTID_TuningChanging = &CLSID_EVENTID_TuningChanging_Value;

const CLSID_EVENTID_TuningChanged_Value = Guid.initString("9d7e6235-4b7d-425d-a6d1-d717c33b9c4c");
pub const CLSID_EVENTID_TuningChanged = &CLSID_EVENTID_TuningChanged_Value;

const CLSID_EVENTID_CandidatePostTuneData_Value = Guid.initString("9f02d3d0-9f06-4369-9f1e-3ad6ca19807e");
pub const CLSID_EVENTID_CandidatePostTuneData = &CLSID_EVENTID_CandidatePostTuneData_Value;

const CLSID_EVENTID_CADenialCountChanged_Value = Guid.initString("2a65c528-2249-4070-ac16-00390cdfb2dd");
pub const CLSID_EVENTID_CADenialCountChanged = &CLSID_EVENTID_CADenialCountChanged_Value;

const CLSID_EVENTID_SignalStatusChanged_Value = Guid.initString("6d9cfaf2-702d-4b01-8dff-6892ad20d191");
pub const CLSID_EVENTID_SignalStatusChanged = &CLSID_EVENTID_SignalStatusChanged_Value;

const CLSID_EVENTID_NewSignalAcquired_Value = Guid.initString("c87ec52d-cd18-404a-a076-c02a273d3de7");
pub const CLSID_EVENTID_NewSignalAcquired = &CLSID_EVENTID_NewSignalAcquired_Value;

const CLSID_EVENTID_EASMessageReceived_Value = Guid.initString("d10df9d5-c261-4b85-9e8a-517b3299cab2");
pub const CLSID_EVENTID_EASMessageReceived = &CLSID_EVENTID_EASMessageReceived_Value;

const CLSID_EVENTID_PSITable_Value = Guid.initString("1b9c3703-d447-4e16-97bb-01799fc031ed");
pub const CLSID_EVENTID_PSITable = &CLSID_EVENTID_PSITable_Value;

const CLSID_EVENTID_ServiceTerminated_Value = Guid.initString("0a1d591c-e0d2-4f8e-8960-2335bef45ccb");
pub const CLSID_EVENTID_ServiceTerminated = &CLSID_EVENTID_ServiceTerminated_Value;

const CLSID_EVENTID_CardStatusChanged_Value = Guid.initString("a265faea-f874-4b38-9ff7-c53d02969996");
pub const CLSID_EVENTID_CardStatusChanged = &CLSID_EVENTID_CardStatusChanged_Value;

const CLSID_EVENTID_DRMParingStatusChanged_Value = Guid.initString("000906f5-f0d1-41d6-a7df-4028697669f6");
pub const CLSID_EVENTID_DRMParingStatusChanged = &CLSID_EVENTID_DRMParingStatusChanged_Value;

const CLSID_EVENTID_DRMParingStepComplete_Value = Guid.initString("5b2ebf78-b752-4420-b41e-a472dc95828e");
pub const CLSID_EVENTID_DRMParingStepComplete = &CLSID_EVENTID_DRMParingStepComplete_Value;

const CLSID_EVENTID_MMIMessage_Value = Guid.initString("052c29af-09a4-4b93-890f-bd6a348968a4");
pub const CLSID_EVENTID_MMIMessage = &CLSID_EVENTID_MMIMessage_Value;

const CLSID_EVENTID_EntitlementChanged_Value = Guid.initString("9071ad5d-2359-4c95-8694-afa81d70bfd5");
pub const CLSID_EVENTID_EntitlementChanged = &CLSID_EVENTID_EntitlementChanged_Value;

const CLSID_EVENTID_STBChannelNumber_Value = Guid.initString("17c4d730-d0f0-413a-8c99-500469de35ad");
pub const CLSID_EVENTID_STBChannelNumber = &CLSID_EVENTID_STBChannelNumber_Value;

const CLSID_EVENTID_BDAEventingServicePendingEvent_Value = Guid.initString("5ca51711-5ddc-41a6-9430-e41b8b3bbc5b");
pub const CLSID_EVENTID_BDAEventingServicePendingEvent = &CLSID_EVENTID_BDAEventingServicePendingEvent_Value;

const CLSID_EVENTID_BDAConditionalAccessTAG_Value = Guid.initString("efc3a459-ae8b-4b4a-8fe9-79a0d097f3ea");
pub const CLSID_EVENTID_BDAConditionalAccessTAG = &CLSID_EVENTID_BDAConditionalAccessTAG_Value;

const CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value = Guid.initString("b2127d42-7be5-4f4b-9130-6679899f4f4b");
pub const CLSID_EVENTTYPE_CASDescrambleFailureEvent = &CLSID_EVENTTYPE_CASDescrambleFailureEvent_Value;

const CLSID_EVENTID_CASFailureSpanningEvent_Value = Guid.initString("ead831ae-5529-4d1f-afce-0d8cd1257d30");
pub const CLSID_EVENTID_CASFailureSpanningEvent = &CLSID_EVENTID_CASFailureSpanningEvent_Value;

pub const ChannelChangeSpanningEvent_State = enum(i32) {
    Start = 0,
    End = 2,
};
pub const ChannelChangeSpanningEvent_Start = ChannelChangeSpanningEvent_State.Start;
pub const ChannelChangeSpanningEvent_End = ChannelChangeSpanningEvent_State.End;

const CLSID_EVENTID_ChannelChangeSpanningEvent_Value = Guid.initString("9067c5e5-4c5c-4205-86c8-7afe20fe1efa");
pub const CLSID_EVENTID_ChannelChangeSpanningEvent = &CLSID_EVENTID_ChannelChangeSpanningEvent_Value;

pub const ChannelChangeInfo = extern struct {
    state: ChannelChangeSpanningEvent_State,
    TimeStamp: u64,
};

const CLSID_EVENTID_ChannelTypeSpanningEvent_Value = Guid.initString("72ab1d51-87d2-489b-ba11-0e08dc210243");
pub const CLSID_EVENTID_ChannelTypeSpanningEvent = &CLSID_EVENTID_ChannelTypeSpanningEvent_Value;

pub const ChannelType = enum(i32) {
    None = 0,
    Other = 1,
    Video = 2,
    Audio = 4,
    Text = 8,
    Subtitles = 16,
    Captions = 32,
    Superimpose = 64,
    Data = 128,
};
pub const ChannelTypeNone = ChannelType.None;
pub const ChannelTypeOther = ChannelType.Other;
pub const ChannelTypeVideo = ChannelType.Video;
pub const ChannelTypeAudio = ChannelType.Audio;
pub const ChannelTypeText = ChannelType.Text;
pub const ChannelTypeSubtitles = ChannelType.Subtitles;
pub const ChannelTypeCaptions = ChannelType.Captions;
pub const ChannelTypeSuperimpose = ChannelType.Superimpose;
pub const ChannelTypeData = ChannelType.Data;

pub const ChannelTypeInfo = extern struct {
    channelType: ChannelType,
    timeStamp: u64,
};

pub const ChannelInfo = extern struct {
    lFrequency: i32,
    Anonymous: extern union {
        DVB: extern struct {
            lONID: i32,
            lTSID: i32,
            lSID: i32,
        },
        DC: extern struct {
            lProgNumber: i32,
        },
        ATSC: extern struct {
            lProgNumber: i32,
        },
    },
};

const CLSID_EVENTID_ChannelInfoSpanningEvent_Value = Guid.initString("41f36d80-4132-4cc2-b121-01a43219d81b");
pub const CLSID_EVENTID_ChannelInfoSpanningEvent = &CLSID_EVENTID_ChannelInfoSpanningEvent_Value;

const CLSID_EVENTID_RRTSpanningEvent_Value = Guid.initString("f6cfc8f4-da93-4f2f-bff8-ba1ee6fca3a2");
pub const CLSID_EVENTID_RRTSpanningEvent = &CLSID_EVENTID_RRTSpanningEvent_Value;

pub const SpanningEventDescriptor = extern struct {
    wDataLen: u16,
    wProgNumber: u16,
    wSID: u16,
    bDescriptor: [1]u8,
};

const CLSID_EVENTID_CSDescriptorSpanningEvent_Value = Guid.initString("efe779d9-97f0-4786-800d-95cf505ddc66");
pub const CLSID_EVENTID_CSDescriptorSpanningEvent = &CLSID_EVENTID_CSDescriptorSpanningEvent_Value;

const CLSID_EVENTID_CtxADescriptorSpanningEvent_Value = Guid.initString("3ab4a2e6-4247-4b34-896c-30afa5d21c24");
pub const CLSID_EVENTID_CtxADescriptorSpanningEvent = &CLSID_EVENTID_CtxADescriptorSpanningEvent_Value;

pub const DVBScramblingControlSpanningEvent = extern struct {
    ulPID: u32,
    fScrambled: BOOL,
};

const CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value = Guid.initString("4bd4e1c4-90a1-4109-8236-27f00e7dcc5b");
pub const CLSID_EVENTID_DVBScramblingControlSpanningEvent = &CLSID_EVENTID_DVBScramblingControlSpanningEvent_Value;

pub const SignalAndServiceStatusSpanningEvent_State = enum(i32) {
    None = -1,
    Clear = 0,
    NoTVSignal = 1,
    ServiceOffAir = 2,
    WeakTVSignal = 3,
    NoSubscription = 4,
    AllAVScrambled = 5,
};
pub const SignalAndServiceStatusSpanningEvent_None = SignalAndServiceStatusSpanningEvent_State.None;
pub const SignalAndServiceStatusSpanningEvent_Clear = SignalAndServiceStatusSpanningEvent_State.Clear;
pub const SignalAndServiceStatusSpanningEvent_NoTVSignal = SignalAndServiceStatusSpanningEvent_State.NoTVSignal;
pub const SignalAndServiceStatusSpanningEvent_ServiceOffAir = SignalAndServiceStatusSpanningEvent_State.ServiceOffAir;
pub const SignalAndServiceStatusSpanningEvent_WeakTVSignal = SignalAndServiceStatusSpanningEvent_State.WeakTVSignal;
pub const SignalAndServiceStatusSpanningEvent_NoSubscription = SignalAndServiceStatusSpanningEvent_State.NoSubscription;
pub const SignalAndServiceStatusSpanningEvent_AllAVScrambled = SignalAndServiceStatusSpanningEvent_State.AllAVScrambled;

const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value = Guid.initString("8068c5cb-3c04-492b-b47d-0308820dce51");
pub const CLSID_EVENTID_SignalAndServiceStatusSpanningEvent = &CLSID_EVENTID_SignalAndServiceStatusSpanningEvent_Value;

pub const SpanningEventEmmMessage = extern struct {
    bCAbroadcasterGroupId: u8,
    bMessageControl: u8,
    wServiceId: u16,
    wTableIdExtension: u16,
    bDeletionStatus: u8,
    bDisplayingDuration1: u8,
    bDisplayingDuration2: u8,
    bDisplayingDuration3: u8,
    bDisplayingCycle: u8,
    bFormatVersion: u8,
    bDisplayPosition: u8,
    wMessageLength: u16,
    szMessageArea: [1]u16,
};

const CLSID_EVENTID_EmmMessageSpanningEvent_Value = Guid.initString("6bf00268-4f7e-4294-aa87-e9e953e43f14");
pub const CLSID_EVENTID_EmmMessageSpanningEvent = &CLSID_EVENTID_EmmMessageSpanningEvent_Value;

const CLSID_EVENTID_AudioTypeSpanningEvent_Value = Guid.initString("501cbfbe-b849-42ce-9be9-3db869fb82b3");
pub const CLSID_EVENTID_AudioTypeSpanningEvent = &CLSID_EVENTID_AudioTypeSpanningEvent_Value;

const CLSID_EVENTID_StreamTypeSpanningEvent_Value = Guid.initString("82af2ebc-30a6-4264-a80b-ad2e1372ac60");
pub const CLSID_EVENTID_StreamTypeSpanningEvent = &CLSID_EVENTID_StreamTypeSpanningEvent_Value;

const CLSID_EVENTID_ARIBcontentSpanningEvent_Value = Guid.initString("3a954083-93d0-463e-90b2-0742c496edf0");
pub const CLSID_EVENTID_ARIBcontentSpanningEvent = &CLSID_EVENTID_ARIBcontentSpanningEvent_Value;

const CLSID_EVENTID_LanguageSpanningEvent_Value = Guid.initString("e292666d-9c02-448d-aa8d-781a93fdc395");
pub const CLSID_EVENTID_LanguageSpanningEvent = &CLSID_EVENTID_LanguageSpanningEvent_Value;

pub const LanguageInfo = extern struct {
    LangID: u16,
    lISOLangCode: i32,
};

const CLSID_EVENTID_DualMonoSpanningEvent_Value = Guid.initString("a9a29b56-a84b-488c-89d5-0d4e7657c8ce");
pub const CLSID_EVENTID_DualMonoSpanningEvent = &CLSID_EVENTID_DualMonoSpanningEvent_Value;

pub const DualMonoInfo = extern struct {
    LangID1: u16,
    LangID2: u16,
    lISOLangCode1: i32,
    lISOLangCode2: i32,
};

const CLSID_EVENTID_PIDListSpanningEvent_Value = Guid.initString("47fc8f65-e2bb-4634-9cef-fdbfe6261d5c");
pub const CLSID_EVENTID_PIDListSpanningEvent = &CLSID_EVENTID_PIDListSpanningEvent_Value;

pub const PIDListSpanningEvent = extern struct {
    wPIDCount: u16,
    pulPIDs: [1]u32,
};

const CLSID_EVENTID_AudioDescriptorSpanningEvent_Value = Guid.initString("107bd41c-a6da-4691-8369-11b2cdaa288e");
pub const CLSID_EVENTID_AudioDescriptorSpanningEvent = &CLSID_EVENTID_AudioDescriptorSpanningEvent_Value;

const CLSID_EVENTID_SubtitleSpanningEvent_Value = Guid.initString("5dcec048-d0b9-4163-872c-4f32223be88a");
pub const CLSID_EVENTID_SubtitleSpanningEvent = &CLSID_EVENTID_SubtitleSpanningEvent_Value;

const CLSID_EVENTID_TeletextSpanningEvent_Value = Guid.initString("9599d950-5f33-4617-af7c-1e54b510daa3");
pub const CLSID_EVENTID_TeletextSpanningEvent = &CLSID_EVENTID_TeletextSpanningEvent_Value;

const CLSID_EVENTID_StreamIDSpanningEvent_Value = Guid.initString("caf1ab68-e153-4d41-a6b3-a7c998db75ee");
pub const CLSID_EVENTID_StreamIDSpanningEvent = &CLSID_EVENTID_StreamIDSpanningEvent_Value;

const CLSID_EVENTID_PBDAParentalControlEvent_Value = Guid.initString("f947aa85-fb52-48e8-b9c5-e1e1f411a51a");
pub const CLSID_EVENTID_PBDAParentalControlEvent = &CLSID_EVENTID_PBDAParentalControlEvent_Value;

pub const RATING_ATTRIBUTE = extern struct {
    rating_attribute_id: u32 align(1),
    rating_attribute_value: u32 align(1),
};

pub const RATING_SYSTEM = extern struct {
    rating_system_id: Guid align(1),
    _bitfield: u8 align(1),
    country_code: [3]u8 align(1),
    rating_attribute_count: u32 align(1),
    lpratingattrib: ?*RATING_ATTRIBUTE align(1),
};

pub const RATING_INFO = extern struct {
    rating_system_count: u32 align(1),
    lpratingsystem: ?*RATING_SYSTEM align(1),
};

pub const PBDAParentalControl = extern struct {
    rating_system_count: u32 align(1),
    rating_systems: ?*RATING_SYSTEM align(1),
};

const CLSID_EVENTID_TuneFailureEvent_Value = Guid.initString("d97287b2-2dfd-436a-9485-99d7d4ab5a69");
pub const CLSID_EVENTID_TuneFailureEvent = &CLSID_EVENTID_TuneFailureEvent_Value;

const CLSID_EVENTID_TuneFailureSpanningEvent_Value = Guid.initString("6f8aa455-5ee1-48ab-a27c-4c8d70b9aeba");
pub const CLSID_EVENTID_TuneFailureSpanningEvent = &CLSID_EVENTID_TuneFailureSpanningEvent_Value;

const CLSID_EVENTID_DvbParentalRatingDescriptor_Value = Guid.initString("2a67a58d-eca5-4eac-abcb-e734d3776d0a");
pub const CLSID_EVENTID_DvbParentalRatingDescriptor = &CLSID_EVENTID_DvbParentalRatingDescriptor_Value;

pub const DvbParentalRatingParam = extern struct {
    szCountryCode: [4]CHAR,
    bRating: u8,
};

pub const DvbParentalRatingDescriptor = extern struct {
    ulNumParams: u32,
    pParams: [1]DvbParentalRatingParam,
};

const CLSID_EVENTID_DFNWithNoActualAVData_Value = Guid.initString("f5689ffe-55f9-4bb3-96be-ae971c63bae0");
pub const CLSID_EVENTID_DFNWithNoActualAVData = &CLSID_EVENTID_DFNWithNoActualAVData_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value = Guid.initString("71985f41-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA = &CLSID_KSDATAFORMAT_TYPE_BDA_ANTENNA_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value = Guid.initString("f4aeb342-0329-4fdd-a8fd-4aff4926c978");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_MPEG2_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value = Guid.initString("8deda6fd-ac5f-4334-8ecf-a4ba8fa7d0f0");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value = Guid.initString("61be0b47-a5eb-499b-9a85-5b16c07f1258");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL = &CLSID_KSDATAFORMAT_TYPE_BDA_IF_SIGNAL_Value;

const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value = Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS = &CLSID_KSDATAFORMAT_TYPE_MPEG2_SECTIONS_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value = Guid.initString("b3c7397c-d303-414d-b33c-4ed2c9d29733");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ATSC_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value = Guid.initString("e9dd31a3-221d-4adb-8532-9af309c1a408");
pub const CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_DVB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value = Guid.initString("762e3f66-336f-48d1-bf83-2b00352c11f0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value = Guid.initString("951727db-d2ce-4528-96f6-3301fabb2de0");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_OPENCABLE_OOB_PSIP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value = Guid.initString("4a2eeb99-6458-4538-b187-04017c41413f");
pub const CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI = &CLSID_KSDATAFORMAT_SUBTYPE_ISDB_SI_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value = Guid.initString("0d7aed42-cb9a-11db-9705-005056c00008");
pub const CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW = &CLSID_KSDATAFORMAT_SUBTYPE_PBDA_TRANSPORT_RAW_Value;

const CLSID_PINNAME_BDA_TRANSPORT_Value = Guid.initString("78216a81-cfa8-493e-9711-36a61c08bd9d");
pub const CLSID_PINNAME_BDA_TRANSPORT = &CLSID_PINNAME_BDA_TRANSPORT_Value;

const CLSID_PINNAME_BDA_ANALOG_VIDEO_Value = Guid.initString("5c0c8281-5667-486c-8482-63e31f01a6e9");
pub const CLSID_PINNAME_BDA_ANALOG_VIDEO = &CLSID_PINNAME_BDA_ANALOG_VIDEO_Value;

const CLSID_PINNAME_BDA_ANALOG_AUDIO_Value = Guid.initString("d28a580a-9b1f-4b0c-9c33-9bf0a8ea636b");
pub const CLSID_PINNAME_BDA_ANALOG_AUDIO = &CLSID_PINNAME_BDA_ANALOG_AUDIO_Value;

const CLSID_PINNAME_BDA_FM_RADIO_Value = Guid.initString("d2855fed-b2d3-4eeb-9bd0-193436a2f890");
pub const CLSID_PINNAME_BDA_FM_RADIO = &CLSID_PINNAME_BDA_FM_RADIO_Value;

const CLSID_PINNAME_BDA_IF_PIN_Value = Guid.initString("1a9d4a42-f3cd-48a1-9aea-71de133cbe14");
pub const CLSID_PINNAME_BDA_IF_PIN = &CLSID_PINNAME_BDA_IF_PIN_Value;

const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value = Guid.initString("297bb104-e5c9-4ace-b123-95c3cbb24d4f");
pub const CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN = &CLSID_PINNAME_BDA_OPENCABLE_PSIP_PIN_Value;

const CLSID_KSPROPSETID_BdaEthernetFilter_Value = Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaEthernetFilter = &CLSID_KSPROPSETID_BdaEthernetFilter_Value;

pub const KSPROPERTY_BDA_ETHERNET_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_ETHERNET_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_ETHERNET_FILTER.LIST;
pub const KSPROPERTY_BDA_ETHERNET_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_ETHERNET_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv4Filter_Value = Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaIPv4Filter = &CLSID_KSPROPSETID_BdaIPv4Filter_Value;

pub const KSPROPERTY_BDA_IPv4_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv4_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv4_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv4_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv4_FILTER.MODE;

const CLSID_KSPROPSETID_BdaIPv6Filter_Value = Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const CLSID_KSPROPSETID_BdaIPv6Filter = &CLSID_KSPROPSETID_BdaIPv6Filter_Value;

pub const KSPROPERTY_BDA_IPv6_FILTER = enum(i32) {
    LIST_SIZE = 0,
    LIST = 1,
    MODE = 2,
};
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST_SIZE = KSPROPERTY_BDA_IPv6_FILTER.LIST_SIZE;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_LIST = KSPROPERTY_BDA_IPv6_FILTER.LIST;
pub const KSPROPERTY_BDA_IPv6_FILTER_MULTICAST_MODE = KSPROPERTY_BDA_IPv6_FILTER.MODE;

const CLSID_KSPROPSETID_BdaSignalStats_Value = Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const CLSID_KSPROPSETID_BdaSignalStats = &CLSID_KSPROPSETID_BdaSignalStats_Value;

pub const KSPROPERTY_BDA_SIGNAL_STATS = enum(i32) {
    IGNAL_STRENGTH = 0,
    IGNAL_QUALITY = 1,
    IGNAL_PRESENT = 2,
    IGNAL_LOCKED = 3,
    AMPLE_TIME = 4,
    IGNAL_LOCK_CAPS = 5,
    IGNAL_LOCK_TYPE = 6,
};
pub const KSPROPERTY_BDA_SIGNAL_STRENGTH = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_STRENGTH;
pub const KSPROPERTY_BDA_SIGNAL_QUALITY = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_QUALITY;
pub const KSPROPERTY_BDA_SIGNAL_PRESENT = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_PRESENT;
pub const KSPROPERTY_BDA_SIGNAL_LOCKED = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCKED;
pub const KSPROPERTY_BDA_SAMPLE_TIME = KSPROPERTY_BDA_SIGNAL_STATS.AMPLE_TIME;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_CAPS = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_CAPS;
pub const KSPROPERTY_BDA_SIGNAL_LOCK_TYPE = KSPROPERTY_BDA_SIGNAL_STATS.IGNAL_LOCK_TYPE;

pub const BDA_LockType = enum(i32) {
    None = 0,
    PLL = 1,
    DecoderDemod = 2,
    Complete = 128,
};
pub const Bda_LockType_None = BDA_LockType.None;
pub const Bda_LockType_PLL = BDA_LockType.PLL;
pub const Bda_LockType_DecoderDemod = BDA_LockType.DecoderDemod;
pub const Bda_LockType_Complete = BDA_LockType.Complete;

const CLSID_KSMETHODSETID_BdaChangeSync_Value = Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaChangeSync = &CLSID_KSMETHODSETID_BdaChangeSync_Value;

pub const KSMETHOD_BDA_CHANGE_SYNC = enum(i32) {
    START_CHANGES = 0,
    CHECK_CHANGES = 1,
    COMMIT_CHANGES = 2,
    GET_CHANGE_STATE = 3,
};
pub const KSMETHOD_BDA_START_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.START_CHANGES;
pub const KSMETHOD_BDA_CHECK_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.CHECK_CHANGES;
pub const KSMETHOD_BDA_COMMIT_CHANGES = KSMETHOD_BDA_CHANGE_SYNC.COMMIT_CHANGES;
pub const KSMETHOD_BDA_GET_CHANGE_STATE = KSMETHOD_BDA_CHANGE_SYNC.GET_CHANGE_STATE;

const CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value = Guid.initString("71985f45-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSMETHODSETID_BdaDeviceConfiguration = &CLSID_KSMETHODSETID_BdaDeviceConfiguration_Value;

pub const KSMETHOD_BDA_DEVICE_CONFIGURATION = enum(i32) {
    CREATE_PIN_FACTORY = 0,
    DELETE_PIN_FACTORY = 1,
    CREATE_TOPOLOGY = 2,
};
pub const KSMETHOD_BDA_CREATE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_PIN_FACTORY;
pub const KSMETHOD_BDA_DELETE_PIN_FACTORY = KSMETHOD_BDA_DEVICE_CONFIGURATION.DELETE_PIN_FACTORY;
pub const KSMETHOD_BDA_CREATE_TOPOLOGY = KSMETHOD_BDA_DEVICE_CONFIGURATION.CREATE_TOPOLOGY;

const CLSID_KSPROPSETID_BdaTopology_Value = Guid.initString("a14ee835-0a23-11d3-9cc7-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaTopology = &CLSID_KSPROPSETID_BdaTopology_Value;

pub const KSPROPERTY_BDA_TOPOLOGY = enum(i32) {
    NODE_TYPES = 0,
    PIN_TYPES = 1,
    TEMPLATE_CONNECTIONS = 2,
    NODE_METHODS = 3,
    NODE_PROPERTIES = 4,
    NODE_EVENTS = 5,
    CONTROLLING_PIN_ID = 6,
    NODE_DESCRIPTORS = 7,
};
pub const KSPROPERTY_BDA_NODE_TYPES = KSPROPERTY_BDA_TOPOLOGY.NODE_TYPES;
pub const KSPROPERTY_BDA_PIN_TYPES = KSPROPERTY_BDA_TOPOLOGY.PIN_TYPES;
pub const KSPROPERTY_BDA_TEMPLATE_CONNECTIONS = KSPROPERTY_BDA_TOPOLOGY.TEMPLATE_CONNECTIONS;
pub const KSPROPERTY_BDA_NODE_METHODS = KSPROPERTY_BDA_TOPOLOGY.NODE_METHODS;
pub const KSPROPERTY_BDA_NODE_PROPERTIES = KSPROPERTY_BDA_TOPOLOGY.NODE_PROPERTIES;
pub const KSPROPERTY_BDA_NODE_EVENTS = KSPROPERTY_BDA_TOPOLOGY.NODE_EVENTS;
pub const KSPROPERTY_BDA_CONTROLLING_PIN_ID = KSPROPERTY_BDA_TOPOLOGY.CONTROLLING_PIN_ID;
pub const KSPROPERTY_BDA_NODE_DESCRIPTORS = KSPROPERTY_BDA_TOPOLOGY.NODE_DESCRIPTORS;

const CLSID_KSPROPSETID_BdaPinControl_Value = Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const CLSID_KSPROPSETID_BdaPinControl = &CLSID_KSPROPSETID_BdaPinControl_Value;

pub const KSPROPERTY_BDA_PIN_CONTROL = enum(i32) {
    ID = 0,
    TYPE = 1,
};
pub const KSPROPERTY_BDA_PIN_ID = KSPROPERTY_BDA_PIN_CONTROL.ID;
pub const KSPROPERTY_BDA_PIN_TYPE = KSPROPERTY_BDA_PIN_CONTROL.TYPE;

const CLSID_KSEVENTSETID_BdaPinEvent_Value = Guid.initString("104781cd-50bd-40d5-95fb-087e0e86a591");
pub const CLSID_KSEVENTSETID_BdaPinEvent = &CLSID_KSEVENTSETID_BdaPinEvent_Value;

pub const KSPROPERTY_BDA_PIN_EVENT = enum(i32) {
    CONNECTED = 0,
    DISCONNECTED = 1,
};
pub const KSEVENT_BDA_PIN_CONNECTED = KSPROPERTY_BDA_PIN_EVENT.CONNECTED;
pub const KSEVENT_BDA_PIN_DISCONNECTED = KSPROPERTY_BDA_PIN_EVENT.DISCONNECTED;

const CLSID_KSPROPSETID_BdaVoidTransform_Value = Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaVoidTransform = &CLSID_KSPROPSETID_BdaVoidTransform_Value;

pub const KSPROPERTY_BDA_VOID_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_VOID_TRANSFORM_START = KSPROPERTY_BDA_VOID_TRANSFORM.ART;
pub const KSPROPERTY_BDA_VOID_TRANSFORM_STOP = KSPROPERTY_BDA_VOID_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaNullTransform_Value = Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaNullTransform = &CLSID_KSPROPSETID_BdaNullTransform_Value;

pub const KSPROPERTY_BDA_NULL_TRANSFORM = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_NULL_TRANSFORM_START = KSPROPERTY_BDA_NULL_TRANSFORM.ART;
pub const KSPROPERTY_BDA_NULL_TRANSFORM_STOP = KSPROPERTY_BDA_NULL_TRANSFORM.OP;

const CLSID_KSPROPSETID_BdaFrequencyFilter_Value = Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaFrequencyFilter = &CLSID_KSPROPSETID_BdaFrequencyFilter_Value;

pub const KSPROPERTY_BDA_FREQUENCY_FILTER = enum(i32) {
    FREQUENCY = 0,
    POLARITY = 1,
    RANGE = 2,
    TRANSPONDER = 3,
    BANDWIDTH = 4,
    FREQUENCY_MULTIPLIER = 5,
    CAPS = 6,
    SCAN_STATUS = 7,
    STANDARD = 8,
    STANDARD_MODE = 9,
};
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY;
pub const KSPROPERTY_BDA_RF_TUNER_POLARITY = KSPROPERTY_BDA_FREQUENCY_FILTER.POLARITY;
pub const KSPROPERTY_BDA_RF_TUNER_RANGE = KSPROPERTY_BDA_FREQUENCY_FILTER.RANGE;
pub const KSPROPERTY_BDA_RF_TUNER_TRANSPONDER = KSPROPERTY_BDA_FREQUENCY_FILTER.TRANSPONDER;
pub const KSPROPERTY_BDA_RF_TUNER_BANDWIDTH = KSPROPERTY_BDA_FREQUENCY_FILTER.BANDWIDTH;
pub const KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER = KSPROPERTY_BDA_FREQUENCY_FILTER.FREQUENCY_MULTIPLIER;
pub const KSPROPERTY_BDA_RF_TUNER_CAPS = KSPROPERTY_BDA_FREQUENCY_FILTER.CAPS;
pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS = KSPROPERTY_BDA_FREQUENCY_FILTER.SCAN_STATUS;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD;
pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE = KSPROPERTY_BDA_FREQUENCY_FILTER.STANDARD_MODE;

pub const BDA_SignalType = enum(i32) {
    Unknown = 0,
    Analog = 1,
    Digital = 2,
};
pub const Bda_SignalType_Unknown = BDA_SignalType.Unknown;
pub const Bda_SignalType_Analog = BDA_SignalType.Analog;
pub const Bda_SignalType_Digital = BDA_SignalType.Digital;

pub const BDA_DigitalSignalStandard = enum(i32) {
    None = 0,
    DVB_T = 1,
    DVB_S = 2,
    DVB_C = 4,
    ATSC = 8,
    ISDB_T = 16,
    ISDB_S = 32,
    ISDB_C = 64,
};
pub const Bda_DigitalStandard_None = BDA_DigitalSignalStandard.None;
pub const Bda_DigitalStandard_DVB_T = BDA_DigitalSignalStandard.DVB_T;
pub const Bda_DigitalStandard_DVB_S = BDA_DigitalSignalStandard.DVB_S;
pub const Bda_DigitalStandard_DVB_C = BDA_DigitalSignalStandard.DVB_C;
pub const Bda_DigitalStandard_ATSC = BDA_DigitalSignalStandard.ATSC;
pub const Bda_DigitalStandard_ISDB_T = BDA_DigitalSignalStandard.ISDB_T;
pub const Bda_DigitalStandard_ISDB_S = BDA_DigitalSignalStandard.ISDB_S;
pub const Bda_DigitalStandard_ISDB_C = BDA_DigitalSignalStandard.ISDB_C;

pub const KSPROPERTY_BDA_RF_TUNER_CAPS_S = extern struct {
    Property: KSP_NODE,
    Mode: u32,
    AnalogStandardsSupported: u32,
    DigitalStandardsSupported: u32,
    MinFrequency: u32,
    MaxFrequency: u32,
    SettlingTime: u32,
    AnalogSensingRange: u32,
    DigitalSensingRange: u32,
    MilliSecondsPerMHz: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_SCAN_STATUS_S = extern struct {
    Property: KSP_NODE,
    CurrentFrequency: u32,
    FrequencyRangeMin: u32,
    FrequencyRangeMax: u32,
    MilliSecondsLeft: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_S = extern struct {
    Property: KSP_NODE,
    SignalType: BDA_SignalType,
    SignalStandard: u32,
};

pub const KSPROPERTY_BDA_RF_TUNER_STANDARD_MODE_S = extern struct {
    Property: KSP_NODE,
    AutoDetect: BOOL,
};

const CLSID_KSEVENTSETID_BdaTunerEvent_Value = Guid.initString("aab59e17-01c9-4ebf-93f2-fc3b79b46f91");
pub const CLSID_KSEVENTSETID_BdaTunerEvent = &CLSID_KSEVENTSETID_BdaTunerEvent_Value;

pub const KSEVENT_BDA_TUNER = enum(i32) {
    N = 0,
};
pub const KSEVENT_BDA_TUNER_SCAN = KSEVENT_BDA_TUNER.N;

pub const KSEVENTDATA_BDA_RF_TUNER_SCAN_S = extern struct {
    EventData: KSEVENTDATA,
    StartFrequency: u32,
    EndFrequency: u32,
    LockRequested: BDA_LockType,
};

const CLSID_KSPROPSETID_BdaLNBInfo_Value = Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const CLSID_KSPROPSETID_BdaLNBInfo = &CLSID_KSPROPSETID_BdaLNBInfo_Value;

pub const KSPROPERTY_BDA_LNB_INFO = enum(i32) {
    LOF_LOW_BAND = 0,
    LOF_HIGH_BAND = 1,
    SWITCH_FREQUENCY = 2,
};
pub const KSPROPERTY_BDA_LNB_LOF_LOW_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_LOW_BAND;
pub const KSPROPERTY_BDA_LNB_LOF_HIGH_BAND = KSPROPERTY_BDA_LNB_INFO.LOF_HIGH_BAND;
pub const KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY = KSPROPERTY_BDA_LNB_INFO.SWITCH_FREQUENCY;

const CLSID_KSPROPSETID_BdaDiseqCommand_Value = Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const CLSID_KSPROPSETID_BdaDiseqCommand = &CLSID_KSPROPSETID_BdaDiseqCommand_Value;

pub const KSPROPERTY_BDA_DISEQC_COMMAND = enum(i32) {
    ENABLE = 0,
    LNB_SOURCE = 1,
    USETONEBURST = 2,
    REPEATS = 3,
    SEND = 4,
    RESPONSE = 5,
};
pub const KSPROPERTY_BDA_DISEQC_ENABLE = KSPROPERTY_BDA_DISEQC_COMMAND.ENABLE;
pub const KSPROPERTY_BDA_DISEQC_LNB_SOURCE = KSPROPERTY_BDA_DISEQC_COMMAND.LNB_SOURCE;
pub const KSPROPERTY_BDA_DISEQC_USETONEBURST = KSPROPERTY_BDA_DISEQC_COMMAND.USETONEBURST;
pub const KSPROPERTY_BDA_DISEQC_REPEATS = KSPROPERTY_BDA_DISEQC_COMMAND.REPEATS;
pub const KSPROPERTY_BDA_DISEQC_SEND = KSPROPERTY_BDA_DISEQC_COMMAND.SEND;
pub const KSPROPERTY_BDA_DISEQC_RESPONSE = KSPROPERTY_BDA_DISEQC_COMMAND.RESPONSE;

const CLSID_KSEVENTSETID_BdaDiseqCEvent_Value = Guid.initString("8b19bbf0-4184-43ac-ad3c-0c889be4c212");
pub const CLSID_KSEVENTSETID_BdaDiseqCEvent = &CLSID_KSEVENTSETID_BdaDiseqCEvent_Value;

pub const KSPROPERTY_BDA_DISEQC_EVENT = enum(i32) {
    D = 0,
};
pub const KSEVENT_BDA_DISEQC_DATA_RECEIVED = KSPROPERTY_BDA_DISEQC_EVENT.D;

const CLSID_KSPROPSETID_BdaDigitalDemodulator_Value = Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const CLSID_KSPROPSETID_BdaDigitalDemodulator = &CLSID_KSPROPSETID_BdaDigitalDemodulator_Value;

pub const KSPROPERTY_BDA_DIGITAL_DEMODULATOR = enum(i32) {
    MODULATION_TYPE = 0,
    INNER_FEC_TYPE = 1,
    INNER_FEC_RATE = 2,
    OUTER_FEC_TYPE = 3,
    OUTER_FEC_RATE = 4,
    SYMBOL_RATE = 5,
    SPECTRAL_INVERSION = 6,
    GUARD_INTERVAL = 7,
    TRANSMISSION_MODE = 8,
    ROLL_OFF = 9,
    PILOT = 10,
    SIGNALTIMEOUTS = 11,
    PLP_NUMBER = 12,
};
pub const KSPROPERTY_BDA_MODULATION_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.MODULATION_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_TYPE;
pub const KSPROPERTY_BDA_INNER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.INNER_FEC_RATE;
pub const KSPROPERTY_BDA_OUTER_FEC_TYPE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_TYPE;
pub const KSPROPERTY_BDA_OUTER_FEC_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.OUTER_FEC_RATE;
pub const KSPROPERTY_BDA_SYMBOL_RATE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SYMBOL_RATE;
pub const KSPROPERTY_BDA_SPECTRAL_INVERSION = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SPECTRAL_INVERSION;
pub const KSPROPERTY_BDA_GUARD_INTERVAL = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.GUARD_INTERVAL;
pub const KSPROPERTY_BDA_TRANSMISSION_MODE = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.TRANSMISSION_MODE;
pub const KSPROPERTY_BDA_ROLL_OFF = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.ROLL_OFF;
pub const KSPROPERTY_BDA_PILOT = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PILOT;
pub const KSPROPERTY_BDA_SIGNALTIMEOUTS = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.SIGNALTIMEOUTS;
pub const KSPROPERTY_BDA_PLP_NUMBER = KSPROPERTY_BDA_DIGITAL_DEMODULATOR.PLP_NUMBER;

const CLSID_KSPROPSETID_BdaAutodemodulate_Value = Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const CLSID_KSPROPSETID_BdaAutodemodulate = &CLSID_KSPROPSETID_BdaAutodemodulate_Value;

pub const KSPROPERTY_BDA_AUTODEMODULATE = enum(i32) {
    ART = 0,
    OP = 1,
};
pub const KSPROPERTY_BDA_AUTODEMODULATE_START = KSPROPERTY_BDA_AUTODEMODULATE.ART;
pub const KSPROPERTY_BDA_AUTODEMODULATE_STOP = KSPROPERTY_BDA_AUTODEMODULATE.OP;

const CLSID_KSPROPSETID_BdaTableSection_Value = Guid.initString("516b99c5-971c-4aaf-b3f3-d9fda8a15e16");
pub const CLSID_KSPROPSETID_BdaTableSection = &CLSID_KSPROPSETID_BdaTableSection_Value;

pub const KSPROPERTY_IDS_BDA_TABLE = enum(i32) {
    N = 0,
};
pub const KSPROPERTY_BDA_TABLE_SECTION = KSPROPERTY_IDS_BDA_TABLE.N;

const CLSID_KSPROPSETID_BdaPIDFilter_Value = Guid.initString("d0a67d65-08df-4fec-8533-e5b550410b85");
pub const CLSID_KSPROPSETID_BdaPIDFilter = &CLSID_KSPROPSETID_BdaPIDFilter_Value;

pub const KSPROPERTY_BDA_PIDFILTER = enum(i32) {
    MAP_PIDS = 0,
    UNMAP_PIDS = 1,
    LIST_PIDS = 2,
};
pub const KSPROPERTY_BDA_PIDFILTER_MAP_PIDS = KSPROPERTY_BDA_PIDFILTER.MAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_UNMAP_PIDS = KSPROPERTY_BDA_PIDFILTER.UNMAP_PIDS;
pub const KSPROPERTY_BDA_PIDFILTER_LIST_PIDS = KSPROPERTY_BDA_PIDFILTER.LIST_PIDS;

const CLSID_KSPROPSETID_BdaCA_Value = Guid.initString("b0693766-5278-4ec6-b9e1-3ce40560ef5a");
pub const CLSID_KSPROPSETID_BdaCA = &CLSID_KSPROPSETID_BdaCA_Value;

pub const KSPROPERTY_BDA_CA = enum(i32) {
    ECM_MAP_STATUS = 0,
    CA_MODULE_STATUS = 1,
    CA_SMART_CARD_STATUS = 2,
    CA_MODULE_UI = 3,
    CA_SET_PROGRAM_PIDS = 4,
    CA_REMOVE_PROGRAM = 5,
};
pub const KSPROPERTY_BDA_ECM_MAP_STATUS = KSPROPERTY_BDA_CA.ECM_MAP_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_STATUS = KSPROPERTY_BDA_CA.CA_MODULE_STATUS;
pub const KSPROPERTY_BDA_CA_SMART_CARD_STATUS = KSPROPERTY_BDA_CA.CA_SMART_CARD_STATUS;
pub const KSPROPERTY_BDA_CA_MODULE_UI = KSPROPERTY_BDA_CA.CA_MODULE_UI;
pub const KSPROPERTY_BDA_CA_SET_PROGRAM_PIDS = KSPROPERTY_BDA_CA.CA_SET_PROGRAM_PIDS;
pub const KSPROPERTY_BDA_CA_REMOVE_PROGRAM = KSPROPERTY_BDA_CA.CA_REMOVE_PROGRAM;

const CLSID_KSEVENTSETID_BdaCAEvent_Value = Guid.initString("488c4ccc-b768-4129-8eb1-b00a071f9068");
pub const CLSID_KSEVENTSETID_BdaCAEvent = &CLSID_KSEVENTSETID_BdaCAEvent_Value;

pub const KSPROPERTY_BDA_CA_EVENT = enum(i32) {
    PROGRAM_FLOW_STATUS_CHANGED = 0,
    CA_MODULE_STATUS_CHANGED = 1,
    CA_SMART_CARD_STATUS_CHANGED = 2,
    CA_MODULE_UI_REQUESTED = 3,
};
pub const KSEVENT_BDA_PROGRAM_FLOW_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.PROGRAM_FLOW_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED = KSPROPERTY_BDA_CA_EVENT.CA_SMART_CARD_STATUS_CHANGED;
pub const KSEVENT_BDA_CA_MODULE_UI_REQUESTED = KSPROPERTY_BDA_CA_EVENT.CA_MODULE_UI_REQUESTED;

const CLSID_KSMETHODSETID_BdaDrmService_Value = Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const CLSID_KSMETHODSETID_BdaDrmService = &CLSID_KSMETHODSETID_BdaDrmService_Value;

pub const KSMETHOD_BDA_DRM = enum(i32) {
    CURRENT = 0,
    DRMSTATUS = 1,
};
pub const KSMETHOD_BDA_DRM_CURRENT = KSMETHOD_BDA_DRM.CURRENT;
pub const KSMETHOD_BDA_DRM_DRMSTATUS = KSMETHOD_BDA_DRM.DRMSTATUS;

const CLSID_KSMETHODSETID_BdaWmdrmSession_Value = Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const CLSID_KSMETHODSETID_BdaWmdrmSession = &CLSID_KSMETHODSETID_BdaWmdrmSession_Value;

pub const KSMETHOD_BDA_WMDRM = enum(i32) {
    STATUS = 0,
    REVINFO = 1,
    CRL = 2,
    MESSAGE = 3,
    REISSUELICENSE = 4,
    RENEWLICENSE = 5,
    LICENSE = 6,
    KEYINFO = 7,
};
pub const KSMETHOD_BDA_WMDRM_STATUS = KSMETHOD_BDA_WMDRM.STATUS;
pub const KSMETHOD_BDA_WMDRM_REVINFO = KSMETHOD_BDA_WMDRM.REVINFO;
pub const KSMETHOD_BDA_WMDRM_CRL = KSMETHOD_BDA_WMDRM.CRL;
pub const KSMETHOD_BDA_WMDRM_MESSAGE = KSMETHOD_BDA_WMDRM.MESSAGE;
pub const KSMETHOD_BDA_WMDRM_REISSUELICENSE = KSMETHOD_BDA_WMDRM.REISSUELICENSE;
pub const KSMETHOD_BDA_WMDRM_RENEWLICENSE = KSMETHOD_BDA_WMDRM.RENEWLICENSE;
pub const KSMETHOD_BDA_WMDRM_LICENSE = KSMETHOD_BDA_WMDRM.LICENSE;
pub const KSMETHOD_BDA_WMDRM_KEYINFO = KSMETHOD_BDA_WMDRM.KEYINFO;

const CLSID_KSMETHODSETID_BdaWmdrmTuner_Value = Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const CLSID_KSMETHODSETID_BdaWmdrmTuner = &CLSID_KSMETHODSETID_BdaWmdrmTuner_Value;

pub const KSMETHOD_BDA_WMDRM_TUNER = enum(i32) {
    CANCELCAPTURETOKEN = 0,
    SETPIDPROTECTION = 1,
    GETPIDPROTECTION = 2,
    SETSYNCVALUE = 3,
    STARTCODEPROFILE = 4,
    PURCHASE_ENTITLEMENT = 5,
};
pub const KSMETHOD_BDA_WMDRMTUNER_CANCELCAPTURETOKEN = KSMETHOD_BDA_WMDRM_TUNER.CANCELCAPTURETOKEN;
pub const KSMETHOD_BDA_WMDRMTUNER_SETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.SETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_GETPIDPROTECTION = KSMETHOD_BDA_WMDRM_TUNER.GETPIDPROTECTION;
pub const KSMETHOD_BDA_WMDRMTUNER_SETSYNCVALUE = KSMETHOD_BDA_WMDRM_TUNER.SETSYNCVALUE;
pub const KSMETHOD_BDA_WMDRMTUNER_STARTCODEPROFILE = KSMETHOD_BDA_WMDRM_TUNER.STARTCODEPROFILE;
pub const KSMETHOD_BDA_WMDRMTUNER_PURCHASE_ENTITLEMENT = KSMETHOD_BDA_WMDRM_TUNER.PURCHASE_ENTITLEMENT;

const CLSID_KSMETHODSETID_BdaEventing_Value = Guid.initString("f99492da-6193-4eb0-8690-6686cbff713e");
pub const CLSID_KSMETHODSETID_BdaEventing = &CLSID_KSMETHODSETID_BdaEventing_Value;

pub const KSMETHOD_BDA_EVENTING_SERVICE = enum(i32) {
    DATA = 0,
    COMPLETE = 1,
};
pub const KSMETHOD_BDA_EVENT_DATA = KSMETHOD_BDA_EVENTING_SERVICE.DATA;
pub const KSMETHOD_BDA_EVENT_COMPLETE = KSMETHOD_BDA_EVENTING_SERVICE.COMPLETE;

const CLSID_KSEVENTSETID_BdaEvent_Value = Guid.initString("ae7e55b2-96d7-4e29-908f-62f95b2a1679");
pub const CLSID_KSEVENTSETID_BdaEvent = &CLSID_KSEVENTSETID_BdaEvent_Value;

pub const KSEVENT_BDA_EVENT_TYPE = enum(i32) {
    T = 0,
};
pub const KSEVENT_BDA_EVENT_PENDINGEVENT = KSEVENT_BDA_EVENT_TYPE.T;

const CLSID_KSMETHODSETID_BdaDebug_Value = Guid.initString("0d4a90ec-c69d-4ee2-8c5a-fb1f63a50da1");
pub const CLSID_KSMETHODSETID_BdaDebug = &CLSID_KSMETHODSETID_BdaDebug_Value;

pub const KSMETHOD_BDA_DEBUG_SERVICE = enum(i32) {
    LEVEL = 0,
    DATA = 1,
};
pub const KSMETHOD_BDA_DEBUG_LEVEL = KSMETHOD_BDA_DEBUG_SERVICE.LEVEL;
pub const KSMETHOD_BDA_DEBUG_DATA = KSMETHOD_BDA_DEBUG_SERVICE.DATA;

const CLSID_KSMETHODSETID_BdaTuner_Value = Guid.initString("b774102f-ac07-478a-8228-2742d961fa7e");
pub const CLSID_KSMETHODSETID_BdaTuner = &CLSID_KSMETHODSETID_BdaTuner_Value;

pub const KSMETHOD_BDA_TUNER_SERVICE = enum(i32) {
    SETTUNER = 0,
    GETTUNERSTATE = 1,
    SIGNALNOISERATIO = 2,
};
pub const KSMETHOD_BDA_TUNER_SETTUNER = KSMETHOD_BDA_TUNER_SERVICE.SETTUNER;
pub const KSMETHOD_BDA_TUNER_GETTUNERSTATE = KSMETHOD_BDA_TUNER_SERVICE.GETTUNERSTATE;
pub const KSMETHOD_BDA_TUNER_SIGNALNOISERATIO = KSMETHOD_BDA_TUNER_SERVICE.SIGNALNOISERATIO;

const CLSID_KSMETHODSETID_BdaNameValueA_Value = Guid.initString("0c24096d-5ff5-47de-a856-062e587e3727");
pub const CLSID_KSMETHODSETID_BdaNameValueA = &CLSID_KSMETHODSETID_BdaNameValueA_Value;

const CLSID_KSMETHODSETID_BdaNameValue_Value = Guid.initString("36e07304-9f0d-4e88-9118-ac0ba317b7f2");
pub const CLSID_KSMETHODSETID_BdaNameValue = &CLSID_KSMETHODSETID_BdaNameValue_Value;

pub const KSMETHOD_BDA_GPNV_SERVICE = enum(i32) {
    GETVALUE = 0,
    SETVALUE = 1,
    NAMEFROMINDEX = 2,
    GETVALUEUPDATENAME = 3,
};
pub const KSMETHOD_BDA_GPNV_GETVALUE = KSMETHOD_BDA_GPNV_SERVICE.GETVALUE;
pub const KSMETHOD_BDA_GPNV_SETVALUE = KSMETHOD_BDA_GPNV_SERVICE.SETVALUE;
pub const KSMETHOD_BDA_GPNV_NAMEFROMINDEX = KSMETHOD_BDA_GPNV_SERVICE.NAMEFROMINDEX;
pub const KSMETHOD_BDA_GPNV_GETVALUEUPDATENAME = KSMETHOD_BDA_GPNV_SERVICE.GETVALUEUPDATENAME;

const CLSID_KSMETHODSETID_BdaMux_Value = Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const CLSID_KSMETHODSETID_BdaMux = &CLSID_KSMETHODSETID_BdaMux_Value;

pub const KSMETHOD_BDA_MUX_SERVICE = enum(i32) {
    GETPIDLIST = 0,
    SETPIDLIST = 1,
};
pub const KSMETHOD_BDA_MUX_GETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.GETPIDLIST;
pub const KSMETHOD_BDA_MUX_SETPIDLIST = KSMETHOD_BDA_MUX_SERVICE.SETPIDLIST;

const CLSID_KSMETHODSETID_BdaScanning_Value = Guid.initString("12eb49df-6249-47f3-b190-e21e6e2f8a9c");
pub const CLSID_KSMETHODSETID_BdaScanning = &CLSID_KSMETHODSETID_BdaScanning_Value;

pub const KSMETHOD_BDA_SCAN_SERVICE = enum(i32) {
    _CAPABILTIES = 0,
    NING_STATE = 1,
    _FILTER = 2,
    _START = 3,
    _RESUME = 4,
    _STOP = 5,
};
pub const KSMETHOD_BDA_SCAN_CAPABILTIES = KSMETHOD_BDA_SCAN_SERVICE._CAPABILTIES;
pub const KSMETHOD_BDA_SCANNING_STATE = KSMETHOD_BDA_SCAN_SERVICE.NING_STATE;
pub const KSMETHOD_BDA_SCAN_FILTER = KSMETHOD_BDA_SCAN_SERVICE._FILTER;
pub const KSMETHOD_BDA_SCAN_START = KSMETHOD_BDA_SCAN_SERVICE._START;
pub const KSMETHOD_BDA_SCAN_RESUME = KSMETHOD_BDA_SCAN_SERVICE._RESUME;
pub const KSMETHOD_BDA_SCAN_STOP = KSMETHOD_BDA_SCAN_SERVICE._STOP;

const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value = Guid.initString("8d9d5562-1589-417d-99ce-ac531dda19f9");
pub const CLSID_KSMETHODSETID_BdaGuideDataDeliveryService = &CLSID_KSMETHODSETID_BdaGuideDataDeliveryService_Value;

pub const KSMETHOD_BDA_GDDS_SERVICE = enum(i32) {
    DATATYPE = 0,
    DATA = 1,
    TUNEXMLFROMIDX = 2,
    GETSERVICES = 3,
    SERVICEFROMTUNEXML = 4,
    DATAUPDATE = 5,
};
pub const KSMETHOD_BDA_GDDS_DATATYPE = KSMETHOD_BDA_GDDS_SERVICE.DATATYPE;
pub const KSMETHOD_BDA_GDDS_DATA = KSMETHOD_BDA_GDDS_SERVICE.DATA;
pub const KSMETHOD_BDA_GDDS_TUNEXMLFROMIDX = KSMETHOD_BDA_GDDS_SERVICE.TUNEXMLFROMIDX;
pub const KSMETHOD_BDA_GDDS_GETSERVICES = KSMETHOD_BDA_GDDS_SERVICE.GETSERVICES;
pub const KSMETHOD_BDA_GDDS_SERVICEFROMTUNEXML = KSMETHOD_BDA_GDDS_SERVICE.SERVICEFROMTUNEXML;
pub const KSMETHOD_BDA_GDDS_DATAUPDATE = KSMETHOD_BDA_GDDS_SERVICE.DATAUPDATE;

const CLSID_KSMETHODSETID_BdaConditionalAccessService_Value = Guid.initString("10ced3b4-320b-41bf-9824-1b2e68e71eb9");
pub const CLSID_KSMETHODSETID_BdaConditionalAccessService = &CLSID_KSMETHODSETID_BdaConditionalAccessService_Value;

pub const KSMETHOD_BDA_CAS_SERVICE = enum(i32) {
    CHECKENTITLEMENTTOKEN = 0,
    SETCAPTURETOKEN = 1,
    OPENBROADCASTMMI = 2,
    CLOSEMMIDIALOG = 3,
};
pub const KSMETHOD_BDA_CAS_CHECKENTITLEMENTTOKEN = KSMETHOD_BDA_CAS_SERVICE.CHECKENTITLEMENTTOKEN;
pub const KSMETHOD_BDA_CAS_SETCAPTURETOKEN = KSMETHOD_BDA_CAS_SERVICE.SETCAPTURETOKEN;
pub const KSMETHOD_BDA_CAS_OPENBROADCASTMMI = KSMETHOD_BDA_CAS_SERVICE.OPENBROADCASTMMI;
pub const KSMETHOD_BDA_CAS_CLOSEMMIDIALOG = KSMETHOD_BDA_CAS_SERVICE.CLOSEMMIDIALOG;

const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value = Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const CLSID_KSMETHODSETID_BdaIsdbConditionalAccess = &CLSID_KSMETHODSETID_BdaIsdbConditionalAccess_Value;

pub const KSMETHOD_BDA_ISDB_CAS = enum(i32) {
    SETREQUEST = 0,
    RESPONSEDATA = 1,
};
pub const KSMETHOD_BDA_ISDBCAS_SETREQUEST = KSMETHOD_BDA_ISDB_CAS.SETREQUEST;
pub const KSMETHOD_BDA_ISDBCAS_RESPONSEDATA = KSMETHOD_BDA_ISDB_CAS.RESPONSEDATA;

const CLSID_KSMETHODSETID_BdaTSSelector_Value = Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const CLSID_KSMETHODSETID_BdaTSSelector = &CLSID_KSMETHODSETID_BdaTSSelector_Value;

pub const KSMETHOD_BDA_TS_SELECTOR = enum(i32) {
    SETTSID = 0,
    GETTSINFORMATION = 1,
};
pub const KSMETHOD_BDA_TS_SELECTOR_SETTSID = KSMETHOD_BDA_TS_SELECTOR.SETTSID;
pub const KSMETHOD_BDA_TS_SELECTOR_GETTSINFORMATION = KSMETHOD_BDA_TS_SELECTOR.GETTSINFORMATION;

const CLSID_KSMETHODSETID_BdaUserActivity_Value = Guid.initString("eda5c834-4531-483c-be0a-94e6c96ff396");
pub const CLSID_KSMETHODSETID_BdaUserActivity = &CLSID_KSMETHODSETID_BdaUserActivity_Value;

pub const KSMETHOD_BDA_USERACTIVITY_SERVICE = enum(i32) {
    USEREASON = 0,
    INTERVAL = 1,
    DETECTED = 2,
};
pub const KSMETHOD_BDA_USERACTIVITY_USEREASON = KSMETHOD_BDA_USERACTIVITY_SERVICE.USEREASON;
pub const KSMETHOD_BDA_USERACTIVITY_INTERVAL = KSMETHOD_BDA_USERACTIVITY_SERVICE.INTERVAL;
pub const KSMETHOD_BDA_USERACTIVITY_DETECTED = KSMETHOD_BDA_USERACTIVITY_SERVICE.DETECTED;

const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value = Guid.initString("fd0a5af4-b41d-11d2-9c95-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT = &CLSID_KSCATEGORY_BDA_RECEIVER_COMPONENT_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value = Guid.initString("71985f48-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_TUNER = &CLSID_KSCATEGORY_BDA_NETWORK_TUNER_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value = Guid.initString("71985f49-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_EPG = &CLSID_KSCATEGORY_BDA_NETWORK_EPG_Value;

const CLSID_KSCATEGORY_BDA_IP_SINK_Value = Guid.initString("71985f4a-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_IP_SINK = &CLSID_KSCATEGORY_BDA_IP_SINK_Value;

const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value = Guid.initString("71985f4b-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER = &CLSID_KSCATEGORY_BDA_NETWORK_PROVIDER_Value;

const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value = Guid.initString("a2e3074f-6c3d-11d3-b653-00c04f79498e");
pub const CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION = &CLSID_KSCATEGORY_BDA_TRANSPORT_INFORMATION_Value;

const CLSID_KSNODE_BDA_RF_TUNER_Value = Guid.initString("71985f4c-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_RF_TUNER = &CLSID_KSNODE_BDA_RF_TUNER_Value;

const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value = Guid.initString("634db199-27dd-46b8-acfb-ecc98e61a2ad");
pub const CLSID_KSNODE_BDA_ANALOG_DEMODULATOR = &CLSID_KSNODE_BDA_ANALOG_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value = Guid.initString("71985f4d-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_QAM_DEMODULATOR = &CLSID_KSNODE_BDA_QAM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value = Guid.initString("6390c905-27c1-4d67-bdb7-77c50d079300");
pub const CLSID_KSNODE_BDA_QPSK_DEMODULATOR = &CLSID_KSNODE_BDA_QPSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value = Guid.initString("71985f4f-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_8VSB_DEMODULATOR = &CLSID_KSNODE_BDA_8VSB_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value = Guid.initString("2dac6e05-edbe-4b9c-b387-1b6fad7d6495");
pub const CLSID_KSNODE_BDA_COFDM_DEMODULATOR = &CLSID_KSNODE_BDA_COFDM_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value = Guid.initString("e957a0e7-dd98-4a3c-810b-3525157ab62e");
pub const CLSID_KSNODE_BDA_8PSK_DEMODULATOR = &CLSID_KSNODE_BDA_8PSK_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value = Guid.initString("fcea3ae3-2cb2-464d-8f5d-305c0bb778a2");
pub const CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_T_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value = Guid.initString("edde230a-9086-432d-b8a5-6670263807e9");
pub const CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR = &CLSID_KSNODE_BDA_ISDB_S_DEMODULATOR_Value;

const CLSID_KSNODE_BDA_OPENCABLE_POD_Value = Guid.initString("345812a0-fb7c-4790-aa7e-b1db88ac19c9");
pub const CLSID_KSNODE_BDA_OPENCABLE_POD = &CLSID_KSNODE_BDA_OPENCABLE_POD_Value;

const CLSID_KSNODE_BDA_COMMON_CA_POD_Value = Guid.initString("d83ef8fc-f3b8-45ab-8b71-ecf7c339deb4");
pub const CLSID_KSNODE_BDA_COMMON_CA_POD = &CLSID_KSNODE_BDA_COMMON_CA_POD_Value;

const CLSID_KSNODE_BDA_PID_FILTER_Value = Guid.initString("f5412789-b0a0-44e1-ae4f-ee999b1b7fbe");
pub const CLSID_KSNODE_BDA_PID_FILTER = &CLSID_KSNODE_BDA_PID_FILTER_Value;

const CLSID_KSNODE_BDA_IP_SINK_Value = Guid.initString("71985f4e-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_KSNODE_BDA_IP_SINK = &CLSID_KSNODE_BDA_IP_SINK_Value;

const CLSID_KSNODE_BDA_VIDEO_ENCODER_Value = Guid.initString("d98429e3-65c9-4ac4-93aa-766782833b7a");
pub const CLSID_KSNODE_BDA_VIDEO_ENCODER = &CLSID_KSNODE_BDA_VIDEO_ENCODER_Value;

const CLSID_KSNODE_BDA_PBDA_CAS_Value = Guid.initString("c026869f-7129-4e71-8696-ec8f75299b77");
pub const CLSID_KSNODE_BDA_PBDA_CAS = &CLSID_KSNODE_BDA_PBDA_CAS_Value;

const CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value = Guid.initString("f2cf2ab3-5b9d-40ae-ab7c-4e7ad0bd1c52");
pub const CLSID_KSNODE_BDA_PBDA_ISDBCAS = &CLSID_KSNODE_BDA_PBDA_ISDBCAS_Value;

const CLSID_KSNODE_BDA_PBDA_TUNER_Value = Guid.initString("aa5e8286-593c-4979-9494-46a2a9dfe076");
pub const CLSID_KSNODE_BDA_PBDA_TUNER = &CLSID_KSNODE_BDA_PBDA_TUNER_Value;

const CLSID_KSNODE_BDA_PBDA_MUX_Value = Guid.initString("f88c7787-6678-4f4b-a13e-da09861d682b");
pub const CLSID_KSNODE_BDA_PBDA_MUX = &CLSID_KSNODE_BDA_PBDA_MUX_Value;

const CLSID_KSNODE_BDA_PBDA_DRM_Value = Guid.initString("9eeebd03-eea1-450f-96ae-633e6de63cce");
pub const CLSID_KSNODE_BDA_PBDA_DRM = &CLSID_KSNODE_BDA_PBDA_DRM_Value;

const CLSID_KSNODE_BDA_DRI_DRM_Value = Guid.initString("4f95ad74-cefb-42d2-94a9-68c5b2c1aabe");
pub const CLSID_KSNODE_BDA_DRI_DRM = &CLSID_KSNODE_BDA_DRI_DRM_Value;

const CLSID_KSNODE_BDA_TS_SELECTOR_Value = Guid.initString("5eddf185-fed1-4f45-9685-bbb73c323cfc");
pub const CLSID_KSNODE_BDA_TS_SELECTOR = &CLSID_KSNODE_BDA_TS_SELECTOR_Value;

const CLSID_PINNAME_IPSINK_INPUT_Value = Guid.initString("3fdffa70-ac9a-11d2-8f17-00c04f7971e2");
pub const CLSID_PINNAME_IPSINK_INPUT = &CLSID_PINNAME_IPSINK_INPUT_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value = Guid.initString("e25f7b8e-cccc-11d2-8f25-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value = Guid.initString("5a9a213c-db08-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_Value;

const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value = Guid.initString("6b891420-db09-11d2-8f32-00c04f7971e2");
pub const CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP = &CLSID_KSDATAFORMAT_SPECIFIER_BDA_IP_Value;

const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value = Guid.initString("dadd5799-7d5b-4b63-80fb-d1442f26b621");
pub const CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_TYPE_BDA_IP_CONTROL_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value = Guid.initString("499856e8-e85b-48ed-9bea-410d0dd4ef81");
pub const CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL = &CLSID_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL_Value;

const CLSID_PINNAME_MPE_Value = Guid.initString("c1b06d73-1dbb-11d3-8f46-00c04f7971e2");
pub const CLSID_PINNAME_MPE = &CLSID_PINNAME_MPE_Value;

const CLSID_KSDATAFORMAT_TYPE_MPE_Value = Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const CLSID_KSDATAFORMAT_TYPE_MPE = &CLSID_KSDATAFORMAT_TYPE_MPE_Value;

const CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value = Guid.initString("143827ab-f77b-498d-81ca-5a007aec28bf");
pub const CLSID_DIGITAL_CABLE_NETWORK_TYPE = &CLSID_DIGITAL_CABLE_NETWORK_TYPE_Value;

const CLSID_ANALOG_TV_NETWORK_TYPE_Value = Guid.initString("b820d87e-e0e3-478f-8a38-4e13f7b3df42");
pub const CLSID_ANALOG_TV_NETWORK_TYPE = &CLSID_ANALOG_TV_NETWORK_TYPE_Value;

const CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value = Guid.initString("742ef867-09e1-40a3-82d3-9669ba35325f");
pub const CLSID_ANALOG_AUXIN_NETWORK_TYPE = &CLSID_ANALOG_AUXIN_NETWORK_TYPE_Value;

const CLSID_ANALOG_FM_NETWORK_TYPE_Value = Guid.initString("7728087b-2bb9-4e30-8078-449476e59dbb");
pub const CLSID_ANALOG_FM_NETWORK_TYPE = &CLSID_ANALOG_FM_NETWORK_TYPE_Value;

const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("95037f6f-3ac7-4452-b6c4-45a9ce9292a2");
pub const CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ISDB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_T_NETWORK_TYPE_Value = Guid.initString("fc3855a6-c901-4f2e-aba8-90815afc6c83");
pub const CLSID_ISDB_T_NETWORK_TYPE = &CLSID_ISDB_T_NETWORK_TYPE_Value;

const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("b0a4e6a0-6a1a-4b83-bb5b-903e1d90e6b6");
pub const CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE = &CLSID_ISDB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ISDB_S_NETWORK_TYPE_Value = Guid.initString("a1e78202-1459-41b1-9ca9-2a92587a42cc");
pub const CLSID_ISDB_S_NETWORK_TYPE = &CLSID_ISDB_S_NETWORK_TYPE_Value;

const CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value = Guid.initString("c974ddb5-41fe-4b25-9741-92f049f1d5d1");
pub const CLSID_ISDB_CABLE_TV_NETWORK_TYPE = &CLSID_ISDB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("93b66fb5-93d4-4323-921c-c1f52df61d3f");
pub const CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE = &CLSID_DIRECT_TV_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("c4f6b31b-c6bf-4759-886f-a7386dca27a0");
pub const CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE = &CLSID_ECHOSTAR_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("0dad2fdd-5fd7-11d3-8f50-00c04f7971e2");
pub const CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_ATSC_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("216c62df-6d7f-4e9a-8571-05f14edb766a");
pub const CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_DVB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value = Guid.initString("9e9e46c6-3aba-4f08-ad0e-cc5ac8148c2b");
pub const CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE = &CLSID_BSKYB_TERRESTRIAL_TV_NETWORK_TYPE_Value;

const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value = Guid.initString("fa4b375a-45b4-4d45-8440-263957b11623");
pub const CLSID_DVB_SATELLITE_TV_NETWORK_TYPE = &CLSID_DVB_SATELLITE_TV_NETWORK_TYPE_Value;

const CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value = Guid.initString("dc0c0fe7-0485-4266-b93f-68fbf80ed834");
pub const CLSID_DVB_CABLE_TV_NETWORK_TYPE = &CLSID_DVB_CABLE_TV_NETWORK_TYPE_Value;

const CLSID_BDA_DEBUG_DATA_AVAILABLE_Value = Guid.initString("69c24f54-9983-497e-b415-282be4c555fb");
pub const CLSID_BDA_DEBUG_DATA_AVAILABLE = &CLSID_BDA_DEBUG_DATA_AVAILABLE_Value;

const CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value = Guid.initString("a806e767-de5c-430c-80bf-a21ebe06c748");
pub const CLSID_BDA_DEBUG_DATA_TYPE_STRING = &CLSID_BDA_DEBUG_DATA_TYPE_STRING_Value;

const CLSID_EVENTID_BDA_IsdbCASResponse_Value = Guid.initString("d4cb1966-41bc-4ced-9a20-fdceac78f70d");
pub const CLSID_EVENTID_BDA_IsdbCASResponse = &CLSID_EVENTID_BDA_IsdbCASResponse_Value;

const CLSID_EVENTID_BDA_CASRequestTuner_Value = Guid.initString("cf39a9d8-f5d3-4685-be57-ed81dba46b27");
pub const CLSID_EVENTID_BDA_CASRequestTuner = &CLSID_EVENTID_BDA_CASRequestTuner_Value;

const CLSID_EVENTID_BDA_CASReleaseTuner_Value = Guid.initString("20c1a16b-441f-49a5-bb5c-e9a04495c6c1");
pub const CLSID_EVENTID_BDA_CASReleaseTuner = &CLSID_EVENTID_BDA_CASReleaseTuner_Value;

const CLSID_EVENTID_BDA_CASOpenMMI_Value = Guid.initString("85dac915-e593-410d-8471-d6812105f28e");
pub const CLSID_EVENTID_BDA_CASOpenMMI = &CLSID_EVENTID_BDA_CASOpenMMI_Value;

const CLSID_EVENTID_BDA_CASCloseMMI_Value = Guid.initString("5d0f550f-de2e-479d-8345-ec0e9557e8a2");
pub const CLSID_EVENTID_BDA_CASCloseMMI = &CLSID_EVENTID_BDA_CASCloseMMI_Value;

const CLSID_EVENTID_BDA_CASBroadcastMMI_Value = Guid.initString("676876f0-1132-404c-a7ca-e72069a9d54f");
pub const CLSID_EVENTID_BDA_CASBroadcastMMI = &CLSID_EVENTID_BDA_CASBroadcastMMI_Value;

const CLSID_EVENTID_BDA_TunerSignalLock_Value = Guid.initString("1872e740-f573-429b-a00e-d9c1e408af09");
pub const CLSID_EVENTID_BDA_TunerSignalLock = &CLSID_EVENTID_BDA_TunerSignalLock_Value;

const CLSID_EVENTID_BDA_TunerNoSignal_Value = Guid.initString("e29b382b-1edd-4930-bc46-682fd72d2dfb");
pub const CLSID_EVENTID_BDA_TunerNoSignal = &CLSID_EVENTID_BDA_TunerNoSignal_Value;

const CLSID_EVENTID_BDA_GPNVValueUpdate_Value = Guid.initString("ff75c68c-f416-4e7e-bf17-6d55c5df1575");
pub const CLSID_EVENTID_BDA_GPNVValueUpdate = &CLSID_EVENTID_BDA_GPNVValueUpdate_Value;

const CLSID_EVENTID_BDA_UpdateDrmStatus_Value = Guid.initString("65a6f681-1462-473b-88ce-cb731427bdb5");
pub const CLSID_EVENTID_BDA_UpdateDrmStatus = &CLSID_EVENTID_BDA_UpdateDrmStatus_Value;

const CLSID_EVENTID_BDA_UpdateScanState_Value = Guid.initString("55702b50-7b49-42b8-a82f-4afb691b0628");
pub const CLSID_EVENTID_BDA_UpdateScanState = &CLSID_EVENTID_BDA_UpdateScanState_Value;

const CLSID_EVENTID_BDA_GuideDataAvailable_Value = Guid.initString("98db717a-478a-4cd4-92d0-95f66b89e5b1");
pub const CLSID_EVENTID_BDA_GuideDataAvailable = &CLSID_EVENTID_BDA_GuideDataAvailable_Value;

const CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value = Guid.initString("a1c3ea2b-175f-4458-b735-507d22db23a6");
pub const CLSID_EVENTID_BDA_GuideServiceInformationUpdated = &CLSID_EVENTID_BDA_GuideServiceInformationUpdated_Value;

const CLSID_EVENTID_BDA_GuideDataError_Value = Guid.initString("ac33c448-6f73-4fd7-b341-594c360d8d74");
pub const CLSID_EVENTID_BDA_GuideDataError = &CLSID_EVENTID_BDA_GuideDataError_Value;

const CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value = Guid.initString("efa628f8-1f2c-4b67-9ea5-acf6fa9a1f36");
pub const CLSID_EVENTID_BDA_DiseqCResponseAvailable = &CLSID_EVENTID_BDA_DiseqCResponseAvailable_Value;

const CLSID_EVENTID_BDA_LbigsOpenConnection_Value = Guid.initString("356207b2-6f31-4eb0-a271-b3fa6bb7680f");
pub const CLSID_EVENTID_BDA_LbigsOpenConnection = &CLSID_EVENTID_BDA_LbigsOpenConnection_Value;

const CLSID_EVENTID_BDA_LbigsSendData_Value = Guid.initString("1123277b-f1c6-4154-8b0d-48e6157059aa");
pub const CLSID_EVENTID_BDA_LbigsSendData = &CLSID_EVENTID_BDA_LbigsSendData_Value;

const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value = Guid.initString("c2f08b99-65ef-4314-9671-e99d4cce0bae");
pub const CLSID_EVENTID_BDA_LbigsCloseConnectionHandle = &CLSID_EVENTID_BDA_LbigsCloseConnectionHandle_Value;

const CLSID_EVENTID_BDA_EncoderSignalLock_Value = Guid.initString("5ec90eb9-39fa-4cfc-b93f-00bb11077f5e");
pub const CLSID_EVENTID_BDA_EncoderSignalLock = &CLSID_EVENTID_BDA_EncoderSignalLock_Value;

const CLSID_EVENTID_BDA_FdcStatus_Value = Guid.initString("05f25366-d0eb-43d2-bc3c-682b863df142");
pub const CLSID_EVENTID_BDA_FdcStatus = &CLSID_EVENTID_BDA_FdcStatus_Value;

const CLSID_EVENTID_BDA_FdcTableSection_Value = Guid.initString("6a0cd757-4ce3-4e5b-9444-7187b87152c5");
pub const CLSID_EVENTID_BDA_FdcTableSection = &CLSID_EVENTID_BDA_FdcTableSection_Value;

const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value = Guid.initString("c40f9f85-09d0-489c-9e9c-0abbb56951b0");
pub const CLSID_EVENTID_BDA_TransprtStreamSelectorInfo = &CLSID_EVENTID_BDA_TransprtStreamSelectorInfo_Value;

const CLSID_EVENTID_BDA_RatingPinReset_Value = Guid.initString("c6e048c0-c574-4c26-bcda-2f4d35eb5e85");
pub const CLSID_EVENTID_BDA_RatingPinReset = &CLSID_EVENTID_BDA_RatingPinReset_Value;

const CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value = Guid.initString("1e1d7141-583f-4ac2-b019-1f430eda0f4c");
pub const CLSID_PBDA_ALWAYS_TUNE_IN_MUX = &CLSID_PBDA_ALWAYS_TUNE_IN_MUX_Value;

pub const PID_BITS = extern struct {
    _bitfield: u16 align(1),
};

pub const MPEG_HEADER_BITS = extern struct {
    _bitfield: u16 align(1),
};

pub const MPEG_HEADER_VERSION_BITS = extern struct {
    _bitfield: u8,
};

const CLSID_BDANETWORKTYPE_ATSC_Value = Guid.initString("71985f51-1ca1-11d3-9cc8-00c04f7971e0");
pub const CLSID_BDANETWORKTYPE_ATSC = &CLSID_BDANETWORKTYPE_ATSC_Value;


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (59)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../zig.zig").Guid;
const AM_MEDIA_TYPE = @import("../../../../windows/win32/media/media_foundation.zig").AM_MEDIA_TYPE;
const AnalogVideoStandard = @import("../../../../windows/win32/media/direct_show.zig").AnalogVideoStandard;
const BinaryConvolutionCodeRate = @import("../../../../windows/win32/media/direct_show.zig").BinaryConvolutionCodeRate;
const BOOL = @import("../../../../windows/win32/foundation.zig").BOOL;
const BSTR = @import("../../../../windows/win32/foundation.zig").BSTR;
const CHAR = @import("../../../../windows/win32/foundation.zig").CHAR;
const ComponentCategory = @import("../../../../windows/win32/media/direct_show.zig").ComponentCategory;
const ComponentStatus = @import("../../../../windows/win32/media/direct_show.zig").ComponentStatus;
const DVBSystemType = @import("../../../../windows/win32/media/direct_show.zig").DVBSystemType;
const FECMethod = @import("../../../../windows/win32/media/direct_show.zig").FECMethod;
const GuardInterval = @import("../../../../windows/win32/media/direct_show.zig").GuardInterval;
const HANDLE = @import("../../../../windows/win32/foundation.zig").HANDLE;
const HDC = @import("../../../../windows/win32/graphics/gdi.zig").HDC;
const HierarchyAlpha = @import("../../../../windows/win32/media/direct_show.zig").HierarchyAlpha;
const HKEY = @import("../../../../windows/win32/system/registry.zig").HKEY;
const HRESULT = @import("../../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../../windows/win32/foundation.zig").HWND;
const IDispatch = @import("../../../../windows/win32/system/com.zig").IDispatch;
const IEnumFilters = @import("../../../../windows/win32/media/direct_show.zig").IEnumFilters;
const IEnumGUID = @import("../../../../windows/win32/system/com.zig").IEnumGUID;
const IEnumMoniker = @import("../../../../windows/win32/system/com.zig").IEnumMoniker;
const IEnumVARIANT = @import("../../../../windows/win32/system/ole.zig").IEnumVARIANT;
const IESEvent = @import("../../../../windows/win32/media/direct_show.zig").IESEvent;
const IESEvents = @import("../../../../windows/win32/media/direct_show.zig").IESEvents;
const IFilterGraph = @import("../../../../windows/win32/media/direct_show.zig").IFilterGraph;
const IGraphBuilder = @import("../../../../windows/win32/media/direct_show.zig").IGraphBuilder;
const IMediaSeeking = @import("../../../../windows/win32/media/direct_show.zig").IMediaSeeking;
const IMFVideoPresenter = @import("../../../../windows/win32/media/media_foundation.zig").IMFVideoPresenter;
const IPersist = @import("../../../../windows/win32/system/com.zig").IPersist;
const IPictureDisp = @import("../../../../windows/win32/system/ole.zig").IPictureDisp;
const IPin = @import("../../../../windows/win32/media/direct_show.zig").IPin;
const IUnknown = @import("../../../../windows/win32/system/com.zig").IUnknown;
const IVMRImageCompositor = @import("../../../../windows/win32/media/direct_show.zig").IVMRImageCompositor;
const IVMRMixerBitmap = @import("../../../../windows/win32/media/direct_show.zig").IVMRMixerBitmap;
const IVMRSurfaceAllocator = @import("../../../../windows/win32/media/direct_show.zig").IVMRSurfaceAllocator;
const KSDATAFORMAT = @import("../../../../windows/win32/media/kernel_streaming.zig").KSDATAFORMAT;
const KSEVENTDATA = @import("../../../../windows/win32/media/kernel_streaming.zig").KSEVENTDATA;
const KSIDENTIFIER = @import("../../../../windows/win32/media/kernel_streaming.zig").KSIDENTIFIER;
const KSM_NODE = @import("../../../../windows/win32/media/kernel_streaming.zig").KSM_NODE;
const KSP_NODE = @import("../../../../windows/win32/media/kernel_streaming.zig").KSP_NODE;
const LNB_Source = @import("../../../../windows/win32/media/direct_show.zig").LNB_Source;
const ModulationType = @import("../../../../windows/win32/media/direct_show.zig").ModulationType;
const MPEG2StreamType = @import("../../../../windows/win32/media/direct_show.zig").MPEG2StreamType;
const Pilot = @import("../../../../windows/win32/media/direct_show.zig").Pilot;
const Polarisation = @import("../../../../windows/win32/media/direct_show.zig").Polarisation;
const PSID = @import("../../../../windows/win32/foundation.zig").PSID;
const PWSTR = @import("../../../../windows/win32/foundation.zig").PWSTR;
const RECT = @import("../../../../windows/win32/foundation.zig").RECT;
const RollOff = @import("../../../../windows/win32/media/direct_show.zig").RollOff;
const SAFEARRAY = @import("../../../../windows/win32/system/com.zig").SAFEARRAY;
const SIZE = @import("../../../../windows/win32/foundation.zig").SIZE;
const SpectralInversion = @import("../../../../windows/win32/media/direct_show.zig").SpectralInversion;
const TransmissionMode = @import("../../../../windows/win32/media/direct_show.zig").TransmissionMode;
const TunerInputType = @import("../../../../windows/win32/media/direct_show.zig").TunerInputType;
const TVAudioMode = @import("../../../../windows/win32/media/direct_show.zig").TVAudioMode;
const VARIANT = @import("../../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../../windows/win32/foundation.zig").VARIANT_BOOL;
const VMRALPHABITMAP = @import("../../../../windows/win32/media/direct_show.zig").VMRALPHABITMAP;

test {
    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
