//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (88)
//--------------------------------------------------------------------------------
pub const COR_IL_MAP = extern struct {
    oldOffset: u32,
    newOffset: u32,
    fAccurate: BOOL,
};

pub const CorDebugIlToNativeMappingTypes = enum(i32) {
    NO_MAPPING = -1,
    PROLOG = -2,
    EPILOG = -3,
};
pub const NO_MAPPING = CorDebugIlToNativeMappingTypes.NO_MAPPING;
pub const PROLOG = CorDebugIlToNativeMappingTypes.PROLOG;
pub const EPILOG = CorDebugIlToNativeMappingTypes.EPILOG;

pub const COR_DEBUG_IL_TO_NATIVE_MAP = extern struct {
    ilOffset: u32,
    nativeStartOffset: u32,
    nativeEndOffset: u32,
};

pub const FunctionIDOrClientID = extern union {
    functionID: usize,
    clientID: usize,
};

pub const FunctionIDMapper = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        pbHookFunction: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn(
        funcId: usize,
        pbHookFunction: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) usize,
} ;

pub const FunctionIDMapper2 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        clientData: ?*anyopaque,
        pbHookFunction: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn(
        funcId: usize,
        clientData: ?*anyopaque,
        pbHookFunction: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) usize,
} ;

pub const COR_PRF_SNAPSHOT_INFO = enum(i32) {
    DEFAULT = 0,
    REGISTER_CONTEXT = 1,
    X86_OPTIMIZED = 2,
};
pub const COR_PRF_SNAPSHOT_DEFAULT = COR_PRF_SNAPSHOT_INFO.DEFAULT;
pub const COR_PRF_SNAPSHOT_REGISTER_CONTEXT = COR_PRF_SNAPSHOT_INFO.REGISTER_CONTEXT;
pub const COR_PRF_SNAPSHOT_X86_OPTIMIZED = COR_PRF_SNAPSHOT_INFO.X86_OPTIMIZED;

pub const COR_PRF_FUNCTION_ARGUMENT_RANGE = extern struct {
    startAddress: usize,
    length: u32,
};

pub const COR_PRF_FUNCTION_ARGUMENT_INFO = extern struct {
    numRanges: u32,
    totalArgumentSize: u32,
    ranges: [1]COR_PRF_FUNCTION_ARGUMENT_RANGE,
};

pub const COR_PRF_CODE_INFO = extern struct {
    startAddress: usize,
    size: usize,
};

pub const COR_PRF_STATIC_TYPE = enum(i32) {
    NOT_A_STATIC = 0,
    APP_DOMAIN_STATIC = 1,
    THREAD_STATIC = 2,
    CONTEXT_STATIC = 4,
    RVA_STATIC = 8,
};
pub const COR_PRF_FIELD_NOT_A_STATIC = COR_PRF_STATIC_TYPE.NOT_A_STATIC;
pub const COR_PRF_FIELD_APP_DOMAIN_STATIC = COR_PRF_STATIC_TYPE.APP_DOMAIN_STATIC;
pub const COR_PRF_FIELD_THREAD_STATIC = COR_PRF_STATIC_TYPE.THREAD_STATIC;
pub const COR_PRF_FIELD_CONTEXT_STATIC = COR_PRF_STATIC_TYPE.CONTEXT_STATIC;
pub const COR_PRF_FIELD_RVA_STATIC = COR_PRF_STATIC_TYPE.RVA_STATIC;

pub const COR_PRF_FUNCTION = extern struct {
    functionId: usize,
    reJitId: usize,
};

pub const COR_PRF_ASSEMBLY_REFERENCE_INFO = extern struct {
    pbPublicKeyOrToken: ?*anyopaque,
    cbPublicKeyOrToken: u32,
    szName: ?[*:0]align(1) const u16,
    pMetaData: ?*ASSEMBLYMETADATA,
    pbHashValue: ?*anyopaque,
    cbHashValue: u32,
    dwAssemblyRefFlags: u32,
};

pub const COR_PRF_METHOD = extern struct {
    moduleId: usize,
    methodId: u32,
};

pub const FunctionEnter = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionLeave = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionTailcall = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcID: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionEnter2 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        clientData: usize,
        func: usize,
        argumentInfo: ?*COR_PRF_FUNCTION_ARGUMENT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcId: usize,
        clientData: usize,
        func: usize,
        argumentInfo: ?*COR_PRF_FUNCTION_ARGUMENT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionLeave2 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        clientData: usize,
        func: usize,
        retvalRange: ?*COR_PRF_FUNCTION_ARGUMENT_RANGE,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcId: usize,
        clientData: usize,
        func: usize,
        retvalRange: ?*COR_PRF_FUNCTION_ARGUMENT_RANGE,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionTailcall2 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        clientData: usize,
        func: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        funcId: usize,
        clientData: usize,
        func: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionEnter3 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionLeave3 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionTailcall3 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionEnter3WithInfo = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionLeave3WithInfo = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const FunctionTailcall3WithInfo = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        functionIDOrClientID: FunctionIDOrClientID,
        eltInfo: usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const StackSnapshotCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        funcId: usize,
        ip: usize,
        frameInfo: usize,
        contextSize: u32,
        context: ?*u8,
        clientData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        funcId: usize,
        ip: usize,
        frameInfo: usize,
        contextSize: u32,
        context: ?*u8,
        clientData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const ObjectReferenceCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        root: usize,
        reference: ?*usize,
        clientData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        root: usize,
        reference: ?*usize,
        clientData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const COR_PRF_MONITOR = enum(i32) {
    MONITOR_NONE = 0,
    MONITOR_FUNCTION_UNLOADS = 1,
    MONITOR_CLASS_LOADS = 2,
    MONITOR_MODULE_LOADS = 4,
    MONITOR_ASSEMBLY_LOADS = 8,
    MONITOR_APPDOMAIN_LOADS = 16,
    MONITOR_JIT_COMPILATION = 32,
    MONITOR_EXCEPTIONS = 64,
    MONITOR_GC = 128,
    MONITOR_OBJECT_ALLOCATED = 256,
    MONITOR_THREADS = 512,
    MONITOR_REMOTING = 1024,
    MONITOR_CODE_TRANSITIONS = 2048,
    MONITOR_ENTERLEAVE = 4096,
    MONITOR_CCW = 8192,
    MONITOR_REMOTING_COOKIE = 17408,
    MONITOR_REMOTING_ASYNC = 33792,
    MONITOR_SUSPENDS = 65536,
    MONITOR_CACHE_SEARCHES = 131072,
    ENABLE_REJIT = 262144,
    ENABLE_INPROC_DEBUGGING = 524288,
    ENABLE_JIT_MAPS = 1048576,
    DISABLE_INLINING = 2097152,
    DISABLE_OPTIMIZATIONS = 4194304,
    ENABLE_OBJECT_ALLOCATED = 8388608,
    MONITOR_CLR_EXCEPTIONS = 16777216,
    MONITOR_ALL = 17301503,
    ENABLE_FUNCTION_ARGS = 33554432,
    ENABLE_FUNCTION_RETVAL = 67108864,
    ENABLE_FRAME_INFO = 134217728,
    ENABLE_STACK_SNAPSHOT = 268435456,
    USE_PROFILE_IMAGES = 536870912,
    DISABLE_TRANSPARENCY_CHECKS_UNDER_FULL_TRUST = 1073741824,
    DISABLE_ALL_NGEN_IMAGES = -2147483648,
    ALL = -1879048193,
    REQUIRE_PROFILE_IMAGE = 536877056,
    ALLOWABLE_AFTER_ATTACH = 268763902,
    ALLOWABLE_NOTIFICATION_PROFILER = -1310512257,
    MONITOR_IMMUTABLE = -285684736,
};
pub const COR_PRF_MONITOR_NONE = COR_PRF_MONITOR.MONITOR_NONE;
pub const COR_PRF_MONITOR_FUNCTION_UNLOADS = COR_PRF_MONITOR.MONITOR_FUNCTION_UNLOADS;
pub const COR_PRF_MONITOR_CLASS_LOADS = COR_PRF_MONITOR.MONITOR_CLASS_LOADS;
pub const COR_PRF_MONITOR_MODULE_LOADS = COR_PRF_MONITOR.MONITOR_MODULE_LOADS;
pub const COR_PRF_MONITOR_ASSEMBLY_LOADS = COR_PRF_MONITOR.MONITOR_ASSEMBLY_LOADS;
pub const COR_PRF_MONITOR_APPDOMAIN_LOADS = COR_PRF_MONITOR.MONITOR_APPDOMAIN_LOADS;
pub const COR_PRF_MONITOR_JIT_COMPILATION = COR_PRF_MONITOR.MONITOR_JIT_COMPILATION;
pub const COR_PRF_MONITOR_EXCEPTIONS = COR_PRF_MONITOR.MONITOR_EXCEPTIONS;
pub const COR_PRF_MONITOR_GC = COR_PRF_MONITOR.MONITOR_GC;
pub const COR_PRF_MONITOR_OBJECT_ALLOCATED = COR_PRF_MONITOR.MONITOR_OBJECT_ALLOCATED;
pub const COR_PRF_MONITOR_THREADS = COR_PRF_MONITOR.MONITOR_THREADS;
pub const COR_PRF_MONITOR_REMOTING = COR_PRF_MONITOR.MONITOR_REMOTING;
pub const COR_PRF_MONITOR_CODE_TRANSITIONS = COR_PRF_MONITOR.MONITOR_CODE_TRANSITIONS;
pub const COR_PRF_MONITOR_ENTERLEAVE = COR_PRF_MONITOR.MONITOR_ENTERLEAVE;
pub const COR_PRF_MONITOR_CCW = COR_PRF_MONITOR.MONITOR_CCW;
pub const COR_PRF_MONITOR_REMOTING_COOKIE = COR_PRF_MONITOR.MONITOR_REMOTING_COOKIE;
pub const COR_PRF_MONITOR_REMOTING_ASYNC = COR_PRF_MONITOR.MONITOR_REMOTING_ASYNC;
pub const COR_PRF_MONITOR_SUSPENDS = COR_PRF_MONITOR.MONITOR_SUSPENDS;
pub const COR_PRF_MONITOR_CACHE_SEARCHES = COR_PRF_MONITOR.MONITOR_CACHE_SEARCHES;
pub const COR_PRF_ENABLE_REJIT = COR_PRF_MONITOR.ENABLE_REJIT;
pub const COR_PRF_ENABLE_INPROC_DEBUGGING = COR_PRF_MONITOR.ENABLE_INPROC_DEBUGGING;
pub const COR_PRF_ENABLE_JIT_MAPS = COR_PRF_MONITOR.ENABLE_JIT_MAPS;
pub const COR_PRF_DISABLE_INLINING = COR_PRF_MONITOR.DISABLE_INLINING;
pub const COR_PRF_DISABLE_OPTIMIZATIONS = COR_PRF_MONITOR.DISABLE_OPTIMIZATIONS;
pub const COR_PRF_ENABLE_OBJECT_ALLOCATED = COR_PRF_MONITOR.ENABLE_OBJECT_ALLOCATED;
pub const COR_PRF_MONITOR_CLR_EXCEPTIONS = COR_PRF_MONITOR.MONITOR_CLR_EXCEPTIONS;
pub const COR_PRF_MONITOR_ALL = COR_PRF_MONITOR.MONITOR_ALL;
pub const COR_PRF_ENABLE_FUNCTION_ARGS = COR_PRF_MONITOR.ENABLE_FUNCTION_ARGS;
pub const COR_PRF_ENABLE_FUNCTION_RETVAL = COR_PRF_MONITOR.ENABLE_FUNCTION_RETVAL;
pub const COR_PRF_ENABLE_FRAME_INFO = COR_PRF_MONITOR.ENABLE_FRAME_INFO;
pub const COR_PRF_ENABLE_STACK_SNAPSHOT = COR_PRF_MONITOR.ENABLE_STACK_SNAPSHOT;
pub const COR_PRF_USE_PROFILE_IMAGES = COR_PRF_MONITOR.USE_PROFILE_IMAGES;
pub const COR_PRF_DISABLE_TRANSPARENCY_CHECKS_UNDER_FULL_TRUST = COR_PRF_MONITOR.DISABLE_TRANSPARENCY_CHECKS_UNDER_FULL_TRUST;
pub const COR_PRF_DISABLE_ALL_NGEN_IMAGES = COR_PRF_MONITOR.DISABLE_ALL_NGEN_IMAGES;
pub const COR_PRF_ALL = COR_PRF_MONITOR.ALL;
pub const COR_PRF_REQUIRE_PROFILE_IMAGE = COR_PRF_MONITOR.REQUIRE_PROFILE_IMAGE;
pub const COR_PRF_ALLOWABLE_AFTER_ATTACH = COR_PRF_MONITOR.ALLOWABLE_AFTER_ATTACH;
pub const COR_PRF_ALLOWABLE_NOTIFICATION_PROFILER = COR_PRF_MONITOR.ALLOWABLE_NOTIFICATION_PROFILER;
pub const COR_PRF_MONITOR_IMMUTABLE = COR_PRF_MONITOR.MONITOR_IMMUTABLE;

pub const COR_PRF_HIGH_MONITOR = enum(i32) {
    MONITOR_NONE = 0,
    ADD_ASSEMBLY_REFERENCES = 1,
    IN_MEMORY_SYMBOLS_UPDATED = 2,
    MONITOR_DYNAMIC_FUNCTION_UNLOADS = 4,
    DISABLE_TIERED_COMPILATION = 8,
    BASIC_GC = 16,
    MONITOR_GC_MOVED_OBJECTS = 32,
    // REQUIRE_PROFILE_IMAGE = 0, this enum value conflicts with MONITOR_NONE
    MONITOR_LARGEOBJECT_ALLOCATED = 64,
    MONITOR_EVENT_PIPE = 128,
    MONITOR_PINNEDOBJECT_ALLOCATED = 256,
    ALLOWABLE_AFTER_ATTACH = 246,
    ALLOWABLE_NOTIFICATION_PROFILER = 254,
    // MONITOR_IMMUTABLE = 8, this enum value conflicts with DISABLE_TIERED_COMPILATION
};
pub const COR_PRF_HIGH_MONITOR_NONE = COR_PRF_HIGH_MONITOR.MONITOR_NONE;
pub const COR_PRF_HIGH_ADD_ASSEMBLY_REFERENCES = COR_PRF_HIGH_MONITOR.ADD_ASSEMBLY_REFERENCES;
pub const COR_PRF_HIGH_IN_MEMORY_SYMBOLS_UPDATED = COR_PRF_HIGH_MONITOR.IN_MEMORY_SYMBOLS_UPDATED;
pub const COR_PRF_HIGH_MONITOR_DYNAMIC_FUNCTION_UNLOADS = COR_PRF_HIGH_MONITOR.MONITOR_DYNAMIC_FUNCTION_UNLOADS;
pub const COR_PRF_HIGH_DISABLE_TIERED_COMPILATION = COR_PRF_HIGH_MONITOR.DISABLE_TIERED_COMPILATION;
pub const COR_PRF_HIGH_BASIC_GC = COR_PRF_HIGH_MONITOR.BASIC_GC;
pub const COR_PRF_HIGH_MONITOR_GC_MOVED_OBJECTS = COR_PRF_HIGH_MONITOR.MONITOR_GC_MOVED_OBJECTS;
pub const COR_PRF_HIGH_REQUIRE_PROFILE_IMAGE = COR_PRF_HIGH_MONITOR.MONITOR_NONE;
pub const COR_PRF_HIGH_MONITOR_LARGEOBJECT_ALLOCATED = COR_PRF_HIGH_MONITOR.MONITOR_LARGEOBJECT_ALLOCATED;
pub const COR_PRF_HIGH_MONITOR_EVENT_PIPE = COR_PRF_HIGH_MONITOR.MONITOR_EVENT_PIPE;
pub const COR_PRF_HIGH_MONITOR_PINNEDOBJECT_ALLOCATED = COR_PRF_HIGH_MONITOR.MONITOR_PINNEDOBJECT_ALLOCATED;
pub const COR_PRF_HIGH_ALLOWABLE_AFTER_ATTACH = COR_PRF_HIGH_MONITOR.ALLOWABLE_AFTER_ATTACH;
pub const COR_PRF_HIGH_ALLOWABLE_NOTIFICATION_PROFILER = COR_PRF_HIGH_MONITOR.ALLOWABLE_NOTIFICATION_PROFILER;
pub const COR_PRF_HIGH_MONITOR_IMMUTABLE = COR_PRF_HIGH_MONITOR.DISABLE_TIERED_COMPILATION;

pub const COR_PRF_MISC = enum(i32) {
    PARENT_UNKNOWN = -3,
    GLOBAL_CLASS = -2,
    GLOBAL_MODULE = -1,
};
pub const PROFILER_PARENT_UNKNOWN = COR_PRF_MISC.PARENT_UNKNOWN;
pub const PROFILER_GLOBAL_CLASS = COR_PRF_MISC.GLOBAL_CLASS;
pub const PROFILER_GLOBAL_MODULE = COR_PRF_MISC.GLOBAL_MODULE;

pub const COR_PRF_JIT_CACHE = enum(i32) {
    FOUND = 0,
    NOT_FOUND = 1,
};
pub const COR_PRF_CACHED_FUNCTION_FOUND = COR_PRF_JIT_CACHE.FOUND;
pub const COR_PRF_CACHED_FUNCTION_NOT_FOUND = COR_PRF_JIT_CACHE.NOT_FOUND;

pub const COR_PRF_TRANSITION_REASON = enum(i32) {
    CALL = 0,
    RETURN = 1,
};
pub const COR_PRF_TRANSITION_CALL = COR_PRF_TRANSITION_REASON.CALL;
pub const COR_PRF_TRANSITION_RETURN = COR_PRF_TRANSITION_REASON.RETURN;

pub const COR_PRF_SUSPEND_REASON = enum(i32) {
    OTHER = 0,
    FOR_GC = 1,
    FOR_APPDOMAIN_SHUTDOWN = 2,
    FOR_CODE_PITCHING = 3,
    FOR_SHUTDOWN = 4,
    FOR_INPROC_DEBUGGER = 6,
    FOR_GC_PREP = 7,
    FOR_REJIT = 8,
    FOR_PROFILER = 9,
};
pub const COR_PRF_SUSPEND_OTHER = COR_PRF_SUSPEND_REASON.OTHER;
pub const COR_PRF_SUSPEND_FOR_GC = COR_PRF_SUSPEND_REASON.FOR_GC;
pub const COR_PRF_SUSPEND_FOR_APPDOMAIN_SHUTDOWN = COR_PRF_SUSPEND_REASON.FOR_APPDOMAIN_SHUTDOWN;
pub const COR_PRF_SUSPEND_FOR_CODE_PITCHING = COR_PRF_SUSPEND_REASON.FOR_CODE_PITCHING;
pub const COR_PRF_SUSPEND_FOR_SHUTDOWN = COR_PRF_SUSPEND_REASON.FOR_SHUTDOWN;
pub const COR_PRF_SUSPEND_FOR_INPROC_DEBUGGER = COR_PRF_SUSPEND_REASON.FOR_INPROC_DEBUGGER;
pub const COR_PRF_SUSPEND_FOR_GC_PREP = COR_PRF_SUSPEND_REASON.FOR_GC_PREP;
pub const COR_PRF_SUSPEND_FOR_REJIT = COR_PRF_SUSPEND_REASON.FOR_REJIT;
pub const COR_PRF_SUSPEND_FOR_PROFILER = COR_PRF_SUSPEND_REASON.FOR_PROFILER;

pub const COR_PRF_RUNTIME_TYPE = enum(i32) {
    DESKTOP_CLR = 1,
    CORE_CLR = 2,
};
pub const COR_PRF_DESKTOP_CLR = COR_PRF_RUNTIME_TYPE.DESKTOP_CLR;
pub const COR_PRF_CORE_CLR = COR_PRF_RUNTIME_TYPE.CORE_CLR;

pub const COR_PRF_REJIT_FLAGS = enum(i32) {
    BLOCK_INLINING = 1,
    INLINING_CALLBACKS = 2,
};
pub const COR_PRF_REJIT_BLOCK_INLINING = COR_PRF_REJIT_FLAGS.BLOCK_INLINING;
pub const COR_PRF_REJIT_INLINING_CALLBACKS = COR_PRF_REJIT_FLAGS.INLINING_CALLBACKS;

pub const COR_PRF_EVENTPIPE_PARAM_TYPE = enum(i32) {
    OBJECT = 1,
    BOOLEAN = 3,
    CHAR = 4,
    SBYTE = 5,
    BYTE = 6,
    INT16 = 7,
    UINT16 = 8,
    INT32 = 9,
    UINT32 = 10,
    INT64 = 11,
    UINT64 = 12,
    SINGLE = 13,
    DOUBLE = 14,
    DECIMAL = 15,
    DATETIME = 16,
    GUID = 17,
    STRING = 18,
    ARRAY = 19,
};
pub const COR_PRF_EVENTPIPE_OBJECT = COR_PRF_EVENTPIPE_PARAM_TYPE.OBJECT;
pub const COR_PRF_EVENTPIPE_BOOLEAN = COR_PRF_EVENTPIPE_PARAM_TYPE.BOOLEAN;
pub const COR_PRF_EVENTPIPE_CHAR = COR_PRF_EVENTPIPE_PARAM_TYPE.CHAR;
pub const COR_PRF_EVENTPIPE_SBYTE = COR_PRF_EVENTPIPE_PARAM_TYPE.SBYTE;
pub const COR_PRF_EVENTPIPE_BYTE = COR_PRF_EVENTPIPE_PARAM_TYPE.BYTE;
pub const COR_PRF_EVENTPIPE_INT16 = COR_PRF_EVENTPIPE_PARAM_TYPE.INT16;
pub const COR_PRF_EVENTPIPE_UINT16 = COR_PRF_EVENTPIPE_PARAM_TYPE.UINT16;
pub const COR_PRF_EVENTPIPE_INT32 = COR_PRF_EVENTPIPE_PARAM_TYPE.INT32;
pub const COR_PRF_EVENTPIPE_UINT32 = COR_PRF_EVENTPIPE_PARAM_TYPE.UINT32;
pub const COR_PRF_EVENTPIPE_INT64 = COR_PRF_EVENTPIPE_PARAM_TYPE.INT64;
pub const COR_PRF_EVENTPIPE_UINT64 = COR_PRF_EVENTPIPE_PARAM_TYPE.UINT64;
pub const COR_PRF_EVENTPIPE_SINGLE = COR_PRF_EVENTPIPE_PARAM_TYPE.SINGLE;
pub const COR_PRF_EVENTPIPE_DOUBLE = COR_PRF_EVENTPIPE_PARAM_TYPE.DOUBLE;
pub const COR_PRF_EVENTPIPE_DECIMAL = COR_PRF_EVENTPIPE_PARAM_TYPE.DECIMAL;
pub const COR_PRF_EVENTPIPE_DATETIME = COR_PRF_EVENTPIPE_PARAM_TYPE.DATETIME;
pub const COR_PRF_EVENTPIPE_GUID = COR_PRF_EVENTPIPE_PARAM_TYPE.GUID;
pub const COR_PRF_EVENTPIPE_STRING = COR_PRF_EVENTPIPE_PARAM_TYPE.STRING;
pub const COR_PRF_EVENTPIPE_ARRAY = COR_PRF_EVENTPIPE_PARAM_TYPE.ARRAY;

pub const COR_PRF_EVENTPIPE_LEVEL = enum(i32) {
    LOGALWAYS = 0,
    CRITICAL = 1,
    ERROR = 2,
    WARNING = 3,
    INFORMATIONAL = 4,
    VERBOSE = 5,
};
pub const COR_PRF_EVENTPIPE_LOGALWAYS = COR_PRF_EVENTPIPE_LEVEL.LOGALWAYS;
pub const COR_PRF_EVENTPIPE_CRITICAL = COR_PRF_EVENTPIPE_LEVEL.CRITICAL;
pub const COR_PRF_EVENTPIPE_ERROR = COR_PRF_EVENTPIPE_LEVEL.ERROR;
pub const COR_PRF_EVENTPIPE_WARNING = COR_PRF_EVENTPIPE_LEVEL.WARNING;
pub const COR_PRF_EVENTPIPE_INFORMATIONAL = COR_PRF_EVENTPIPE_LEVEL.INFORMATIONAL;
pub const COR_PRF_EVENTPIPE_VERBOSE = COR_PRF_EVENTPIPE_LEVEL.VERBOSE;

pub const COR_PRF_EVENTPIPE_PROVIDER_CONFIG = extern struct {
    providerName: ?[*:0]align(1) const u16,
    keywords: u64,
    loggingLevel: u32,
    filterData: ?[*:0]align(1) const u16,
};

pub const COR_PRF_EVENTPIPE_PARAM_DESC = extern struct {
    type: u32,
    elementType: u32,
    name: ?[*:0]align(1) const u16,
};

pub const COR_PRF_EVENT_DATA = extern struct {
    ptr: u64,
    size: u32,
    reserved: u32,
};

pub const COR_PRF_FILTER_DATA = extern struct {
    Ptr: u64,
    Size: u32,
    Type: u32,
};

pub const EventPipeProviderCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        source_id: ?*const u8,
        is_enabled: u32,
        level: u8,
        match_any_keywords: u64,
        match_all_keywords: u64,
        filter_data: ?*COR_PRF_FILTER_DATA,
        callback_data: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        source_id: ?*const u8,
        is_enabled: u32,
        level: u8,
        match_any_keywords: u64,
        match_all_keywords: u64,
        filter_data: ?*COR_PRF_FILTER_DATA,
        callback_data: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const COR_PRF_HANDLE_TYPE = enum(i32) {
    WEAK = 1,
    STRONG = 2,
    PINNED = 3,
};
pub const COR_PRF_HANDLE_TYPE_WEAK = COR_PRF_HANDLE_TYPE.WEAK;
pub const COR_PRF_HANDLE_TYPE_STRONG = COR_PRF_HANDLE_TYPE.STRONG;
pub const COR_PRF_HANDLE_TYPE_PINNED = COR_PRF_HANDLE_TYPE.PINNED;

const IID_ICorProfilerCallback_Value = Guid.initString("176fbed1-a55c-4796-98ca-a9da0ef883e7");
pub const IID_ICorProfilerCallback = &IID_ICorProfilerCallback_Value;
pub const ICorProfilerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                pICorProfilerInfoUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                pICorProfilerInfoUnk: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Shutdown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppDomainCreationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppDomainCreationFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppDomainShutdownStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppDomainShutdownFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                appDomainId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssemblyLoadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssemblyLoadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssemblyUnloadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssemblyUnloadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                assemblyId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModuleLoadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModuleLoadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModuleUnloadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModuleUnloadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ModuleAttachedToAssembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                AssemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                moduleId: usize,
                AssemblyId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClassLoadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClassLoadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                classId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                classId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClassUnloadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClassUnloadFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                classId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                classId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FunctionUnloadStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITCompilationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITCompilationFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITCachedFunctionSearchStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                pbUseCachedFunction: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                pbUseCachedFunction: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITCachedFunctionSearchFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                result: COR_PRF_JIT_CACHE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                result: COR_PRF_JIT_CACHE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITFunctionPitched: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JITInlining: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                callerId: usize,
                calleeId: usize,
                pfShouldInline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                callerId: usize,
                calleeId: usize,
                pfShouldInline: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThreadCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThreadDestroyed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ThreadAssignedToOSThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                managedThreadId: usize,
                osThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                managedThreadId: usize,
                osThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingClientInvocationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingClientSendingMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingClientReceivingReply: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingClientInvocationFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingServerReceivingMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingServerInvocationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingServerInvocationReturned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemotingServerSendingReply: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                pCookie: ?*Guid,
                fIsAsync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnmanagedToManagedTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                reason: COR_PRF_TRANSITION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                reason: COR_PRF_TRANSITION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ManagedToUnmanagedTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                reason: COR_PRF_TRANSITION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                reason: COR_PRF_TRANSITION_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeSuspendStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                suspendReason: COR_PRF_SUSPEND_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                suspendReason: COR_PRF_SUSPEND_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeSuspendFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeSuspendAborted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeResumeStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeResumeFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeThreadSuspended: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RuntimeThreadResumed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                threadId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MovedReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                cMovedObjectIDRanges: u32,
                oldObjectIDRangeStart: [*]usize,
                newObjectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                cMovedObjectIDRanges: u32,
                oldObjectIDRangeStart: [*]usize,
                newObjectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ObjectAllocated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                objectId: usize,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                objectId: usize,
                classId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ObjectsAllocatedByClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                cClassCount: u32,
                classIds: [*]usize,
                cObjects: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                cClassCount: u32,
                classIds: [*]usize,
                cObjects: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ObjectReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                objectId: usize,
                classId: usize,
                cObjectRefs: u32,
                objectRefIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                objectId: usize,
                classId: usize,
                cObjectRefs: u32,
                objectRefIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RootReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                cRootRefs: u32,
                rootRefIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                cRootRefs: u32,
                rootRefIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionThrown: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                thrownObjectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                thrownObjectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionSearchFunctionEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionSearchFunctionLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionSearchFilterEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionSearchFilterLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionSearchCatcherFound: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionOSHandlerEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                __unused: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                __unused: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionOSHandlerLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                __unused: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                __unused: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionUnwindFunctionEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionUnwindFunctionLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionUnwindFinallyEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionUnwindFinallyLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionCatcherEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                objectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                functionId: usize,
                objectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionCatcherLeave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        COMClassicVTableCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                wrappedClassId: usize,
                implementedIID: ?*const Guid,
                pVTable: ?*anyopaque,
                cSlots: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                wrappedClassId: usize,
                implementedIID: ?*const Guid,
                pVTable: ?*anyopaque,
                cSlots: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        COMClassicVTableDestroyed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
                wrappedClassId: usize,
                implementedIID: ?*const Guid,
                pVTable: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
                wrappedClassId: usize,
                implementedIID: ?*const Guid,
                pVTable: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionCLRCatcherFound: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExceptionCLRCatcherExecute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_Initialize(self: *const T, pICorProfilerInfoUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).Initialize(@as(*const ICorProfilerCallback, @ptrCast(self)), pICorProfilerInfoUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).Shutdown(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AppDomainCreationStarted(self: *const T, appDomainId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AppDomainCreationStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), appDomainId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AppDomainCreationFinished(self: *const T, appDomainId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AppDomainCreationFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), appDomainId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AppDomainShutdownStarted(self: *const T, appDomainId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AppDomainShutdownStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), appDomainId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AppDomainShutdownFinished(self: *const T, appDomainId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AppDomainShutdownFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), appDomainId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AssemblyLoadStarted(self: *const T, assemblyId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AssemblyLoadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), assemblyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AssemblyLoadFinished(self: *const T, assemblyId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AssemblyLoadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), assemblyId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AssemblyUnloadStarted(self: *const T, assemblyId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AssemblyUnloadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), assemblyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_AssemblyUnloadFinished(self: *const T, assemblyId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).AssemblyUnloadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), assemblyId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ModuleLoadStarted(self: *const T, moduleId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ModuleLoadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), moduleId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ModuleLoadFinished(self: *const T, moduleId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ModuleLoadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), moduleId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ModuleUnloadStarted(self: *const T, moduleId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ModuleUnloadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), moduleId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ModuleUnloadFinished(self: *const T, moduleId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ModuleUnloadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), moduleId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ModuleAttachedToAssembly(self: *const T, moduleId: usize, AssemblyId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ModuleAttachedToAssembly(@as(*const ICorProfilerCallback, @ptrCast(self)), moduleId, AssemblyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ClassLoadStarted(self: *const T, classId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ClassLoadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), classId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ClassLoadFinished(self: *const T, classId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ClassLoadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), classId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ClassUnloadStarted(self: *const T, classId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ClassUnloadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), classId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ClassUnloadFinished(self: *const T, classId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ClassUnloadFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), classId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_FunctionUnloadStarted(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).FunctionUnloadStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITCompilationStarted(self: *const T, functionId: usize, fIsSafeToBlock: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITCompilationStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, fIsSafeToBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITCompilationFinished(self: *const T, functionId: usize, hrStatus: HRESULT, fIsSafeToBlock: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITCompilationFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, hrStatus, fIsSafeToBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITCachedFunctionSearchStarted(self: *const T, functionId: usize, pbUseCachedFunction: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITCachedFunctionSearchStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, pbUseCachedFunction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITCachedFunctionSearchFinished(self: *const T, functionId: usize, result: COR_PRF_JIT_CACHE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITCachedFunctionSearchFinished(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITFunctionPitched(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITFunctionPitched(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_JITInlining(self: *const T, callerId: usize, calleeId: usize, pfShouldInline: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).JITInlining(@as(*const ICorProfilerCallback, @ptrCast(self)), callerId, calleeId, pfShouldInline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ThreadCreated(self: *const T, threadId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ThreadCreated(@as(*const ICorProfilerCallback, @ptrCast(self)), threadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ThreadDestroyed(self: *const T, threadId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ThreadDestroyed(@as(*const ICorProfilerCallback, @ptrCast(self)), threadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ThreadAssignedToOSThread(self: *const T, managedThreadId: usize, osThreadId: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ThreadAssignedToOSThread(@as(*const ICorProfilerCallback, @ptrCast(self)), managedThreadId, osThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingClientInvocationStarted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingClientInvocationStarted(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingClientSendingMessage(self: *const T, pCookie: ?*Guid, fIsAsync: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingClientSendingMessage(@as(*const ICorProfilerCallback, @ptrCast(self)), pCookie, fIsAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingClientReceivingReply(self: *const T, pCookie: ?*Guid, fIsAsync: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingClientReceivingReply(@as(*const ICorProfilerCallback, @ptrCast(self)), pCookie, fIsAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingClientInvocationFinished(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingClientInvocationFinished(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingServerReceivingMessage(self: *const T, pCookie: ?*Guid, fIsAsync: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingServerReceivingMessage(@as(*const ICorProfilerCallback, @ptrCast(self)), pCookie, fIsAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingServerInvocationStarted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingServerInvocationStarted(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingServerInvocationReturned(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingServerInvocationReturned(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RemotingServerSendingReply(self: *const T, pCookie: ?*Guid, fIsAsync: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RemotingServerSendingReply(@as(*const ICorProfilerCallback, @ptrCast(self)), pCookie, fIsAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_UnmanagedToManagedTransition(self: *const T, functionId: usize, reason: COR_PRF_TRANSITION_REASON) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).UnmanagedToManagedTransition(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, reason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ManagedToUnmanagedTransition(self: *const T, functionId: usize, reason: COR_PRF_TRANSITION_REASON) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ManagedToUnmanagedTransition(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, reason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeSuspendStarted(self: *const T, suspendReason: COR_PRF_SUSPEND_REASON) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeSuspendStarted(@as(*const ICorProfilerCallback, @ptrCast(self)), suspendReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeSuspendFinished(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeSuspendFinished(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeSuspendAborted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeSuspendAborted(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeResumeStarted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeResumeStarted(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeResumeFinished(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeResumeFinished(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeThreadSuspended(self: *const T, threadId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeThreadSuspended(@as(*const ICorProfilerCallback, @ptrCast(self)), threadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RuntimeThreadResumed(self: *const T, threadId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RuntimeThreadResumed(@as(*const ICorProfilerCallback, @ptrCast(self)), threadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_MovedReferences(self: *const T, cMovedObjectIDRanges: u32, oldObjectIDRangeStart: [*]usize, newObjectIDRangeStart: [*]usize, cObjectIDRangeLength: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).MovedReferences(@as(*const ICorProfilerCallback, @ptrCast(self)), cMovedObjectIDRanges, oldObjectIDRangeStart, newObjectIDRangeStart, cObjectIDRangeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ObjectAllocated(self: *const T, objectId: usize, classId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ObjectAllocated(@as(*const ICorProfilerCallback, @ptrCast(self)), objectId, classId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ObjectsAllocatedByClass(self: *const T, cClassCount: u32, classIds: [*]usize, cObjects: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ObjectsAllocatedByClass(@as(*const ICorProfilerCallback, @ptrCast(self)), cClassCount, classIds, cObjects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ObjectReferences(self: *const T, objectId: usize, classId: usize, cObjectRefs: u32, objectRefIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ObjectReferences(@as(*const ICorProfilerCallback, @ptrCast(self)), objectId, classId, cObjectRefs, objectRefIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_RootReferences(self: *const T, cRootRefs: u32, rootRefIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).RootReferences(@as(*const ICorProfilerCallback, @ptrCast(self)), cRootRefs, rootRefIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionThrown(self: *const T, thrownObjectId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionThrown(@as(*const ICorProfilerCallback, @ptrCast(self)), thrownObjectId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionSearchFunctionEnter(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionSearchFunctionEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionSearchFunctionLeave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionSearchFunctionLeave(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionSearchFilterEnter(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionSearchFilterEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionSearchFilterLeave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionSearchFilterLeave(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionSearchCatcherFound(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionSearchCatcherFound(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionOSHandlerEnter(self: *const T, __unused: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionOSHandlerEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), __unused);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionOSHandlerLeave(self: *const T, __unused: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionOSHandlerLeave(@as(*const ICorProfilerCallback, @ptrCast(self)), __unused);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionUnwindFunctionEnter(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionUnwindFunctionEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionUnwindFunctionLeave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionUnwindFunctionLeave(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionUnwindFinallyEnter(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionUnwindFinallyEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionUnwindFinallyLeave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionUnwindFinallyLeave(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionCatcherEnter(self: *const T, functionId: usize, objectId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionCatcherEnter(@as(*const ICorProfilerCallback, @ptrCast(self)), functionId, objectId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionCatcherLeave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionCatcherLeave(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_COMClassicVTableCreated(self: *const T, wrappedClassId: usize, implementedIID: ?*const Guid, pVTable: ?*anyopaque, cSlots: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).COMClassicVTableCreated(@as(*const ICorProfilerCallback, @ptrCast(self)), wrappedClassId, implementedIID, pVTable, cSlots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_COMClassicVTableDestroyed(self: *const T, wrappedClassId: usize, implementedIID: ?*const Guid, pVTable: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).COMClassicVTableDestroyed(@as(*const ICorProfilerCallback, @ptrCast(self)), wrappedClassId, implementedIID, pVTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionCLRCatcherFound(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionCLRCatcherFound(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback_ExceptionCLRCatcherExecute(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback.VTable, @ptrCast(self.vtable)).ExceptionCLRCatcherExecute(@as(*const ICorProfilerCallback, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COR_PRF_GC_ROOT_KIND = enum(i32) {
    STACK = 1,
    FINALIZER = 2,
    HANDLE = 3,
    OTHER = 0,
};
pub const COR_PRF_GC_ROOT_STACK = COR_PRF_GC_ROOT_KIND.STACK;
pub const COR_PRF_GC_ROOT_FINALIZER = COR_PRF_GC_ROOT_KIND.FINALIZER;
pub const COR_PRF_GC_ROOT_HANDLE = COR_PRF_GC_ROOT_KIND.HANDLE;
pub const COR_PRF_GC_ROOT_OTHER = COR_PRF_GC_ROOT_KIND.OTHER;

pub const COR_PRF_GC_ROOT_FLAGS = enum(i32) {
    PINNING = 1,
    WEAKREF = 2,
    INTERIOR = 4,
    REFCOUNTED = 8,
};
pub const COR_PRF_GC_ROOT_PINNING = COR_PRF_GC_ROOT_FLAGS.PINNING;
pub const COR_PRF_GC_ROOT_WEAKREF = COR_PRF_GC_ROOT_FLAGS.WEAKREF;
pub const COR_PRF_GC_ROOT_INTERIOR = COR_PRF_GC_ROOT_FLAGS.INTERIOR;
pub const COR_PRF_GC_ROOT_REFCOUNTED = COR_PRF_GC_ROOT_FLAGS.REFCOUNTED;

pub const COR_PRF_FINALIZER_FLAGS = enum(i32) {
    L = 1,
};
pub const COR_PRF_FINALIZER_CRITICAL = COR_PRF_FINALIZER_FLAGS.L;

pub const COR_PRF_GC_GENERATION = enum(i32) {
    GEN_0 = 0,
    GEN_1 = 1,
    GEN_2 = 2,
    LARGE_OBJECT_HEAP = 3,
    PINNED_OBJECT_HEAP = 4,
};
pub const COR_PRF_GC_GEN_0 = COR_PRF_GC_GENERATION.GEN_0;
pub const COR_PRF_GC_GEN_1 = COR_PRF_GC_GENERATION.GEN_1;
pub const COR_PRF_GC_GEN_2 = COR_PRF_GC_GENERATION.GEN_2;
pub const COR_PRF_GC_LARGE_OBJECT_HEAP = COR_PRF_GC_GENERATION.LARGE_OBJECT_HEAP;
pub const COR_PRF_GC_PINNED_OBJECT_HEAP = COR_PRF_GC_GENERATION.PINNED_OBJECT_HEAP;

pub const COR_PRF_GC_GENERATION_RANGE = extern struct {
    generation: COR_PRF_GC_GENERATION,
    rangeStart: usize,
    rangeLength: usize,
    rangeLengthReserved: usize,
};

pub const COR_PRF_NONGC_HEAP_RANGE = extern struct {
    rangeStart: usize,
    rangeLength: usize,
    rangeLengthReserved: usize,
};

pub const COR_PRF_CLAUSE_TYPE = enum(i32) {
    NONE = 0,
    FILTER = 1,
    CATCH = 2,
    FINALLY = 3,
};
pub const COR_PRF_CLAUSE_NONE = COR_PRF_CLAUSE_TYPE.NONE;
pub const COR_PRF_CLAUSE_FILTER = COR_PRF_CLAUSE_TYPE.FILTER;
pub const COR_PRF_CLAUSE_CATCH = COR_PRF_CLAUSE_TYPE.CATCH;
pub const COR_PRF_CLAUSE_FINALLY = COR_PRF_CLAUSE_TYPE.FINALLY;

pub const COR_PRF_EX_CLAUSE_INFO = extern struct {
    clauseType: COR_PRF_CLAUSE_TYPE,
    programCounter: usize,
    framePointer: usize,
    shadowStackPointer: usize,
};

pub const COR_PRF_GC_REASON = enum(i32) {
    INDUCED = 1,
    OTHER = 0,
};
pub const COR_PRF_GC_INDUCED = COR_PRF_GC_REASON.INDUCED;
pub const COR_PRF_GC_OTHER = COR_PRF_GC_REASON.OTHER;

pub const COR_PRF_MODULE_FLAGS = enum(i32) {
    DISK = 1,
    NGEN = 2,
    DYNAMIC = 4,
    COLLECTIBLE = 8,
    RESOURCE = 16,
    FLAT_LAYOUT = 32,
    WINDOWS_RUNTIME = 64,
};
pub const COR_PRF_MODULE_DISK = COR_PRF_MODULE_FLAGS.DISK;
pub const COR_PRF_MODULE_NGEN = COR_PRF_MODULE_FLAGS.NGEN;
pub const COR_PRF_MODULE_DYNAMIC = COR_PRF_MODULE_FLAGS.DYNAMIC;
pub const COR_PRF_MODULE_COLLECTIBLE = COR_PRF_MODULE_FLAGS.COLLECTIBLE;
pub const COR_PRF_MODULE_RESOURCE = COR_PRF_MODULE_FLAGS.RESOURCE;
pub const COR_PRF_MODULE_FLAT_LAYOUT = COR_PRF_MODULE_FLAGS.FLAT_LAYOUT;
pub const COR_PRF_MODULE_WINDOWS_RUNTIME = COR_PRF_MODULE_FLAGS.WINDOWS_RUNTIME;

const IID_ICorProfilerCallback2_Value = Guid.initString("8a8cc829-ccf2-49fe-bbae-0f022228071a");
pub const IID_ICorProfilerCallback2 = &IID_ICorProfilerCallback2_Value;
pub const ICorProfilerCallback2 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback.VTable,
        ThreadNameChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                threadId: usize,
                cchName: u32,
                name: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                threadId: usize,
                cchName: u32,
                name: ?[*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GarbageCollectionStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                cGenerations: i32,
                generationCollected: [*]BOOL,
                reason: COR_PRF_GC_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                cGenerations: i32,
                generationCollected: [*]BOOL,
                reason: COR_PRF_GC_REASON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SurvivingReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                cSurvivingObjectIDRanges: u32,
                objectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                cSurvivingObjectIDRanges: u32,
                objectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GarbageCollectionFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FinalizeableObjectQueued: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                finalizerFlags: u32,
                objectID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                finalizerFlags: u32,
                objectID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RootReferences2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                cRootRefs: u32,
                rootRefIds: [*]usize,
                rootKinds: [*]COR_PRF_GC_ROOT_KIND,
                rootFlags: [*]COR_PRF_GC_ROOT_FLAGS,
                rootIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                cRootRefs: u32,
                rootRefIds: [*]usize,
                rootKinds: [*]COR_PRF_GC_ROOT_KIND,
                rootFlags: [*]COR_PRF_GC_ROOT_FLAGS,
                rootIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                handleId: usize,
                initialObjectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                handleId: usize,
                initialObjectId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HandleDestroyed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback2,
                handleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback2,
                handleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_ThreadNameChanged(self: *const T, threadId: usize, cchName: u32, name: ?[*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).ThreadNameChanged(@as(*const ICorProfilerCallback2, @ptrCast(self)), threadId, cchName, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_GarbageCollectionStarted(self: *const T, cGenerations: i32, generationCollected: [*]BOOL, reason: COR_PRF_GC_REASON) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).GarbageCollectionStarted(@as(*const ICorProfilerCallback2, @ptrCast(self)), cGenerations, generationCollected, reason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_SurvivingReferences(self: *const T, cSurvivingObjectIDRanges: u32, objectIDRangeStart: [*]usize, cObjectIDRangeLength: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).SurvivingReferences(@as(*const ICorProfilerCallback2, @ptrCast(self)), cSurvivingObjectIDRanges, objectIDRangeStart, cObjectIDRangeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_GarbageCollectionFinished(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).GarbageCollectionFinished(@as(*const ICorProfilerCallback2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_FinalizeableObjectQueued(self: *const T, finalizerFlags: u32, objectID: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).FinalizeableObjectQueued(@as(*const ICorProfilerCallback2, @ptrCast(self)), finalizerFlags, objectID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_RootReferences2(self: *const T, cRootRefs: u32, rootRefIds: [*]usize, rootKinds: [*]COR_PRF_GC_ROOT_KIND, rootFlags: [*]COR_PRF_GC_ROOT_FLAGS, rootIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).RootReferences2(@as(*const ICorProfilerCallback2, @ptrCast(self)), cRootRefs, rootRefIds, rootKinds, rootFlags, rootIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_HandleCreated(self: *const T, handleId: usize, initialObjectId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).HandleCreated(@as(*const ICorProfilerCallback2, @ptrCast(self)), handleId, initialObjectId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback2_HandleDestroyed(self: *const T, handleId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback2.VTable, @ptrCast(self.vtable)).HandleDestroyed(@as(*const ICorProfilerCallback2, @ptrCast(self)), handleId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback3_Value = Guid.initString("4fd2ed52-7731-4b8d-9469-03d2cc3086c5");
pub const IID_ICorProfilerCallback3 = &IID_ICorProfilerCallback3_Value;
pub const ICorProfilerCallback3 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback2.VTable,
        InitializeForAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback3,
                pCorProfilerInfoUnk: ?*IUnknown,
                pvClientData: ?*anyopaque,
                cbClientData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback3,
                pCorProfilerInfoUnk: ?*IUnknown,
                pvClientData: ?*anyopaque,
                cbClientData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProfilerAttachComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProfilerDetachSucceeded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback3_InitializeForAttach(self: *const T, pCorProfilerInfoUnk: ?*IUnknown, pvClientData: ?*anyopaque, cbClientData: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback3.VTable, @ptrCast(self.vtable)).InitializeForAttach(@as(*const ICorProfilerCallback3, @ptrCast(self)), pCorProfilerInfoUnk, pvClientData, cbClientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback3_ProfilerAttachComplete(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback3.VTable, @ptrCast(self.vtable)).ProfilerAttachComplete(@as(*const ICorProfilerCallback3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback3_ProfilerDetachSucceeded(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback3.VTable, @ptrCast(self.vtable)).ProfilerDetachSucceeded(@as(*const ICorProfilerCallback3, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback4_Value = Guid.initString("7b63b2e3-107d-4d48-b2f6-f61e229470d2");
pub const IID_ICorProfilerCallback4 = &IID_ICorProfilerCallback4_Value;
pub const ICorProfilerCallback4 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback3.VTable,
        ReJITCompilationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                functionId: usize,
                rejitId: usize,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                functionId: usize,
                rejitId: usize,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReJITParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                moduleId: usize,
                methodId: u32,
                pFunctionControl: ?*ICorProfilerFunctionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                moduleId: usize,
                methodId: u32,
                pFunctionControl: ?*ICorProfilerFunctionControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReJITCompilationFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                functionId: usize,
                rejitId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                functionId: usize,
                rejitId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReJITError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                moduleId: usize,
                methodId: u32,
                functionId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                moduleId: usize,
                methodId: u32,
                functionId: usize,
                hrStatus: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MovedReferences2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                cMovedObjectIDRanges: u32,
                oldObjectIDRangeStart: [*]usize,
                newObjectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                cMovedObjectIDRanges: u32,
                oldObjectIDRangeStart: [*]usize,
                newObjectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SurvivingReferences2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback4,
                cSurvivingObjectIDRanges: u32,
                objectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback4,
                cSurvivingObjectIDRanges: u32,
                objectIDRangeStart: [*]usize,
                cObjectIDRangeLength: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_ReJITCompilationStarted(self: *const T, functionId: usize, rejitId: usize, fIsSafeToBlock: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).ReJITCompilationStarted(@as(*const ICorProfilerCallback4, @ptrCast(self)), functionId, rejitId, fIsSafeToBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_GetReJITParameters(self: *const T, moduleId: usize, methodId: u32, pFunctionControl: ?*ICorProfilerFunctionControl) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).GetReJITParameters(@as(*const ICorProfilerCallback4, @ptrCast(self)), moduleId, methodId, pFunctionControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_ReJITCompilationFinished(self: *const T, functionId: usize, rejitId: usize, hrStatus: HRESULT, fIsSafeToBlock: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).ReJITCompilationFinished(@as(*const ICorProfilerCallback4, @ptrCast(self)), functionId, rejitId, hrStatus, fIsSafeToBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_ReJITError(self: *const T, moduleId: usize, methodId: u32, functionId: usize, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).ReJITError(@as(*const ICorProfilerCallback4, @ptrCast(self)), moduleId, methodId, functionId, hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_MovedReferences2(self: *const T, cMovedObjectIDRanges: u32, oldObjectIDRangeStart: [*]usize, newObjectIDRangeStart: [*]usize, cObjectIDRangeLength: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).MovedReferences2(@as(*const ICorProfilerCallback4, @ptrCast(self)), cMovedObjectIDRanges, oldObjectIDRangeStart, newObjectIDRangeStart, cObjectIDRangeLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback4_SurvivingReferences2(self: *const T, cSurvivingObjectIDRanges: u32, objectIDRangeStart: [*]usize, cObjectIDRangeLength: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback4.VTable, @ptrCast(self.vtable)).SurvivingReferences2(@as(*const ICorProfilerCallback4, @ptrCast(self)), cSurvivingObjectIDRanges, objectIDRangeStart, cObjectIDRangeLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback5_Value = Guid.initString("8dfba405-8c9f-45f8-bffa-83b14cef78b5");
pub const IID_ICorProfilerCallback5 = &IID_ICorProfilerCallback5_Value;
pub const ICorProfilerCallback5 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback4.VTable,
        ConditionalWeakTableElementReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback5,
                cRootRefs: u32,
                keyRefIds: [*]usize,
                valueRefIds: [*]usize,
                rootIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback5,
                cRootRefs: u32,
                keyRefIds: [*]usize,
                valueRefIds: [*]usize,
                rootIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback5_ConditionalWeakTableElementReferences(self: *const T, cRootRefs: u32, keyRefIds: [*]usize, valueRefIds: [*]usize, rootIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback5.VTable, @ptrCast(self.vtable)).ConditionalWeakTableElementReferences(@as(*const ICorProfilerCallback5, @ptrCast(self)), cRootRefs, keyRefIds, valueRefIds, rootIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback6_Value = Guid.initString("fc13df4b-4448-4f4f-950c-ba8d19d00c36");
pub const IID_ICorProfilerCallback6 = &IID_ICorProfilerCallback6_Value;
pub const ICorProfilerCallback6 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback5.VTable,
        GetAssemblyReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback6,
                wszAssemblyPath: ?[*:0]align(1) const u16,
                pAsmRefProvider: ?*ICorProfilerAssemblyReferenceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback6,
                wszAssemblyPath: ?[*:0]align(1) const u16,
                pAsmRefProvider: ?*ICorProfilerAssemblyReferenceProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback6_GetAssemblyReferences(self: *const T, wszAssemblyPath: ?[*:0]align(1) const u16, pAsmRefProvider: ?*ICorProfilerAssemblyReferenceProvider) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback6.VTable, @ptrCast(self.vtable)).GetAssemblyReferences(@as(*const ICorProfilerCallback6, @ptrCast(self)), wszAssemblyPath, pAsmRefProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback7_Value = Guid.initString("f76a2dba-1d52-4539-866c-2aa518f9efc3");
pub const IID_ICorProfilerCallback7 = &IID_ICorProfilerCallback7_Value;
pub const ICorProfilerCallback7 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback6.VTable,
        ModuleInMemorySymbolsUpdated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback7,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback7,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback7_ModuleInMemorySymbolsUpdated(self: *const T, moduleId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback7.VTable, @ptrCast(self.vtable)).ModuleInMemorySymbolsUpdated(@as(*const ICorProfilerCallback7, @ptrCast(self)), moduleId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback8_Value = Guid.initString("5bed9b15-c079-4d47-bfe2-215a140c07e0");
pub const IID_ICorProfilerCallback8 = &IID_ICorProfilerCallback8_Value;
pub const ICorProfilerCallback8 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback7.VTable,
        DynamicMethodJITCompilationStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback8,
                functionId: usize,
                fIsSafeToBlock: BOOL,
                pILHeader: ?*u8,
                cbILHeader: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback8,
                functionId: usize,
                fIsSafeToBlock: BOOL,
                pILHeader: ?*u8,
                cbILHeader: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DynamicMethodJITCompilationFinished: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback8,
                functionId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback8,
                functionId: usize,
                hrStatus: HRESULT,
                fIsSafeToBlock: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback8_DynamicMethodJITCompilationStarted(self: *const T, functionId: usize, fIsSafeToBlock: BOOL, pILHeader: ?*u8, cbILHeader: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback8.VTable, @ptrCast(self.vtable)).DynamicMethodJITCompilationStarted(@as(*const ICorProfilerCallback8, @ptrCast(self)), functionId, fIsSafeToBlock, pILHeader, cbILHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback8_DynamicMethodJITCompilationFinished(self: *const T, functionId: usize, hrStatus: HRESULT, fIsSafeToBlock: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback8.VTable, @ptrCast(self.vtable)).DynamicMethodJITCompilationFinished(@as(*const ICorProfilerCallback8, @ptrCast(self)), functionId, hrStatus, fIsSafeToBlock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback9_Value = Guid.initString("27583ec3-c8f5-482f-8052-194b8ce4705a");
pub const IID_ICorProfilerCallback9 = &IID_ICorProfilerCallback9_Value;
pub const ICorProfilerCallback9 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback8.VTable,
        DynamicMethodUnloaded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback9,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback9,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback9_DynamicMethodUnloaded(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback9.VTable, @ptrCast(self.vtable)).DynamicMethodUnloaded(@as(*const ICorProfilerCallback9, @ptrCast(self)), functionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback10_Value = Guid.initString("cec5b60e-c69c-495f-87f6-84d28ee16ffb");
pub const IID_ICorProfilerCallback10 = &IID_ICorProfilerCallback10_Value;
pub const ICorProfilerCallback10 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback9.VTable,
        EventPipeEventDelivered: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback10,
                provider: usize,
                eventId: u32,
                eventVersion: u32,
                cbMetadataBlob: u32,
                metadataBlob: [*:0]u8,
                cbEventData: u32,
                eventData: [*:0]u8,
                pActivityId: ?*const Guid,
                pRelatedActivityId: ?*const Guid,
                eventThread: usize,
                numStackFrames: u32,
                stackFrames: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback10,
                provider: usize,
                eventId: u32,
                eventVersion: u32,
                cbMetadataBlob: u32,
                metadataBlob: [*:0]u8,
                cbEventData: u32,
                eventData: [*:0]u8,
                pActivityId: ?*const Guid,
                pRelatedActivityId: ?*const Guid,
                eventThread: usize,
                numStackFrames: u32,
                stackFrames: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeProviderCreated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback10,
                provider: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback10,
                provider: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback9.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback10_EventPipeEventDelivered(self: *const T, provider: usize, eventId: u32, eventVersion: u32, cbMetadataBlob: u32, metadataBlob: [*:0]u8, cbEventData: u32, eventData: [*:0]u8, pActivityId: ?*const Guid, pRelatedActivityId: ?*const Guid, eventThread: usize, numStackFrames: u32, stackFrames: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback10.VTable, @ptrCast(self.vtable)).EventPipeEventDelivered(@as(*const ICorProfilerCallback10, @ptrCast(self)), provider, eventId, eventVersion, cbMetadataBlob, metadataBlob, cbEventData, eventData, pActivityId, pRelatedActivityId, eventThread, numStackFrames, stackFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback10_EventPipeProviderCreated(self: *const T, provider: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback10.VTable, @ptrCast(self.vtable)).EventPipeProviderCreated(@as(*const ICorProfilerCallback10, @ptrCast(self)), provider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerCallback11_Value = Guid.initString("42350846-aaed-47f7-b128-fd0c98881cde");
pub const IID_ICorProfilerCallback11 = &IID_ICorProfilerCallback11_Value;
pub const ICorProfilerCallback11 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerCallback10.VTable,
        LoadAsNotificationOnly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerCallback11,
                pbNotificationOnly: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerCallback11,
                pbNotificationOnly: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerCallback10.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerCallback11_LoadAsNotificationOnly(self: *const T, pbNotificationOnly: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerCallback11.VTable, @ptrCast(self.vtable)).LoadAsNotificationOnly(@as(*const ICorProfilerCallback11, @ptrCast(self)), pbNotificationOnly);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COR_PRF_CODEGEN_FLAGS = enum(i32) {
    INLINING = 1,
    ALL_OPTIMIZATIONS = 2,
};
pub const COR_PRF_CODEGEN_DISABLE_INLINING = COR_PRF_CODEGEN_FLAGS.INLINING;
pub const COR_PRF_CODEGEN_DISABLE_ALL_OPTIMIZATIONS = COR_PRF_CODEGEN_FLAGS.ALL_OPTIMIZATIONS;

const IID_ICorProfilerInfo_Value = Guid.initString("28b5557d-3f3f-48b4-90b2-5f9eea2f6c48");
pub const IID_ICorProfilerInfo = &IID_ICorProfilerInfo_Value;
pub const ICorProfilerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClassFromObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                objectId: usize,
                pClassId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                objectId: usize,
                pClassId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassFromToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                typeDef: u32,
                pClassId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                typeDef: u32,
                pClassId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                pStart: ?*?*u8,
                pcSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                pStart: ?*?*u8,
                pcSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                pdwEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                pdwEvents: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionFromIP: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                ip: ?*u8,
                pFunctionId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                ip: ?*u8,
                pFunctionId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionFromToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                token: u32,
                pFunctionId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                token: u32,
                pFunctionId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHandleFromThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                phThread: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                phThread: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                objectId: usize,
                pcSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                objectId: usize,
                pcSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsArrayClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                classId: usize,
                pBaseElemType: ?*CorElementType,
                pBaseClassId: ?*usize,
                pcRank: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                classId: usize,
                pBaseElemType: ?*CorElementType,
                pBaseClassId: ?*usize,
                pcRank: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                pdwWin32ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                pdwWin32ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                pThreadId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                pThreadId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassIDInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                classId: usize,
                pModuleId: ?*usize,
                pTypeDefToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                classId: usize,
                pModuleId: ?*usize,
                pTypeDefToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                pClassId: ?*usize,
                pModuleId: ?*usize,
                pToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                pClassId: ?*usize,
                pModuleId: ?*usize,
                pToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                dwEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                dwEvents: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnterLeaveFunctionHooks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                pFuncEnter: ?*?FunctionEnter,
                pFuncLeave: ?*?FunctionLeave,
                pFuncTailcall: ?*?FunctionTailcall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                pFuncEnter: ?*?FunctionEnter,
                pFuncLeave: ?*?FunctionLeave,
                pFuncTailcall: ?*?FunctionTailcall,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFunctionIDMapper: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                pFunc: ?*?FunctionIDMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                pFunc: ?*?FunctionIDMapper,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTokenAndMetaDataFromFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                riid: ?*const Guid,
                ppImport: ?*?*IUnknown,
                pToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                riid: ?*const Guid,
                ppImport: ?*?*IUnknown,
                pToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                ppBaseLoadAddress: ?*?*u8,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAssemblyId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                ppBaseLoadAddress: ?*?*u8,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAssemblyId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleMetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                dwOpenFlags: u32,
                riid: ?*const Guid,
                ppOut: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetILFunctionBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                methodId: u32,
                ppMethodHeader: ?*?*u8,
                pcbMethodSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                methodId: u32,
                ppMethodHeader: ?*?*u8,
                pcbMethodSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetILFunctionBodyAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                ppMalloc: ?*?*IMethodMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                ppMalloc: ?*?*IMethodMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetILFunctionBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                methodid: u32,
                pbNewILMethodHeader: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                moduleId: usize,
                methodid: u32,
                pbNewILMethodHeader: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppDomainInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                appDomainId: usize,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pProcessId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                appDomainId: usize,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pProcessId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                assemblyId: usize,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAppDomainId: ?*usize,
                pModuleId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                assemblyId: usize,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAppDomainId: ?*usize,
                pModuleId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFunctionReJIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ForceGC: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetILInstrumentedCodeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                fStartJit: BOOL,
                cILMapEntries: u32,
                rgILMapEntries: [*]COR_IL_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                fStartJit: BOOL,
                cILMapEntries: u32,
                rgILMapEntries: [*]COR_IL_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInprocInspectionInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                ppicd: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                ppicd: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInprocInspectionIThisThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                ppicd: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                ppicd: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                pContextId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                threadId: usize,
                pContextId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginInprocDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                fThisThreadOnly: BOOL,
                pdwProfilerContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                fThisThreadOnly: BOOL,
                pdwProfilerContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInprocDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                dwProfilerContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                dwProfilerContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetILToNativeMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: [*]COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo,
                functionId: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: [*]COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetClassFromObject(self: *const T, objectId: usize, pClassId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetClassFromObject(@as(*const ICorProfilerInfo, @ptrCast(self)), objectId, pClassId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetClassFromToken(self: *const T, moduleId: usize, typeDef: u32, pClassId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetClassFromToken(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, typeDef, pClassId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetCodeInfo(self: *const T, functionId: usize, pStart: ?*?*u8, pcSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetCodeInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId, pStart, pcSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetEventMask(self: *const T, pdwEvents: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetEventMask(@as(*const ICorProfilerInfo, @ptrCast(self)), pdwEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetFunctionFromIP(self: *const T, ip: ?*u8, pFunctionId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetFunctionFromIP(@as(*const ICorProfilerInfo, @ptrCast(self)), ip, pFunctionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetFunctionFromToken(self: *const T, moduleId: usize, token: u32, pFunctionId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetFunctionFromToken(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, token, pFunctionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetHandleFromThread(self: *const T, threadId: usize, phThread: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetHandleFromThread(@as(*const ICorProfilerInfo, @ptrCast(self)), threadId, phThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetObjectSize(self: *const T, objectId: usize, pcSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetObjectSize(@as(*const ICorProfilerInfo, @ptrCast(self)), objectId, pcSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_IsArrayClass(self: *const T, classId: usize, pBaseElemType: ?*CorElementType, pBaseClassId: ?*usize, pcRank: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).IsArrayClass(@as(*const ICorProfilerInfo, @ptrCast(self)), classId, pBaseElemType, pBaseClassId, pcRank);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetThreadInfo(self: *const T, threadId: usize, pdwWin32ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetThreadInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), threadId, pdwWin32ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetCurrentThreadID(self: *const T, pThreadId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetCurrentThreadID(@as(*const ICorProfilerInfo, @ptrCast(self)), pThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetClassIDInfo(self: *const T, classId: usize, pModuleId: ?*usize, pTypeDefToken: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetClassIDInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), classId, pModuleId, pTypeDefToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetFunctionInfo(self: *const T, functionId: usize, pClassId: ?*usize, pModuleId: ?*usize, pToken: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetFunctionInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId, pClassId, pModuleId, pToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetEventMask(self: *const T, dwEvents: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetEventMask(@as(*const ICorProfilerInfo, @ptrCast(self)), dwEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetEnterLeaveFunctionHooks(self: *const T, pFuncEnter: ?*?FunctionEnter, pFuncLeave: ?*?FunctionLeave, pFuncTailcall: ?*?FunctionTailcall) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetEnterLeaveFunctionHooks(@as(*const ICorProfilerInfo, @ptrCast(self)), pFuncEnter, pFuncLeave, pFuncTailcall);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetFunctionIDMapper(self: *const T, pFunc: ?*?FunctionIDMapper) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetFunctionIDMapper(@as(*const ICorProfilerInfo, @ptrCast(self)), pFunc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetTokenAndMetaDataFromFunction(self: *const T, functionId: usize, riid: ?*const Guid, ppImport: ?*?*IUnknown, pToken: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetTokenAndMetaDataFromFunction(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId, riid, ppImport, pToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetModuleInfo(self: *const T, moduleId: usize, ppBaseLoadAddress: ?*?*u8, cchName: u32, pcchName: ?*u32, szName: [*:0]u16, pAssemblyId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetModuleInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, ppBaseLoadAddress, cchName, pcchName, szName, pAssemblyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetModuleMetaData(self: *const T, moduleId: usize, dwOpenFlags: u32, riid: ?*const Guid, ppOut: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetModuleMetaData(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, dwOpenFlags, riid, ppOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetILFunctionBody(self: *const T, moduleId: usize, methodId: u32, ppMethodHeader: ?*?*u8, pcbMethodSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetILFunctionBody(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, methodId, ppMethodHeader, pcbMethodSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetILFunctionBodyAllocator(self: *const T, moduleId: usize, ppMalloc: ?*?*IMethodMalloc) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetILFunctionBodyAllocator(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, ppMalloc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetILFunctionBody(self: *const T, moduleId: usize, methodid: u32, pbNewILMethodHeader: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetILFunctionBody(@as(*const ICorProfilerInfo, @ptrCast(self)), moduleId, methodid, pbNewILMethodHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetAppDomainInfo(self: *const T, appDomainId: usize, cchName: u32, pcchName: ?*u32, szName: [*:0]u16, pProcessId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetAppDomainInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), appDomainId, cchName, pcchName, szName, pProcessId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetAssemblyInfo(self: *const T, assemblyId: usize, cchName: u32, pcchName: ?*u32, szName: [*:0]u16, pAppDomainId: ?*usize, pModuleId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetAssemblyInfo(@as(*const ICorProfilerInfo, @ptrCast(self)), assemblyId, cchName, pcchName, szName, pAppDomainId, pModuleId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetFunctionReJIT(self: *const T, functionId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetFunctionReJIT(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_ForceGC(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).ForceGC(@as(*const ICorProfilerInfo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_SetILInstrumentedCodeMap(self: *const T, functionId: usize, fStartJit: BOOL, cILMapEntries: u32, rgILMapEntries: [*]COR_IL_MAP) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).SetILInstrumentedCodeMap(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId, fStartJit, cILMapEntries, rgILMapEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetInprocInspectionInterface(self: *const T, ppicd: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetInprocInspectionInterface(@as(*const ICorProfilerInfo, @ptrCast(self)), ppicd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetInprocInspectionIThisThread(self: *const T, ppicd: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetInprocInspectionIThisThread(@as(*const ICorProfilerInfo, @ptrCast(self)), ppicd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetThreadContext(self: *const T, threadId: usize, pContextId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const ICorProfilerInfo, @ptrCast(self)), threadId, pContextId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_BeginInprocDebugging(self: *const T, fThisThreadOnly: BOOL, pdwProfilerContext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).BeginInprocDebugging(@as(*const ICorProfilerInfo, @ptrCast(self)), fThisThreadOnly, pdwProfilerContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_EndInprocDebugging(self: *const T, dwProfilerContext: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).EndInprocDebugging(@as(*const ICorProfilerInfo, @ptrCast(self)), dwProfilerContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo_GetILToNativeMapping(self: *const T, functionId: usize, cMap: u32, pcMap: ?*u32, map: [*]COR_DEBUG_IL_TO_NATIVE_MAP) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo.VTable, @ptrCast(self.vtable)).GetILToNativeMapping(@as(*const ICorProfilerInfo, @ptrCast(self)), functionId, cMap, pcMap, map);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo2_Value = Guid.initString("cc0935cd-a518-487d-b0bb-a93214e65478");
pub const IID_ICorProfilerInfo2 = &IID_ICorProfilerInfo2_Value;
pub const ICorProfilerInfo2 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo.VTable,
        DoStackSnapshot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                thread: usize,
                callback: ?*?StackSnapshotCallback,
                infoFlags: u32,
                clientData: ?*anyopaque,
                context: [*:0]u8,
                contextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                thread: usize,
                callback: ?*?StackSnapshotCallback,
                infoFlags: u32,
                clientData: ?*anyopaque,
                context: [*:0]u8,
                contextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnterLeaveFunctionHooks2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                pFuncEnter: ?*?FunctionEnter2,
                pFuncLeave: ?*?FunctionLeave2,
                pFuncTailcall: ?*?FunctionTailcall2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                pFuncEnter: ?*?FunctionEnter2,
                pFuncLeave: ?*?FunctionLeave2,
                pFuncTailcall: ?*?FunctionTailcall2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionInfo2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                funcId: usize,
                frameInfo: usize,
                pClassId: ?*usize,
                pModuleId: ?*usize,
                pToken: ?*u32,
                cTypeArgs: u32,
                pcTypeArgs: ?*u32,
                typeArgs: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                funcId: usize,
                frameInfo: usize,
                pClassId: ?*usize,
                pModuleId: ?*usize,
                pToken: ?*u32,
                cTypeArgs: u32,
                pcTypeArgs: ?*u32,
                typeArgs: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                pBufferLengthOffset: ?*u32,
                pStringLengthOffset: ?*u32,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                pBufferLengthOffset: ?*u32,
                pStringLengthOffset: ?*u32,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classID: usize,
                rFieldOffset: ?*COR_FIELD_OFFSET,
                cFieldOffset: u32,
                pcFieldOffset: ?*u32,
                pulClassSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classID: usize,
                rFieldOffset: ?*COR_FIELD_OFFSET,
                cFieldOffset: u32,
                pcFieldOffset: ?*u32,
                pulClassSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassIDInfo2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                pModuleId: ?*usize,
                pTypeDefToken: ?*u32,
                pParentClassId: ?*usize,
                cNumTypeArgs: u32,
                pcNumTypeArgs: ?*u32,
                typeArgs: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                pModuleId: ?*usize,
                pTypeDefToken: ?*u32,
                pParentClassId: ?*usize,
                cNumTypeArgs: u32,
                pcNumTypeArgs: ?*u32,
                typeArgs: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeInfo2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                functionID: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: [*]COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                functionID: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: [*]COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClassFromTokenAndTypeArgs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                typeDef: u32,
                cTypeArgs: u32,
                typeArgs: [*]usize,
                pClassID: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                typeDef: u32,
                cTypeArgs: u32,
                typeArgs: [*]usize,
                pClassID: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionFromTokenAndTypeArgs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                funcDef: u32,
                classId: usize,
                cTypeArgs: u32,
                typeArgs: [*]usize,
                pFunctionID: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                funcDef: u32,
                classId: usize,
                cTypeArgs: u32,
                typeArgs: [*]usize,
                pFunctionID: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumModuleFrozenObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                moduleID: usize,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrayObjectInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                objectId: usize,
                cDimensions: u32,
                pDimensionSizes: [*]u32,
                pDimensionLowerBounds: [*]i32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                objectId: usize,
                cDimensions: u32,
                pDimensionSizes: [*]u32,
                pDimensionLowerBounds: [*]i32,
                ppData: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBoxClassLayout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                threadId: usize,
                pAppDomainId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                threadId: usize,
                pAppDomainId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRVAStaticAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppDomainStaticAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                appDomainId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                appDomainId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadStaticAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                threadId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                threadId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStaticAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                contextId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                contextId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStaticFieldInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                pFieldInfo: ?*COR_PRF_STATIC_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                classId: usize,
                fieldToken: u32,
                pFieldInfo: ?*COR_PRF_STATIC_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenerationBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                cObjectRanges: u32,
                pcObjectRanges: ?*u32,
                ranges: [*]COR_PRF_GC_GENERATION_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                cObjectRanges: u32,
                pcObjectRanges: ?*u32,
                ranges: [*]COR_PRF_GC_GENERATION_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectGeneration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                objectId: usize,
                range: ?*COR_PRF_GC_GENERATION_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                objectId: usize,
                range: ?*COR_PRF_GC_GENERATION_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifiedExceptionClauseInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo2,
                pinfo: ?*COR_PRF_EX_CLAUSE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo2,
                pinfo: ?*COR_PRF_EX_CLAUSE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_DoStackSnapshot(self: *const T, thread: usize, callback: ?*?StackSnapshotCallback, infoFlags: u32, clientData: ?*anyopaque, context: [*:0]u8, contextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).DoStackSnapshot(@as(*const ICorProfilerInfo2, @ptrCast(self)), thread, callback, infoFlags, clientData, context, contextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_SetEnterLeaveFunctionHooks2(self: *const T, pFuncEnter: ?*?FunctionEnter2, pFuncLeave: ?*?FunctionLeave2, pFuncTailcall: ?*?FunctionTailcall2) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).SetEnterLeaveFunctionHooks2(@as(*const ICorProfilerInfo2, @ptrCast(self)), pFuncEnter, pFuncLeave, pFuncTailcall);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetFunctionInfo2(self: *const T, funcId: usize, frameInfo: usize, pClassId: ?*usize, pModuleId: ?*usize, pToken: ?*u32, cTypeArgs: u32, pcTypeArgs: ?*u32, typeArgs: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetFunctionInfo2(@as(*const ICorProfilerInfo2, @ptrCast(self)), funcId, frameInfo, pClassId, pModuleId, pToken, cTypeArgs, pcTypeArgs, typeArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetStringLayout(self: *const T, pBufferLengthOffset: ?*u32, pStringLengthOffset: ?*u32, pBufferOffset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetStringLayout(@as(*const ICorProfilerInfo2, @ptrCast(self)), pBufferLengthOffset, pStringLengthOffset, pBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetClassLayout(self: *const T, classID: usize, rFieldOffset: ?*COR_FIELD_OFFSET, cFieldOffset: u32, pcFieldOffset: ?*u32, pulClassSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetClassLayout(@as(*const ICorProfilerInfo2, @ptrCast(self)), classID, rFieldOffset, cFieldOffset, pcFieldOffset, pulClassSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetClassIDInfo2(self: *const T, classId: usize, pModuleId: ?*usize, pTypeDefToken: ?*u32, pParentClassId: ?*usize, cNumTypeArgs: u32, pcNumTypeArgs: ?*u32, typeArgs: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetClassIDInfo2(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, pModuleId, pTypeDefToken, pParentClassId, cNumTypeArgs, pcNumTypeArgs, typeArgs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetCodeInfo2(self: *const T, functionID: usize, cCodeInfos: u32, pcCodeInfos: ?*u32, codeInfos: [*]COR_PRF_CODE_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetCodeInfo2(@as(*const ICorProfilerInfo2, @ptrCast(self)), functionID, cCodeInfos, pcCodeInfos, codeInfos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetClassFromTokenAndTypeArgs(self: *const T, moduleID: usize, typeDef: u32, cTypeArgs: u32, typeArgs: [*]usize, pClassID: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetClassFromTokenAndTypeArgs(@as(*const ICorProfilerInfo2, @ptrCast(self)), moduleID, typeDef, cTypeArgs, typeArgs, pClassID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetFunctionFromTokenAndTypeArgs(self: *const T, moduleID: usize, funcDef: u32, classId: usize, cTypeArgs: u32, typeArgs: [*]usize, pFunctionID: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetFunctionFromTokenAndTypeArgs(@as(*const ICorProfilerInfo2, @ptrCast(self)), moduleID, funcDef, classId, cTypeArgs, typeArgs, pFunctionID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_EnumModuleFrozenObjects(self: *const T, moduleID: usize, ppEnum: ?*?*ICorProfilerObjectEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).EnumModuleFrozenObjects(@as(*const ICorProfilerInfo2, @ptrCast(self)), moduleID, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetArrayObjectInfo(self: *const T, objectId: usize, cDimensions: u32, pDimensionSizes: [*]u32, pDimensionLowerBounds: [*]i32, ppData: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetArrayObjectInfo(@as(*const ICorProfilerInfo2, @ptrCast(self)), objectId, cDimensions, pDimensionSizes, pDimensionLowerBounds, ppData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetBoxClassLayout(self: *const T, classId: usize, pBufferOffset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetBoxClassLayout(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, pBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetThreadAppDomain(self: *const T, threadId: usize, pAppDomainId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetThreadAppDomain(@as(*const ICorProfilerInfo2, @ptrCast(self)), threadId, pAppDomainId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetRVAStaticAddress(self: *const T, classId: usize, fieldToken: u32, ppAddress: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetRVAStaticAddress(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, fieldToken, ppAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetAppDomainStaticAddress(self: *const T, classId: usize, fieldToken: u32, appDomainId: usize, ppAddress: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetAppDomainStaticAddress(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, fieldToken, appDomainId, ppAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetThreadStaticAddress(self: *const T, classId: usize, fieldToken: u32, threadId: usize, ppAddress: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetThreadStaticAddress(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, fieldToken, threadId, ppAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetContextStaticAddress(self: *const T, classId: usize, fieldToken: u32, contextId: usize, ppAddress: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetContextStaticAddress(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, fieldToken, contextId, ppAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetStaticFieldInfo(self: *const T, classId: usize, fieldToken: u32, pFieldInfo: ?*COR_PRF_STATIC_TYPE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetStaticFieldInfo(@as(*const ICorProfilerInfo2, @ptrCast(self)), classId, fieldToken, pFieldInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetGenerationBounds(self: *const T, cObjectRanges: u32, pcObjectRanges: ?*u32, ranges: [*]COR_PRF_GC_GENERATION_RANGE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetGenerationBounds(@as(*const ICorProfilerInfo2, @ptrCast(self)), cObjectRanges, pcObjectRanges, ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetObjectGeneration(self: *const T, objectId: usize, range: ?*COR_PRF_GC_GENERATION_RANGE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetObjectGeneration(@as(*const ICorProfilerInfo2, @ptrCast(self)), objectId, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo2_GetNotifiedExceptionClauseInfo(self: *const T, pinfo: ?*COR_PRF_EX_CLAUSE_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo2.VTable, @ptrCast(self.vtable)).GetNotifiedExceptionClauseInfo(@as(*const ICorProfilerInfo2, @ptrCast(self)), pinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo3_Value = Guid.initString("b555ed4f-452a-4e54-8b39-b5360bad32a0");
pub const IID_ICorProfilerInfo3 = &IID_ICorProfilerInfo3_Value;
pub const ICorProfilerInfo3 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo2.VTable,
        EnumJITedFunctions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestProfilerDetach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                dwExpectedCompletionMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                dwExpectedCompletionMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFunctionIDMapper2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                pFunc: ?*?FunctionIDMapper2,
                clientData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                pFunc: ?*?FunctionIDMapper2,
                clientData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringLayout2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                pStringLengthOffset: ?*u32,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                pStringLengthOffset: ?*u32,
                pBufferOffset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnterLeaveFunctionHooks3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                pFuncEnter3: ?*?FunctionEnter3,
                pFuncLeave3: ?*?FunctionLeave3,
                pFuncTailcall3: ?*?FunctionTailcall3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                pFuncEnter3: ?*?FunctionEnter3,
                pFuncLeave3: ?*?FunctionLeave3,
                pFuncTailcall3: ?*?FunctionTailcall3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnterLeaveFunctionHooks3WithInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                pFuncEnter3WithInfo: ?*?FunctionEnter3WithInfo,
                pFuncLeave3WithInfo: ?*?FunctionLeave3WithInfo,
                pFuncTailcall3WithInfo: ?*?FunctionTailcall3WithInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                pFuncEnter3WithInfo: ?*?FunctionEnter3WithInfo,
                pFuncLeave3WithInfo: ?*?FunctionLeave3WithInfo,
                pFuncTailcall3WithInfo: ?*?FunctionTailcall3WithInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEnter3Info: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
                pcbArgumentInfo: ?*u32,
                pArgumentInfo: [*]COR_PRF_FUNCTION_ARGUMENT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
                pcbArgumentInfo: ?*u32,
                pArgumentInfo: [*]COR_PRF_FUNCTION_ARGUMENT_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionLeave3Info: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
                pRetvalRange: ?*COR_PRF_FUNCTION_ARGUMENT_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
                pRetvalRange: ?*COR_PRF_FUNCTION_ARGUMENT_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionTailcall3Info: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                functionId: usize,
                eltInfo: usize,
                pFrameInfo: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                ppEnum: ?*?*ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                ppEnum: ?*?*ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                pClrInstanceId: ?*u16,
                pRuntimeType: ?*COR_PRF_RUNTIME_TYPE,
                pMajorVersion: ?*u16,
                pMinorVersion: ?*u16,
                pBuildNumber: ?*u16,
                pQFEVersion: ?*u16,
                cchVersionString: u32,
                pcchVersionString: ?*u32,
                szVersionString: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                pClrInstanceId: ?*u16,
                pRuntimeType: ?*COR_PRF_RUNTIME_TYPE,
                pMajorVersion: ?*u16,
                pMinorVersion: ?*u16,
                pBuildNumber: ?*u16,
                pQFEVersion: ?*u16,
                cchVersionString: u32,
                pcchVersionString: ?*u32,
                szVersionString: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadStaticAddress2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                classId: usize,
                fieldToken: u32,
                appDomainId: usize,
                threadId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                classId: usize,
                fieldToken: u32,
                appDomainId: usize,
                threadId: usize,
                ppAddress: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAppDomainsContainingModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                moduleId: usize,
                cAppDomainIds: u32,
                pcAppDomainIds: ?*u32,
                appDomainIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                moduleId: usize,
                cAppDomainIds: u32,
                pcAppDomainIds: ?*u32,
                appDomainIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleInfo2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo3,
                moduleId: usize,
                ppBaseLoadAddress: ?*?*u8,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAssemblyId: ?*usize,
                pdwModuleFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo3,
                moduleId: usize,
                ppBaseLoadAddress: ?*?*u8,
                cchName: u32,
                pcchName: ?*u32,
                szName: [*:0]u16,
                pAssemblyId: ?*usize,
                pdwModuleFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_EnumJITedFunctions(self: *const T, ppEnum: ?*?*ICorProfilerFunctionEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).EnumJITedFunctions(@as(*const ICorProfilerInfo3, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_RequestProfilerDetach(self: *const T, dwExpectedCompletionMilliseconds: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).RequestProfilerDetach(@as(*const ICorProfilerInfo3, @ptrCast(self)), dwExpectedCompletionMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_SetFunctionIDMapper2(self: *const T, pFunc: ?*?FunctionIDMapper2, clientData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).SetFunctionIDMapper2(@as(*const ICorProfilerInfo3, @ptrCast(self)), pFunc, clientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetStringLayout2(self: *const T, pStringLengthOffset: ?*u32, pBufferOffset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetStringLayout2(@as(*const ICorProfilerInfo3, @ptrCast(self)), pStringLengthOffset, pBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_SetEnterLeaveFunctionHooks3(self: *const T, pFuncEnter3: ?*?FunctionEnter3, pFuncLeave3: ?*?FunctionLeave3, pFuncTailcall3: ?*?FunctionTailcall3) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).SetEnterLeaveFunctionHooks3(@as(*const ICorProfilerInfo3, @ptrCast(self)), pFuncEnter3, pFuncLeave3, pFuncTailcall3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_SetEnterLeaveFunctionHooks3WithInfo(self: *const T, pFuncEnter3WithInfo: ?*?FunctionEnter3WithInfo, pFuncLeave3WithInfo: ?*?FunctionLeave3WithInfo, pFuncTailcall3WithInfo: ?*?FunctionTailcall3WithInfo) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).SetEnterLeaveFunctionHooks3WithInfo(@as(*const ICorProfilerInfo3, @ptrCast(self)), pFuncEnter3WithInfo, pFuncLeave3WithInfo, pFuncTailcall3WithInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetFunctionEnter3Info(self: *const T, functionId: usize, eltInfo: usize, pFrameInfo: ?*usize, pcbArgumentInfo: ?*u32, pArgumentInfo: [*]COR_PRF_FUNCTION_ARGUMENT_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetFunctionEnter3Info(@as(*const ICorProfilerInfo3, @ptrCast(self)), functionId, eltInfo, pFrameInfo, pcbArgumentInfo, pArgumentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetFunctionLeave3Info(self: *const T, functionId: usize, eltInfo: usize, pFrameInfo: ?*usize, pRetvalRange: ?*COR_PRF_FUNCTION_ARGUMENT_RANGE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetFunctionLeave3Info(@as(*const ICorProfilerInfo3, @ptrCast(self)), functionId, eltInfo, pFrameInfo, pRetvalRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetFunctionTailcall3Info(self: *const T, functionId: usize, eltInfo: usize, pFrameInfo: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetFunctionTailcall3Info(@as(*const ICorProfilerInfo3, @ptrCast(self)), functionId, eltInfo, pFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_EnumModules(self: *const T, ppEnum: ?*?*ICorProfilerModuleEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).EnumModules(@as(*const ICorProfilerInfo3, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetRuntimeInformation(self: *const T, pClrInstanceId: ?*u16, pRuntimeType: ?*COR_PRF_RUNTIME_TYPE, pMajorVersion: ?*u16, pMinorVersion: ?*u16, pBuildNumber: ?*u16, pQFEVersion: ?*u16, cchVersionString: u32, pcchVersionString: ?*u32, szVersionString: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetRuntimeInformation(@as(*const ICorProfilerInfo3, @ptrCast(self)), pClrInstanceId, pRuntimeType, pMajorVersion, pMinorVersion, pBuildNumber, pQFEVersion, cchVersionString, pcchVersionString, szVersionString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetThreadStaticAddress2(self: *const T, classId: usize, fieldToken: u32, appDomainId: usize, threadId: usize, ppAddress: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetThreadStaticAddress2(@as(*const ICorProfilerInfo3, @ptrCast(self)), classId, fieldToken, appDomainId, threadId, ppAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetAppDomainsContainingModule(self: *const T, moduleId: usize, cAppDomainIds: u32, pcAppDomainIds: ?*u32, appDomainIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetAppDomainsContainingModule(@as(*const ICorProfilerInfo3, @ptrCast(self)), moduleId, cAppDomainIds, pcAppDomainIds, appDomainIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo3_GetModuleInfo2(self: *const T, moduleId: usize, ppBaseLoadAddress: ?*?*u8, cchName: u32, pcchName: ?*u32, szName: [*:0]u16, pAssemblyId: ?*usize, pdwModuleFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo3.VTable, @ptrCast(self.vtable)).GetModuleInfo2(@as(*const ICorProfilerInfo3, @ptrCast(self)), moduleId, ppBaseLoadAddress, cchName, pcchName, szName, pAssemblyId, pdwModuleFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerObjectEnum_Value = Guid.initString("2c6269bd-2d13-4321-ae12-6686365fd6af");
pub const IID_ICorProfilerObjectEnum = &IID_ICorProfilerObjectEnum_Value;
pub const ICorProfilerObjectEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerObjectEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerObjectEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerObjectEnum,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerObjectEnum,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerObjectEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerObjectEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerObjectEnum,
                celt: u32,
                objects: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerObjectEnum,
                celt: u32,
                objects: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerObjectEnum_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerObjectEnum.VTable, @ptrCast(self.vtable)).Skip(@as(*const ICorProfilerObjectEnum, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerObjectEnum_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerObjectEnum.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICorProfilerObjectEnum, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerObjectEnum_Clone(self: *const T, ppEnum: ?*?*ICorProfilerObjectEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerObjectEnum.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICorProfilerObjectEnum, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerObjectEnum_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerObjectEnum.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICorProfilerObjectEnum, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerObjectEnum_Next(self: *const T, celt: u32, objects: [*]usize, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerObjectEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const ICorProfilerObjectEnum, @ptrCast(self)), celt, objects, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerFunctionEnum_Value = Guid.initString("ff71301a-b994-429d-a10b-b345a65280ef");
pub const IID_ICorProfilerFunctionEnum = &IID_ICorProfilerFunctionEnum_Value;
pub const ICorProfilerFunctionEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionEnum,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionEnum,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionEnum,
                celt: u32,
                ids: [*]COR_PRF_FUNCTION,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionEnum,
                celt: u32,
                ids: [*]COR_PRF_FUNCTION,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionEnum_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionEnum.VTable, @ptrCast(self.vtable)).Skip(@as(*const ICorProfilerFunctionEnum, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionEnum_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionEnum.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICorProfilerFunctionEnum, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionEnum_Clone(self: *const T, ppEnum: ?*?*ICorProfilerFunctionEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionEnum.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICorProfilerFunctionEnum, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionEnum_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionEnum.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICorProfilerFunctionEnum, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionEnum_Next(self: *const T, celt: u32, ids: [*]COR_PRF_FUNCTION, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const ICorProfilerFunctionEnum, @ptrCast(self)), celt, ids, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerModuleEnum_Value = Guid.initString("b0266d75-2081-4493-af7f-028ba34db891");
pub const IID_ICorProfilerModuleEnum = &IID_ICorProfilerModuleEnum_Value;
pub const ICorProfilerModuleEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerModuleEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerModuleEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerModuleEnum,
                ppEnum: ?*?*ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerModuleEnum,
                ppEnum: ?*?*ICorProfilerModuleEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerModuleEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerModuleEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerModuleEnum,
                celt: u32,
                ids: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerModuleEnum,
                celt: u32,
                ids: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerModuleEnum_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerModuleEnum.VTable, @ptrCast(self.vtable)).Skip(@as(*const ICorProfilerModuleEnum, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerModuleEnum_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerModuleEnum.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICorProfilerModuleEnum, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerModuleEnum_Clone(self: *const T, ppEnum: ?*?*ICorProfilerModuleEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerModuleEnum.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICorProfilerModuleEnum, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerModuleEnum_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerModuleEnum.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICorProfilerModuleEnum, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerModuleEnum_Next(self: *const T, celt: u32, ids: [*]usize, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerModuleEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const ICorProfilerModuleEnum, @ptrCast(self)), celt, ids, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMethodMalloc_Value = Guid.initString("a0efb28b-6ee2-4d7b-b983-a75ef7beedb8");
pub const IID_IMethodMalloc = &IID_IMethodMalloc_Value;
pub const IMethodMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMethodMalloc,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
            else => *const fn(
                self: *const IMethodMalloc,
                cb: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMethodMalloc_Alloc(self: *const T, cb: u32) callconv(.Inline) ?*anyopaque {
            return @as(*const IMethodMalloc.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IMethodMalloc, @ptrCast(self)), cb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerFunctionControl_Value = Guid.initString("f0963021-e1ea-4732-8581-e01b0bd3c0c6");
pub const IID_ICorProfilerFunctionControl = &IID_ICorProfilerFunctionControl_Value;
pub const ICorProfilerFunctionControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCodegenFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionControl,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionControl,
                flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetILFunctionBody: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionControl,
                cbNewILMethodHeader: u32,
                pbNewILMethodHeader: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionControl,
                cbNewILMethodHeader: u32,
                pbNewILMethodHeader: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetILInstrumentedCodeMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerFunctionControl,
                cILMapEntries: u32,
                rgILMapEntries: [*]COR_IL_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerFunctionControl,
                cILMapEntries: u32,
                rgILMapEntries: [*]COR_IL_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionControl_SetCodegenFlags(self: *const T, flags: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionControl.VTable, @ptrCast(self.vtable)).SetCodegenFlags(@as(*const ICorProfilerFunctionControl, @ptrCast(self)), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionControl_SetILFunctionBody(self: *const T, cbNewILMethodHeader: u32, pbNewILMethodHeader: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionControl.VTable, @ptrCast(self.vtable)).SetILFunctionBody(@as(*const ICorProfilerFunctionControl, @ptrCast(self)), cbNewILMethodHeader, pbNewILMethodHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerFunctionControl_SetILInstrumentedCodeMap(self: *const T, cILMapEntries: u32, rgILMapEntries: [*]COR_IL_MAP) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerFunctionControl.VTable, @ptrCast(self.vtable)).SetILInstrumentedCodeMap(@as(*const ICorProfilerFunctionControl, @ptrCast(self)), cILMapEntries, rgILMapEntries);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo4_Value = Guid.initString("0d8fdcaa-6257-47bf-b1bf-94dac88466ee");
pub const IID_ICorProfilerInfo4 = &IID_ICorProfilerInfo4_Value;
pub const ICorProfilerInfo4 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo3.VTable,
        EnumThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                ppEnum: ?*?*ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                ppEnum: ?*?*ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeCurrentThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestReJIT: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestRevert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
                status: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
                status: [*]HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeInfo3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                functionID: usize,
                reJitId: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: [*]COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                functionID: usize,
                reJitId: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: [*]COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionFromIP2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                ip: ?*u8,
                pFunctionId: ?*usize,
                pReJitId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                ip: ?*u8,
                pFunctionId: ?*usize,
                pReJitId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReJITIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                functionId: usize,
                cReJitIds: u32,
                pcReJitIds: ?*u32,
                reJitIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                functionId: usize,
                cReJitIds: u32,
                pcReJitIds: ?*u32,
                reJitIds: [*]usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetILToNativeMapping2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                functionId: usize,
                reJitId: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: [*]COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                functionId: usize,
                reJitId: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: [*]COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumJITedFunctions2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                ppEnum: ?*?*ICorProfilerFunctionEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectSize2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo4,
                objectId: usize,
                pcSize: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo4,
                objectId: usize,
                pcSize: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_EnumThreads(self: *const T, ppEnum: ?*?*ICorProfilerThreadEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).EnumThreads(@as(*const ICorProfilerInfo4, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_InitializeCurrentThread(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).InitializeCurrentThread(@as(*const ICorProfilerInfo4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_RequestReJIT(self: *const T, cFunctions: u32, moduleIds: [*]usize, methodIds: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).RequestReJIT(@as(*const ICorProfilerInfo4, @ptrCast(self)), cFunctions, moduleIds, methodIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_RequestRevert(self: *const T, cFunctions: u32, moduleIds: [*]usize, methodIds: [*]u32, status: [*]HRESULT) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).RequestRevert(@as(*const ICorProfilerInfo4, @ptrCast(self)), cFunctions, moduleIds, methodIds, status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_GetCodeInfo3(self: *const T, functionID: usize, reJitId: usize, cCodeInfos: u32, pcCodeInfos: ?*u32, codeInfos: [*]COR_PRF_CODE_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).GetCodeInfo3(@as(*const ICorProfilerInfo4, @ptrCast(self)), functionID, reJitId, cCodeInfos, pcCodeInfos, codeInfos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_GetFunctionFromIP2(self: *const T, ip: ?*u8, pFunctionId: ?*usize, pReJitId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).GetFunctionFromIP2(@as(*const ICorProfilerInfo4, @ptrCast(self)), ip, pFunctionId, pReJitId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_GetReJITIDs(self: *const T, functionId: usize, cReJitIds: u32, pcReJitIds: ?*u32, reJitIds: [*]usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).GetReJITIDs(@as(*const ICorProfilerInfo4, @ptrCast(self)), functionId, cReJitIds, pcReJitIds, reJitIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_GetILToNativeMapping2(self: *const T, functionId: usize, reJitId: usize, cMap: u32, pcMap: ?*u32, map: [*]COR_DEBUG_IL_TO_NATIVE_MAP) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).GetILToNativeMapping2(@as(*const ICorProfilerInfo4, @ptrCast(self)), functionId, reJitId, cMap, pcMap, map);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_EnumJITedFunctions2(self: *const T, ppEnum: ?*?*ICorProfilerFunctionEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).EnumJITedFunctions2(@as(*const ICorProfilerInfo4, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo4_GetObjectSize2(self: *const T, objectId: usize, pcSize: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo4.VTable, @ptrCast(self.vtable)).GetObjectSize2(@as(*const ICorProfilerInfo4, @ptrCast(self)), objectId, pcSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo5_Value = Guid.initString("07602928-ce38-4b83-81e7-74adaf781214");
pub const IID_ICorProfilerInfo5 = &IID_ICorProfilerInfo5_Value;
pub const ICorProfilerInfo5 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo4.VTable,
        GetEventMask2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo5,
                pdwEventsLow: ?*u32,
                pdwEventsHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo5,
                pdwEventsLow: ?*u32,
                pdwEventsHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventMask2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo5,
                dwEventsLow: u32,
                dwEventsHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo5,
                dwEventsLow: u32,
                dwEventsHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo5_GetEventMask2(self: *const T, pdwEventsLow: ?*u32, pdwEventsHigh: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo5.VTable, @ptrCast(self.vtable)).GetEventMask2(@as(*const ICorProfilerInfo5, @ptrCast(self)), pdwEventsLow, pdwEventsHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo5_SetEventMask2(self: *const T, dwEventsLow: u32, dwEventsHigh: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo5.VTable, @ptrCast(self.vtable)).SetEventMask2(@as(*const ICorProfilerInfo5, @ptrCast(self)), dwEventsLow, dwEventsHigh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo6_Value = Guid.initString("f30a070d-bffb-46a7-b1d8-8781ef7b698a");
pub const IID_ICorProfilerInfo6 = &IID_ICorProfilerInfo6_Value;
pub const ICorProfilerInfo6 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo5.VTable,
        EnumNgenModuleMethodsInliningThisMethod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo6,
                inlinersModuleId: usize,
                inlineeModuleId: usize,
                inlineeMethodId: u32,
                incompleteData: ?*BOOL,
                ppEnum: ?*?*ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo6,
                inlinersModuleId: usize,
                inlineeModuleId: usize,
                inlineeMethodId: u32,
                incompleteData: ?*BOOL,
                ppEnum: ?*?*ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo6_EnumNgenModuleMethodsInliningThisMethod(self: *const T, inlinersModuleId: usize, inlineeModuleId: usize, inlineeMethodId: u32, incompleteData: ?*BOOL, ppEnum: ?*?*ICorProfilerMethodEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo6.VTable, @ptrCast(self.vtable)).EnumNgenModuleMethodsInliningThisMethod(@as(*const ICorProfilerInfo6, @ptrCast(self)), inlinersModuleId, inlineeModuleId, inlineeMethodId, incompleteData, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo7_Value = Guid.initString("9aeecc0d-63e0-4187-8c00-e312f503f663");
pub const IID_ICorProfilerInfo7 = &IID_ICorProfilerInfo7_Value;
pub const ICorProfilerInfo7 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo6.VTable,
        ApplyMetaData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInMemorySymbolsLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
                pCountSymbolBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
                pCountSymbolBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadInMemorySymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
                symbolsReadOffset: u32,
                pSymbolBytes: ?*u8,
                countSymbolBytes: u32,
                pCountSymbolBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo7,
                moduleId: usize,
                symbolsReadOffset: u32,
                pSymbolBytes: ?*u8,
                countSymbolBytes: u32,
                pCountSymbolBytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo7_ApplyMetaData(self: *const T, moduleId: usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo7.VTable, @ptrCast(self.vtable)).ApplyMetaData(@as(*const ICorProfilerInfo7, @ptrCast(self)), moduleId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo7_GetInMemorySymbolsLength(self: *const T, moduleId: usize, pCountSymbolBytes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo7.VTable, @ptrCast(self.vtable)).GetInMemorySymbolsLength(@as(*const ICorProfilerInfo7, @ptrCast(self)), moduleId, pCountSymbolBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo7_ReadInMemorySymbols(self: *const T, moduleId: usize, symbolsReadOffset: u32, pSymbolBytes: ?*u8, countSymbolBytes: u32, pCountSymbolBytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo7.VTable, @ptrCast(self.vtable)).ReadInMemorySymbols(@as(*const ICorProfilerInfo7, @ptrCast(self)), moduleId, symbolsReadOffset, pSymbolBytes, countSymbolBytes, pCountSymbolBytesRead);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo8_Value = Guid.initString("c5ac80a6-782e-4716-8044-39598c60cfbf");
pub const IID_ICorProfilerInfo8 = &IID_ICorProfilerInfo8_Value;
pub const ICorProfilerInfo8 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo7.VTable,
        IsFunctionDynamic: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo8,
                functionId: usize,
                isDynamic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo8,
                functionId: usize,
                isDynamic: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionFromIP3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo8,
                ip: ?*u8,
                functionId: ?*usize,
                pReJitId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo8,
                ip: ?*u8,
                functionId: ?*usize,
                pReJitId: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDynamicFunctionInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo8,
                functionId: usize,
                moduleId: ?*usize,
                ppvSig: ?*?*u8,
                pbSig: ?*u32,
                cchName: u32,
                pcchName: ?*u32,
                wszName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo8,
                functionId: usize,
                moduleId: ?*usize,
                ppvSig: ?*?*u8,
                pbSig: ?*u32,
                cchName: u32,
                pcchName: ?*u32,
                wszName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo8_IsFunctionDynamic(self: *const T, functionId: usize, isDynamic: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo8.VTable, @ptrCast(self.vtable)).IsFunctionDynamic(@as(*const ICorProfilerInfo8, @ptrCast(self)), functionId, isDynamic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo8_GetFunctionFromIP3(self: *const T, ip: ?*u8, functionId: ?*usize, pReJitId: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo8.VTable, @ptrCast(self.vtable)).GetFunctionFromIP3(@as(*const ICorProfilerInfo8, @ptrCast(self)), ip, functionId, pReJitId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo8_GetDynamicFunctionInfo(self: *const T, functionId: usize, moduleId: ?*usize, ppvSig: ?*?*u8, pbSig: ?*u32, cchName: u32, pcchName: ?*u32, wszName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo8.VTable, @ptrCast(self.vtable)).GetDynamicFunctionInfo(@as(*const ICorProfilerInfo8, @ptrCast(self)), functionId, moduleId, ppvSig, pbSig, cchName, pcchName, wszName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo9_Value = Guid.initString("008170db-f8cc-4796-9a51-dc8aa0b47012");
pub const IID_ICorProfilerInfo9 = &IID_ICorProfilerInfo9_Value;
pub const ICorProfilerInfo9 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo8.VTable,
        GetNativeCodeStartAddresses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo9,
                functionID: usize,
                reJitId: usize,
                cCodeStartAddresses: u32,
                pcCodeStartAddresses: ?*u32,
                codeStartAddresses: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo9,
                functionID: usize,
                reJitId: usize,
                cCodeStartAddresses: u32,
                pcCodeStartAddresses: ?*u32,
                codeStartAddresses: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetILToNativeMapping3: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo9,
                pNativeCodeStartAddress: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: ?*COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo9,
                pNativeCodeStartAddress: usize,
                cMap: u32,
                pcMap: ?*u32,
                map: ?*COR_DEBUG_IL_TO_NATIVE_MAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeInfo4: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo9,
                pNativeCodeStartAddress: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: ?*COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo9,
                pNativeCodeStartAddress: usize,
                cCodeInfos: u32,
                pcCodeInfos: ?*u32,
                codeInfos: ?*COR_PRF_CODE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo9_GetNativeCodeStartAddresses(self: *const T, functionID: usize, reJitId: usize, cCodeStartAddresses: u32, pcCodeStartAddresses: ?*u32, codeStartAddresses: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo9.VTable, @ptrCast(self.vtable)).GetNativeCodeStartAddresses(@as(*const ICorProfilerInfo9, @ptrCast(self)), functionID, reJitId, cCodeStartAddresses, pcCodeStartAddresses, codeStartAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo9_GetILToNativeMapping3(self: *const T, pNativeCodeStartAddress: usize, cMap: u32, pcMap: ?*u32, map: ?*COR_DEBUG_IL_TO_NATIVE_MAP) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo9.VTable, @ptrCast(self.vtable)).GetILToNativeMapping3(@as(*const ICorProfilerInfo9, @ptrCast(self)), pNativeCodeStartAddress, cMap, pcMap, map);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo9_GetCodeInfo4(self: *const T, pNativeCodeStartAddress: usize, cCodeInfos: u32, pcCodeInfos: ?*u32, codeInfos: ?*COR_PRF_CODE_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo9.VTable, @ptrCast(self.vtable)).GetCodeInfo4(@as(*const ICorProfilerInfo9, @ptrCast(self)), pNativeCodeStartAddress, cCodeInfos, pcCodeInfos, codeInfos);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo10_Value = Guid.initString("2f1b5152-c869-40c9-aa5f-3abe026bd720");
pub const IID_ICorProfilerInfo10 = &IID_ICorProfilerInfo10_Value;
pub const ICorProfilerInfo10 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo9.VTable,
        EnumerateObjectReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
                objectId: usize,
                callback: ?ObjectReferenceCallback,
                clientData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
                objectId: usize,
                callback: ?ObjectReferenceCallback,
                clientData: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFrozenObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
                objectId: usize,
                pbFrozen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
                objectId: usize,
                pbFrozen: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLOHObjectSizeThreshold: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
                pThreshold: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
                pThreshold: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestReJITWithInliners: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
                dwRejitFlags: u32,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
                dwRejitFlags: u32,
                cFunctions: u32,
                moduleIds: [*]usize,
                methodIds: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspendRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumeRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo10,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo10,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo9.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_EnumerateObjectReferences(self: *const T, objectId: usize, callback: ?ObjectReferenceCallback, clientData: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).EnumerateObjectReferences(@as(*const ICorProfilerInfo10, @ptrCast(self)), objectId, callback, clientData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_IsFrozenObject(self: *const T, objectId: usize, pbFrozen: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).IsFrozenObject(@as(*const ICorProfilerInfo10, @ptrCast(self)), objectId, pbFrozen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_GetLOHObjectSizeThreshold(self: *const T, pThreshold: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).GetLOHObjectSizeThreshold(@as(*const ICorProfilerInfo10, @ptrCast(self)), pThreshold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_RequestReJITWithInliners(self: *const T, dwRejitFlags: u32, cFunctions: u32, moduleIds: [*]usize, methodIds: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).RequestReJITWithInliners(@as(*const ICorProfilerInfo10, @ptrCast(self)), dwRejitFlags, cFunctions, moduleIds, methodIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_SuspendRuntime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).SuspendRuntime(@as(*const ICorProfilerInfo10, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo10_ResumeRuntime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo10.VTable, @ptrCast(self.vtable)).ResumeRuntime(@as(*const ICorProfilerInfo10, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo11_Value = Guid.initString("06398876-8987-4154-b621-40a00d6e4d04");
pub const IID_ICorProfilerInfo11 = &IID_ICorProfilerInfo11_Value;
pub const ICorProfilerInfo11 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo10.VTable,
        GetEnvironmentVariableA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo11,
                szName: ?[*:0]align(1) const u16,
                cchValue: u32,
                pcchValue: ?*u32,
                szValue: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo11,
                szName: ?[*:0]align(1) const u16,
                cchValue: u32,
                pcchValue: ?*u32,
                szValue: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnvironmentVariable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo11,
                szName: ?[*:0]align(1) const u16,
                szValue: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo11,
                szName: ?[*:0]align(1) const u16,
                szValue: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo10.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo11_GetEnvironmentVariableA(self: *const T, szName: ?[*:0]align(1) const u16, cchValue: u32, pcchValue: ?*u32, szValue: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo11.VTable, @ptrCast(self.vtable)).GetEnvironmentVariableA(@as(*const ICorProfilerInfo11, @ptrCast(self)), szName, cchValue, pcchValue, szValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo11_SetEnvironmentVariable(self: *const T, szName: ?[*:0]align(1) const u16, szValue: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo11.VTable, @ptrCast(self.vtable)).SetEnvironmentVariable(@as(*const ICorProfilerInfo11, @ptrCast(self)), szName, szValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo12_Value = Guid.initString("27b24ccd-1cb1-47c5-96ee-98190dc30959");
pub const IID_ICorProfilerInfo12 = &IID_ICorProfilerInfo12_Value;
pub const ICorProfilerInfo12 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo11.VTable,
        EventPipeStartSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                cProviderConfigs: u32,
                pProviderConfigs: [*]COR_PRF_EVENTPIPE_PROVIDER_CONFIG,
                requestRundown: BOOL,
                pSession: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                cProviderConfigs: u32,
                pProviderConfigs: [*]COR_PRF_EVENTPIPE_PROVIDER_CONFIG,
                requestRundown: BOOL,
                pSession: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeAddProviderToSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                session: u64,
                providerConfig: COR_PRF_EVENTPIPE_PROVIDER_CONFIG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                session: u64,
                providerConfig: COR_PRF_EVENTPIPE_PROVIDER_CONFIG,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeStopSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                session: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                session: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeCreateProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                providerName: ?[*:0]align(1) const u16,
                pProvider: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                providerName: ?[*:0]align(1) const u16,
                pProvider: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeGetProviderInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                provider: usize,
                cchName: u32,
                pcchName: ?*u32,
                providerName: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                provider: usize,
                cchName: u32,
                pcchName: ?*u32,
                providerName: [*:0]u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeDefineEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                provider: usize,
                eventName: ?[*:0]align(1) const u16,
                eventID: u32,
                keywords: u64,
                eventVersion: u32,
                level: u32,
                opcode: u8,
                needStack: BOOL,
                cParamDescs: u32,
                pParamDescs: [*]COR_PRF_EVENTPIPE_PARAM_DESC,
                pEvent: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                provider: usize,
                eventName: ?[*:0]align(1) const u16,
                eventID: u32,
                keywords: u64,
                eventVersion: u32,
                level: u32,
                opcode: u8,
                needStack: BOOL,
                cParamDescs: u32,
                pParamDescs: [*]COR_PRF_EVENTPIPE_PARAM_DESC,
                pEvent: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeWriteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo12,
                event: usize,
                cData: u32,
                data: [*]COR_PRF_EVENT_DATA,
                pActivityId: ?*const Guid,
                pRelatedActivityId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo12,
                event: usize,
                cData: u32,
                data: [*]COR_PRF_EVENT_DATA,
                pActivityId: ?*const Guid,
                pRelatedActivityId: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo11.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeStartSession(self: *const T, cProviderConfigs: u32, pProviderConfigs: [*]COR_PRF_EVENTPIPE_PROVIDER_CONFIG, requestRundown: BOOL, pSession: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeStartSession(@as(*const ICorProfilerInfo12, @ptrCast(self)), cProviderConfigs, pProviderConfigs, requestRundown, pSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeAddProviderToSession(self: *const T, session: u64, providerConfig: COR_PRF_EVENTPIPE_PROVIDER_CONFIG) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeAddProviderToSession(@as(*const ICorProfilerInfo12, @ptrCast(self)), session, providerConfig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeStopSession(self: *const T, session: u64) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeStopSession(@as(*const ICorProfilerInfo12, @ptrCast(self)), session);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeCreateProvider(self: *const T, providerName: ?[*:0]align(1) const u16, pProvider: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeCreateProvider(@as(*const ICorProfilerInfo12, @ptrCast(self)), providerName, pProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeGetProviderInfo(self: *const T, provider: usize, cchName: u32, pcchName: ?*u32, providerName: [*:0]u16) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeGetProviderInfo(@as(*const ICorProfilerInfo12, @ptrCast(self)), provider, cchName, pcchName, providerName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeDefineEvent(self: *const T, provider: usize, eventName: ?[*:0]align(1) const u16, eventID: u32, keywords: u64, eventVersion: u32, level: u32, opcode: u8, needStack: BOOL, cParamDescs: u32, pParamDescs: [*]COR_PRF_EVENTPIPE_PARAM_DESC, pEvent: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeDefineEvent(@as(*const ICorProfilerInfo12, @ptrCast(self)), provider, eventName, eventID, keywords, eventVersion, level, opcode, needStack, cParamDescs, pParamDescs, pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo12_EventPipeWriteEvent(self: *const T, event: usize, cData: u32, data: [*]COR_PRF_EVENT_DATA, pActivityId: ?*const Guid, pRelatedActivityId: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo12.VTable, @ptrCast(self.vtable)).EventPipeWriteEvent(@as(*const ICorProfilerInfo12, @ptrCast(self)), event, cData, data, pActivityId, pRelatedActivityId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo13_Value = Guid.initString("6e6c7ee2-0701-4ec2-9d29-2e8733b66934");
pub const IID_ICorProfilerInfo13 = &IID_ICorProfilerInfo13_Value;
pub const ICorProfilerInfo13 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo12.VTable,
        CreateHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo13,
                object: usize,
                type: COR_PRF_HANDLE_TYPE,
                pHandle: ?*?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo13,
                object: usize,
                type: COR_PRF_HANDLE_TYPE,
                pHandle: ?*?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo13,
                handle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo13,
                handle: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectIDFromHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo13,
                handle: ?*?*anyopaque,
                pObject: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo13,
                handle: ?*?*anyopaque,
                pObject: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo12.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo13_CreateHandle(self: *const T, object: usize, type_: COR_PRF_HANDLE_TYPE, pHandle: ?*?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo13.VTable, @ptrCast(self.vtable)).CreateHandle(@as(*const ICorProfilerInfo13, @ptrCast(self)), object, type_, pHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo13_DestroyHandle(self: *const T, handle: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo13.VTable, @ptrCast(self.vtable)).DestroyHandle(@as(*const ICorProfilerInfo13, @ptrCast(self)), handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo13_GetObjectIDFromHandle(self: *const T, handle: ?*?*anyopaque, pObject: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo13.VTable, @ptrCast(self.vtable)).GetObjectIDFromHandle(@as(*const ICorProfilerInfo13, @ptrCast(self)), handle, pObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerInfo14_Value = Guid.initString("f460e352-d76d-4fe9-835f-f6af9d6e862d");
pub const IID_ICorProfilerInfo14 = &IID_ICorProfilerInfo14_Value;
pub const ICorProfilerInfo14 = extern struct {
    pub const VTable = extern struct {
        base: ICorProfilerInfo13.VTable,
        EnumerateNonGCObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo14,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo14,
                ppEnum: ?*?*ICorProfilerObjectEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNonGCHeapBounds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo14,
                cObjectRanges: u32,
                pcObjectRanges: ?*u32,
                ranges: [*]COR_PRF_NONGC_HEAP_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo14,
                cObjectRanges: u32,
                pcObjectRanges: ?*u32,
                ranges: [*]COR_PRF_NONGC_HEAP_RANGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EventPipeCreateProvider2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerInfo14,
                providerName: ?[*:0]align(1) const u16,
                pCallback: ?*?EventPipeProviderCallback,
                pProvider: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerInfo14,
                providerName: ?[*:0]align(1) const u16,
                pCallback: ?*?EventPipeProviderCallback,
                pProvider: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICorProfilerInfo13.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo14_EnumerateNonGCObjects(self: *const T, ppEnum: ?*?*ICorProfilerObjectEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo14.VTable, @ptrCast(self.vtable)).EnumerateNonGCObjects(@as(*const ICorProfilerInfo14, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo14_GetNonGCHeapBounds(self: *const T, cObjectRanges: u32, pcObjectRanges: ?*u32, ranges: [*]COR_PRF_NONGC_HEAP_RANGE) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo14.VTable, @ptrCast(self.vtable)).GetNonGCHeapBounds(@as(*const ICorProfilerInfo14, @ptrCast(self)), cObjectRanges, pcObjectRanges, ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerInfo14_EventPipeCreateProvider2(self: *const T, providerName: ?[*:0]align(1) const u16, pCallback: ?*?EventPipeProviderCallback, pProvider: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerInfo14.VTable, @ptrCast(self.vtable)).EventPipeCreateProvider2(@as(*const ICorProfilerInfo14, @ptrCast(self)), providerName, pCallback, pProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerMethodEnum_Value = Guid.initString("fccee788-0088-454b-a811-c99f298d1942");
pub const IID_ICorProfilerMethodEnum = &IID_ICorProfilerMethodEnum_Value;
pub const ICorProfilerMethodEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerMethodEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerMethodEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerMethodEnum,
                ppEnum: ?*?*ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerMethodEnum,
                ppEnum: ?*?*ICorProfilerMethodEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerMethodEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerMethodEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerMethodEnum,
                celt: u32,
                elements: [*]COR_PRF_METHOD,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerMethodEnum,
                celt: u32,
                elements: [*]COR_PRF_METHOD,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerMethodEnum_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerMethodEnum.VTable, @ptrCast(self.vtable)).Skip(@as(*const ICorProfilerMethodEnum, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerMethodEnum_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerMethodEnum.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICorProfilerMethodEnum, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerMethodEnum_Clone(self: *const T, ppEnum: ?*?*ICorProfilerMethodEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerMethodEnum.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICorProfilerMethodEnum, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerMethodEnum_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerMethodEnum.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICorProfilerMethodEnum, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerMethodEnum_Next(self: *const T, celt: u32, elements: [*]COR_PRF_METHOD, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerMethodEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const ICorProfilerMethodEnum, @ptrCast(self)), celt, elements, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerThreadEnum_Value = Guid.initString("571194f7-25ed-419f-aa8b-7016b3159701");
pub const IID_ICorProfilerThreadEnum = &IID_ICorProfilerThreadEnum_Value;
pub const ICorProfilerThreadEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerThreadEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerThreadEnum,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerThreadEnum,
                ppEnum: ?*?*ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerThreadEnum,
                ppEnum: ?*?*ICorProfilerThreadEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerThreadEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerThreadEnum,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerThreadEnum,
                celt: u32,
                ids: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerThreadEnum,
                celt: u32,
                ids: [*]usize,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerThreadEnum_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerThreadEnum.VTable, @ptrCast(self.vtable)).Skip(@as(*const ICorProfilerThreadEnum, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerThreadEnum_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerThreadEnum.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICorProfilerThreadEnum, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerThreadEnum_Clone(self: *const T, ppEnum: ?*?*ICorProfilerThreadEnum) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerThreadEnum.VTable, @ptrCast(self.vtable)).Clone(@as(*const ICorProfilerThreadEnum, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerThreadEnum_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerThreadEnum.VTable, @ptrCast(self.vtable)).GetCount(@as(*const ICorProfilerThreadEnum, @ptrCast(self)), pcelt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerThreadEnum_Next(self: *const T, celt: u32, ids: [*]usize, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerThreadEnum.VTable, @ptrCast(self.vtable)).Next(@as(*const ICorProfilerThreadEnum, @ptrCast(self)), celt, ids, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorProfilerAssemblyReferenceProvider_Value = Guid.initString("66a78c24-2eef-4f65-b45f-dd1d8038bf3c");
pub const IID_ICorProfilerAssemblyReferenceProvider = &IID_ICorProfilerAssemblyReferenceProvider_Value;
pub const ICorProfilerAssemblyReferenceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAssemblyReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorProfilerAssemblyReferenceProvider,
                pAssemblyRefInfo: ?*const COR_PRF_ASSEMBLY_REFERENCE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorProfilerAssemblyReferenceProvider,
                pAssemblyRefInfo: ?*const COR_PRF_ASSEMBLY_REFERENCE_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorProfilerAssemblyReferenceProvider_AddAssemblyReference(self: *const T, pAssemblyRefInfo: ?*const COR_PRF_ASSEMBLY_REFERENCE_INFO) callconv(.Inline) HRESULT {
            return @as(*const ICorProfilerAssemblyReferenceProvider.VTable, @ptrCast(self.vtable)).AddAssemblyReference(@as(*const ICorProfilerAssemblyReferenceProvider, @ptrCast(self)), pAssemblyRefInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (9)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../zig.zig").Guid;
const ASSEMBLYMETADATA = @import("../../../../windows/win32/system/win_rt/metadata.zig").ASSEMBLYMETADATA;
const BOOL = @import("../../../../windows/win32/foundation.zig").BOOL;
const COR_FIELD_OFFSET = @import("../../../../windows/win32/system/win_rt/metadata.zig").COR_FIELD_OFFSET;
const CorElementType = @import("../../../../windows/win32/system/win_rt/metadata.zig").CorElementType;
const HANDLE = @import("../../../../windows/win32/foundation.zig").HANDLE;
const HRESULT = @import("../../../../windows/win32/foundation.zig").HRESULT;
const IUnknown = @import("../../../../windows/win32/system/com.zig").IUnknown;
const PWSTR = @import("../../../../windows/win32/foundation.zig").PWSTR;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "FunctionIDMapper")) { _ = FunctionIDMapper; }
    if (@hasDecl(@This(), "FunctionIDMapper2")) { _ = FunctionIDMapper2; }
    if (@hasDecl(@This(), "FunctionEnter")) { _ = FunctionEnter; }
    if (@hasDecl(@This(), "FunctionLeave")) { _ = FunctionLeave; }
    if (@hasDecl(@This(), "FunctionTailcall")) { _ = FunctionTailcall; }
    if (@hasDecl(@This(), "FunctionEnter2")) { _ = FunctionEnter2; }
    if (@hasDecl(@This(), "FunctionLeave2")) { _ = FunctionLeave2; }
    if (@hasDecl(@This(), "FunctionTailcall2")) { _ = FunctionTailcall2; }
    if (@hasDecl(@This(), "FunctionEnter3")) { _ = FunctionEnter3; }
    if (@hasDecl(@This(), "FunctionLeave3")) { _ = FunctionLeave3; }
    if (@hasDecl(@This(), "FunctionTailcall3")) { _ = FunctionTailcall3; }
    if (@hasDecl(@This(), "FunctionEnter3WithInfo")) { _ = FunctionEnter3WithInfo; }
    if (@hasDecl(@This(), "FunctionLeave3WithInfo")) { _ = FunctionLeave3WithInfo; }
    if (@hasDecl(@This(), "FunctionTailcall3WithInfo")) { _ = FunctionTailcall3WithInfo; }
    if (@hasDecl(@This(), "StackSnapshotCallback")) { _ = StackSnapshotCallback; }
    if (@hasDecl(@This(), "ObjectReferenceCallback")) { _ = ObjectReferenceCallback; }
    if (@hasDecl(@This(), "EventPipeProviderCallback")) { _ = EventPipeProviderCallback; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
