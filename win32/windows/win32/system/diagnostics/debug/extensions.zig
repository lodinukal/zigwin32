//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (922)
//--------------------------------------------------------------------------------
pub const ERROR_DBG_CANCELLED = @as(u32, 3221226695);
pub const ERROR_DBG_TIMEOUT = @as(u32, 3221226932);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS = @as(u32, 4);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL = @as(u32, 4);
pub const DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER = @as(u32, 0);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT = @as(u32, 1);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_THREAD = @as(u32, 2);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_RECORD = @as(u32, 3);
pub const DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 4);
pub const DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 5);
pub const DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS = @as(u32, 6);
pub const DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM = @as(u32, 7);
pub const DEBUG_REQUEST_TARGET_CAN_DETACH = @as(u32, 8);
pub const DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE = @as(u32, 9);
pub const DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET = @as(u32, 10);
pub const DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM = @as(u32, 11);
pub const DEBUG_REQUEST_EXT_TYPED_DATA_ANSI = @as(u32, 12);
pub const DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE = @as(u32, 13);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE = @as(u32, 14);
pub const DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO = @as(u32, 15);
pub const DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO = @as(u32, 16);
pub const DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO = @as(u32, 17);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI = @as(u32, 18);
pub const DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE = @as(u32, 19);
pub const DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION = @as(u32, 20);
pub const DEBUG_REQUEST_GET_DUMP_HEADER = @as(u32, 21);
pub const DEBUG_REQUEST_SET_DUMP_HEADER = @as(u32, 22);
pub const DEBUG_REQUEST_MIDORI = @as(u32, 23);
pub const DEBUG_REQUEST_PROCESS_DESCRIPTORS = @as(u32, 24);
pub const DEBUG_REQUEST_MISC_INFORMATION = @as(u32, 25);
pub const DEBUG_REQUEST_OPEN_PROCESS_TOKEN = @as(u32, 26);
pub const DEBUG_REQUEST_OPEN_THREAD_TOKEN = @as(u32, 27);
pub const DEBUG_REQUEST_DUPLICATE_TOKEN = @as(u32, 28);
pub const DEBUG_REQUEST_QUERY_INFO_TOKEN = @as(u32, 29);
pub const DEBUG_REQUEST_CLOSE_TOKEN = @as(u32, 30);
pub const DEBUG_REQUEST_WOW_PROCESS = @as(u32, 31);
pub const DEBUG_REQUEST_WOW_MODULE = @as(u32, 32);
pub const DEBUG_LIVE_USER_NON_INVASIVE = @as(u32, 33);
pub const DEBUG_REQUEST_RESUME_THREAD = @as(u32, 34);
pub const DEBUG_REQUEST_INLINE_QUERY = @as(u32, 35);
pub const DEBUG_REQUEST_TL_INSTRUMENTATION_AWARE = @as(u32, 36);
pub const DEBUG_REQUEST_GET_INSTRUMENTATION_VERSION = @as(u32, 37);
pub const DEBUG_REQUEST_GET_MODULE_ARCHITECTURE = @as(u32, 38);
pub const DEBUG_REQUEST_GET_IMAGE_ARCHITECTURE = @as(u32, 39);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN = @as(u32, 0);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE = @as(u32, 1);
pub const DEBUG_SRCFILE_SYMBOL_CHECKSUMINFO = @as(u32, 2);
pub const DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE = @as(u32, 0);
pub const DEBUG_SYMINFO_IMAGEHLP_MODULEW64 = @as(u32, 1);
pub const DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE = @as(u32, 2);
pub const DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS = @as(u32, 3);
pub const DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION = @as(u32, 0);
pub const DEBUG_SYSOBJINFO_THREAD_NAME_WIDE = @as(u32, 1);
pub const DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE = @as(u32, 2);
pub const DEBUG_TBINFO_EXIT_STATUS = @as(u32, 1);
pub const DEBUG_TBINFO_PRIORITY_CLASS = @as(u32, 2);
pub const DEBUG_TBINFO_PRIORITY = @as(u32, 4);
pub const DEBUG_TBINFO_TIMES = @as(u32, 8);
pub const DEBUG_TBINFO_START_OFFSET = @as(u32, 16);
pub const DEBUG_TBINFO_AFFINITY = @as(u32, 32);
pub const DEBUG_TBINFO_ALL = @as(u32, 63);
pub const DEBUG_BREAKPOINT_CODE = @as(u32, 0);
pub const DEBUG_BREAKPOINT_DATA = @as(u32, 1);
pub const DEBUG_BREAKPOINT_TIME = @as(u32, 2);
pub const DEBUG_BREAKPOINT_INLINE = @as(u32, 3);
pub const DEBUG_BREAKPOINT_GO_ONLY = @as(u32, 1);
pub const DEBUG_BREAKPOINT_DEFERRED = @as(u32, 2);
pub const DEBUG_BREAKPOINT_ENABLED = @as(u32, 4);
pub const DEBUG_BREAKPOINT_ADDER_ONLY = @as(u32, 8);
pub const DEBUG_BREAKPOINT_ONE_SHOT = @as(u32, 16);
pub const DEBUG_BREAK_READ = @as(u32, 1);
pub const DEBUG_BREAK_WRITE = @as(u32, 2);
pub const DEBUG_BREAK_EXECUTE = @as(u32, 4);
pub const DEBUG_BREAK_IO = @as(u32, 8);
pub const DEBUG_ATTACH_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_ATTACH_LOCAL_KERNEL = @as(u32, 1);
pub const DEBUG_ATTACH_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_ATTACH_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_GET_PROC_DEFAULT = @as(u32, 0);
pub const DEBUG_GET_PROC_FULL_MATCH = @as(u32, 1);
pub const DEBUG_GET_PROC_ONLY_MATCH = @as(u32, 2);
pub const DEBUG_GET_PROC_SERVICE_NAME = @as(u32, 4);
pub const DEBUG_PROC_DESC_DEFAULT = @as(u32, 0);
pub const DEBUG_PROC_DESC_NO_PATHS = @as(u32, 1);
pub const DEBUG_PROC_DESC_NO_SERVICES = @as(u32, 2);
pub const DEBUG_PROC_DESC_NO_MTS_PACKAGES = @as(u32, 4);
pub const DEBUG_PROC_DESC_NO_COMMAND_LINE = @as(u32, 8);
pub const DEBUG_PROC_DESC_NO_SESSION_ID = @as(u32, 16);
pub const DEBUG_PROC_DESC_NO_USER_NAME = @as(u32, 32);
pub const DEBUG_PROC_DESC_WITH_PACKAGEFAMILY = @as(u32, 64);
pub const DEBUG_PROC_DESC_WITH_ARCHITECTURE = @as(u32, 128);
pub const DEBUG_ATTACH_DEFAULT = @as(u32, 0);
pub const DEBUG_ATTACH_NONINVASIVE = @as(u32, 1);
pub const DEBUG_ATTACH_EXISTING = @as(u32, 2);
pub const DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND = @as(u32, 4);
pub const DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK = @as(u32, 8);
pub const DEBUG_ATTACH_INVASIVE_RESUME_PROCESS = @as(u32, 16);
pub const DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL = @as(u32, 32);
pub const DEBUG_ECREATE_PROCESS_DEFAULT = @as(u32, 0);
pub const DEBUG_ECREATE_PROCESS_INHERIT_HANDLES = @as(u32, 1);
pub const DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS = @as(u32, 2);
pub const DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE = @as(u32, 4);
pub const DEBUG_PROCESS_DETACH_ON_EXIT = @as(u32, 1);
pub const DEBUG_PROCESS_ONLY_THIS_PROCESS = @as(u32, 2);
pub const DEBUG_CONNECT_SESSION_DEFAULT = @as(u32, 0);
pub const DEBUG_CONNECT_SESSION_NO_VERSION = @as(u32, 1);
pub const DEBUG_CONNECT_SESSION_NO_ANNOUNCE = @as(u32, 2);
pub const DEBUG_SERVERS_DEBUGGER = @as(u32, 1);
pub const DEBUG_SERVERS_PROCESS = @as(u32, 2);
pub const DEBUG_SERVERS_ALL = @as(u32, 3);
pub const DEBUG_END_PASSIVE = @as(u32, 0);
pub const DEBUG_END_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_END_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_END_REENTRANT = @as(u32, 3);
pub const DEBUG_END_DISCONNECT = @as(u32, 4);
pub const DEBUG_OUTPUT_NORMAL = @as(u32, 1);
pub const DEBUG_OUTPUT_ERROR = @as(u32, 2);
pub const DEBUG_OUTPUT_WARNING = @as(u32, 4);
pub const DEBUG_OUTPUT_VERBOSE = @as(u32, 8);
pub const DEBUG_OUTPUT_PROMPT = @as(u32, 16);
pub const DEBUG_OUTPUT_PROMPT_REGISTERS = @as(u32, 32);
pub const DEBUG_OUTPUT_EXTENSION_WARNING = @as(u32, 64);
pub const DEBUG_OUTPUT_DEBUGGEE = @as(u32, 128);
pub const DEBUG_OUTPUT_DEBUGGEE_PROMPT = @as(u32, 256);
pub const DEBUG_OUTPUT_SYMBOLS = @as(u32, 512);
pub const DEBUG_OUTPUT_STATUS = @as(u32, 1024);
pub const DEBUG_OUTPUT_XML = @as(u32, 2048);
pub const DEBUG_IOUTPUT_KD_PROTOCOL = @as(u32, 2147483648);
pub const DEBUG_IOUTPUT_REMOTING = @as(u32, 1073741824);
pub const DEBUG_IOUTPUT_BREAKPOINT = @as(u32, 536870912);
pub const DEBUG_IOUTPUT_EVENT = @as(u32, 268435456);
pub const DEBUG_IOUTPUT_ADDR_TRANSLATE = @as(u32, 134217728);
pub const DEBUG_OUTPUT_IDENTITY_DEFAULT = @as(u32, 0);
pub const DEBUG_CLIENT_UNKNOWN = @as(u32, 0);
pub const DEBUG_CLIENT_VSINT = @as(u32, 1);
pub const DEBUG_CLIENT_NTSD = @as(u32, 2);
pub const DEBUG_CLIENT_NTKD = @as(u32, 3);
pub const DEBUG_CLIENT_CDB = @as(u32, 4);
pub const DEBUG_CLIENT_KD = @as(u32, 5);
pub const DEBUG_CLIENT_WINDBG = @as(u32, 6);
pub const DEBUG_CLIENT_WINIDE = @as(u32, 7);
pub const DEBUG_FORMAT_DEFAULT = @as(u32, 0);
pub const DEBUG_FORMAT_CAB_SECONDARY_ALL_IMAGES = @as(u32, 268435456);
pub const DEBUG_FORMAT_WRITE_CAB = @as(u32, 536870912);
pub const DEBUG_FORMAT_CAB_SECONDARY_FILES = @as(u32, 1073741824);
pub const DEBUG_FORMAT_NO_OVERWRITE = @as(u32, 2147483648);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY = @as(u32, 1);
pub const DEBUG_FORMAT_USER_SMALL_HANDLE_DATA = @as(u32, 2);
pub const DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES = @as(u32, 4);
pub const DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY = @as(u32, 8);
pub const DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS = @as(u32, 16);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY = @as(u32, 32);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_PATHS = @as(u32, 64);
pub const DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA = @as(u32, 128);
pub const DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY = @as(u32, 256);
pub const DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA = @as(u32, 512);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO = @as(u32, 1024);
pub const DEBUG_FORMAT_USER_SMALL_THREAD_INFO = @as(u32, 2048);
pub const DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS = @as(u32, 4096);
pub const DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE = @as(u32, 8192);
pub const DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE = @as(u32, 16384);
pub const DEBUG_FORMAT_USER_SMALL_MODULE_HEADERS = @as(u32, 32768);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_TRIAGE = @as(u32, 65536);
pub const DEBUG_FORMAT_USER_SMALL_ADD_AVX_XSTATE_CONTEXT = @as(u32, 131072);
pub const DEBUG_FORMAT_USER_SMALL_IPT_TRACE = @as(u32, 262144);
pub const DEBUG_FORMAT_USER_SMALL_IGNORE_INACCESSIBLE_MEM = @as(u32, 134217728);
pub const DEBUG_FORMAT_USER_SMALL_SCAN_PARTIAL_PAGES = @as(u32, 268435456);
pub const DEBUG_DUMP_FILE_BASE = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_PAGE_FILE_DUMP = @as(u32, 0);
pub const DEBUG_DUMP_FILE_LOAD_FAILED_INDEX = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX = @as(u32, 4294967294);
pub const DEBUG_STATUS_NO_CHANGE = @as(u32, 0);
pub const DEBUG_STATUS_GO = @as(u32, 1);
pub const DEBUG_STATUS_GO_HANDLED = @as(u32, 2);
pub const DEBUG_STATUS_GO_NOT_HANDLED = @as(u32, 3);
pub const DEBUG_STATUS_STEP_OVER = @as(u32, 4);
pub const DEBUG_STATUS_STEP_INTO = @as(u32, 5);
pub const DEBUG_STATUS_BREAK = @as(u32, 6);
pub const DEBUG_STATUS_NO_DEBUGGEE = @as(u32, 7);
pub const DEBUG_STATUS_STEP_BRANCH = @as(u32, 8);
pub const DEBUG_STATUS_IGNORE_EVENT = @as(u32, 9);
pub const DEBUG_STATUS_RESTART_REQUESTED = @as(u32, 10);
pub const DEBUG_STATUS_REVERSE_GO = @as(u32, 11);
pub const DEBUG_STATUS_REVERSE_STEP_BRANCH = @as(u32, 12);
pub const DEBUG_STATUS_REVERSE_STEP_OVER = @as(u32, 13);
pub const DEBUG_STATUS_REVERSE_STEP_INTO = @as(u32, 14);
pub const DEBUG_STATUS_OUT_OF_SYNC = @as(u32, 15);
pub const DEBUG_STATUS_WAIT_INPUT = @as(u32, 16);
pub const DEBUG_STATUS_TIMEOUT = @as(u32, 17);
pub const DEBUG_STATUS_MASK = @as(u32, 31);
pub const DEBUG_STATUS_INSIDE_WAIT = @as(u64, 4294967296);
pub const DEBUG_STATUS_WAIT_TIMEOUT = @as(u64, 8589934592);
pub const DEBUG_OUTCTL_THIS_CLIENT = @as(u32, 0);
pub const DEBUG_OUTCTL_ALL_CLIENTS = @as(u32, 1);
pub const DEBUG_OUTCTL_ALL_OTHER_CLIENTS = @as(u32, 2);
pub const DEBUG_OUTCTL_IGNORE = @as(u32, 3);
pub const DEBUG_OUTCTL_LOG_ONLY = @as(u32, 4);
pub const DEBUG_OUTCTL_SEND_MASK = @as(u32, 7);
pub const DEBUG_OUTCTL_NOT_LOGGED = @as(u32, 8);
pub const DEBUG_OUTCTL_OVERRIDE_MASK = @as(u32, 16);
pub const DEBUG_OUTCTL_DML = @as(u32, 32);
pub const DEBUG_OUTCTL_AMBIENT_DML = @as(u32, 4294967294);
pub const DEBUG_OUTCTL_AMBIENT_TEXT = @as(u32, 4294967295);
pub const DEBUG_OUTCTL_AMBIENT = @as(u32, 4294967295);
pub const DEBUG_INTERRUPT_ACTIVE = @as(u32, 0);
pub const DEBUG_INTERRUPT_PASSIVE = @as(u32, 1);
pub const DEBUG_INTERRUPT_EXIT = @as(u32, 2);
pub const DEBUG_CURRENT_DEFAULT = @as(u32, 15);
pub const DEBUG_CURRENT_SYMBOL = @as(u32, 1);
pub const DEBUG_CURRENT_DISASM = @as(u32, 2);
pub const DEBUG_CURRENT_REGISTERS = @as(u32, 4);
pub const DEBUG_CURRENT_SOURCE_LINE = @as(u32, 8);
pub const DEBUG_DISASM_EFFECTIVE_ADDRESS = @as(u32, 1);
pub const DEBUG_DISASM_MATCHING_SYMBOLS = @as(u32, 2);
pub const DEBUG_DISASM_SOURCE_LINE_NUMBER = @as(u32, 4);
pub const DEBUG_DISASM_SOURCE_FILE_NAME = @as(u32, 8);
pub const DEBUG_LEVEL_SOURCE = @as(u32, 0);
pub const DEBUG_LEVEL_ASSEMBLY = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS = @as(u32, 2);
pub const DEBUG_ENGOPT_ALLOW_NETWORK_PATHS = @as(u32, 4);
pub const DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS = @as(u32, 16);
pub const DEBUG_ENGOPT_INITIAL_BREAK = @as(u32, 32);
pub const DEBUG_ENGOPT_INITIAL_MODULE_BREAK = @as(u32, 64);
pub const DEBUG_ENGOPT_FINAL_BREAK = @as(u32, 128);
pub const DEBUG_ENGOPT_NO_EXECUTE_REPEAT = @as(u32, 256);
pub const DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION = @as(u32, 512);
pub const DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS = @as(u32, 1024);
pub const DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS = @as(u32, 2048);
pub const DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS = @as(u32, 4096);
pub const DEBUG_ENGOPT_KD_QUIET_MODE = @as(u32, 8192);
pub const DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT = @as(u32, 16384);
pub const DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD = @as(u32, 32768);
pub const DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS = @as(u32, 65536);
pub const DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING = @as(u32, 131072);
pub const DEBUG_ENGOPT_PREFER_DML = @as(u32, 262144);
pub const DEBUG_ENGOPT_DISABLESQM = @as(u32, 524288);
pub const DEBUG_ENGOPT_DISABLE_STEPLINES_OPTIONS = @as(u32, 2097152);
pub const DEBUG_ENGOPT_DEBUGGING_SENSITIVE_DATA = @as(u32, 4194304);
pub const DEBUG_ENGOPT_PREFER_TRACE_FILES = @as(u32, 8388608);
pub const DEBUG_ENGOPT_RESOLVE_SHADOWED_VARIABLES = @as(u32, 16777216);
pub const DEBUG_ENGOPT_ALL = @as(u32, 32505855);
pub const DEBUG_ANY_ID = @as(u32, 4294967295);
pub const DBG_FRAME_DEFAULT = @as(u32, 0);
pub const DBG_FRAME_IGNORE_INLINE = @as(u32, 4294967295);
pub const STACK_FRAME_TYPE_INIT = @as(u32, 0);
pub const STACK_FRAME_TYPE_STACK = @as(u32, 1);
pub const STACK_FRAME_TYPE_INLINE = @as(u32, 2);
pub const STACK_FRAME_TYPE_RA = @as(u32, 128);
pub const STACK_FRAME_TYPE_IGNORE = @as(u32, 255);
pub const DEBUG_STACK_ARGUMENTS = @as(u32, 1);
pub const DEBUG_STACK_FUNCTION_INFO = @as(u32, 2);
pub const DEBUG_STACK_SOURCE_LINE = @as(u32, 4);
pub const DEBUG_STACK_FRAME_ADDRESSES = @as(u32, 8);
pub const DEBUG_STACK_COLUMN_NAMES = @as(u32, 16);
pub const DEBUG_STACK_NONVOLATILE_REGISTERS = @as(u32, 32);
pub const DEBUG_STACK_FRAME_NUMBERS = @as(u32, 64);
pub const DEBUG_STACK_PARAMETERS = @as(u32, 128);
pub const DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY = @as(u32, 256);
pub const DEBUG_STACK_FRAME_MEMORY_USAGE = @as(u32, 512);
pub const DEBUG_STACK_PARAMETERS_NEWLINE = @as(u32, 1024);
pub const DEBUG_STACK_DML = @as(u32, 2048);
pub const DEBUG_STACK_FRAME_OFFSETS = @as(u32, 4096);
pub const DEBUG_STACK_PROVIDER = @as(u32, 8192);
pub const DEBUG_STACK_FRAME_ARCH = @as(u32, 16384);
pub const DEBUG_CLASS_UNINITIALIZED = @as(u32, 0);
pub const DEBUG_CLASS_KERNEL = @as(u32, 1);
pub const DEBUG_CLASS_USER_WINDOWS = @as(u32, 2);
pub const DEBUG_CLASS_IMAGE_FILE = @as(u32, 3);
pub const DEBUG_DUMP_SMALL = @as(u32, 1024);
pub const DEBUG_DUMP_DEFAULT = @as(u32, 1025);
pub const DEBUG_DUMP_FULL = @as(u32, 1026);
pub const DEBUG_DUMP_IMAGE_FILE = @as(u32, 1027);
pub const DEBUG_DUMP_TRACE_LOG = @as(u32, 1028);
pub const DEBUG_DUMP_WINDOWS_CE = @as(u32, 1029);
pub const DEBUG_DUMP_ACTIVE = @as(u32, 1030);
pub const DEBUG_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_KERNEL_LOCAL = @as(u32, 1);
pub const DEBUG_KERNEL_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_KERNEL_IDNA = @as(u32, 3);
pub const DEBUG_KERNEL_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_KERNEL_REPT = @as(u32, 5);
pub const DEBUG_KERNEL_SMALL_DUMP = @as(u32, 1024);
pub const DEBUG_KERNEL_DUMP = @as(u32, 1025);
pub const DEBUG_KERNEL_ACTIVE_DUMP = @as(u32, 1030);
pub const DEBUG_KERNEL_FULL_DUMP = @as(u32, 1026);
pub const DEBUG_KERNEL_TRACE_LOG = @as(u32, 1028);
pub const DEBUG_USER_WINDOWS_PROCESS = @as(u32, 0);
pub const DEBUG_USER_WINDOWS_PROCESS_SERVER = @as(u32, 1);
pub const DEBUG_USER_WINDOWS_IDNA = @as(u32, 2);
pub const DEBUG_USER_WINDOWS_REPT = @as(u32, 3);
pub const DEBUG_USER_WINDOWS_SMALL_DUMP = @as(u32, 1024);
pub const DEBUG_USER_WINDOWS_DUMP = @as(u32, 1025);
pub const DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE = @as(u32, 1029);
pub const DEBUG_EXTENSION_AT_ENGINE = @as(u32, 0);
pub const DEBUG_EXECUTE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXECUTE_ECHO = @as(u32, 1);
pub const DEBUG_EXECUTE_NOT_LOGGED = @as(u32, 2);
pub const DEBUG_EXECUTE_NO_REPEAT = @as(u32, 4);
pub const DEBUG_EXECUTE_USER_TYPED = @as(u32, 8);
pub const DEBUG_EXECUTE_USER_CLICKED = @as(u32, 16);
pub const DEBUG_EXECUTE_EXTENSION = @as(u32, 32);
pub const DEBUG_EXECUTE_INTERNAL = @as(u32, 64);
pub const DEBUG_EXECUTE_SCRIPT = @as(u32, 128);
pub const DEBUG_EXECUTE_TOOLBAR = @as(u32, 256);
pub const DEBUG_EXECUTE_MENU = @as(u32, 512);
pub const DEBUG_EXECUTE_HOTKEY = @as(u32, 1024);
pub const DEBUG_EXECUTE_EVENT = @as(u32, 2048);
pub const DEBUG_FILTER_CREATE_THREAD = @as(u32, 0);
pub const DEBUG_FILTER_EXIT_THREAD = @as(u32, 1);
pub const DEBUG_FILTER_CREATE_PROCESS = @as(u32, 2);
pub const DEBUG_FILTER_EXIT_PROCESS = @as(u32, 3);
pub const DEBUG_FILTER_LOAD_MODULE = @as(u32, 4);
pub const DEBUG_FILTER_UNLOAD_MODULE = @as(u32, 5);
pub const DEBUG_FILTER_SYSTEM_ERROR = @as(u32, 6);
pub const DEBUG_FILTER_INITIAL_BREAKPOINT = @as(u32, 7);
pub const DEBUG_FILTER_INITIAL_MODULE_LOAD = @as(u32, 8);
pub const DEBUG_FILTER_DEBUGGEE_OUTPUT = @as(u32, 9);
pub const DEBUG_FILTER_BREAK = @as(u32, 0);
pub const DEBUG_FILTER_SECOND_CHANCE_BREAK = @as(u32, 1);
pub const DEBUG_FILTER_OUTPUT = @as(u32, 2);
pub const DEBUG_FILTER_IGNORE = @as(u32, 3);
pub const DEBUG_FILTER_REMOVE = @as(u32, 4);
pub const DEBUG_FILTER_GO_HANDLED = @as(u32, 0);
pub const DEBUG_FILTER_GO_NOT_HANDLED = @as(u32, 1);
pub const DEBUG_WAIT_DEFAULT = @as(u32, 0);
pub const DEBUG_VALUE_INVALID = @as(u32, 0);
pub const DEBUG_VALUE_INT8 = @as(u32, 1);
pub const DEBUG_VALUE_INT16 = @as(u32, 2);
pub const DEBUG_VALUE_INT32 = @as(u32, 3);
pub const DEBUG_VALUE_INT64 = @as(u32, 4);
pub const DEBUG_VALUE_FLOAT32 = @as(u32, 5);
pub const DEBUG_VALUE_FLOAT64 = @as(u32, 6);
pub const DEBUG_VALUE_FLOAT80 = @as(u32, 7);
pub const DEBUG_VALUE_FLOAT82 = @as(u32, 8);
pub const DEBUG_VALUE_FLOAT128 = @as(u32, 9);
pub const DEBUG_VALUE_VECTOR64 = @as(u32, 10);
pub const DEBUG_VALUE_VECTOR128 = @as(u32, 11);
pub const DEBUG_VALUE_TYPES = @as(u32, 12);
pub const DEBUG_OUT_TEXT_REPL_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_VERBOSE = @as(u32, 1);
pub const DEBUG_ASMOPT_NO_CODE_BYTES = @as(u32, 2);
pub const DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH = @as(u32, 4);
pub const DEBUG_ASMOPT_SOURCE_LINE_NUMBER = @as(u32, 8);
pub const DEBUG_EXPR_MASM = @as(u32, 0);
pub const DEBUG_EXPR_CPLUSPLUS = @as(u32, 1);
pub const DEBUG_EINDEX_NAME = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_START = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_END = @as(u32, 1);
pub const DEBUG_EINDEX_FROM_CURRENT = @as(u32, 2);
pub const DEBUG_LOG_DEFAULT = @as(u32, 0);
pub const DEBUG_LOG_APPEND = @as(u32, 1);
pub const DEBUG_LOG_UNICODE = @as(u32, 2);
pub const DEBUG_LOG_DML = @as(u32, 4);
pub const DEBUG_SYSVERSTR_SERVICE_PACK = @as(u32, 0);
pub const DEBUG_SYSVERSTR_BUILD = @as(u32, 1);
pub const DEBUG_MANAGED_DISABLED = @as(u32, 0);
pub const DEBUG_MANAGED_ALLOWED = @as(u32, 1);
pub const DEBUG_MANAGED_DLL_LOADED = @as(u32, 2);
pub const DEBUG_MANSTR_NONE = @as(u32, 0);
pub const DEBUG_MANSTR_LOADED_SUPPORT_DLL = @as(u32, 1);
pub const DEBUG_MANSTR_LOAD_STATUS = @as(u32, 2);
pub const DEBUG_MANRESET_DEFAULT = @as(u32, 0);
pub const DEBUG_MANRESET_LOAD_DLL = @as(u32, 1);
pub const DEBUG_EXEC_FLAGS_NONBLOCK = @as(u32, 1);
pub const DEBUG_DATA_SPACE_VIRTUAL = @as(u32, 0);
pub const DEBUG_DATA_SPACE_PHYSICAL = @as(u32, 1);
pub const DEBUG_DATA_SPACE_CONTROL = @as(u32, 2);
pub const DEBUG_DATA_SPACE_IO = @as(u32, 3);
pub const DEBUG_DATA_SPACE_MSR = @as(u32, 4);
pub const DEBUG_DATA_SPACE_BUS_DATA = @as(u32, 5);
pub const DEBUG_DATA_SPACE_DEBUGGER_DATA = @as(u32, 6);
pub const DEBUG_DATA_SPACE_COUNT = @as(u32, 7);
pub const DEBUG_DATA_KernBase = @as(u32, 24);
pub const DEBUG_DATA_BreakpointWithStatusAddr = @as(u32, 32);
pub const DEBUG_DATA_SavedContextAddr = @as(u32, 40);
pub const DEBUG_DATA_KiCallUserModeAddr = @as(u32, 56);
pub const DEBUG_DATA_KeUserCallbackDispatcherAddr = @as(u32, 64);
pub const DEBUG_DATA_PsLoadedModuleListAddr = @as(u32, 72);
pub const DEBUG_DATA_PsActiveProcessHeadAddr = @as(u32, 80);
pub const DEBUG_DATA_PspCidTableAddr = @as(u32, 88);
pub const DEBUG_DATA_ExpSystemResourcesListAddr = @as(u32, 96);
pub const DEBUG_DATA_ExpPagedPoolDescriptorAddr = @as(u32, 104);
pub const DEBUG_DATA_ExpNumberOfPagedPoolsAddr = @as(u32, 112);
pub const DEBUG_DATA_KeTimeIncrementAddr = @as(u32, 120);
pub const DEBUG_DATA_KeBugCheckCallbackListHeadAddr = @as(u32, 128);
pub const DEBUG_DATA_KiBugcheckDataAddr = @as(u32, 136);
pub const DEBUG_DATA_IopErrorLogListHeadAddr = @as(u32, 144);
pub const DEBUG_DATA_ObpRootDirectoryObjectAddr = @as(u32, 152);
pub const DEBUG_DATA_ObpTypeObjectTypeAddr = @as(u32, 160);
pub const DEBUG_DATA_MmSystemCacheStartAddr = @as(u32, 168);
pub const DEBUG_DATA_MmSystemCacheEndAddr = @as(u32, 176);
pub const DEBUG_DATA_MmSystemCacheWsAddr = @as(u32, 184);
pub const DEBUG_DATA_MmPfnDatabaseAddr = @as(u32, 192);
pub const DEBUG_DATA_MmSystemPtesStartAddr = @as(u32, 200);
pub const DEBUG_DATA_MmSystemPtesEndAddr = @as(u32, 208);
pub const DEBUG_DATA_MmSubsectionBaseAddr = @as(u32, 216);
pub const DEBUG_DATA_MmNumberOfPagingFilesAddr = @as(u32, 224);
pub const DEBUG_DATA_MmLowestPhysicalPageAddr = @as(u32, 232);
pub const DEBUG_DATA_MmHighestPhysicalPageAddr = @as(u32, 240);
pub const DEBUG_DATA_MmNumberOfPhysicalPagesAddr = @as(u32, 248);
pub const DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr = @as(u32, 256);
pub const DEBUG_DATA_MmNonPagedSystemStartAddr = @as(u32, 264);
pub const DEBUG_DATA_MmNonPagedPoolStartAddr = @as(u32, 272);
pub const DEBUG_DATA_MmNonPagedPoolEndAddr = @as(u32, 280);
pub const DEBUG_DATA_MmPagedPoolStartAddr = @as(u32, 288);
pub const DEBUG_DATA_MmPagedPoolEndAddr = @as(u32, 296);
pub const DEBUG_DATA_MmPagedPoolInformationAddr = @as(u32, 304);
pub const DEBUG_DATA_MmPageSize = @as(u32, 312);
pub const DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr = @as(u32, 320);
pub const DEBUG_DATA_MmTotalCommitLimitAddr = @as(u32, 328);
pub const DEBUG_DATA_MmTotalCommittedPagesAddr = @as(u32, 336);
pub const DEBUG_DATA_MmSharedCommitAddr = @as(u32, 344);
pub const DEBUG_DATA_MmDriverCommitAddr = @as(u32, 352);
pub const DEBUG_DATA_MmProcessCommitAddr = @as(u32, 360);
pub const DEBUG_DATA_MmPagedPoolCommitAddr = @as(u32, 368);
pub const DEBUG_DATA_MmExtendedCommitAddr = @as(u32, 376);
pub const DEBUG_DATA_MmZeroedPageListHeadAddr = @as(u32, 384);
pub const DEBUG_DATA_MmFreePageListHeadAddr = @as(u32, 392);
pub const DEBUG_DATA_MmStandbyPageListHeadAddr = @as(u32, 400);
pub const DEBUG_DATA_MmModifiedPageListHeadAddr = @as(u32, 408);
pub const DEBUG_DATA_MmModifiedNoWritePageListHeadAddr = @as(u32, 416);
pub const DEBUG_DATA_MmAvailablePagesAddr = @as(u32, 424);
pub const DEBUG_DATA_MmResidentAvailablePagesAddr = @as(u32, 432);
pub const DEBUG_DATA_PoolTrackTableAddr = @as(u32, 440);
pub const DEBUG_DATA_NonPagedPoolDescriptorAddr = @as(u32, 448);
pub const DEBUG_DATA_MmHighestUserAddressAddr = @as(u32, 456);
pub const DEBUG_DATA_MmSystemRangeStartAddr = @as(u32, 464);
pub const DEBUG_DATA_MmUserProbeAddressAddr = @as(u32, 472);
pub const DEBUG_DATA_KdPrintCircularBufferAddr = @as(u32, 480);
pub const DEBUG_DATA_KdPrintCircularBufferEndAddr = @as(u32, 488);
pub const DEBUG_DATA_KdPrintWritePointerAddr = @as(u32, 496);
pub const DEBUG_DATA_KdPrintRolloverCountAddr = @as(u32, 504);
pub const DEBUG_DATA_MmLoadedUserImageListAddr = @as(u32, 512);
pub const DEBUG_DATA_NtBuildLabAddr = @as(u32, 520);
pub const DEBUG_DATA_KiNormalSystemCall = @as(u32, 528);
pub const DEBUG_DATA_KiProcessorBlockAddr = @as(u32, 536);
pub const DEBUG_DATA_MmUnloadedDriversAddr = @as(u32, 544);
pub const DEBUG_DATA_MmLastUnloadedDriverAddr = @as(u32, 552);
pub const DEBUG_DATA_MmTriageActionTakenAddr = @as(u32, 560);
pub const DEBUG_DATA_MmSpecialPoolTagAddr = @as(u32, 568);
pub const DEBUG_DATA_KernelVerifierAddr = @as(u32, 576);
pub const DEBUG_DATA_MmVerifierDataAddr = @as(u32, 584);
pub const DEBUG_DATA_MmAllocatedNonPagedPoolAddr = @as(u32, 592);
pub const DEBUG_DATA_MmPeakCommitmentAddr = @as(u32, 600);
pub const DEBUG_DATA_MmTotalCommitLimitMaximumAddr = @as(u32, 608);
pub const DEBUG_DATA_CmNtCSDVersionAddr = @as(u32, 616);
pub const DEBUG_DATA_MmPhysicalMemoryBlockAddr = @as(u32, 624);
pub const DEBUG_DATA_MmSessionBase = @as(u32, 632);
pub const DEBUG_DATA_MmSessionSize = @as(u32, 640);
pub const DEBUG_DATA_MmSystemParentTablePage = @as(u32, 648);
pub const DEBUG_DATA_MmVirtualTranslationBase = @as(u32, 656);
pub const DEBUG_DATA_OffsetKThreadNextProcessor = @as(u32, 664);
pub const DEBUG_DATA_OffsetKThreadTeb = @as(u32, 666);
pub const DEBUG_DATA_OffsetKThreadKernelStack = @as(u32, 668);
pub const DEBUG_DATA_OffsetKThreadInitialStack = @as(u32, 670);
pub const DEBUG_DATA_OffsetKThreadApcProcess = @as(u32, 672);
pub const DEBUG_DATA_OffsetKThreadState = @as(u32, 674);
pub const DEBUG_DATA_OffsetKThreadBStore = @as(u32, 676);
pub const DEBUG_DATA_OffsetKThreadBStoreLimit = @as(u32, 678);
pub const DEBUG_DATA_SizeEProcess = @as(u32, 680);
pub const DEBUG_DATA_OffsetEprocessPeb = @as(u32, 682);
pub const DEBUG_DATA_OffsetEprocessParentCID = @as(u32, 684);
pub const DEBUG_DATA_OffsetEprocessDirectoryTableBase = @as(u32, 686);
pub const DEBUG_DATA_SizePrcb = @as(u32, 688);
pub const DEBUG_DATA_OffsetPrcbDpcRoutine = @as(u32, 690);
pub const DEBUG_DATA_OffsetPrcbCurrentThread = @as(u32, 692);
pub const DEBUG_DATA_OffsetPrcbMhz = @as(u32, 694);
pub const DEBUG_DATA_OffsetPrcbCpuType = @as(u32, 696);
pub const DEBUG_DATA_OffsetPrcbVendorString = @as(u32, 698);
pub const DEBUG_DATA_OffsetPrcbProcessorState = @as(u32, 700);
pub const DEBUG_DATA_OffsetPrcbNumber = @as(u32, 702);
pub const DEBUG_DATA_SizeEThread = @as(u32, 704);
pub const DEBUG_DATA_KdPrintCircularBufferPtrAddr = @as(u32, 712);
pub const DEBUG_DATA_KdPrintBufferSizeAddr = @as(u32, 720);
pub const DEBUG_DATA_MmBadPagesDetected = @as(u32, 800);
pub const DEBUG_DATA_EtwpDebuggerData = @as(u32, 816);
pub const DEBUG_DATA_PteBase = @as(u32, 864);
pub const DEBUG_DATA_PaeEnabled = @as(u32, 100000);
pub const DEBUG_DATA_SharedUserData = @as(u32, 100008);
pub const DEBUG_DATA_ProductType = @as(u32, 100016);
pub const DEBUG_DATA_SuiteMask = @as(u32, 100024);
pub const DEBUG_DATA_DumpWriterStatus = @as(u32, 100032);
pub const DEBUG_DATA_DumpFormatVersion = @as(u32, 100040);
pub const DEBUG_DATA_DumpWriterVersion = @as(u32, 100048);
pub const DEBUG_DATA_DumpPowerState = @as(u32, 100056);
pub const DEBUG_DATA_DumpMmStorage = @as(u32, 100064);
pub const DEBUG_DATA_DumpAttributes = @as(u32, 100072);
pub const DEBUG_DATA_PagingLevels = @as(u32, 100080);
pub const DEBUG_DATA_KPCR_OFFSET = @as(u32, 0);
pub const DEBUG_DATA_KPRCB_OFFSET = @as(u32, 1);
pub const DEBUG_DATA_KTHREAD_OFFSET = @as(u32, 2);
pub const DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET = @as(u32, 3);
pub const DEBUG_DATA_PROCESSOR_IDENTIFICATION = @as(u32, 4);
pub const DEBUG_DATA_PROCESSOR_SPEED = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_BASIC = @as(u32, 0);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME = @as(u32, 1);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME = @as(u32, 2);
pub const DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT = @as(u32, 3);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE = @as(u32, 4);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1 = @as(u32, 6);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1 = @as(u32, 7);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2 = @as(u32, 8);
pub const DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS = @as(u32, 9);
pub const DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS = @as(u32, 10);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1 = @as(u32, 11);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2 = @as(u32, 12);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_EVENT_1 = @as(u32, 13);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SECTION_1 = @as(u32, 14);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SEMAPHORE_1 = @as(u32, 15);
pub const DEBUG_OFFSINFO_VIRTUAL_SOURCE = @as(u32, 1);
pub const DEBUG_VSOURCE_INVALID = @as(u32, 0);
pub const DEBUG_VSOURCE_DEBUGGEE = @as(u32, 1);
pub const DEBUG_VSOURCE_MAPPED_IMAGE = @as(u32, 2);
pub const DEBUG_VSOURCE_DUMP_WITHOUT_MEMINFO = @as(u32, 3);
pub const DEBUG_VSEARCH_DEFAULT = @as(u32, 0);
pub const DEBUG_VSEARCH_WRITABLE_ONLY = @as(u32, 1);
pub const DEBUG_PHYSICAL_DEFAULT = @as(u32, 0);
pub const DEBUG_PHYSICAL_CACHED = @as(u32, 1);
pub const DEBUG_PHYSICAL_UNCACHED = @as(u32, 2);
pub const DEBUG_PHYSICAL_WRITE_COMBINED = @as(u32, 3);
pub const DEBUG_EVENT_BREAKPOINT = @as(u32, 1);
pub const DEBUG_EVENT_EXCEPTION = @as(u32, 2);
pub const DEBUG_EVENT_CREATE_THREAD = @as(u32, 4);
pub const DEBUG_EVENT_EXIT_THREAD = @as(u32, 8);
pub const DEBUG_EVENT_CREATE_PROCESS = @as(u32, 16);
pub const DEBUG_EVENT_EXIT_PROCESS = @as(u32, 32);
pub const DEBUG_EVENT_LOAD_MODULE = @as(u32, 64);
pub const DEBUG_EVENT_UNLOAD_MODULE = @as(u32, 128);
pub const DEBUG_EVENT_SYSTEM_ERROR = @as(u32, 256);
pub const DEBUG_EVENT_SESSION_STATUS = @as(u32, 512);
pub const DEBUG_EVENT_CHANGE_DEBUGGEE_STATE = @as(u32, 1024);
pub const DEBUG_EVENT_CHANGE_ENGINE_STATE = @as(u32, 2048);
pub const DEBUG_EVENT_CHANGE_SYMBOL_STATE = @as(u32, 4096);
pub const DEBUG_EVENT_SERVICE_EXCEPTION = @as(u32, 8192);
pub const DEBUG_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_SESSION_END_SESSION_PASSIVE = @as(u32, 3);
pub const DEBUG_SESSION_END = @as(u32, 4);
pub const DEBUG_SESSION_REBOOT = @as(u32, 5);
pub const DEBUG_SESSION_HIBERNATE = @as(u32, 6);
pub const DEBUG_SESSION_FAILURE = @as(u32, 7);
pub const DEBUG_CDS_ALL = @as(u32, 4294967295);
pub const DEBUG_CDS_REGISTERS = @as(u32, 1);
pub const DEBUG_CDS_DATA = @as(u32, 2);
pub const DEBUG_CDS_REFRESH = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_EVALUATE = @as(u32, 1);
pub const DEBUG_CDS_REFRESH_EXECUTE = @as(u32, 2);
pub const DEBUG_CDS_REFRESH_EXECUTECOMMANDFILE = @as(u32, 3);
pub const DEBUG_CDS_REFRESH_ADDBREAKPOINT = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_REMOVEBREAKPOINT = @as(u32, 5);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUAL = @as(u32, 6);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUALUNCACHED = @as(u32, 7);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL = @as(u32, 8);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL2 = @as(u32, 9);
pub const DEBUG_CDS_REFRESH_SETVALUE = @as(u32, 10);
pub const DEBUG_CDS_REFRESH_SETVALUE2 = @as(u32, 11);
pub const DEBUG_CDS_REFRESH_SETSCOPE = @as(u32, 12);
pub const DEBUG_CDS_REFRESH_SETSCOPEFRAMEBYINDEX = @as(u32, 13);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMJITDEBUGINFO = @as(u32, 14);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMSTOREDEVENT = @as(u32, 15);
pub const DEBUG_CDS_REFRESH_INLINESTEP = @as(u32, 16);
pub const DEBUG_CDS_REFRESH_INLINESTEP_PSEUDO = @as(u32, 17);
pub const DEBUG_CES_ALL = @as(u32, 4294967295);
pub const DEBUG_CES_CURRENT_THREAD = @as(u32, 1);
pub const DEBUG_CES_EFFECTIVE_PROCESSOR = @as(u32, 2);
pub const DEBUG_CES_BREAKPOINTS = @as(u32, 4);
pub const DEBUG_CES_CODE_LEVEL = @as(u32, 8);
pub const DEBUG_CES_EXECUTION_STATUS = @as(u32, 16);
pub const DEBUG_CES_ENGINE_OPTIONS = @as(u32, 32);
pub const DEBUG_CES_LOG_FILE = @as(u32, 64);
pub const DEBUG_CES_RADIX = @as(u32, 128);
pub const DEBUG_CES_EVENT_FILTERS = @as(u32, 256);
pub const DEBUG_CES_PROCESS_OPTIONS = @as(u32, 512);
pub const DEBUG_CES_EXTENSIONS = @as(u32, 1024);
pub const DEBUG_CES_SYSTEMS = @as(u32, 2048);
pub const DEBUG_CES_ASSEMBLY_OPTIONS = @as(u32, 4096);
pub const DEBUG_CES_EXPRESSION_SYNTAX = @as(u32, 8192);
pub const DEBUG_CES_TEXT_REPLACEMENTS = @as(u32, 16384);
pub const DEBUG_CSS_ALL = @as(u32, 4294967295);
pub const DEBUG_CSS_LOADS = @as(u32, 1);
pub const DEBUG_CSS_UNLOADS = @as(u32, 2);
pub const DEBUG_CSS_SCOPE = @as(u32, 4);
pub const DEBUG_CSS_PATHS = @as(u32, 8);
pub const DEBUG_CSS_SYMBOL_OPTIONS = @as(u32, 16);
pub const DEBUG_CSS_TYPE_OPTIONS = @as(u32, 32);
pub const DEBUG_CSS_COLLAPSE_CHILDREN = @as(u32, 64);
pub const DEBUG_OUTCBI_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBI_TEXT = @as(u32, 2);
pub const DEBUG_OUTCBI_DML = @as(u32, 4);
pub const DEBUG_OUTCBI_ANY_FORMAT = @as(u32, 6);
pub const DEBUG_OUTCB_TEXT = @as(u32, 0);
pub const DEBUG_OUTCB_DML = @as(u32, 1);
pub const DEBUG_OUTCB_EXPLICIT_FLUSH = @as(u32, 2);
pub const DEBUG_OUTCBF_COMBINED_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBF_DML_HAS_TAGS = @as(u32, 2);
pub const DEBUG_OUTCBF_DML_HAS_SPECIAL_CHARACTERS = @as(u32, 4);
pub const DEBUG_REGISTERS_DEFAULT = @as(u32, 0);
pub const DEBUG_REGISTERS_INT32 = @as(u32, 1);
pub const DEBUG_REGISTERS_INT64 = @as(u32, 2);
pub const DEBUG_REGISTERS_FLOAT = @as(u32, 4);
pub const DEBUG_REGISTERS_ALL = @as(u32, 7);
pub const DEBUG_REGISTER_SUB_REGISTER = @as(u32, 1);
pub const DEBUG_REGSRC_DEBUGGEE = @as(u32, 0);
pub const DEBUG_REGSRC_EXPLICIT = @as(u32, 1);
pub const DEBUG_REGSRC_FRAME = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTPUT_SYMBOLS_NO_NAMES = @as(u32, 1);
pub const DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_NO_VALUES = @as(u32, 4);
pub const DEBUG_OUTPUT_SYMBOLS_NO_TYPES = @as(u32, 16);
pub const DEBUG_OUTPUT_NAME_END = "**NAME**";
pub const DEBUG_OUTPUT_OFFSET_END = "**OFF**";
pub const DEBUG_OUTPUT_VALUE_END = "**VALUE**";
pub const DEBUG_OUTPUT_TYPE_END = "**TYPE**";
pub const DEBUG_OUTPUT_NAME_END_WIDE = "**NAME**";
pub const DEBUG_OUTPUT_OFFSET_END_WIDE = "**OFF**";
pub const DEBUG_OUTPUT_VALUE_END_WIDE = "**VALUE**";
pub const DEBUG_OUTPUT_TYPE_END_WIDE = "**TYPE**";
pub const DEBUG_OUTPUT_NAME_END_T = "**NAME**";
pub const DEBUG_OUTPUT_OFFSET_END_T = "**OFF**";
pub const DEBUG_OUTPUT_VALUE_END_T = "**VALUE**";
pub const DEBUG_OUTPUT_TYPE_END_T = "**TYPE**";
pub const DEBUG_SYMBOL_EXPANSION_LEVEL_MASK = @as(u32, 15);
pub const DEBUG_SYMBOL_EXPANDED = @as(u32, 16);
pub const DEBUG_SYMBOL_READ_ONLY = @as(u32, 32);
pub const DEBUG_SYMBOL_IS_ARRAY = @as(u32, 64);
pub const DEBUG_SYMBOL_IS_FLOAT = @as(u32, 128);
pub const DEBUG_SYMBOL_IS_ARGUMENT = @as(u32, 256);
pub const DEBUG_SYMBOL_IS_LOCAL = @as(u32, 512);
pub const DEBUG_SYMENT_IS_CODE = @as(u32, 1);
pub const DEBUG_SYMENT_IS_DATA = @as(u32, 2);
pub const DEBUG_SYMENT_IS_PARAMETER = @as(u32, 4);
pub const DEBUG_SYMENT_IS_LOCAL = @as(u32, 8);
pub const DEBUG_SYMENT_IS_MANAGED = @as(u32, 16);
pub const DEBUG_SYMENT_IS_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_LOADED = @as(u32, 0);
pub const DEBUG_MODULE_UNLOADED = @as(u32, 1);
pub const DEBUG_MODULE_USER_MODE = @as(u32, 2);
pub const DEBUG_MODULE_EXE_MODULE = @as(u32, 4);
pub const DEBUG_MODULE_EXPLICIT = @as(u32, 8);
pub const DEBUG_MODULE_SECONDARY = @as(u32, 16);
pub const DEBUG_MODULE_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_SYM_BAD_CHECKSUM = @as(u32, 65536);
pub const DEBUG_SYMTYPE_NONE = @as(u32, 0);
pub const DEBUG_SYMTYPE_COFF = @as(u32, 1);
pub const DEBUG_SYMTYPE_CODEVIEW = @as(u32, 2);
pub const DEBUG_SYMTYPE_PDB = @as(u32, 3);
pub const DEBUG_SYMTYPE_EXPORT = @as(u32, 4);
pub const DEBUG_SYMTYPE_DEFERRED = @as(u32, 5);
pub const DEBUG_SYMTYPE_SYM = @as(u32, 6);
pub const DEBUG_SYMTYPE_DIA = @as(u32, 7);
pub const DEBUG_SCOPE_GROUP_ARGUMENTS = @as(u32, 1);
pub const DEBUG_SCOPE_GROUP_LOCALS = @as(u32, 2);
pub const DEBUG_SCOPE_GROUP_ALL = @as(u32, 3);
pub const DEBUG_SCOPE_GROUP_BY_DATAMODEL = @as(u32, 4);
pub const DEBUG_OUTTYPE_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTTYPE_NO_INDENT = @as(u32, 1);
pub const DEBUG_OUTTYPE_NO_OFFSET = @as(u32, 2);
pub const DEBUG_OUTTYPE_VERBOSE = @as(u32, 4);
pub const DEBUG_OUTTYPE_COMPACT_OUTPUT = @as(u32, 8);
pub const DEBUG_OUTTYPE_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DEBUG_OUTTYPE_ADDRESS_AT_END = @as(u32, 131072);
pub const DEBUG_OUTTYPE_BLOCK_RECURSE = @as(u32, 2097152);
pub const DEBUG_FIND_SOURCE_DEFAULT = @as(u32, 0);
pub const DEBUG_FIND_SOURCE_FULL_PATH = @as(u32, 1);
pub const DEBUG_FIND_SOURCE_BEST_MATCH = @as(u32, 2);
pub const DEBUG_FIND_SOURCE_NO_SRCSRV = @as(u32, 4);
pub const DEBUG_FIND_SOURCE_TOKEN_LOOKUP = @as(u32, 8);
pub const DEBUG_FIND_SOURCE_WITH_CHECKSUM = @as(u32, 16);
pub const DEBUG_FIND_SOURCE_WITH_CHECKSUM_STRICT = @as(u32, 32);
pub const MODULE_ORDERS_MASK = @as(u32, 4026531840);
pub const MODULE_ORDERS_LOADTIME = @as(u32, 268435456);
pub const MODULE_ORDERS_MODULENAME = @as(u32, 536870912);
pub const DEBUG_MODNAME_IMAGE = @as(u32, 0);
pub const DEBUG_MODNAME_MODULE = @as(u32, 1);
pub const DEBUG_MODNAME_LOADED_IMAGE = @as(u32, 2);
pub const DEBUG_MODNAME_SYMBOL_FILE = @as(u32, 3);
pub const DEBUG_MODNAME_MAPPED_IMAGE = @as(u32, 4);
pub const DEBUG_TYPEOPTS_UNICODE_DISPLAY = @as(u32, 1);
pub const DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY = @as(u32, 2);
pub const DEBUG_TYPEOPTS_FORCERADIX_OUTPUT = @as(u32, 4);
pub const DEBUG_TYPEOPTS_MATCH_MAXSIZE = @as(u32, 8);
pub const DEBUG_GETMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_GETMOD_NO_LOADED_MODULES = @as(u32, 1);
pub const DEBUG_GETMOD_NO_UNLOADED_MODULES = @as(u32, 2);
pub const DEBUG_ADDSYNTHMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_ADDSYNTHMOD_ZEROBASE = @as(u32, 1);
pub const DEBUG_ADDSYNTHSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_FORCE_OFFSET = @as(u32, 1);
pub const DEBUG_OUTSYM_SOURCE_LINE = @as(u32, 2);
pub const DEBUG_OUTSYM_ALLOW_DISPLACEMENT = @as(u32, 4);
pub const DEBUG_GETFNENT_DEFAULT = @as(u32, 0);
pub const DEBUG_GETFNENT_RAW_ENTRY_ONLY = @as(u32, 1);
pub const DEBUG_SOURCE_IS_STATEMENT = @as(u32, 1);
pub const DEBUG_GSEL_DEFAULT = @as(u32, 0);
pub const DEBUG_GSEL_NO_SYMBOL_LOADS = @as(u32, 1);
pub const DEBUG_GSEL_ALLOW_LOWER = @as(u32, 2);
pub const DEBUG_GSEL_ALLOW_HIGHER = @as(u32, 4);
pub const DEBUG_GSEL_NEAREST_ONLY = @as(u32, 8);
pub const DEBUG_GSEL_INLINE_CALLSITE = @as(u32, 16);
pub const DEBUG_FRAME_DEFAULT = @as(u32, 0);
pub const DEBUG_FRAME_IGNORE_INLINE = @as(u32, 1);
pub const DEBUG_COMMAND_EXCEPTION_ID = @as(u32, 3688893886);
pub const DEBUG_CMDEX_INVALID = @as(u32, 0);
pub const DEBUG_CMDEX_ADD_EVENT_STRING = @as(u32, 1);
pub const DEBUG_CMDEX_RESET_EVENT_STRINGS = @as(u32, 2);
pub const DEBUG_EXTINIT_HAS_COMMAND_HELP = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_NOTIFY_SESSION_INACTIVE = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACCESSIBLE = @as(u32, 2);
pub const DEBUG_NOTIFY_SESSION_INACCESSIBLE = @as(u32, 3);
pub const DEBUG_KNOWN_STRUCT_GET_NAMES = @as(u32, 1);
pub const DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT = @as(u32, 2);
pub const DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME = @as(u32, 3);
pub const DEBUG_EXT_QVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_VALUE = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_POINTER = @as(u32, 1);
pub const _EXTSAPI_VER_ = @as(u32, 10);
pub const DUMP_HANDLE_FLAG_PRINT_OBJECT = @as(u32, 2);
pub const DUMP_HANDLE_FLAG_PRINT_FREE_ENTRY = @as(u32, 4);
pub const DUMP_HANDLE_FLAG_KERNEL_TABLE = @as(u32, 16);
pub const DUMP_HANDLE_FLAG_CID_TABLE = @as(u32, 32);
pub const KDEXTS_LOCK_CALLBACKROUTINE_DEFINED = @as(u32, 2);
pub const FAILURE_ANALYSIS_NO_DB_LOOKUP = @as(u32, 1);
pub const FAILURE_ANALYSIS_VERBOSE = @as(u32, 2);
pub const FAILURE_ANALYSIS_ASSUME_HANG = @as(u32, 4);
pub const FAILURE_ANALYSIS_IGNORE_BREAKIN = @as(u32, 8);
pub const FAILURE_ANALYSIS_SET_FAILURE_CONTEXT = @as(u32, 16);
pub const FAILURE_ANALYSIS_EXCEPTION_AS_HANG = @as(u32, 32);
pub const FAILURE_ANALYSIS_AUTOBUG_PROCESSING = @as(u32, 64);
pub const FAILURE_ANALYSIS_XML_OUTPUT = @as(u32, 128);
pub const FAILURE_ANALYSIS_CALLSTACK_XML = @as(u32, 256);
pub const FAILURE_ANALYSIS_REGISTRY_DATA = @as(u32, 512);
pub const FAILURE_ANALYSIS_WMI_QUERY_DATA = @as(u32, 1024);
pub const FAILURE_ANALYSIS_USER_ATTRIBUTES = @as(u32, 2048);
pub const FAILURE_ANALYSIS_MODULE_INFO_XML = @as(u32, 4096);
pub const FAILURE_ANALYSIS_NO_IMAGE_CORRUPTION = @as(u32, 8192);
pub const FAILURE_ANALYSIS_AUTOSET_SYMPATH = @as(u32, 16384);
pub const FAILURE_ANALYSIS_USER_ATTRIBUTES_ALL = @as(u32, 32768);
pub const FAILURE_ANALYSIS_USER_ATTRIBUTES_FRAMES = @as(u32, 65536);
pub const FAILURE_ANALYSIS_MULTI_TARGET = @as(u32, 131072);
pub const FAILURE_ANALYSIS_SHOW_SOURCE = @as(u32, 262144);
pub const FAILURE_ANALYSIS_SHOW_WCT_STACKS = @as(u32, 524288);
pub const FAILURE_ANALYSIS_CREATE_INSTANCE = @as(u32, 1048576);
pub const FAILURE_ANALYSIS_LIVE_DEBUG_HOLD_CHECK = @as(u32, 2097152);
pub const FAILURE_ANALYSIS_XML_FILE_OUTPUT = @as(u32, 4194304);
pub const FAILURE_ANALYSIS_XSD_VERIFY = @as(u32, 8388608);
pub const FAILURE_ANALYSIS_CALLSTACK_XML_FULL_SOURCE_INFO = @as(u32, 16777216);
pub const FAILURE_ANALYSIS_HEAP_CORRUPTION_BLAME_FUNCTION = @as(u32, 33554432);
pub const FAILURE_ANALYSIS_PERMIT_HEAP_ACCESS_VIOLATIONS = @as(u32, 67108864);
pub const FAILURE_ANALYSIS_XSLT_FILE_INPUT = @as(u32, 268435456);
pub const FAILURE_ANALYSIS_XSLT_FILE_OUTPUT = @as(u32, 536870912);
pub const CLSID_DebugFailureAnalysisBasic = Guid.initString("b74eed7f-1c7d-4c1b-959f-b96dd9175aa4");
pub const CLSID_DebugFailureAnalysisTarget = Guid.initString("ba9bfb05-ef75-4bbd-a745-a6b5529458b8");
pub const CLSID_DebugFailureAnalysisUser = Guid.initString("e60b0c93-cf49-4a32-8147-0362202dc56b");
pub const CLSID_DebugFailureAnalysisKernel = Guid.initString("ee433078-64af-4c33-ab2f-ecad7f2a002d");
pub const CLSID_DebugFailureAnalysisWinCE = Guid.initString("67d5e86f-f5e2-462a-9233-1bd616fcc7e8");
pub const CLSID_DebugFailureAnalysisXBox360 = Guid.initString("901625bb-95f1-4318-ac80-9d733cee8c8b");
pub const CROSS_PLATFORM_MAXIMUM_PROCESSORS = @as(u32, 2048);
pub const MAX_STACK_IN_BYTES = @as(u32, 4096);
pub const TRIAGE_FOLLOWUP_FAIL = @as(u32, 0);
pub const TRIAGE_FOLLOWUP_IGNORE = @as(u32, 1);
pub const TRIAGE_FOLLOWUP_DEFAULT = @as(u32, 2);
pub const TRIAGE_FOLLOWUP_SUCCESS = @as(u32, 3);
pub const EXT_ANALYZER_FLAG_MOD = @as(u32, 1);
pub const EXT_ANALYZER_FLAG_ID = @as(u32, 2);
pub const EXTDLL_DATA_QUERY_BUILD_BINDIR = @as(u32, 1);
pub const EXTDLL_DATA_QUERY_BUILD_SYMDIR = @as(u32, 2);
pub const EXTDLL_DATA_QUERY_BUILD_WOW64SYMDIR = @as(u32, 3);
pub const EXTDLL_DATA_QUERY_BUILD_WOW64BINDIR = @as(u32, 4);
pub const EXTDLL_DATA_QUERY_BUILD_BINDIR_SYMSRV = @as(u32, 11);
pub const EXTDLL_DATA_QUERY_BUILD_SYMDIR_SYMSRV = @as(u32, 12);
pub const EXTDLL_DATA_QUERY_BUILD_WOW64SYMDIR_SYMSRV = @as(u32, 13);
pub const EXTDLL_DATA_QUERY_BUILD_WOW64BINDIR_SYMSRV = @as(u32, 14);
pub const EXT_API_VERSION_NUMBER = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER32 = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER64 = @as(u32, 6);
pub const IG_KD_CONTEXT = @as(u32, 1);
pub const IG_READ_CONTROL_SPACE = @as(u32, 2);
pub const IG_WRITE_CONTROL_SPACE = @as(u32, 3);
pub const IG_READ_IO_SPACE = @as(u32, 4);
pub const IG_WRITE_IO_SPACE = @as(u32, 5);
pub const IG_READ_PHYSICAL = @as(u32, 6);
pub const IG_WRITE_PHYSICAL = @as(u32, 7);
pub const IG_READ_IO_SPACE_EX = @as(u32, 8);
pub const IG_WRITE_IO_SPACE_EX = @as(u32, 9);
pub const IG_KSTACK_HELP = @as(u32, 10);
pub const IG_SET_THREAD = @as(u32, 11);
pub const IG_READ_MSR = @as(u32, 12);
pub const IG_WRITE_MSR = @as(u32, 13);
pub const IG_GET_DEBUGGER_DATA = @as(u32, 14);
pub const IG_GET_KERNEL_VERSION = @as(u32, 15);
pub const IG_RELOAD_SYMBOLS = @as(u32, 16);
pub const IG_GET_SET_SYMPATH = @as(u32, 17);
pub const IG_GET_EXCEPTION_RECORD = @as(u32, 18);
pub const IG_IS_PTR64 = @as(u32, 19);
pub const IG_GET_BUS_DATA = @as(u32, 20);
pub const IG_SET_BUS_DATA = @as(u32, 21);
pub const IG_DUMP_SYMBOL_INFO = @as(u32, 22);
pub const IG_LOWMEM_CHECK = @as(u32, 23);
pub const IG_SEARCH_MEMORY = @as(u32, 24);
pub const IG_GET_CURRENT_THREAD = @as(u32, 25);
pub const IG_GET_CURRENT_PROCESS = @as(u32, 26);
pub const IG_GET_TYPE_SIZE = @as(u32, 27);
pub const IG_GET_CURRENT_PROCESS_HANDLE = @as(u32, 28);
pub const IG_GET_INPUT_LINE = @as(u32, 29);
pub const IG_GET_EXPRESSION_EX = @as(u32, 30);
pub const IG_TRANSLATE_VIRTUAL_TO_PHYSICAL = @as(u32, 31);
pub const IG_GET_CACHE_SIZE = @as(u32, 32);
pub const IG_READ_PHYSICAL_WITH_FLAGS = @as(u32, 33);
pub const IG_WRITE_PHYSICAL_WITH_FLAGS = @as(u32, 34);
pub const IG_POINTER_SEARCH_PHYSICAL = @as(u32, 35);
pub const IG_OBSOLETE_PLACEHOLDER_36 = @as(u32, 36);
pub const IG_GET_THREAD_OS_INFO = @as(u32, 37);
pub const IG_GET_CLR_DATA_INTERFACE = @as(u32, 38);
pub const IG_MATCH_PATTERN_A = @as(u32, 39);
pub const IG_FIND_FILE = @as(u32, 40);
pub const IG_TYPED_DATA_OBSOLETE = @as(u32, 41);
pub const IG_QUERY_TARGET_INTERFACE = @as(u32, 42);
pub const IG_TYPED_DATA = @as(u32, 43);
pub const IG_DISASSEMBLE_BUFFER = @as(u32, 44);
pub const IG_GET_ANY_MODULE_IN_RANGE = @as(u32, 45);
pub const IG_VIRTUAL_TO_PHYSICAL = @as(u32, 46);
pub const IG_PHYSICAL_TO_VIRTUAL = @as(u32, 47);
pub const IG_GET_CONTEXT_EX = @as(u32, 48);
pub const IG_GET_TEB_ADDRESS = @as(u32, 128);
pub const IG_GET_PEB_ADDRESS = @as(u32, 129);
pub const PHYS_FLAG_DEFAULT = @as(u32, 0);
pub const PHYS_FLAG_CACHED = @as(u32, 1);
pub const PHYS_FLAG_UNCACHED = @as(u32, 2);
pub const PHYS_FLAG_WRITE_COMBINED = @as(u32, 3);
pub const PTR_SEARCH_PHYS_ALL_HITS = @as(u32, 1);
pub const PTR_SEARCH_PHYS_PTE = @as(u32, 2);
pub const PTR_SEARCH_PHYS_RANGE_CHECK_ONLY = @as(u32, 4);
pub const PTR_SEARCH_PHYS_SIZE_SHIFT = @as(u32, 3);
pub const PTR_SEARCH_NO_SYMBOL_CHECK = @as(u32, 2147483648);
pub const EXT_FIND_FILE_ALLOW_GIVEN_PATH = @as(u32, 1);
pub const DEBUG_TYPED_DATA_IS_IN_MEMORY = @as(u32, 1);
pub const DEBUG_TYPED_DATA_PHYSICAL_DEFAULT = @as(u32, 2);
pub const DEBUG_TYPED_DATA_PHYSICAL_CACHED = @as(u32, 4);
pub const DEBUG_TYPED_DATA_PHYSICAL_UNCACHED = @as(u32, 6);
pub const DEBUG_TYPED_DATA_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const DEBUG_TYPED_DATA_PHYSICAL_MEMORY = @as(u32, 14);
pub const EXT_TDF_PHYSICAL_DEFAULT = @as(u32, 2);
pub const EXT_TDF_PHYSICAL_CACHED = @as(u32, 4);
pub const EXT_TDF_PHYSICAL_UNCACHED = @as(u32, 6);
pub const EXT_TDF_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const EXT_TDF_PHYSICAL_MEMORY = @as(u32, 14);
pub const WDBGEXTS_ADDRESS_DEFAULT = @as(u32, 0);
pub const WDBGEXTS_ADDRESS_SEG16 = @as(u32, 1);
pub const WDBGEXTS_ADDRESS_SEG32 = @as(u32, 2);
pub const WDBGEXTS_ADDRESS_RESERVED0 = @as(u32, 2147483648);
pub const DBGKD_VERS_FLAG_MP = @as(u32, 1);
pub const DBGKD_VERS_FLAG_DATA = @as(u32, 2);
pub const DBGKD_VERS_FLAG_PTR64 = @as(u32, 4);
pub const DBGKD_VERS_FLAG_NOMM = @as(u32, 8);
pub const DBGKD_VERS_FLAG_HSS = @as(u32, 16);
pub const DBGKD_VERS_FLAG_PARTITIONS = @as(u32, 32);
pub const DBGKD_VERS_FLAG_HAL_IN_NTOS = @as(u32, 64);
pub const KD_SECONDARY_VERSION_DEFAULT = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_1 = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_2 = @as(u32, 1);
pub const KD_SECONDARY_VERSION_AMD64_CONTEXT = @as(u32, 2);
pub const CURRENT_KD_SECONDARY_VERSION = @as(u32, 2);
pub const DBG_DUMP_NO_INDENT = @as(u32, 1);
pub const DBG_DUMP_NO_OFFSET = @as(u32, 2);
pub const DBG_DUMP_VERBOSE = @as(u32, 4);
pub const DBG_DUMP_CALL_FOR_EACH = @as(u32, 8);
pub const DBG_DUMP_LIST = @as(u32, 32);
pub const DBG_DUMP_NO_PRINT = @as(u32, 64);
pub const DBG_DUMP_GET_SIZE_ONLY = @as(u32, 128);
pub const DBG_DUMP_COMPACT_OUT = @as(u32, 8192);
pub const DBG_DUMP_ARRAY = @as(u32, 32768);
pub const DBG_DUMP_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DBG_DUMP_ADDRESS_AT_END = @as(u32, 131072);
pub const DBG_DUMP_COPY_TYPE_DATA = @as(u32, 262144);
pub const DBG_DUMP_READ_PHYSICAL = @as(u32, 524288);
pub const DBG_DUMP_FUNCTION_FORMAT = @as(u32, 1048576);
pub const DBG_DUMP_BLOCK_RECURSE = @as(u32, 2097152);
pub const DBG_DUMP_MATCH_SIZE = @as(u32, 4194304);
pub const DBG_RETURN_TYPE = @as(u32, 0);
pub const DBG_RETURN_SUBTYPES = @as(u32, 0);
pub const DBG_RETURN_TYPE_VALUES = @as(u32, 0);
pub const DBG_DUMP_FIELD_CALL_BEFORE_PRINT = @as(u32, 1);
pub const DBG_DUMP_FIELD_NO_CALLBACK_REQ = @as(u32, 2);
pub const DBG_DUMP_FIELD_RECUR_ON_THIS = @as(u32, 4);
pub const DBG_DUMP_FIELD_FULL_NAME = @as(u32, 8);
pub const DBG_DUMP_FIELD_ARRAY = @as(u32, 16);
pub const DBG_DUMP_FIELD_COPY_FIELD_DATA = @as(u32, 32);
pub const DBG_DUMP_FIELD_RETURN_ADDRESS = @as(u32, 4096);
pub const DBG_DUMP_FIELD_SIZE_IN_BITS = @as(u32, 8192);
pub const DBG_DUMP_FIELD_NO_PRINT = @as(u32, 16384);
pub const DBG_DUMP_FIELD_DEFAULT_STRING = @as(u32, 65536);
pub const DBG_DUMP_FIELD_WCHAR_STRING = @as(u32, 131072);
pub const DBG_DUMP_FIELD_MULTI_STRING = @as(u32, 262144);
pub const DBG_DUMP_FIELD_GUID_STRING = @as(u32, 524288);
pub const DBG_DUMP_FIELD_UTF32_STRING = @as(u32, 1048576);
pub const MEMORY_READ_ERROR = @as(u32, 1);
pub const SYMBOL_TYPE_INDEX_NOT_FOUND = @as(u32, 2);
pub const SYMBOL_TYPE_INFO_NOT_FOUND = @as(u32, 3);
pub const FIELDS_DID_NOT_MATCH = @as(u32, 4);
pub const NULL_SYM_DUMP_PARAM = @as(u32, 5);
pub const NULL_FIELD_NAME = @as(u32, 6);
pub const INCORRECT_VERSION_INFO = @as(u32, 7);
pub const EXIT_ON_CONTROLC = @as(u32, 8);
pub const CANNOT_ALLOCATE_MEMORY = @as(u32, 9);
pub const INSUFFICIENT_SPACE_TO_COPY = @as(u32, 10);
pub const ADDRESS_TYPE_INDEX_NOT_FOUND = @as(u32, 11);
pub const UNAVAILABLE_ERROR = @as(u32, 12);
pub const DBGKD_SIMULATION_NONE = @as(i32, 0);
pub const DBGKD_SIMULATION_EXDI = @as(i32, 1);

//--------------------------------------------------------------------------------
// Section: Types (373)
//--------------------------------------------------------------------------------
pub const DEBUG_OFFSET_REGION = extern struct {
    Base: u64,
    Size: u64,
};

const IID_IDebugAdvanced_Value = Guid.initString("f2df5f53-071f-47bd-9de6-5734c3fed689");
pub const IID_IDebugAdvanced = &IID_IDebugAdvanced_Value;
pub const IDebugAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced, @ptrCast(self)), Context, ContextSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_READ_USER_MINIDUMP_STREAM = extern struct {
    StreamType: u32,
    Flags: u32,
    Offset: u64,
    Buffer: ?*anyopaque,
    BufferSize: u32,
    BufferUsed: u32,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_IN = extern struct {
    Flags: u32,
    MatchCountLimit: u32,
    Reserved: [3]u64,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_OUT = extern struct {
    Flags: u32,
    ReplaceIndex: u32,
    MatchCount: u32,
    Reserved1: u32,
    Reserved2: [2]u64,
};

pub const DEBUG_CACHED_SYMBOL_INFO = extern struct {
    ModBase: u64,
    Arg1: u64,
    Arg2: u64,
    Id: u32,
    Arg3: u32,
};

pub const PROCESS_NAME_ENTRY = extern struct {
    ProcessId: u32,
    NameOffset: u32,
    NameSize: u32,
    NextEntry: u32,
};

pub const DEBUG_THREAD_BASIC_INFORMATION = extern struct {
    Valid: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

const IID_IDebugAdvanced2_Value = Guid.initString("716d14c9-119b-4ba5-af1f-0890e672416a");
pub const IID_IDebugAdvanced2 = &IID_IDebugAdvanced2_Value;
pub const IDebugAdvanced2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced2,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced2, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced2, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced2, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]align(1) const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced2, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced2.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced2, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAdvanced3_Value = Guid.initString("cba4abb4-84c4-444d-87ca-a04e13286739");
pub const IID_IDebugAdvanced3 = &IID_IDebugAdvanced3_Value;
pub const IDebugAdvanced3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndTokenWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced3,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced3, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced3, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced3, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]align(1) const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced3, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSourceFileInformationWide(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]align(1) const u16, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).FindSourceFileAndTokenWide(@as(*const IDebugAdvanced3, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced3.VTable, @ptrCast(self.vtable)).GetSymbolInformationWide(@as(*const IDebugAdvanced3, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYMBOL_INFO_EX = extern struct {
    SizeOfStruct: u32,
    TypeOfInfo: u32,
    Offset: u64,
    Line: u32,
    Displacement: u32,
    Reserved: [4]u32,
};

const IID_IDebugAdvanced4_Value = Guid.initString("d1069067-2a65-4bf0-ae97-76184b67856b");
pub const IID_IDebugAdvanced4 = &IID_IDebugAdvanced4_Value;
pub const IDebugAdvanced4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Request: u32,
                // TODO: what to do with BytesParamIndex 2?
                InBuffer: ?*anyopaque,
                InBufferSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                OutBuffer: ?*anyopaque,
                OutBufferSize: u32,
                OutSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u8,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemObjectInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                SourceFile: ?PWSTR,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileAndTokenWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                StartElement: u32,
                ModAddr: u64,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 5?
                FileToken: ?*anyopaque,
                FileTokenSize: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolInformationWideEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
                pInfoEx: ?*SYMBOL_INFO_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugAdvanced4,
                Which: u32,
                Arg64: u64,
                Arg32: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
                StringBuffer: ?[*:0]u16,
                StringBufferSize: u32,
                StringSize: ?*u32,
                pInfoEx: ?*SYMBOL_INFO_EX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetThreadContext(@as(*const IDebugAdvanced4, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_SetThreadContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).SetThreadContext(@as(*const IDebugAdvanced4, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_Request(self: *const T, Request: u32, InBuffer: ?*anyopaque, InBufferSize: u32, OutBuffer: ?*anyopaque, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).Request(@as(*const IDebugAdvanced4, @ptrCast(self)), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSourceFileInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]align(1) const u8, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).FindSourceFileAndToken(@as(*const IDebugAdvanced4, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSystemObjectInformation(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSourceFileInformationWide(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]align(1) const u16, Flags: u32, FileToken: ?*anyopaque, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).FindSourceFileAndTokenWide(@as(*const IDebugAdvanced4, @ptrCast(self)), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformationWide(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformationWideEx(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32, pInfoEx: ?*SYMBOL_INFO_EX) callconv(.Inline) HRESULT {
            return @as(*const IDebugAdvanced4.VTable, @ptrCast(self.vtable)).GetSymbolInformationWideEx(@as(*const IDebugAdvanced4, @ptrCast(self)), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize, pInfoEx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_BREAKPOINT_PARAMETERS = extern struct {
    Offset: u64,
    Id: u32,
    BreakType: u32,
    ProcType: u32,
    Flags: u32,
    DataSize: u32,
    DataAccessType: u32,
    PassCount: u32,
    CurrentPassCount: u32,
    MatchThread: u32,
    CommandSize: u32,
    OffsetExpressionSize: u32,
};

const IID_IDebugBreakpoint_Value = Guid.initString("5bd9d474-5975-423a-b88b-65a8e7110e65");
pub const IID_IDebugBreakpoint = &IID_IDebugBreakpoint_Value;
pub const IDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint, @ptrCast(self)), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint, @ptrCast(self)), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint, @ptrCast(self)), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint, @ptrCast(self)), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetCommand(self: *const T, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint, @ptrCast(self)), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetOffsetExpression(self: *const T, Expression: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint, @ptrCast(self)), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint, @ptrCast(self)), Params);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint2_Value = Guid.initString("1b278d20-79f2-426e-a3f9-c1ddf375d48e");
pub const IID_IDebugBreakpoint2 = &IID_IDebugBreakpoint2_Value;
pub const IDebugBreakpoint2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint2,
                Expression: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint2, @ptrCast(self)), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint2, @ptrCast(self)), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint2, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint2, @ptrCast(self)), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetCommand(self: *const T, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint2, @ptrCast(self)), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffsetExpression(self: *const T, Expression: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint2, @ptrCast(self)), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint2, @ptrCast(self)), Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetCommandWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetCommandWide(self: *const T, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetCommandWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).GetOffsetExpressionWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint2.VTable, @ptrCast(self.vtable)).SetOffsetExpressionWide(@as(*const IDebugBreakpoint2, @ptrCast(self)), Expression);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint3_Value = Guid.initString("38f5c249-b448-43bb-9835-579d4ec02249");
pub const IID_IDebugBreakpoint3 = &IID_IDebugBreakpoint3_Value;
pub const IDebugBreakpoint3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                BreakType: ?*u32,
                ProcType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Adder: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Size: ?*u32,
                AccessType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDataParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Size: u32,
                AccessType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPassCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMatchThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Thread: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExpressionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOffsetExpressionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Expression: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugBreakpoint3,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugBreakpoint3,
                Guid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugBreakpoint3, @ptrCast(self)), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetAdder(@as(*const IDebugBreakpoint3, @ptrCast(self)), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).AddFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).RemoveFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetFlags(@as(*const IDebugBreakpoint3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugBreakpoint3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffset(@as(*const IDebugBreakpoint3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetDataParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetDataParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCurrentPassCount(@as(*const IDebugBreakpoint3, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetMatchThreadId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetMatchThreadId(@as(*const IDebugBreakpoint3, @ptrCast(self)), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCommand(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetCommand(self: *const T, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetCommand(@as(*const IDebugBreakpoint3, @ptrCast(self)), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffsetExpression(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffsetExpression(self: *const T, Expression: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffsetExpression(@as(*const IDebugBreakpoint3, @ptrCast(self)), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetParameters(@as(*const IDebugBreakpoint3, @ptrCast(self)), Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetCommandWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetCommandWide(self: *const T, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetCommandWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetOffsetExpressionWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).SetOffsetExpressionWide(@as(*const IDebugBreakpoint3, @ptrCast(self)), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetGuid(self: *const T, _param_Guid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IDebugBreakpoint3.VTable, @ptrCast(self.vtable)).GetGuid(@as(*const IDebugBreakpoint3, @ptrCast(self)), _param_Guid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_CREATE_PROCESS_OPTIONS = extern struct {
    CreateFlags: u32,
    EngCreateFlags: u32,
    VerifierFlags: u32,
    Reserved: u32,
};

pub const DEBUG_CLIENT_CONTEXT = extern struct {
    cbSize: u32,
    eClient: u32,
};

const IID_IDebugClient_Value = Guid.initString("27fe5639-8407-4f47-8364-ee118fb08ac8");
pub const IID_IDebugClient = &IID_IDebugClient_Value;
pub const IDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient2_Value = Guid.initString("edbed635-372e-4dab-bbfe-ed0d2f63be81");
pub const IID_IDebugClient2 = &IID_IDebugClient2_Value;
pub const IDebugClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient2, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient2, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient2, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient2, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient2, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient2, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient2, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient2, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient2, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient2, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient2, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient2, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient2, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient2, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient2, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient2, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient2, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient2, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient2, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient2, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient2, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient2, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient2, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient2, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient2, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient2, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient2.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient3_Value = Guid.initString("dd492d7f-71b8-4ad6-a8dc-1c887479ff91");
pub const IID_IDebugClient3 = &IID_IDebugClient3_Value;
pub const IDebugClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient3,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient3, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient3, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient3, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient3, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient3, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient3, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient3, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient3, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient3, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient3, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient3, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient3, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient3, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient3, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient3, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient3, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient3, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient3, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient3, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient3, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient3, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient3, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient3, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient3, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient3, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient3, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient3.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient3, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient4_Value = Guid.initString("ca83c3de-5089-4cf8-93c8-d892387f2a5e");
pub const IID_IDebugClient4 = &IID_IDebugClient4_Value;
pub const IDebugClient4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient4, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient4, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient4, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient4, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient4, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient4, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient4, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient4, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient4, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient4, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient4, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient4, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient4, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient4, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient4, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient4, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient4, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient4, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient4, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient4, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient4, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient4, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient4, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient4, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient4, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient4, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient4, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient4, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OpenDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient4, @ptrCast(self)), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient4, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient4.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient4, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient5_Value = Guid.initString("e3acb9d7-7ec2-4f0c-a0da-e81e0cbbe628");
pub const IID_IDebugClient5 = &IID_IDebugClient5_Value;
pub const IDebugClient5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient5,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient5,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient5, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient5, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient5, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient5, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient5, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient5, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient5, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient5, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient5, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient5, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient5, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient5, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient5, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient5, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient5, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient5, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient5, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient5, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient5, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient5, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient5, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient5, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OpenDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient5, @ptrCast(self)), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient5, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient5, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient5, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u16, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient5, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]align(1) const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient5, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartServerWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient5, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient5, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient5, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient5, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient5, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient5, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient5, @ptrCast(self)), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetQuitLockString(self: *const T, String: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient5, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient5, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetQuitLockStringWide(self: *const T, String: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient5.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient5, @ptrCast(self)), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient6_Value = Guid.initString("fd28b4c5-c498-4686-a28e-62cad2154eb3");
pub const IID_IDebugClient6 = &IID_IDebugClient6_Value;
pub const IDebugClient6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient6,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient6, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient6, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient6, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient6, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient6, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient6, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient6, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient6, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient6, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient6, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient6, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient6, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient6, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient6, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient6, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient6, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient6, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient6, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient6, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient6, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient6, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient6, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OpenDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient6, @ptrCast(self)), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient6, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient6, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient6, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u16, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient6, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]align(1) const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient6, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartServerWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient6, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient6, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient6, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient6, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient6, @ptrCast(self)), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetQuitLockString(self: *const T, String: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient6, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient6, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetQuitLockStringWide(self: *const T, String: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient6, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient6.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient6, @ptrCast(self)), Callbacks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient7_Value = Guid.initString("13586be3-542e-481e-b1f2-8497ba74f9a9");
pub const IID_IDebugClient7 = &IID_IDebugClient7_Value;
pub const IDebugClient7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient7,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient7,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient7, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient7, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient7, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient7, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient7, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient7, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient7, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient7, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient7, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient7, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient7, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient7, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient7, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient7, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient7, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient7, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient7, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient7, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient7, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient7, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient7, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient7, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OpenDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient7, @ptrCast(self)), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient7, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient7, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient7, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u16, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient7, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]align(1) const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient7, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartServerWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient7, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient7, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient7, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient7, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient7, @ptrCast(self)), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetQuitLockString(self: *const T, String: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient7, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient7, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetQuitLockStringWide(self: *const T, String: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient7, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient7, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetClientContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient7.VTable, @ptrCast(self.vtable)).SetClientContext(@as(*const IDebugClient7, @ptrCast(self)), Context, ContextSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient8_Value = Guid.initString("cec43add-6375-469e-83d5-414e4033c19a");
pub const IID_IDebugClient8 = &IID_IDebugClient8_Value;
pub const IDebugClient8 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]align(1) const u8,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]align(1) const u8,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisconnectProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIds: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                Ids: ?[*]u32,
                Count: u32,
                ActualCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u8,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcessOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
                HistoryLimit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSession: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExitCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Code: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DispatchCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitDispatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateClient: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Client: ?*?*IDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOtherOutputMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Client: ?*IDebugClient,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Columns: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputWidth: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Columns: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Prefix: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                DumpFile: ?[*:0]align(1) const u8,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                InfoFile: ?[*:0]align(1) const u8,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndProcessServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForProcessServerEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKernelDebuggerEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DetachCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbandonCurrentProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessSystemIdByExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                ExeName: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRunningProcessDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                SystemId: u32,
                Flags: u32,
                ExeName: ?[*:0]u16,
                ExeNameSize: u32,
                ActualExeNameSize: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                ActualDescriptionSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttachWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                CreateFlags: u32,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Qualifier: u32,
                FormatFlags: u32,
                Comment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDumpInformationFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberDumpFiles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
                Handle: ?*u64,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttachKernelWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
                ConnectOptions: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                OptionsSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKernelConnectionOptionsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Flags: u32,
                Options: ?[*:0]align(1) const u16,
                Reserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectProcessServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                RemoteOptions: ?[*:0]align(1) const u16,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartServerWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Options: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputServersWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Machine: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugOutputCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PrefixSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Prefix: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                IdentitySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputIdentityWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                OutputControl: u32,
                Flags: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventCallbacksWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventCallbacksWide,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcess2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u8,
                Environment: ?[*:0]align(1) const u8,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessAndAttach2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Server: u64,
                CommandLine: ?PWSTR,
                // TODO: what to do with BytesParamIndex 3?
                OptionsBuffer: ?*anyopaque,
                OptionsBufferSize: u32,
                InitialDirectory: ?[*:0]align(1) const u16,
                Environment: ?[*:0]align(1) const u16,
                ProcessId: u32,
                AttachFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushOutputLinePrefixWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                NewPrefix: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PopOutputLinePrefix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberInputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOutputCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                EventFlags: u32,
                Count: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                String: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetQuitLockStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                String: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventContextCallbacks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                Callbacks: ?*IDebugEventContextCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClientContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                // TODO: what to do with BytesParamIndex 1?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenDumpFileWide2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                AlternateArch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugClient8,
                FileName: ?[*:0]align(1) const u16,
                FileHandle: u64,
                AlternateArch: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachKernel(@as(*const IDebugClient8, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptions(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u8, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]align(1) const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectProcessServer(@as(*const IDebugClient8, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DisconnectProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIds(@as(*const IDebugClient8, @ptrCast(self)), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableName(@as(*const IDebugClient8, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessDescription(@as(*const IDebugClient8, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachProcess(@as(*const IDebugClient8, @ptrCast(self)), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).RemoveProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetProcessOptions(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OpenDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFile(@as(*const IDebugClient8, @ptrCast(self)), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_WriteDumpFile(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFile(@as(*const IDebugClient8, @ptrCast(self)), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectSession(@as(*const IDebugClient8, @ptrCast(self)), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_StartServer(self: *const T, Options: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartServer(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputServers(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).TerminateProcesses(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DetachProcesses(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).EndSession(@as(*const IDebugClient8, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetExitCode(@as(*const IDebugClient8, @ptrCast(self)), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DispatchCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ExitDispatch(@as(*const IDebugClient8, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateClient(@as(*const IDebugClient8, @ptrCast(self)), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOtherOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOtherOutputMask(@as(*const IDebugClient8, @ptrCast(self)), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputWidth(@as(*const IDebugClient8, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputWidth(@as(*const IDebugClient8, @ptrCast(self)), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetIdentity(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputIdentity(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).FlushCallbacks(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]align(1) const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFile2(@as(*const IDebugClient8, @ptrCast(self)), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]align(1) const u8, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddDumpInformationFile(@as(*const IDebugClient8, @ptrCast(self)), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).EndProcessServer(@as(*const IDebugClient8, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WaitForProcessServerEnd(@as(*const IDebugClient8, @ptrCast(self)), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).IsKernelDebuggerEnabled(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).TerminateCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).DetachCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AbandonCurrentProcess(@as(*const IDebugClient8, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]align(1) const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessSystemIdByExecutableNameWide(@as(*const IDebugClient8, @ptrCast(self)), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetRunningProcessDescriptionWide(@as(*const IDebugClient8, @ptrCast(self)), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessWide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttachWide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OpenDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_WriteDumpFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).WriteDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AddDumpInformationFileWide(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberDumpFiles(@as(*const IDebugClient8, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetDumpFile(@as(*const IDebugClient8, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetDumpFileWide(@as(*const IDebugClient8, @ptrCast(self)), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).AttachKernelWide(@as(*const IDebugClient8, @ptrCast(self)), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetKernelConnectionOptionsWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetKernelConnectionOptionsWide(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]align(1) const u16, Reserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartProcessServerWide(@as(*const IDebugClient8, @ptrCast(self)), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]align(1) const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).ConnectProcessServerWide(@as(*const IDebugClient8, @ptrCast(self)), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_StartServerWide(self: *const T, Options: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).StartServerWide(@as(*const IDebugClient8, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputServersWide(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetIdentityWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OutputIdentityWide(@as(*const IDebugClient8, @ptrCast(self)), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetEventCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventCallbacksWide(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcess2(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcess2Wide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u8, Environment: ?[*:0]align(1) const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*anyopaque, OptionsBufferSize: u32, InitialDirectory: ?[*:0]align(1) const u16, Environment: ?[*:0]align(1) const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).CreateProcessAndAttach2Wide(@as(*const IDebugClient8, @ptrCast(self)), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PushOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PushOutputLinePrefixWide(@as(*const IDebugClient8, @ptrCast(self)), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).PopOutputLinePrefix(@as(*const IDebugClient8, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberInputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberOutputCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetNumberEventCallbacks(@as(*const IDebugClient8, @ptrCast(self)), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetQuitLockString(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetQuitLockString(self: *const T, String: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetQuitLockString(@as(*const IDebugClient8, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).GetQuitLockStringWide(@as(*const IDebugClient8, @ptrCast(self)), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetQuitLockStringWide(self: *const T, String: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetQuitLockStringWide(@as(*const IDebugClient8, @ptrCast(self)), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetEventContextCallbacks(@as(*const IDebugClient8, @ptrCast(self)), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_SetClientContext(self: *const T, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).SetClientContext(@as(*const IDebugClient8, @ptrCast(self)), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient8_OpenDumpFileWide2(self: *const T, FileName: ?[*:0]align(1) const u16, FileHandle: u64, AlternateArch: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugClient8.VTable, @ptrCast(self.vtable)).OpenDumpFileWide2(@as(*const IDebugClient8, @ptrCast(self)), FileName, FileHandle, AlternateArch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient_Value = Guid.initString("a02b66c4-aea3-4234-a9f7-fe4c383d4e29");
pub const IID_IDebugPlmClient = &IID_IDebugPlmClient_Value;
pub const IDebugPlmClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]align(1) const u16, AppName: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient2_Value = Guid.initString("597c980d-e7bd-4309-962c-9d9b69a7372c");
pub const IID_IDebugPlmClient2 = &IID_IDebugPlmClient2_Value;
pub const IDebugPlmClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchPlmBgTaskForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient2,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient2_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]align(1) const u16, AppName: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient2.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient2, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient2_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]align(1) const u16, BackgroundTaskId: ?[*:0]align(1) const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient2.VTable, @ptrCast(self.vtable)).LaunchPlmBgTaskForDebugWide(@as(*const IDebugPlmClient2, @ptrCast(self)), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient3_Value = Guid.initString("d4a5dbd1-ca02-4d90-856a-2a92bfd0f20f");
pub const IID_IDebugPlmClient3 = &IID_IDebugPlmClient3_Value;
pub const IDebugPlmClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchPlmBgTaskForDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Timeout: u32,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPlmPackageList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                Stream: ?*IDebugOutputStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnablePlmPackageDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisablePlmPackageDebugWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspendPlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResumePlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminatePlmPackageWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LaunchAndDebugPlmAppWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                AppName: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateAndDebugPlmBgTaskWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPlmClient3,
                Server: u64,
                PackageFullName: ?[*:0]align(1) const u16,
                BackgroundTaskId: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]align(1) const u16, AppName: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchPlmPackageForDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]align(1) const u16, BackgroundTaskId: ?[*:0]align(1) const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchPlmBgTaskForDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_QueryPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16, Stream: ?*IDebugOutputStream) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).QueryPlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_QueryPlmPackageList(self: *const T, Server: u64, Stream: ?*IDebugOutputStream) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).QueryPlmPackageList(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_EnablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).EnablePlmPackageDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_DisablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).DisablePlmPackageDebugWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_SuspendPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).SuspendPlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_ResumePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).ResumePlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_TerminatePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).TerminatePlmPackageWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchAndDebugPlmAppWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16, AppName: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).LaunchAndDebugPlmAppWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, AppName, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_ActivateAndDebugPlmBgTaskWide(self: *const T, Server: u64, PackageFullName: ?[*:0]align(1) const u16, BackgroundTaskId: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugPlmClient3.VTable, @ptrCast(self.vtable)).ActivateAndDebugPlmBgTaskWide(@as(*const IDebugPlmClient3, @ptrCast(self)), Server, PackageFullName, BackgroundTaskId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputStream_Value = Guid.initString("7782d8f2-2b85-4059-ab88-28ceddca1c80");
pub const IID_IDebugOutputStream = &IID_IDebugOutputStream_Value;
pub const IDebugOutputStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputStream,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputStream,
                psz: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputStream_Write(self: *const T, psz: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputStream.VTable, @ptrCast(self.vtable)).Write(@as(*const IDebugOutputStream, @ptrCast(self)), psz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
};

pub const DEBUG_STACK_FRAME_EX = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
    InlineFrameContext: u32,
    Reserved1: u32,
};

pub const INLINE_FRAME_CONTEXT = extern union {
    ContextValue: u32,
    Anonymous: extern struct {
        FrameId: u8,
        FrameType: u8,
        FrameSignature: u16,
    },
};

pub const STACK_SRC_INFO = extern struct {
    ImagePath: ?[*:0]align(1) const u16,
    ModuleName: ?[*:0]align(1) const u16,
    Function: ?[*:0]align(1) const u16,
    Displacement: u32,
    Row: u32,
    Column: u32,
};

pub const STACK_SYM_FRAME_INFO = extern struct {
    StackFrameEx: DEBUG_STACK_FRAME_EX,
    SrcInfo: STACK_SRC_INFO,
};

pub const DEBUG_SPECIFIC_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    ArgumentSize: u32,
};

pub const DEBUG_EXCEPTION_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    SecondCommandSize: u32,
    ExceptionCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_BREAKPOINT = extern struct {
    Id: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXCEPTION = extern struct {
    ExceptionRecord: EXCEPTION_RECORD64,
    FirstChance: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_THREAD = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_PROCESS = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_LOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR = extern struct {
    Error: u32,
    Level: u32,
};

pub const DEBUG_LAST_EVENT_INFO_SERVICE_EXCEPTION = extern struct {
    Kind: u32,
    DataSize: u32,
    Address: u64,
};

pub const DEBUG_VALUE = extern struct {
    Anonymous: extern union {
        I8: u8,
        I16: u16,
        I32: u32,
        Anonymous: extern struct {
            I64: u64,
            Nat: BOOL,
        },
        F32: f32,
        F64: f64,
        F80Bytes: [10]u8,
        F82Bytes: [11]u8,
        F128Bytes: [16]u8,
        VI8: [16]u8,
        VI16: [8]u16,
        VI32: [4]u32,
        VI64: [2]u64,
        VF32: [4]f32,
        VF64: [2]f64,
        I64Parts32: extern struct {
            LowPart: u32,
            HighPart: u32,
        },
        F128Parts64: extern struct {
            LowPart: u64,
            HighPart: i64,
        },
        RawBytes: [24]u8,
    },
    TailOfRawBytes: u32,
    Type: u32,
};

const IID_IDebugControl_Value = Guid.initString("5182e668-105e-416e-ad92-24ef800424ba");
pub const IID_IDebugControl = &IID_IDebugControl_Value;
pub const IDebugControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl2_Value = Guid.initString("d4366723-44df-4bed-8c7e-4c05424f4588");
pub const IID_IDebugControl2 = &IID_IDebugControl2_Value;
pub const IDebugControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl2, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl2, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl2, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl2, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl2, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl2, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl2, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl2, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl2, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl2, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl2, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl2, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl2, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl2, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl2, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl2, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl2, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl2, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl2, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl2, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl2, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl2, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl2, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl2, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl2, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl2, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl2, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl2, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl2, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl2, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl2, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl2, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl2, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl2, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl2, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl2, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl2, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl2, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl2, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl2, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl2, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl2, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl2, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl2, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl2, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl2, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl2, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl2, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl2, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl2, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl2, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl2, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl2, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl2, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl2, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl2, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl2.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl2, @ptrCast(self)), OutputControl, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl3_Value = Guid.initString("7df74a86-b03f-407f-90ab-a20dadcead08");
pub const IID_IDebugControl3 = &IID_IDebugControl3_Value;
pub const IDebugControl3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl3,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl3,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl3, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl3, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl3, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl3, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl3, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl3, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl3, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl3, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl3, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl3, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl3, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl3, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl3, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl3, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl3, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl3, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl3, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl3, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl3, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl3, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl3, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl3, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl3, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl3, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl3, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl3, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl3, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl3, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl3, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl3, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl3, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl3, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl3, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl3, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl3, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl3, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl3, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl3, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl3, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl3, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl3, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl3, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl3, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl3, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl3, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl3, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl3, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl3, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl3, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl3, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl3, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl3, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl3, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl3, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl3, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl3, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl3, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl3, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl3, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl3, @ptrCast(self)), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl3, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl3, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl3.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl3, @ptrCast(self)), Relation, Value, NextIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl4_Value = Guid.initString("94e60ce9-9b41-4b19-9fc0-6d9eb35272b3");
pub const IID_IDebugControl4 = &IID_IDebugControl4_Value;
pub const IDebugControl4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl4,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl4, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl4, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl4, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl4, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl4, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl4, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl4, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl4, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl4, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl4, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl4, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl4, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl4, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl4, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl4, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl4, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl4, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl4, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl4, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl4, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl4, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl4, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl4, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl4, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl4, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl4, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl4, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl4, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl4, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl4, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl4, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl4, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl4, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl4, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl4, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl4, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl4, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl4, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl4, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl4, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl4, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl4, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl4, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl4, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl4, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl4, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl4, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl4, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl4, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl4, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl4, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl4, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl4, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl4, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl4, @ptrCast(self)), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl4, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl4, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl4, @ptrCast(self)), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFileWide(self: *const T, File: ?[*:0]align(1) const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl4, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReturnInputWide(self: *const T, Buffer: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl4, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl4, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl4, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl4, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl4, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_EvaluateWide(self: *const T, Expression: ?[*:0]align(1) const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl4, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl4, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl4, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl4, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl4, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddExtensionWide(self: *const T, Path: ?[*:0]align(1) const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl4, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionByPathWide(self: *const T, Path: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl4, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl4, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl4, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl4, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, DstText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl4, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl4, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl4, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl4, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile2(self: *const T, File: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl4, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl4, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile2Wide(self: *const T, File: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl4, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl4, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl4, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl4, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl4, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl4, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl4, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl4, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl4, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl4.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl4, @ptrCast(self)), Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl5_Value = Guid.initString("b2ffe162-2412-429f-8d1d-5bf6dd824696");
pub const IID_IDebugControl5 = &IID_IDebugControl5_Value;
pub const IDebugControl5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl5,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl5,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl5, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl5, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl5, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl5, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl5, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl5, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl5, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl5, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl5, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl5, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl5, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl5, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl5, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl5, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl5, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl5, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl5, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl5, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl5, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl5, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl5, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl5, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl5, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl5, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl5, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl5, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl5, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl5, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl5, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl5, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl5, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl5, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl5, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl5, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl5, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl5, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl5, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl5, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl5, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl5, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl5, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl5, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl5, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl5, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl5, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl5, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl5, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl5, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl5, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl5, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl5, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl5, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl5, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl5, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl5, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl5, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl5, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl5, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl5, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl5, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl5, @ptrCast(self)), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl5, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl5, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl5, @ptrCast(self)), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFileWide(self: *const T, File: ?[*:0]align(1) const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl5, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReturnInputWide(self: *const T, Buffer: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl5, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl5, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl5, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl5, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl5, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_EvaluateWide(self: *const T, Expression: ?[*:0]align(1) const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl5, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl5, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl5, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl5, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl5, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddExtensionWide(self: *const T, Path: ?[*:0]align(1) const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl5, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionByPathWide(self: *const T, Path: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl5, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl5, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl5, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl5, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, DstText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl5, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl5, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl5, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl5, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile2(self: *const T, File: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl5, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl5, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile2Wide(self: *const T, File: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl5, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl5, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl5, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl5, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl5, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl5, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl5, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl5, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl5, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl5, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl5.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl5, @ptrCast(self)), _param_Guid, Bp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl6_Value = Guid.initString("bc0d583f-126d-43a1-9cc4-a860ab1d537b");
pub const IID_IDebugControl6 = &IID_IDebugControl6_Value;
pub const IDebugControl6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatusEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSynchronizationStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl6,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl6,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl6, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl6, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl6, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl6, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl6, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl6, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl6, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl6, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl6, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl6, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl6, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl6, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl6, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl6, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl6, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl6, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl6, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl6, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl6, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl6, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl6, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl6, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl6, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl6, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl6, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl6, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl6, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl6, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl6, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl6, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl6, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl6, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl6, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl6, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl6, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl6, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl6, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl6, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl6, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl6, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl6, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl6, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl6, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl6, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl6, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl6, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl6, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl6, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl6, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl6, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl6, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl6, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl6, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl6, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl6, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl6, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl6, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl6, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl6, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl6, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl6, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl6, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl6, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl6, @ptrCast(self)), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl6, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl6, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl6, @ptrCast(self)), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFileWide(self: *const T, File: ?[*:0]align(1) const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl6, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReturnInputWide(self: *const T, Buffer: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl6, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl6, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl6, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl6, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl6, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl6, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_EvaluateWide(self: *const T, Expression: ?[*:0]align(1) const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl6, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl6, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl6, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl6, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl6, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddExtensionWide(self: *const T, Path: ?[*:0]align(1) const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl6, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionByPathWide(self: *const T, Path: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl6, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl6, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl6, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl6, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, DstText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl6, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl6, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl6, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl6, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile2(self: *const T, File: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl6, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl6, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile2Wide(self: *const T, File: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl6, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl6, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl6, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl6, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl6, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl6, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl6, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl6, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl6, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl6, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl6, @ptrCast(self)), _param_Guid, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutionStatusEx(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetExecutionStatusEx(@as(*const IDebugControl6, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl6.VTable, @ptrCast(self.vtable)).GetSynchronizationStatus(@as(*const IDebugControl6, @ptrCast(self)), SendsAttempted, SecondsSinceLastResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl7_Value = Guid.initString("b86fb3b1-80d4-475b-aea3-cf06539cf63a");
pub const IID_IDebugControl7 = &IID_IDebugControl7_Value;
pub const IDebugControl7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Seconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterruptTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Seconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u8,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Input: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: [*:0]u8,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPrompt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u8,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputCurrentState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Assemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]align(1) const u8,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassemble: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisassembleEffectiveOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Offset: u64,
                Flags: u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputDisassemblyLines: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                PreviousLines: u32,
                TotalLines: u32,
                Offset: u64,
                Flags: u32,
                OffsetLine: ?*u32,
                StartOffset: ?*u64,
                EndOffset: ?*u64,
                LineOffsets: ?[*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearInstruction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: u64,
                Delta: i32,
                NearOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReturnOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutingProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPossibleExecutingProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcessors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Major: ?*u32,
                Minor: ?*u32,
                ServicePackString: ?[*:0]u8,
                ServicePackStringSize: u32,
                ServicePackStringUsed: ?*u32,
                ServicePackNumber: ?*u32,
                BuildString: ?[*:0]u8,
                BuildStringSize: u32,
                BuildStringUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPointer64Bit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBugCheckData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Code: ?*u32,
                Arg1: ?*u64,
                Arg2: ?*u64,
                Arg3: ?*u64,
                Arg4: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedProcessorTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Types: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEffectiveProcessorType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExecutionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Level: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCodeLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEngineOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputLevel: ?*u32,
                BreakLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSystemErrorControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputLevel: u32,
                BreakLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacro: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Radix: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRadix: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Radix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Expression: ?[*:0]align(1) const u8,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                In: ?*DEBUG_VALUE,
                OutType: u32,
                Out: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CoerceValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Count: u32,
                In: [*]DEBUG_VALUE,
                OutTypes: [*]u32,
                Out: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Count: u32,
                Ids: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u8,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]align(1) const u8,
                Arguments: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u8,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis32: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindbgExtensionApis64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Api: ?*WINDBG_EXTENSION_APIS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEventFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SpecificEvents: ?*u32,
                SpecificExceptions: ?*u32,
                ArbitraryExceptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Count: u32,
                Codes: ?[*]u32,
                Start: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Count: u32,
                Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: u32,
                Timeout: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u8,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeDate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                TimeDate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDumpFormatFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                FormatFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                NumRepl: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u8,
                Index: u32,
                SrcBuffer: ?[*:0]u8,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u8,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u8,
                DstText: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTextReplacements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAssemblyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberExpressionSyntaxes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u8,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u8,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberEvents: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Events: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNextEventIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Relation: u32,
                Value: u32,
                NextIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Append: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u16,
                Append: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: [*:0]u16,
                BufferSize: u32,
                InputSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnInputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlledOutputVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Mask: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputPromptVaListWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Format: ?[*:0]align(1) const u16,
                Args: ?*i8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPromptTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AssembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: u64,
                Instr: ?[*:0]align(1) const u16,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisassembleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Offset: u64,
                Flags: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                DisassemblySize: ?*u32,
                EndOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessorTypeNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Slot: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MacroSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextMacroWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Slot: u32,
                Macro: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Expression: ?[*:0]align(1) const u16,
                DesiredType: u32,
                Value: ?*DEBUG_VALUE,
                RemainderIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Command: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteCommandFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                CommandFile: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByIndex2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointById2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Id: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: u32,
                DesiredId: u32,
                Bp: ?*?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveBreakpoint2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u16,
                Flags: u32,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionByPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Path: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallExtensionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
                Function: ?[*:0]align(1) const u16,
                Arguments: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtensionFunctionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Handle: u64,
                FuncName: ?[*:0]align(1) const u16,
                Function: ?*?FARPROC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                TextSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilterCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ArgumentSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpecificFilterArgumentWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Argument: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                CommandSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExceptionFilterSecondCommandWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Command: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastEventInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
                Description: ?[*:0]u16,
                DescriptionSize: u32,
                DescriptionUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u16,
                Index: u32,
                SrcBuffer: ?[*:0]u16,
                SrcBufferSize: u32,
                SrcSize: ?*u32,
                DstBuffer: ?[*:0]u16,
                DstBufferSize: u32,
                DstSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTextReplacementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SrcText: ?[*:0]align(1) const u16,
                DstText: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetExpressionSyntaxByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                AbbrevName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExpressionSyntaxNamesWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                FullNameBuffer: ?[*:0]u16,
                FullNameBufferSize: u32,
                FullNameSize: ?*u32,
                AbbrevNameBuffer: ?[*:0]u16,
                AbbrevNameBufferSize: u32,
                AbbrevNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventIndexDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Index: u32,
                Which: u32,
                Buffer: ?PWSTR,
                BufferSize: u32,
                DescSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FileSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenLogFile2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                PlatformId: ?*u32,
                Win32Major: ?*u32,
                Win32Minor: ?*u32,
                KdMajor: ?*u32,
                KdMinor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemVersionStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTrace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStoredEventInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Type: ?*u32,
                ProcessId: ?*u32,
                ThreadId: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
                ContextUsed: ?*u32,
                // TODO: what to do with BytesParamIndex 7?
                ExtraInformation: ?*anyopaque,
                ExtraInformationSize: u32,
                ExtraInformationUsed: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u8,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetManagedStatusWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: ?*u32,
                WhichString: u32,
                String: ?[*:0]u16,
                StringSize: u32,
                StringNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetManagedStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                FrameOffset: u64,
                StackOffset: u64,
                InstructionOffset: u64,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                // TODO: what to do with BytesParamIndex 1?
                StartContext: ?*anyopaque,
                StartContextSize: u32,
                Frames: ?[*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 5?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                FramesFilled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputContextStackTraceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                OutputControl: u32,
                Frames: [*]DEBUG_STACK_FRAME_EX,
                FramesSize: u32,
                // TODO: what to do with BytesParamIndex 4?
                FrameContexts: ?*anyopaque,
                FrameContextsSize: u32,
                FrameContextsEntrySize: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBreakpointByGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Guid: ?*Guid,
                Bp: ?*?*IDebugBreakpoint3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExecutionStatusEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Status: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSynchronizationStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                SendsAttempted: ?*u32,
                SecondsSinceLastResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDebuggeeType2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugControl7,
                Flags: u32,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugControl7,
                Flags: u32,
                Class: ?*u32,
                Qualifier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetInterrupt(@as(*const IDebugControl7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetInterrupt(@as(*const IDebugControl7, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetInterruptTimeout(@as(*const IDebugControl7, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetInterruptTimeout(@as(*const IDebugControl7, @ptrCast(self)), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile(self: *const T, File: ?[*:0]align(1) const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile(@as(*const IDebugControl7, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CloseLogFile(@as(*const IDebugControl7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogMask(@as(*const IDebugControl7, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetLogMask(@as(*const IDebugControl7, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Input(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReturnInput(self: *const T, Buffer: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReturnInput(@as(*const IDebugControl7, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Output(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVaList(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutput(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputVaList(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPrompt(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptVaList(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPromptText(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputCurrentState(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVersionInformation(@as(*const IDebugControl7, @ptrCast(self)), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNotifyEventHandle(@as(*const IDebugControl7, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetNotifyEventHandle(@as(*const IDebugControl7, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Assemble(@as(*const IDebugControl7, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Disassemble(@as(*const IDebugControl7, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDisassembleEffectiveOffset(@as(*const IDebugControl7, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputDisassembly(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputDisassemblyLines(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNearInstruction(@as(*const IDebugControl7, @ptrCast(self)), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStackTrace(@as(*const IDebugControl7, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetReturnOffset(@as(*const IDebugControl7, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputStackTrace(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDebuggeeType(@as(*const IDebugControl7, @ptrCast(self)), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetActualProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutingProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberPossibleExecutingProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPossibleExecutingProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberProcessors(@as(*const IDebugControl7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersion(@as(*const IDebugControl7, @ptrCast(self)), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPageSize(@as(*const IDebugControl7, @ptrCast(self)), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).IsPointer64Bit(@as(*const IDebugControl7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReadBugCheckData(@as(*const IDebugControl7, @ptrCast(self)), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberSupportedProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSupportedProcessorTypes(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetProcessorTypeNames(@as(*const IDebugControl7, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEffectiveProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEffectiveProcessorType(@as(*const IDebugControl7, @ptrCast(self)), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutionStatus(@as(*const IDebugControl7, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExecutionStatus(@as(*const IDebugControl7, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCodeLevel(@as(*const IDebugControl7, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetCodeLevel(@as(*const IDebugControl7, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEngineOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemErrorControl(@as(*const IDebugControl7, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSystemErrorControl(@as(*const IDebugControl7, @ptrCast(self)), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextMacro(@as(*const IDebugControl7, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextMacro(@as(*const IDebugControl7, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetRadix(@as(*const IDebugControl7, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetRadix(@as(*const IDebugControl7, @ptrCast(self)), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Evaluate(self: *const T, Expression: ?[*:0]align(1) const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDebugControl7, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CoerceValue(@as(*const IDebugControl7, @ptrCast(self)), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CoerceValues(@as(*const IDebugControl7, @ptrCast(self)), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteCommandFile(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberBreakpoints(@as(*const IDebugControl7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex(@as(*const IDebugControl7, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointById(@as(*const IDebugControl7, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddBreakpoint(@as(*const IDebugControl7, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveBreakpoint(@as(*const IDebugControl7, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddExtension(self: *const T, Path: ?[*:0]align(1) const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddExtension(@as(*const IDebugControl7, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveExtension(@as(*const IDebugControl7, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionByPath(self: *const T, Path: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionByPath(@as(*const IDebugControl7, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u8, Arguments: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CallExtension(@as(*const IDebugControl7, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionFunction(@as(*const IDebugControl7, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis32(@as(*const IDebugControl7, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetWindbgExtensionApis64(@as(*const IDebugControl7, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberEventFilters(@as(*const IDebugControl7, @ptrCast(self)), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterText(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEventFilterCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgument(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgument(@as(*const IDebugControl7, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterParameters(@as(*const IDebugControl7, @ptrCast(self)), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommand(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).WaitForEvent(@as(*const IDebugControl7, @ptrCast(self)), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLastEventInformation(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentTimeDate(@as(*const IDebugControl7, @ptrCast(self)), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentSystemUpTime(@as(*const IDebugControl7, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDumpFormatFlags(@as(*const IDebugControl7, @ptrCast(self)), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberTextReplacements(@as(*const IDebugControl7, @ptrCast(self)), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextReplacement(@as(*const IDebugControl7, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextReplacement(self: *const T, SrcText: ?[*:0]align(1) const u8, DstText: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextReplacement(@as(*const IDebugControl7, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveTextReplacements(@as(*const IDebugControl7, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputTextReplacements(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetAssemblyOptions(@as(*const IDebugControl7, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntax(@as(*const IDebugControl7, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntax(@as(*const IDebugControl7, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByName(@as(*const IDebugControl7, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberExpressionSyntaxes(@as(*const IDebugControl7, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNames(@as(*const IDebugControl7, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetNumberEvents(@as(*const IDebugControl7, @ptrCast(self)), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventIndexDescription(@as(*const IDebugControl7, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetCurrentEventIndex(@as(*const IDebugControl7, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetNextEventIndex(@as(*const IDebugControl7, @ptrCast(self)), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFileWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFileWide(self: *const T, File: ?[*:0]align(1) const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFileWide(@as(*const IDebugControl7, @ptrCast(self)), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).InputWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReturnInputWide(self: *const T, Buffer: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ReturnInputWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputWide(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputVaListWide(@as(*const IDebugControl7, @ptrCast(self)), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ControlledOutputVaListWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]align(1) const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputPromptVaListWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetPromptTextWide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]align(1) const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AssembleWide(@as(*const IDebugControl7, @ptrCast(self)), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).DisassembleWide(@as(*const IDebugControl7, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetProcessorTypeNamesWide(@as(*const IDebugControl7, @ptrCast(self)), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextMacroWide(@as(*const IDebugControl7, @ptrCast(self)), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextMacroWide(@as(*const IDebugControl7, @ptrCast(self)), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_EvaluateWide(self: *const T, Expression: ?[*:0]align(1) const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).EvaluateWide(@as(*const IDebugControl7, @ptrCast(self)), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ExecuteCommandFileWide(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByIndex2(@as(*const IDebugControl7, @ptrCast(self)), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointById2(@as(*const IDebugControl7, @ptrCast(self)), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddBreakpoint2(@as(*const IDebugControl7, @ptrCast(self)), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).RemoveBreakpoint2(@as(*const IDebugControl7, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddExtensionWide(self: *const T, Path: ?[*:0]align(1) const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).AddExtensionWide(@as(*const IDebugControl7, @ptrCast(self)), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionByPathWide(self: *const T, Path: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionByPathWide(@as(*const IDebugControl7, @ptrCast(self)), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]align(1) const u16, Arguments: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).CallExtensionWide(@as(*const IDebugControl7, @ptrCast(self)), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]align(1) const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExtensionFunctionWide(@as(*const IDebugControl7, @ptrCast(self)), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterTextWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventFilterCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetEventFilterCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSpecificFilterArgumentWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetSpecificFilterArgumentWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExceptionFilterSecondCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExceptionFilterSecondCommandWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLastEventInformationWide(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetTextReplacementWide(@as(*const IDebugControl7, @ptrCast(self)), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]align(1) const u16, DstText: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetTextReplacementWide(@as(*const IDebugControl7, @ptrCast(self)), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).SetExpressionSyntaxByNameWide(@as(*const IDebugControl7, @ptrCast(self)), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExpressionSyntaxNamesWide(@as(*const IDebugControl7, @ptrCast(self)), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetEventIndexDescriptionWide(@as(*const IDebugControl7, @ptrCast(self)), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile2(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile2(self: *const T, File: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile2(@as(*const IDebugControl7, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetLogFile2Wide(@as(*const IDebugControl7, @ptrCast(self)), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile2Wide(self: *const T, File: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OpenLogFile2Wide(@as(*const IDebugControl7, @ptrCast(self)), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionValues(@as(*const IDebugControl7, @ptrCast(self)), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionString(@as(*const IDebugControl7, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSystemVersionStringWide(@as(*const IDebugControl7, @ptrCast(self)), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetContextStackTrace(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetContextStackTrace(@as(*const IDebugControl7, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputContextStackTrace(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*anyopaque, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*anyopaque, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStoredEventInformation(@as(*const IDebugControl7, @ptrCast(self)), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetManagedStatus(@as(*const IDebugControl7, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetManagedStatusWide(@as(*const IDebugControl7, @ptrCast(self)), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).ResetManagedStatus(@as(*const IDebugControl7, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetContextStackTraceEx(self: *const T, StartContext: ?*anyopaque, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetContextStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*anyopaque, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).OutputContextStackTraceEx(@as(*const IDebugControl7, @ptrCast(self)), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetBreakpointByGuid(@as(*const IDebugControl7, @ptrCast(self)), _param_Guid, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutionStatusEx(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetExecutionStatusEx(@as(*const IDebugControl7, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetSynchronizationStatus(@as(*const IDebugControl7, @ptrCast(self)), SendsAttempted, SecondsSinceLastResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDebuggeeType2(self: *const T, Flags: u32, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugControl7.VTable, @ptrCast(self.vtable)).GetDebuggeeType2(@as(*const IDebugControl7, @ptrCast(self)), Flags, Class, Qualifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALPHA = extern struct {
    Type: u32,
    Revision: u32,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_AMD64 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_IA64 = extern struct {
    Model: u32,
    Revision: u32,
    Family: u32,
    ArchRev: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_X86 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM64 = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALL = extern union {
    Alpha: DEBUG_PROCESSOR_IDENTIFICATION_ALPHA,
    Amd64: DEBUG_PROCESSOR_IDENTIFICATION_AMD64,
    Ia64: DEBUG_PROCESSOR_IDENTIFICATION_IA64,
    X86: DEBUG_PROCESSOR_IDENTIFICATION_X86,
    Arm: DEBUG_PROCESSOR_IDENTIFICATION_ARM,
    Arm64: DEBUG_PROCESSOR_IDENTIFICATION_ARM64,
};

const IID_IDebugDataSpaces_Value = Guid.initString("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa");
pub const IID_IDebugDataSpaces = &IID_IDebugDataSpaces_Value;
pub const IDebugDataSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_HANDLE_DATA_BASIC = extern struct {
    TypeNameSize: u32,
    ObjectNameSize: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
};

const IID_IDebugDataSpaces2_Value = Guid.initString("7a5e852f-96e9-468f-ac1b-0b3addc4a049");
pub const IID_IDebugDataSpaces2 = &IID_IDebugDataSpaces2_Value;
pub const IDebugDataSpaces2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces2,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces2, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces2, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces2, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces2, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces2, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces2, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces2, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces2, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces2, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces2.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces2, @ptrCast(self)), Offset, Info);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces3_Value = Guid.initString("23f79d6c-8aaf-4f7c-a607-9995f5407e63");
pub const IID_IDebugDataSpaces3 = &IID_IDebugDataSpaces3_Value;
pub const IDebugDataSpaces3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadImageNtHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces3, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces3, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces3, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces3, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces3, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces3, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces3, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces3, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces3, @ptrCast(self)), Offset, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadImageNtHeaders(@as(*const IDebugDataSpaces3, @ptrCast(self)), ImageBase, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, TotalSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).ReadTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Tag, Offset, Buffer, BufferSize, TotalSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_StartEnumTagged(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).StartEnumTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).GetNextTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle, Tag, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_EndEnumTagged(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces3.VTable, @ptrCast(self.vtable)).EndEnumTagged(@as(*const IDebugDataSpaces3, @ptrCast(self)), Handle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces4_Value = Guid.initString("d98ada1f-29e9-4ef5-a6c0-e53349883212");
pub const IID_IDebugDataSpaces4 = &IID_IDebugDataSpaces4_Value;
pub const IDebugDataSpaces4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteVirtualUncached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointersVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Count: u32,
                Offset: u64,
                Ptrs: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteIo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                InterfaceType: u32,
                BusNumber: u32,
                AddressSpace: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteMsr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Msr: u32,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBusData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                BusDataType: u32,
                BusNumber: u32,
                SlotNumber: u32,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 5?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckLowMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadDebuggerData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Index: u32,
                // TODO: what to do with BytesParamIndex 2?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadProcessorSystemData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Processor: u32,
                Index: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualToPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Physical: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVirtualTranslationPhysicalOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Virtual: u64,
                Offsets: ?[*]u64,
                OffsetsSize: u32,
                Levels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadHandleData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
                DataType: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                DataSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FillPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Start: u64,
                Size: u32,
                // TODO: what to do with BytesParamIndex 3?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                Filled: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Info: ?*MEMORY_BASIC_INFORMATION64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadImageNtHeaders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                ImageBase: u64,
                Headers: ?*IMAGE_NT_HEADERS64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Tag: ?*Guid,
                Offset: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                TotalSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
                Tag: ?*Guid,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndEnumTagged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Space: u32,
                Which: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Space: u32,
                Which: u32,
                Offset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                InfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextDifferentlyValidOffsetVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                NextOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                NextOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValidRegionVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Base: u64,
                Size: u32,
                ValidBase: ?*u64,
                ValidSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Base: u64,
                Size: u32,
                ValidBase: ?*u64,
                ValidSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SearchVirtual2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 4?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Length: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 4?
                Pattern: ?*anyopaque,
                PatternSize: u32,
                PatternGranularity: u32,
                MatchOffset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMultiByteStringVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadMultiByteStringVirtualWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadUnicodeStringVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                CodePage: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadUnicodeStringVirtualWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                MaxBytes: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringBytes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPhysical2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePhysical2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugDataSpaces4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).SearchVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadVirtualUncached(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteVirtualUncached(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPointersVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePointersVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePhysical(self: *const T, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadControl(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteControl(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadIo(@as(*const IDebugDataSpaces4, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteIo(@as(*const IDebugDataSpaces4, @ptrCast(self)), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMsr(@as(*const IDebugDataSpaces4, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteMsr(@as(*const IDebugDataSpaces4, @ptrCast(self)), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadBusData(@as(*const IDebugDataSpaces4, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WriteBusData(@as(*const IDebugDataSpaces4, @ptrCast(self)), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).CheckLowMemory(@as(*const IDebugDataSpaces4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadDebuggerData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadProcessorSystemData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).VirtualToPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetVirtualTranslationPhysicalOffsets(@as(*const IDebugDataSpaces4, @ptrCast(self)), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*anyopaque, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadHandleData(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).FillVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*anyopaque, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).FillPhysical(@as(*const IDebugDataSpaces4, @ptrCast(self)), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).QueryVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadImageNtHeaders(@as(*const IDebugDataSpaces4, @ptrCast(self)), ImageBase, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*anyopaque, BufferSize: u32, TotalSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Tag, Offset, Buffer, BufferSize, TotalSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_StartEnumTagged(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).StartEnumTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetNextTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle, Tag, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_EndEnumTagged(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).EndEnumTagged(@as(*const IDebugDataSpaces4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetOffsetInformation(self: *const T, Space: u32, Which: u32, Offset: u64, Buffer: ?*anyopaque, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetOffsetInformation(@as(*const IDebugDataSpaces4, @ptrCast(self)), Space, Which, Offset, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetNextDifferentlyValidOffsetVirtual(self: *const T, Offset: u64, NextOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetNextDifferentlyValidOffsetVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, NextOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetValidRegionVirtual(self: *const T, Base: u64, Size: u32, ValidBase: ?*u64, ValidSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).GetValidRegionVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Base, Size, ValidBase, ValidSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_SearchVirtual2(self: *const T, Offset: u64, Length: u64, Flags: u32, Pattern: ?*anyopaque, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).SearchVirtual2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Length, Flags, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMultiByteStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMultiByteStringVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMultiByteStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadMultiByteStringVirtualWide(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadUnicodeStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadUnicodeStringVirtual(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadUnicodeStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadUnicodeStringVirtualWide(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).ReadPhysical2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugDataSpaces4.VTable, @ptrCast(self.vtable)).WritePhysical2(@as(*const IDebugDataSpaces4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BytesWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacks_Value = Guid.initString("337be28b-5036-4d72-b6bf-c45fbb9f2eaa");
pub const IID_IDebugEventCallbacks = &IID_IDebugEventCallbacks_Value;
pub const IDebugEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Bp: ?*IDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u8,
                ImageName: ?[*:0]align(1) const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u8,
                ImageName: ?[*:0]align(1) const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u8,
                ImageName: ?[*:0]align(1) const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u8,
                ImageName: ?[*:0]align(1) const u8,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                ImageBaseName: ?[*:0]align(1) const u8,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                ImageBaseName: ?[*:0]align(1) const u8,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventCallbacks, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventCallbacks, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventCallbacks, @ptrCast(self)), Exception, FirstChance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventCallbacks, @ptrCast(self)), Handle, DataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ExitThread(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventCallbacks, @ptrCast(self)), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u8, ImageName: ?[*:0]align(1) const u8, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ExitProcess(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventCallbacks, @ptrCast(self)), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u8, ImageName: ?[*:0]align(1) const u8, CheckSum: u32, TimeDateStamp: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]align(1) const u8, BaseOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventCallbacks, @ptrCast(self)), ImageBaseName, BaseOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_SystemError(self: *const T, Error: u32, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventCallbacks, @ptrCast(self)), Error, Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventCallbacks, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacks.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventCallbacks, @ptrCast(self)), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacksWide_Value = Guid.initString("0690e046-9c23-45ac-a04f-987ac29ad0d3");
pub const IID_IDebugEventCallbacksWide = &IID_IDebugEventCallbacksWide_Value;
pub const IDebugEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Bp: ?*IDebugBreakpoint2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                ExitCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                ImageBaseName: ?[*:0]align(1) const u16,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                ImageBaseName: ?[*:0]align(1) const u16,
                BaseOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Error: u32,
                Level: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventCallbacksWide,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Exception, FirstChance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Handle, DataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ExitThread(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u16, ImageName: ?[*:0]align(1) const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ExitProcess(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u16, ImageName: ?[*:0]align(1) const u16, CheckSum: u32, TimeDateStamp: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_UnloadModule(self: *const T, ImageBaseName: ?[*:0]align(1) const u16, BaseOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), ImageBaseName, BaseOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_SystemError(self: *const T, Error: u32, Level: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Error, Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventCallbacksWide.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventCallbacksWide, @ptrCast(self)), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_EVENT_CONTEXT = extern struct {
    Size: u32,
    ProcessEngineId: u32,
    ThreadEngineId: u32,
    FrameEngineId: u32,
};

const IID_IDebugEventContextCallbacks_Value = Guid.initString("61a4905b-23f9-4247-b3c5-53d087529ab7");
pub const IID_IDebugEventContextCallbacks = &IID_IDebugEventContextCallbacks_Value;
pub const IDebugEventContextCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Breakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Bp: ?*IDebugBreakpoint2,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Bp: ?*IDebugBreakpoint2,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Exception: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Exception: ?*EXCEPTION_RECORD64,
                FirstChance: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Handle: u64,
                DataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 4?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateProcessA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 12?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                Handle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                InitialThreadHandle: u64,
                ThreadDataOffset: u64,
                StartOffset: u64,
                // TODO: what to do with BytesParamIndex 12?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                ExitCode: u32,
                // TODO: what to do with BytesParamIndex 2?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                // TODO: what to do with BytesParamIndex 8?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                ImageFileHandle: u64,
                BaseOffset: u64,
                ModuleSize: u32,
                ModuleName: ?[*:0]align(1) const u16,
                ImageName: ?[*:0]align(1) const u16,
                CheckSum: u32,
                TimeDateStamp: u32,
                // TODO: what to do with BytesParamIndex 8?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                ImageBaseName: ?[*:0]align(1) const u16,
                BaseOffset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                ImageBaseName: ?[*:0]align(1) const u16,
                BaseOffset: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SystemError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Error: u32,
                Level: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Error: u32,
                Level: u32,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Status: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDebuggeeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeEngineState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
                // TODO: what to do with BytesParamIndex 3?
                Context: ?*anyopaque,
                ContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeSymbolState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugEventContextCallbacks,
                Flags: u32,
                Argument: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).Breakpoint(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Bp, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).Exception(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Exception, FirstChance, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).CreateThread(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Handle, DataOffset, StartOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ExitThread(self: *const T, ExitCode: u32, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ExitThread(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ExitCode, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u16, ImageName: ?[*:0]align(1) const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).CreateProcessA(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ExitProcess(self: *const T, ExitCode: u32, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ExitCode, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]align(1) const u16, ImageName: ?[*:0]align(1) const u16, CheckSum: u32, TimeDateStamp: u32, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).LoadModule(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]align(1) const u16, BaseOffset: u64, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).UnloadModule(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), ImageBaseName, BaseOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_SystemError(self: *const T, Error: u32, Level: u32, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).SystemError(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Error, Level, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).SessionStatus(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeDebuggeeState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64, Context: ?*anyopaque, ContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeEngineState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugEventContextCallbacks.VTable, @ptrCast(self.vtable)).ChangeSymbolState(@as(*const IDebugEventContextCallbacks, @ptrCast(self)), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugInputCallbacks_Value = Guid.initString("9f50e42c-f136-499e-9a97-73036c94ed2d");
pub const IID_IDebugInputCallbacks = &IID_IDebugInputCallbacks_Value;
pub const IDebugInputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugInputCallbacks,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugInputCallbacks,
                BufferSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndInput: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugInputCallbacks,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugInputCallbacks_StartInput(self: *const T, BufferSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugInputCallbacks.VTable, @ptrCast(self.vtable)).StartInput(@as(*const IDebugInputCallbacks, @ptrCast(self)), BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugInputCallbacks_EndInput(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugInputCallbacks.VTable, @ptrCast(self.vtable)).EndInput(@as(*const IDebugInputCallbacks, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks_Value = Guid.initString("4bf58045-d654-4c40-b0af-683090f356dc");
pub const IID_IDebugOutputCallbacks = &IID_IDebugOutputCallbacks_Value;
pub const IDebugOutputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputCallbacks,
                Mask: u32,
                Text: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputCallbacks,
                Mask: u32,
                Text: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks_Output(self: *const T, Mask: u32, Text: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputCallbacks.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacks, @ptrCast(self)), Mask, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacksWide_Value = Guid.initString("4c7fd663-c394-4e26-8ef1-34ad5ed3764c");
pub const IID_IDebugOutputCallbacksWide = &IID_IDebugOutputCallbacksWide_Value;
pub const IDebugOutputCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputCallbacksWide,
                Mask: u32,
                Text: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputCallbacksWide,
                Mask: u32,
                Text: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacksWide_Output(self: *const T, Mask: u32, Text: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputCallbacksWide.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacksWide, @ptrCast(self)), Mask, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks2_Value = Guid.initString("67721fe9-56d2-4a44-a325-2b65513ce6eb");
pub const IID_IDebugOutputCallbacks2 = &IID_IDebugOutputCallbacks2_Value;
pub const IDebugOutputCallbacks2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputCallbacks2,
                Mask: u32,
                Text: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputCallbacks2,
                Mask: u32,
                Text: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterestMask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputCallbacks2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputCallbacks2,
                Mask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Output2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugOutputCallbacks2,
                Which: u32,
                Flags: u32,
                Arg: u64,
                Text: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugOutputCallbacks2,
                Which: u32,
                Flags: u32,
                Arg: u64,
                Text: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_Output(self: *const T, Mask: u32, Text: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).Output(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Mask, Text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).GetInterestMask(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_Output2(self: *const T, Which: u32, Flags: u32, Arg: u64, Text: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugOutputCallbacks2.VTable, @ptrCast(self.vtable)).Output2(@as(*const IDebugOutputCallbacks2, @ptrCast(self)), Which, Flags, Arg, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_REGISTER_DESCRIPTION = extern struct {
    Type: u32,
    Flags: u32,
    SubregMaster: u32,
    SubregLength: u32,
    SubregMask: u64,
    SubregShift: u32,
    Reserved0: u32,
};

const IID_IDebugRegisters_Value = Guid.initString("ce289126-9e84-45a7-937e-67bb18691493");
pub const IID_IDebugRegisters = &IID_IDebugRegisters_Value;
pub const IDebugRegisters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetNumberRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetNumberRegisters(@as(*const IDebugRegisters, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDebugRegisters, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetIndexByName(self: *const T, Name: ?[*:0]align(1) const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetIndexByName(@as(*const IDebugRegisters, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugRegisters, @ptrCast(self)), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDebugRegisters, @ptrCast(self)), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetValues(@as(*const IDebugRegisters, @ptrCast(self)), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).SetValues(@as(*const IDebugRegisters, @ptrCast(self)), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).OutputRegisters(@as(*const IDebugRegisters, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetInstructionOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetInstructionOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetStackOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetStackOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetFrameOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters.VTable, @ptrCast(self.vtable)).GetFrameOffset(@as(*const IDebugRegisters, @ptrCast(self)), Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugRegisters2_Value = Guid.initString("1656afa9-19c6-4e3a-97e7-5dc9160cf9c4");
pub const IID_IDebugRegisters2 = &IID_IDebugRegisters2_Value;
pub const IDebugRegisters2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                Value: ?*DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Desc: ?*DEBUG_REGISTER_DESCRIPTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberPseudoRegisters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoDescriptionWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Register: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                TypeModule: ?*u64,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoIndexByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoIndexByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPseudoValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPseudoValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValues2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValues2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Count: u32,
                Indices: ?[*]u32,
                Start: u32,
                Values: [*]DEBUG_VALUE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputRegisters2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Source: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                OutputControl: u32,
                Source: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInstructionOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugRegisters2,
                Source: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetNumberRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetNumberRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetIndexByName(self: *const T, Name: ?[*:0]align(1) const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetIndexByName(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugRegisters2, @ptrCast(self)), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IDebugRegisters2, @ptrCast(self)), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValues(@as(*const IDebugRegisters2, @ptrCast(self)), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValues(@as(*const IDebugRegisters2, @ptrCast(self)), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).OutputRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetInstructionOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetInstructionOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetStackOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetStackOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetFrameOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetFrameOffset(@as(*const IDebugRegisters2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetDescriptionWide(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetIndexByNameWide(self: *const T, Name: ?[*:0]align(1) const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetIndexByNameWide(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetNumberPseudoRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetNumberPseudoRegisters(@as(*const IDebugRegisters2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoDescription(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoDescriptionWide(@as(*const IDebugRegisters2, @ptrCast(self)), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoIndexByName(self: *const T, Name: ?[*:0]align(1) const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoIndexByName(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoIndexByNameWide(self: *const T, Name: ?[*:0]align(1) const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoIndexByNameWide(@as(*const IDebugRegisters2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetPseudoValues(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetPseudoValues(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetValues2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).SetValues2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_OutputRegisters2(self: *const T, OutputControl: u32, Source: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).OutputRegisters2(@as(*const IDebugRegisters2, @ptrCast(self)), OutputControl, Source, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetInstructionOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetInstructionOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetStackOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetStackOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetFrameOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugRegisters2.VTable, @ptrCast(self.vtable)).GetFrameOffset2(@as(*const IDebugRegisters2, @ptrCast(self)), Source, Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_PARAMETERS = extern struct {
    Module: u64,
    TypeId: u32,
    ParentSymbol: u32,
    SubElements: u32,
    Flags: u32,
    Reserved: u64,
};

const IID_IDebugSymbolGroup_Value = Guid.initString("f2528316-0f1a-4431-aeed-11d096e1e2ab");
pub const IID_IDebugSymbolGroup = &IID_IDebugSymbolGroup_Value;
pub const IDebugSymbolGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Name: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Value: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Value: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Type: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup,
                Index: u32,
                Type: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetNumberSymbols(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetNumberSymbols(@as(*const IDebugSymbolGroup, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_AddSymbol(self: *const T, Name: ?[*:0]align(1) const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).AddSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_RemoveSymbolByName(self: *const T, Name: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).RemoveSymbolByName(@as(*const IDebugSymbolGroup, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_RemoveSymbolByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).RemoveSymbolByIndex(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetSymbolName(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).GetSymbolParameters(@as(*const IDebugSymbolGroup, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).ExpandSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Expand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).OutputSymbols(@as(*const IDebugSymbolGroup, @ptrCast(self)), OutputControl, Flags, Start, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).WriteSymbol(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup.VTable, @ptrCast(self.vtable)).OutputAsType(@as(*const IDebugSymbolGroup, @ptrCast(self)), Index, Type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    Id: u64,
    Arg64: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    NameSize: u32,
    Token: u32,
    Tag: u32,
    Arg32: u32,
    Reserved: u32,
};

const IID_IDebugSymbolGroup2_Value = Guid.initString("6a7ccc5f-fb5e-4dcc-b41c-6c20307bccc7");
pub const IID_IDebugSymbolGroup2 = &IID_IDebugSymbolGroup2_Value;
pub const IDebugSymbolGroup2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u8,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Start: u32,
                Count: u32,
                Params: [*]DEBUG_SYMBOL_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExpandSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Expand: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbols: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                OutputControl: u32,
                Flags: u32,
                Start: u32,
                Count: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u16,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Name: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Value: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputAsTypeWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Type: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolRegister: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Register: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Register: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolValueText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolValueTextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Entry: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbolGroup2,
                Index: u32,
                Entry: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetNumberSymbols(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetNumberSymbols(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_AddSymbol(self: *const T, Name: ?[*:0]align(1) const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).AddSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByName(self: *const T, Name: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByIndex(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolParameters(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).ExpandSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Expand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputSymbols(@as(*const IDebugSymbolGroup2, @ptrCast(self)), OutputControl, Flags, Start, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).WriteSymbol(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputAsType(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_AddSymbolWide(self: *const T, Name: ?[*:0]align(1) const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).AddSymbolWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByNameWide(self: *const T, Name: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).RemoveSymbolByNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_WriteSymbolWide(self: *const T, Index: u32, Value: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).WriteSymbolWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputAsTypeWide(self: *const T, Index: u32, Type: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).OutputAsTypeWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolTypeName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolTypeName(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolTypeNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolTypeNameWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolSize(self: *const T, Index: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolSize(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolOffset(self: *const T, Index: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolOffset(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolRegister(self: *const T, Index: u32, Register: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolRegister(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Register);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolValueText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolValueText(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolValueTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolValueTextWide(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolEntryInformation(self: *const T, Index: u32, Entry: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbolGroup2.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbolGroup2, @ptrCast(self)), Index, Entry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_PARAMETERS = extern struct {
    Base: u64,
    Size: u32,
    TimeDateStamp: u32,
    Checksum: u32,
    Flags: u32,
    SymbolType: u32,
    ImageNameSize: u32,
    ModuleNameSize: u32,
    LoadedImageNameSize: u32,
    SymbolFileNameSize: u32,
    MappedImageNameSize: u32,
    Reserved: [2]u64,
};

const IID_IDebugSymbols_Value = Guid.initString("8c31e98c-983a-48a5-9016-6fe5d667a950");
pub const IID_IDebugSymbols = &IID_IDebugSymbols_Value;
pub const IDebugSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols, @ptrCast(self)), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByModuleName(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols, @ptrCast(self)), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols, @ptrCast(self)), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]align(1) const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols, @ptrCast(self)), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_StartSymbolMatch(self: *const T, Pattern: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_Reload(self: *const T, Module: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSymbolPath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendSymbolPath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetImagePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendImagePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSourcePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendSourcePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]align(1) const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols2_Value = Guid.initString("3a707211-afdd-4495-ad4f-56fecdf8163f");
pub const IID_IDebugSymbols2 = &IID_IDebugSymbols2_Value;
pub const IDebugSymbols2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols2,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols2, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols2, @ptrCast(self)), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByModuleName(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols2, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols2, @ptrCast(self)), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]align(1) const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols2, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols2, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols2, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols2, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols2, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols2, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_StartSymbolMatch(self: *const T, Pattern: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_Reload(self: *const T, Module: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols2, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSymbolPath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendSymbolPath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetImagePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendImagePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSourcePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendSourcePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols2, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols2, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]align(1) const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols2, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols2, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols2, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols2, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols2.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols2, @ptrCast(self)), Options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_AND_ID = extern struct {
    ModuleBase: u64,
    Id: u64,
};

pub const DEBUG_SYMBOL_SOURCE_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    FileNameId: u64,
    EngineInternal: u64,
    Size: u32,
    Flags: u32,
    FileNameSize: u32,
    StartLine: u32,
    EndLine: u32,
    StartColumn: u32,
    EndColumn: u32,
    Reserved: u32,
};

const IID_IDebugSymbols3_Value = Guid.initString("f02fbecc-50ac-4f36-9ad9-c975e8f32ff8");
pub const IID_IDebugSymbols3 = &IID_IDebugSymbols3_Value;
pub const IDebugSymbols3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols3,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols3,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols3, @ptrCast(self)), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols3, @ptrCast(self)), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]align(1) const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols3, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols3, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols3, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols3, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_StartSymbolMatch(self: *const T, Pattern: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_Reload(self: *const T, Module: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols3, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolPath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSymbolPath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetImagePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendImagePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSourcePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSourcePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols3, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]align(1) const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols3, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols3, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols3, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]align(1) const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols3, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols3, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols3, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols3, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReloadWide(self: *const T, Module: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolPathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetImagePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendImagePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSourcePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSourcePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols3, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols3, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]align(1) const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols3, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols3, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName2(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols3, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u8, ModuleName: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols3, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u16, ModuleName: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols3, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols3, @ptrCast(self)), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols3, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols3, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols3, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols3, @ptrCast(self)), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols3, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols3, @ptrCast(self)), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols3, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols3, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols3, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols3.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols3, @ptrCast(self)), FromEntry, Flags, ToEntry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols4_Value = Guid.initString("e391bbd8-9d8c-4418-840b-c006592a1752");
pub const IID_IDebugSymbols4 = &IID_IDebugSymbols4_Value;
pub const IDebugSymbols4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols4,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols4, @ptrCast(self)), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols4, @ptrCast(self)), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]align(1) const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols4, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols4, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_StartSymbolMatch(self: *const T, Pattern: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_Reload(self: *const T, Module: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols4, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolPath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSymbolPath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetImagePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendImagePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSourcePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSourcePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols4, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]align(1) const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols4, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols4, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols4, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]align(1) const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols4, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols4, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols4, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols4, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReloadWide(self: *const T, Module: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolPathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetImagePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendImagePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSourcePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSourcePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols4, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols4, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]align(1) const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols4, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols4, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName2(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols4, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u8, ModuleName: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols4, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u16, ModuleName: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols4, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols4, @ptrCast(self)), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols4, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols4, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols4, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols4, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols4, @ptrCast(self)), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols4, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols4, @ptrCast(self)), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols4, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols4, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols4, @ptrCast(self)), FromEntry, Flags, ToEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetScopeEx(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).SetScopeEx(@as(*const IDebugSymbols4, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetNameByInlineContextWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).GetLineByInlineContextWide(@as(*const IDebugSymbols4, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols4.VTable, @ptrCast(self.vtable)).OutputSymbolByInlineContext(@as(*const IDebugSymbols4, @ptrCast(self)), OutputControl, Flags, Offset, InlineContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols5_Value = Guid.initString("c65fa83e-1e69-475e-8e0e-b5d79e9cc17e");
pub const IID_IDebugSymbols5 = &IID_IDebugSymbols5_Value;
pub const IDebugSymbols5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Loaded: ?*u32,
                Unloaded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                ImageNameBuffer: ?[*:0]u8,
                ImageNameBufferSize: u32,
                ImageNameSize: ?*u32,
                ModuleNameBuffer: ?[*:0]u8,
                ModuleNameBufferSize: u32,
                ModuleNameSize: ?*u32,
                LoadedImageNameBuffer: ?[*:0]u8,
                LoadedImageNameBufferSize: u32,
                LoadedImageNameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Count: u32,
                Bases: ?[*]u64,
                Start: u32,
                Params: [*]DEBUG_MODULE_PARAMETERS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Size: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u8,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetTypeId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataVirtual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesRead: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BytesWritten: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputTypedDataPhysical: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Offset: u64,
                Module: u64,
                TypeId: u32,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetScope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup,
                Symbols: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]align(1) const u8,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndSymbolMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Handle: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reload: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePath: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                File: ?[*:0]align(1) const u8,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u8,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTypeOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Options: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNearNameByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Delta: i32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffsetByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                Name: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Field: ?[*:0]align(1) const u16,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolTypeIdWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                TypeId: ?*u32,
                Module: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Update: ?*IDebugSymbolGroup2,
                Symbols: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSymbolGroup2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Group: ?*?*IDebugSymbolGroup2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Pattern: ?[*:0]align(1) const u16,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNextSymbolMatchWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Handle: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                MatchSize: ?*u32,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReloadWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSymbolPathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendImagePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                PathSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePathElementWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ElementSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Path: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AppendSourcePathWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Addition: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSourceFileWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                StartElement: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                FoundElement: ?*u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                FoundSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceFileLineOffsetsWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                File: ?[*:0]align(1) const u16,
                Buffer: ?[*]u64,
                BufferLines: u32,
                FileLines: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleVersionInformationWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
                Item: ?[*:0]align(1) const u16,
                // TODO: what to do with BytesParamIndex 4?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                VerInfoSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleNameStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Which: u32,
                Index: u32,
                Base: u64,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConstantNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                Value: u64,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                TypeId: u32,
                FieldIndex: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsManagedModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u8,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByModuleName2Wide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Name: ?[*:0]align(1) const u16,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleByOffset2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                StartIndex: u32,
                Flags: u32,
                Index: ?*u32,
                Base: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u8,
                ModuleName: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticModuleWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Base: u64,
                Size: u32,
                ImagePath: ?[*:0]align(1) const u16,
                ModuleName: ?[*:0]align(1) const u16,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Base: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromJitDebugInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                InfoOffset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFromStoredEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionEntryByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                // TODO: what to do with BytesParamIndex 3?
                Buffer: ?*anyopaque,
                BufferSize: u32,
                BufferNeeded: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u8,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFieldTypeAndOffsetWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Module: u64,
                ContainerTypeId: u32,
                Field: ?[*:0]align(1) const u16,
                FieldTypeId: ?*u32,
                Offset: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u8,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSyntheticSymbolWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Size: u32,
                Name: ?[*:0]align(1) const u16,
                Flags: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveSyntheticSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                Displacements: ?[*]u64,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u8,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntriesByNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Symbol: ?[*:0]align(1) const u16,
                Flags: u32,
                Ids: ?[*]DEBUG_MODULE_AND_ID,
                IdsCount: u32,
                Entries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryByToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                ModuleBase: u64,
                Token: u32,
                Id: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Info: ?*DEBUG_SYMBOL_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Id: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolEntryBySymbolEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                FromId: ?*DEBUG_MODULE_AND_ID,
                Flags: u32,
                ToId: ?*DEBUG_MODULE_AND_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u8,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntriesByLineWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Line: u32,
                File: ?[*:0]align(1) const u16,
                Flags: u32,
                Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
                EntriesCount: u32,
                EntriesAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryStringWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Which: u32,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                StringSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryOffsetRegions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                Regions: ?[*]DEBUG_OFFSET_REGION,
                RegionsCount: u32,
                RegionsAvail: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEntryBySourceEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
                Flags: u32,
                ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                InstructionOffset: ?*u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                InstructionOffset: u64,
                ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
                // TODO: what to do with BytesParamIndex 3?
                ScopeContext: ?*anyopaque,
                ScopeContextSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u8,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNameByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                NameBuffer: ?[*:0]u16,
                NameBufferSize: u32,
                NameSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u8,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLineByInlineContextWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Offset: u64,
                InlineContext: u32,
                Line: ?*u32,
                FileBuffer: ?[*:0]u16,
                FileBufferSize: u32,
                FileSize: ?*u32,
                Displacement: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OutputSymbolByInlineContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                OutputControl: u32,
                Flags: u32,
                Offset: u64,
                InlineContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentScopeFrameIndexEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScopeFrameByIndexEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSymbols5,
                Flags: u32,
                Index: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByName(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNearNameByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByLine(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNumberModules(@as(*const IDebugSymbols5, @ptrCast(self)), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNames(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleParameters(@as(*const IDebugSymbols5, @ptrCast(self)), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolModule(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]align(1) const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeSize(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetTypeId(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReadTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).WriteTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputTypedDataVirtual(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReadTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*anyopaque, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).WriteTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputTypedDataPhysical(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScope(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScope(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ResetScope(@as(*const IDebugSymbols5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).CreateSymbolGroup(@as(*const IDebugSymbols5, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_StartSymbolMatch(self: *const T, Pattern: ?[*:0]align(1) const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).StartSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNextSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).EndSymbolMatch(@as(*const IDebugSymbols5, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_Reload(self: *const T, Module: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).Reload(@as(*const IDebugSymbols5, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolPath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSymbolPath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSymbolPath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetImagePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendImagePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendImagePath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathElement(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSourcePath(self: *const T, Path: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSourcePath(self: *const T, Addition: ?[*:0]align(1) const u8) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSourcePath(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).FindSourceFile(@as(*const IDebugSymbols5, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]align(1) const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsets(@as(*const IDebugSymbols5, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u8, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleVersionInformation(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNameString(@as(*const IDebugSymbols5, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetConstantName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldName(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetTypeOptions(@as(*const IDebugSymbols5, @ptrCast(self)), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNearNameByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetOffsetByLineWide(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolModuleWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]align(1) const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetTypeIdWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]align(1) const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolTypeIdWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeSymbolGroup2(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).CreateSymbolGroup2(@as(*const IDebugSymbols5, @ptrCast(self)), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]align(1) const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).StartSymbolMatchWide(@as(*const IDebugSymbols5, @ptrCast(self)), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNextSymbolMatchWide(@as(*const IDebugSymbols5, @ptrCast(self)), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReloadWide(self: *const T, Module: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).ReloadWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolPathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSymbolPathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetImagePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendImagePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendImagePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourcePathElementWide(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSourcePathWide(self: *const T, Path: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSourcePathWide(self: *const T, Addition: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AppendSourcePathWide(@as(*const IDebugSymbols5, @ptrCast(self)), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]align(1) const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).FindSourceFileWide(@as(*const IDebugSymbols5, @ptrCast(self)), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]align(1) const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceFileLineOffsetsWide(@as(*const IDebugSymbols5, @ptrCast(self)), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]align(1) const u16, Buffer: ?*anyopaque, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleVersionInformationWide(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleNameStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetConstantNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).IsManagedModule(@as(*const IDebugSymbols5, @ptrCast(self)), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName2(self: *const T, Name: ?[*:0]align(1) const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]align(1) const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByModuleName2Wide(@as(*const IDebugSymbols5, @ptrCast(self)), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetModuleByOffset2(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u8, ModuleName: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticModule(@as(*const IDebugSymbols5, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]align(1) const u16, ModuleName: ?[*:0]align(1) const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticModuleWide(@as(*const IDebugSymbols5, @ptrCast(self)), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSyntheticModule(@as(*const IDebugSymbols5, @ptrCast(self)), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndex(@as(*const IDebugSymbols5, @ptrCast(self)), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFromJitDebugInfo(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFromStoredEvent(@as(*const IDebugSymbols5, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputSymbolByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*anyopaque, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFunctionEntryByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]align(1) const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetFieldTypeAndOffsetWide(@as(*const IDebugSymbols5, @ptrCast(self)), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticSymbol(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]align(1) const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).AddSyntheticSymbolWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).RemoveSyntheticSymbol(@as(*const IDebugSymbols5, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]align(1) const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByName(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]align(1) const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntriesByNameWide(@as(*const IDebugSymbols5, @ptrCast(self)), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryByToken(@as(*const IDebugSymbols5, @ptrCast(self)), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryInformation(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryString(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryOffsetRegions(@as(*const IDebugSymbols5, @ptrCast(self)), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSymbolEntryBySymbolEntry(@as(*const IDebugSymbols5, @ptrCast(self)), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByOffset(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]align(1) const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLine(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]align(1) const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntriesByLineWide(@as(*const IDebugSymbols5, @ptrCast(self)), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryString(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryStringWide(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryOffsetRegions(@as(*const IDebugSymbols5, @ptrCast(self)), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetSourceEntryBySourceEntry(@as(*const IDebugSymbols5, @ptrCast(self)), FromEntry, Flags, ToEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetScopeEx(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*anyopaque, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeEx(@as(*const IDebugSymbols5, @ptrCast(self)), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetNameByInlineContextWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetLineByInlineContextWide(@as(*const IDebugSymbols5, @ptrCast(self)), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).OutputSymbolByInlineContext(@as(*const IDebugSymbols5, @ptrCast(self)), OutputControl, Flags, Offset, InlineContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetCurrentScopeFrameIndexEx(self: *const T, Flags: u32, Index: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).GetCurrentScopeFrameIndexEx(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFrameByIndexEx(self: *const T, Flags: u32, Index: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSymbols5.VTable, @ptrCast(self.vtable)).SetScopeFrameByIndexEx(@as(*const IDebugSymbols5, @ptrCast(self)), Flags, Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects_Value = Guid.initString("6b86fe2c-2c4f-4f0c-9da2-174311acc327");
pub const IID_IDebugSystemObjects = &IID_IDebugSystemObjects_Value;
pub const IDebugSystemObjects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects, @ptrCast(self)), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects, @ptrCast(self)), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects, @ptrCast(self)), Buffer, BufferSize, ExeSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects2_Value = Guid.initString("0ae9f5ff-1852-4679-b055-494bee6407ee");
pub const IID_IDebugSystemObjects2 = &IID_IDebugSystemObjects2_Value;
pub const IDebugSystemObjects2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects2,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects2, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects2, @ptrCast(self)), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects2, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects2, @ptrCast(self)), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects2, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects2, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects2, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects2, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects2, @ptrCast(self)), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects2, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects2.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects2, @ptrCast(self)), Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects3_Value = Guid.initString("e9676e2f-e286-4ea3-b0f9-dfe5d9fc330e");
pub const IID_IDebugSystemObjects3 = &IID_IDebugSystemObjects3_Value;
pub const IDebugSystemObjects3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSystems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreadsAndProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemByServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects3,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects3, @ptrCast(self)), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects3, @ptrCast(self)), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects3, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects3, @ptrCast(self)), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects3, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects3, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventSystem(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetEventSystem(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentSystemId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).SetCurrentSystemId(@as(*const IDebugSystemObjects3, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberSystems(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetNumberSystems(@as(*const IDebugSystemObjects3, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetSystemIdsByIndex(@as(*const IDebugSystemObjects3, @ptrCast(self)), Start, Count, Ids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetTotalNumberThreadsAndProcesses(@as(*const IDebugSystemObjects3, @ptrCast(self)), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemServer(self: *const T, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemServer(@as(*const IDebugSystemObjects3, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetSystemByServer(@as(*const IDebugSystemObjects3, @ptrCast(self)), Server, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects3.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerName(@as(*const IDebugSystemObjects3, @ptrCast(self)), Buffer, BufferSize, NameSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects4_Value = Guid.initString("489468e6-7d0f-4af5-87ab-25207454d553");
pub const IID_IDebugSystemObjects4 = &IID_IDebugSystemObjects4_Value;
pub const IDebugSystemObjects4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentThreadId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentProcessId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Total: ?*u32,
                LargestProcess: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByProcessor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Processor: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByTeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentThreadHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: ?[*]u32,
                SysIds: ?[*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByPeb: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                SysId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdBySystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                SysId: u32,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Handle: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcessIdByHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Handle: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessUpTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                UpTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitThreadDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetImplicitProcessDataOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Offset: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventSystem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentSystemId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Id: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberSystems: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Number: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemIdsByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Start: u32,
                Count: u32,
                Ids: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalNumberThreadsAndProcesses: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                TotalThreads: ?*u32,
                TotalProcesses: ?*u32,
                LargestProcessThreads: ?*u32,
                LargestSystemThreads: ?*u32,
                LargestSystemProcesses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Server: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSystemByServer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Server: u64,
                Id: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u8,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProcessExecutableNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                ExeSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSystemServerNameWide: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugSystemObjects4,
                Buffer: ?[*:0]u16,
                BufferSize: u32,
                NameSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventThread(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventProcess(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentThreadId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentProcessId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberThreads(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetTotalNumberThreads(@as(*const IDebugSystemObjects4, @ptrCast(self)), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByProcessor(@as(*const IDebugSystemObjects4, @ptrCast(self)), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadTeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByTeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdBySystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentThreadHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetThreadIdByHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberProcesses(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessPeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByPeb(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdBySystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetProcessIdByHandle(@as(*const IDebugSystemObjects4, @ptrCast(self)), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableName(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessUpTime(@as(*const IDebugSystemObjects4, @ptrCast(self)), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetImplicitThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetImplicitThreadDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetImplicitProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetImplicitProcessDataOffset(@as(*const IDebugSystemObjects4, @ptrCast(self)), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventSystem(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetEventSystem(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentSystemId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).SetCurrentSystemId(@as(*const IDebugSystemObjects4, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberSystems(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetNumberSystems(@as(*const IDebugSystemObjects4, @ptrCast(self)), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetSystemIdsByIndex(@as(*const IDebugSystemObjects4, @ptrCast(self)), Start, Count, Ids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetTotalNumberThreadsAndProcesses(@as(*const IDebugSystemObjects4, @ptrCast(self)), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServer(self: *const T, Server: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServer(@as(*const IDebugSystemObjects4, @ptrCast(self)), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetSystemByServer(@as(*const IDebugSystemObjects4, @ptrCast(self)), Server, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerName(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessExecutableNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentProcessExecutableNameWide(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServerNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugSystemObjects4.VTable, @ptrCast(self.vtable)).GetCurrentSystemServerNameWide(@as(*const IDebugSystemObjects4, @ptrCast(self)), Buffer, BufferSize, NameSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PDEBUG_EXTENSION_INITIALIZE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Version: ?*u32,
        Flags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Version: ?*u32,
        Flags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_UNINITIALIZE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PDEBUG_EXTENSION_CANUNLOAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_UNLOAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PDEBUG_EXTENSION_NOTIFY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Notify: u32,
        Argument: u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        Notify: u32,
        Argument: u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PDEBUG_EXTENSION_CALL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Args: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Args: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_KNOWN_STRUCT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Flags: u32,
        Offset: u64,
        TypeName: ?PSTR,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Flags: u32,
        Offset: u64,
        TypeName: ?PSTR,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_KNOWN_STRUCT_EX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Offset: u64,
        TypeName: ?[*:0]align(1) const u8,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Offset: u64,
        TypeName: ?[*:0]align(1) const u8,
        Buffer: ?[*:0]u8,
        BufferChars: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_QUERY_VALUE_NAMES = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Buffer: [*:0]u16,
        BufferChars: u32,
        BufferNeeded: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Buffer: [*:0]u16,
        BufferChars: u32,
        BufferNeeded: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_EXTENSION_PROVIDE_VALUE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Name: ?[*:0]align(1) const u16,
        Value: ?*u64,
        TypeModBase: ?*u64,
        TypeId: ?*u32,
        TypeFlags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Name: ?[*:0]align(1) const u16,
        Value: ?*u64,
        TypeModBase: ?*u64,
        TypeId: ?*u32,
        TypeFlags: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        StreamType: u32,
        MiniDumpStreamBuffer: [*]u8,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        StreamType: u32,
        MiniDumpStreamBuffer: [*]u8,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SystemThreadId: u32,
        NativeFrames: [*]DEBUG_STACK_FRAME_EX,
        CountNativeFrames: u32,
        StackSymFrames: ?*?*STACK_SYM_FRAME_INFO,
        StackSymFramesFilled: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        SystemThreadId: u32,
        NativeFrames: [*]DEBUG_STACK_FRAME_EX,
        CountNativeFrames: u32,
        StackSymFrames: ?*?*STACK_SYM_FRAME_INFO,
        StackSymFramesFilled: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        StackSymFrames: ?*STACK_SYM_FRAME_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        StackSymFrames: ?*STACK_SYM_FRAME_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DebugBaseEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacks.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugEventCallbacks.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DebugBaseEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacksWide.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugEventCallbacksWide.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Location = extern struct {
    HostDefined: u64,
    Offset: u64,
};

pub const ModelObjectKind = enum(i32) {
    PropertyAccessor = 0,
    Context = 1,
    TargetObject = 2,
    TargetObjectReference = 3,
    Synthetic = 4,
    NoValue = 5,
    Error = 6,
    Intrinsic = 7,
    Method = 8,
    KeyReference = 9,
};
pub const ObjectPropertyAccessor = ModelObjectKind.PropertyAccessor;
pub const ObjectContext = ModelObjectKind.Context;
pub const ObjectTargetObject = ModelObjectKind.TargetObject;
pub const ObjectTargetObjectReference = ModelObjectKind.TargetObjectReference;
pub const ObjectSynthetic = ModelObjectKind.Synthetic;
pub const ObjectNoValue = ModelObjectKind.NoValue;
pub const ObjectError = ModelObjectKind.Error;
pub const ObjectIntrinsic = ModelObjectKind.Intrinsic;
pub const ObjectMethod = ModelObjectKind.Method;
pub const ObjectKeyReference = ModelObjectKind.KeyReference;

pub const SymbolKind = enum(i32) {
    l = 0,
    Module = 1,
    Type = 2,
    Field = 3,
    Constant = 4,
    Data = 5,
    BaseClass = 6,
    Public = 7,
    Function = 8,
};
pub const Symbol = SymbolKind.l;
pub const SymbolModule = SymbolKind.Module;
pub const SymbolType = SymbolKind.Type;
pub const SymbolField = SymbolKind.Field;
pub const SymbolConstant = SymbolKind.Constant;
pub const SymbolData = SymbolKind.Data;
pub const SymbolBaseClass = SymbolKind.BaseClass;
pub const SymbolPublic = SymbolKind.Public;
pub const SymbolFunction = SymbolKind.Function;

pub const TypeKind = enum(i32) {
    UDT = 0,
    Pointer = 1,
    MemberPointer = 2,
    Array = 3,
    Function = 4,
    Typedef = 5,
    Enum = 6,
    Intrinsic = 7,
    ExtendedArray = 8,
};
pub const TypeUDT = TypeKind.UDT;
pub const TypePointer = TypeKind.Pointer;
pub const TypeMemberPointer = TypeKind.MemberPointer;
pub const TypeArray = TypeKind.Array;
pub const TypeFunction = TypeKind.Function;
pub const TypeTypedef = TypeKind.Typedef;
pub const TypeEnum = TypeKind.Enum;
pub const TypeIntrinsic = TypeKind.Intrinsic;
pub const TypeExtendedArray = TypeKind.ExtendedArray;

pub const IntrinsicKind = enum(i32) {
    Void = 0,
    Bool = 1,
    Char = 2,
    WChar = 3,
    Int = 4,
    UInt = 5,
    Long = 6,
    ULong = 7,
    Float = 8,
    HRESULT = 9,
    Char16 = 10,
    Char32 = 11,
};
pub const IntrinsicVoid = IntrinsicKind.Void;
pub const IntrinsicBool = IntrinsicKind.Bool;
pub const IntrinsicChar = IntrinsicKind.Char;
pub const IntrinsicWChar = IntrinsicKind.WChar;
pub const IntrinsicInt = IntrinsicKind.Int;
pub const IntrinsicUInt = IntrinsicKind.UInt;
pub const IntrinsicLong = IntrinsicKind.Long;
pub const IntrinsicULong = IntrinsicKind.ULong;
pub const IntrinsicFloat = IntrinsicKind.Float;
pub const IntrinsicHRESULT = IntrinsicKind.HRESULT;
pub const IntrinsicChar16 = IntrinsicKind.Char16;
pub const IntrinsicChar32 = IntrinsicKind.Char32;

pub const PointerKind = enum(i32) {
    Standard = 0,
    Reference = 1,
    RValueReference = 2,
    CXHat = 3,
    ManagedReference = 4,
};
pub const PointerStandard = PointerKind.Standard;
pub const PointerReference = PointerKind.Reference;
pub const PointerRValueReference = PointerKind.RValueReference;
pub const PointerCXHat = PointerKind.CXHat;
pub const PointerManagedReference = PointerKind.ManagedReference;

pub const CallingConventionKind = enum(i32) {
    Unknown = 0,
    CDecl = 1,
    FastCall = 2,
    StdCall = 3,
    SysCall = 4,
    ThisCall = 5,
};
pub const CallingConventionUnknown = CallingConventionKind.Unknown;
pub const CallingConventionCDecl = CallingConventionKind.CDecl;
pub const CallingConventionFastCall = CallingConventionKind.FastCall;
pub const CallingConventionStdCall = CallingConventionKind.StdCall;
pub const CallingConventionSysCall = CallingConventionKind.SysCall;
pub const CallingConventionThisCall = CallingConventionKind.ThisCall;

pub const LocationKind = enum(i32) {
    Member = 0,
    Static = 1,
    Constant = 2,
    None = 3,
};
pub const LocationMember = LocationKind.Member;
pub const LocationStatic = LocationKind.Static;
pub const LocationConstant = LocationKind.Constant;
pub const LocationNone = LocationKind.None;

pub const PreferredFormat = enum(i32) {
    None = 0,
    SingleCharacter = 1,
    QuotedString = 2,
    String = 3,
    QuotedUnicodeString = 4,
    UnicodeString = 5,
    QuotedUTF8String = 6,
    UTF8String = 7,
    BSTRString = 8,
    QuotedHString = 9,
    HString = 10,
    Raw = 11,
    EnumNameOnly = 12,
    EscapedStringWithQuote = 13,
    UTF32String = 14,
    QuotedUTF32String = 15,
};
pub const FormatNone = PreferredFormat.None;
pub const FormatSingleCharacter = PreferredFormat.SingleCharacter;
pub const FormatQuotedString = PreferredFormat.QuotedString;
pub const FormatString = PreferredFormat.String;
pub const FormatQuotedUnicodeString = PreferredFormat.QuotedUnicodeString;
pub const FormatUnicodeString = PreferredFormat.UnicodeString;
pub const FormatQuotedUTF8String = PreferredFormat.QuotedUTF8String;
pub const FormatUTF8String = PreferredFormat.UTF8String;
pub const FormatBSTRString = PreferredFormat.BSTRString;
pub const FormatQuotedHString = PreferredFormat.QuotedHString;
pub const FormatHString = PreferredFormat.HString;
pub const FormatRaw = PreferredFormat.Raw;
pub const FormatEnumNameOnly = PreferredFormat.EnumNameOnly;
pub const FormatEscapedStringWithQuote = PreferredFormat.EscapedStringWithQuote;
pub const FormatUTF32String = PreferredFormat.UTF32String;
pub const FormatQuotedUTF32String = PreferredFormat.QuotedUTF32String;

const IID_IHostDataModelAccess_Value = Guid.initString("f2bce54e-4835-4f8a-836e-7981e29904d1");
pub const IID_IHostDataModelAccess = &IID_IHostDataModelAccess_Value;
pub const IHostDataModelAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostDataModelAccess,
                manager: ?*?*IDataModelManager,
                host: ?*?*IDebugHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostDataModelAccess,
                manager: ?*?*IDataModelManager,
                host: ?*?*IDebugHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostDataModelAccess_GetDataModel(self: *const T, manager: ?*?*IDataModelManager, host: ?*?*IDebugHost) callconv(.Inline) HRESULT {
            return @as(*const IHostDataModelAccess.VTable, @ptrCast(self.vtable)).GetDataModel(@as(*const IHostDataModelAccess, @ptrCast(self)), manager, host);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyStore_Value = Guid.initString("0fc7557d-401d-4fca-9365-da1e9850697c");
pub const IID_IKeyStore = &IID_IKeyStore_Value;
pub const IKeyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyStore,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_GetKey(self: *const T, key: ?[*:0]align(1) const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_SetKey(self: *const T, key: ?[*:0]align(1) const u16, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_GetKeyValue(self: *const T, key: ?[*:0]align(1) const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IKeyStore, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_SetKeyValue(self: *const T, key: ?[*:0]align(1) const u16, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IKeyStore, @ptrCast(self)), key, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_ClearKeys(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IKeyStore.VTable, @ptrCast(self.vtable)).ClearKeys(@as(*const IKeyStore, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RawSearchFlags = enum(i32) {
    ne = 0,
    Bases = 1,
};
pub const RawSearchNone = RawSearchFlags.ne;
pub const RawSearchNoBases = RawSearchFlags.Bases;

const IID_IModelObject_Value = Guid.initString("e28c7893-3f4b-4b96-baca-293cdc55f45d");
pub const IID_IModelObject = &IID_IModelObject_Value;
pub const IModelObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                kind: ?*ModelObjectKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                kind: ?*ModelObjectKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicValueAs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                vt: VARENUM,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                vt: VARENUM,
                intrinsicData: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeyValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateRawValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Dereference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TryCastToRuntimeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                runtimeTypedObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                runtimeTypedObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTargetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                location: ?*Location,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                location: ?*Location,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfParentModels: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                numModels: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                numModels: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                i: u64,
                model: ?*?*IModelObject,
                contextObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                i: u64,
                model: ?*?*IModelObject,
                contextObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                model: ?*IModelObject,
                contextObject: ?*IModelObject,
                override: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                model: ?*IModelObject,
                contextObject: ?*IModelObject,
                override: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveParentModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                model: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                model: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                objectReference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                objectReference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                key: ?[*:0]align(1) const u16,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeyReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ClearConcepts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRawReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                searchFlags: u32,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateRawReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                kind: SymbolKind,
                searchFlags: u32,
                enumerator: ?*?*IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetContextForDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextForDataModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                dataModelObject: ?*IModelObject,
                context: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Compare: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                other: ?*IModelObject,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                other: ?*IModelObject,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEqualTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelObject,
                other: ?*IModelObject,
                equal: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelObject,
                other: ?*IModelObject,
                equal: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IModelObject, @ptrCast(self)), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKind(self: *const T, kind: ?*ModelObjectKind) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKind(@as(*const IModelObject, @ptrCast(self)), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetIntrinsicValue(self: *const T, intrinsicData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetIntrinsicValue(@as(*const IModelObject, @ptrCast(self)), intrinsicData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetIntrinsicValueAs(self: *const T, vt: VARENUM, intrinsicData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetIntrinsicValueAs(@as(*const IModelObject, @ptrCast(self)), vt, intrinsicData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKeyValue(self: *const T, key: ?[*:0]align(1) const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetKeyValue(self: *const T, key: ?[*:0]align(1) const u16, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IModelObject, @ptrCast(self)), key, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeyValues(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeyValues(@as(*const IModelObject, @ptrCast(self)), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetRawValue(self: *const T, kind: SymbolKind, name: ?[*:0]align(1) const u16, searchFlags: u32, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetRawValue(@as(*const IModelObject, @ptrCast(self)), kind, name, searchFlags, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateRawValues(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateRawValues(@as(*const IModelObject, @ptrCast(self)), kind, searchFlags, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_Dereference(self: *const T, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).Dereference(@as(*const IModelObject, @ptrCast(self)), object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_TryCastToRuntimeType(self: *const T, runtimeTypedObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).TryCastToRuntimeType(@as(*const IModelObject, @ptrCast(self)), runtimeTypedObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetConcept(@as(*const IModelObject, @ptrCast(self)), conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IModelObject, @ptrCast(self)), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetTypeInfo(self: *const T, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetTypeInfo(@as(*const IModelObject, @ptrCast(self)), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetTargetInfo(self: *const T, location: ?*Location, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetTargetInfo(@as(*const IModelObject, @ptrCast(self)), location, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetNumberOfParentModels(self: *const T, numModels: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetNumberOfParentModels(@as(*const IModelObject, @ptrCast(self)), numModels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetParentModel(self: *const T, i: u64, model: ?*?*IModelObject, contextObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetParentModel(@as(*const IModelObject, @ptrCast(self)), i, model, contextObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_AddParentModel(self: *const T, model: ?*IModelObject, contextObject: ?*IModelObject, override: u8) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).AddParentModel(@as(*const IModelObject, @ptrCast(self)), model, contextObject, override);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_RemoveParentModel(self: *const T, model: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).RemoveParentModel(@as(*const IModelObject, @ptrCast(self)), model);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKey(self: *const T, key: ?[*:0]align(1) const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKeyReference(self: *const T, key: ?[*:0]align(1) const u16, objectReference: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetKeyReference(@as(*const IModelObject, @ptrCast(self)), key, objectReference, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetKey(self: *const T, key: ?[*:0]align(1) const u16, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IModelObject, @ptrCast(self)), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_ClearKeys(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).ClearKeys(@as(*const IModelObject, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeys(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeys(@as(*const IModelObject, @ptrCast(self)), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeyReferences(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateKeyReferences(@as(*const IModelObject, @ptrCast(self)), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetConcept(@as(*const IModelObject, @ptrCast(self)), conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_ClearConcepts(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).ClearConcepts(@as(*const IModelObject, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetRawReference(self: *const T, kind: SymbolKind, name: ?[*:0]align(1) const u16, searchFlags: u32, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetRawReference(@as(*const IModelObject, @ptrCast(self)), kind, name, searchFlags, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateRawReferences(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).EnumerateRawReferences(@as(*const IModelObject, @ptrCast(self)), kind, searchFlags, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).SetContextForDataModel(@as(*const IModelObject, @ptrCast(self)), dataModelObject, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).GetContextForDataModel(@as(*const IModelObject, @ptrCast(self)), dataModelObject, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_Compare(self: *const T, other: ?*IModelObject, ppResult: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).Compare(@as(*const IModelObject, @ptrCast(self)), other, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_IsEqualTo(self: *const T, other: ?*IModelObject, equal: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IModelObject.VTable, @ptrCast(self.vtable)).IsEqualTo(@as(*const IModelObject, @ptrCast(self)), other, equal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager_Value = Guid.initString("73fe19f4-a110-4500-8ed9-3c28896f508c");
pub const IID_IDataModelManager = &IID_IDataModelManager_Value;
pub const IDataModelManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateNoValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateErrorObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                hrError: HRESULT,
                pwszMessage: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                hrError: HRESULT,
                pwszMessage: ?[*:0]align(1) const u16,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedObjectReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                objectLocation: Location,
                objectType: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSyntheticObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                context: ?*IDebugHostContext,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDataModelObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                dataModel: ?*IDataModelConcept,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                dataModel: ?*IDataModelConcept,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateIntrinsicObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                objectKind: ModelObjectKind,
                intrinsicData: ?*VARIANT,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                objectKind: ModelObjectKind,
                intrinsicData: ?*VARIANT,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedIntrinsicObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModelForType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                type: ?*IDebugHostType,
                dataModel: ?*?*IModelObject,
                typeSignature: ?*?*IDebugHostTypeSignature,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                type: ?*IDebugHostType,
                dataModel: ?*?*IModelObject,
                typeSignature: ?*?*IDebugHostTypeSignature,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterModelForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterExtensionForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                typeSignature: ?*IDebugHostTypeSignature,
                dataModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterExtensionForTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                dataModel: ?*IModelObject,
                typeSignature: ?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMetadataStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                parentStore: ?*IKeyStore,
                metadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                parentStore: ?*IKeyStore,
                metadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRootNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                rootNamespace: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                rootNamespace: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
                modeObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
                modeObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquireNamedModel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
                modelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager,
                modelName: ?[*:0]align(1) const u16,
                modelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_Close(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).Close(@as(*const IDataModelManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateNoValue(self: *const T, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateNoValue(@as(*const IDataModelManager, @ptrCast(self)), object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateErrorObject(self: *const T, hrError: HRESULT, pwszMessage: ?[*:0]align(1) const u16, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateErrorObject(@as(*const IDataModelManager, @ptrCast(self)), hrError, pwszMessage, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedObject(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedObject(@as(*const IDataModelManager, @ptrCast(self)), context, objectLocation, objectType, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedObjectReference(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedObjectReference(@as(*const IDataModelManager, @ptrCast(self)), context, objectLocation, objectType, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateSyntheticObject(self: *const T, context: ?*IDebugHostContext, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateSyntheticObject(@as(*const IDataModelManager, @ptrCast(self)), context, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateDataModelObject(self: *const T, dataModel: ?*IDataModelConcept, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateDataModelObject(@as(*const IDataModelManager, @ptrCast(self)), dataModel, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateIntrinsicObject(self: *const T, objectKind: ModelObjectKind, intrinsicData: ?*VARIANT, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateIntrinsicObject(@as(*const IDataModelManager, @ptrCast(self)), objectKind, intrinsicData, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedIntrinsicObject(self: *const T, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateTypedIntrinsicObject(@as(*const IDataModelManager, @ptrCast(self)), intrinsicData, type_, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetModelForType(self: *const T, type_: ?*IDebugHostType, dataModel: ?*?*IModelObject, typeSignature: ?*?*IDebugHostTypeSignature, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetModelForType(@as(*const IDataModelManager, @ptrCast(self)), type_, dataModel, typeSignature, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterModelForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterModelForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), dataModel, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterExtensionForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterExtensionForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterExtensionForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterExtensionForTypeSignature(@as(*const IDataModelManager, @ptrCast(self)), dataModel, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateMetadataStore(self: *const T, parentStore: ?*IKeyStore, metadataStore: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).CreateMetadataStore(@as(*const IDataModelManager, @ptrCast(self)), parentStore, metadataStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetRootNamespace(self: *const T, rootNamespace: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).GetRootNamespace(@as(*const IDataModelManager, @ptrCast(self)), rootNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterNamedModel(self: *const T, modelName: ?[*:0]align(1) const u16, modeObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).RegisterNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName, modeObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterNamedModel(self: *const T, modelName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).UnregisterNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_AcquireNamedModel(self: *const T, modelName: ?[*:0]align(1) const u16, modelObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager.VTable, @ptrCast(self.vtable)).AcquireNamedModel(@as(*const IDataModelManager, @ptrCast(self)), modelName, modelObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference_Value = Guid.initString("5253dcf8-5aff-4c62-b302-56a289e00998");
pub const IID_IModelKeyReference = &IID_IModelKeyReference_Value;
pub const IModelKeyReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                keyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                keyName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOriginalObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                originalObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                originalObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                containingObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                containingObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                object: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKeyValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference,
                object: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKeyName(self: *const T, keyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKeyName(@as(*const IModelKeyReference, @ptrCast(self)), keyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetOriginalObject(self: *const T, originalObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetOriginalObject(@as(*const IModelKeyReference, @ptrCast(self)), originalObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetContextObject(self: *const T, containingObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetContextObject(@as(*const IModelKeyReference, @ptrCast(self)), containingObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKey(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKeyValue(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).GetKeyValue(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_SetKey(self: *const T, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IModelKeyReference, @ptrCast(self)), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_SetKeyValue(self: *const T, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference.VTable, @ptrCast(self.vtable)).SetKeyValue(@as(*const IModelKeyReference, @ptrCast(self)), object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelPropertyAccessor_Value = Guid.initString("5a0c63d9-0526-42b8-960c-9516a3254c85");
pub const IID_IModelPropertyAccessor = &IID_IModelPropertyAccessor_Value;
pub const IModelPropertyAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelPropertyAccessor,
                key: ?[*:0]align(1) const u16,
                contextObject: ?*IModelObject,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelPropertyAccessor,
                key: ?[*:0]align(1) const u16,
                contextObject: ?*IModelObject,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelPropertyAccessor,
                key: ?[*:0]align(1) const u16,
                contextObject: ?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelPropertyAccessor,
                key: ?[*:0]align(1) const u16,
                contextObject: ?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelPropertyAccessor_GetValue(self: *const T, key: ?[*:0]align(1) const u16, contextObject: ?*IModelObject, value: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelPropertyAccessor.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IModelPropertyAccessor, @ptrCast(self)), key, contextObject, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelPropertyAccessor_SetValue(self: *const T, key: ?[*:0]align(1) const u16, contextObject: ?*IModelObject, value: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelPropertyAccessor.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IModelPropertyAccessor, @ptrCast(self)), key, contextObject, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelMethod_Value = Guid.initString("80600c1f-b90b-4896-82ad-1c00207909e8");
pub const IID_IModelMethod = &IID_IModelMethod_Value;
pub const IModelMethod = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Call: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelMethod,
                pContextObject: ?*IModelObject,
                argCount: u64,
                ppArguments: [*]?*IModelObject,
                ppResult: ?*?*IModelObject,
                ppMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelMethod,
                pContextObject: ?*IModelObject,
                argCount: u64,
                ppArguments: [*]?*IModelObject,
                ppResult: ?*?*IModelObject,
                ppMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelMethod_Call(self: *const T, pContextObject: ?*IModelObject, argCount: u64, ppArguments: [*]?*IModelObject, ppResult: ?*?*IModelObject, ppMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelMethod.VTable, @ptrCast(self.vtable)).Call(@as(*const IModelMethod, @ptrCast(self)), pContextObject, argCount, ppArguments, ppResult, ppMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyEnumerator_Value = Guid.initString("345fa92e-5e00-4319-9cae-971f7601cdcf");
pub const IID_IKeyEnumerator = &IID_IKeyEnumerator_Value;
pub const IKeyEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IKeyEnumerator,
                key: ?*?BSTR,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IKeyEnumerator,
                key: ?*?BSTR,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IKeyEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IKeyEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyEnumerator_GetNext(self: *const T, key: ?*?BSTR, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IKeyEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IKeyEnumerator, @ptrCast(self)), key, value, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawEnumerator_Value = Guid.initString("e13613f9-3a3c-40b5-8f48-1e5ebfb9b21b");
pub const IID_IRawEnumerator = &IID_IRawEnumerator_Value;
pub const IRawEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRawEnumerator,
                name: ?*?BSTR,
                kind: ?*SymbolKind,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRawEnumerator,
                name: ?*?BSTR,
                kind: ?*SymbolKind,
                value: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IRawEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IRawEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawEnumerator_GetNext(self: *const T, name: ?*?BSTR, kind: ?*SymbolKind, value: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IRawEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IRawEnumerator, @ptrCast(self)), name, kind, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelConcept_Value = Guid.initString("fcb98d1d-1114-4fbf-b24c-effcb5def0d3");
pub const IID_IDataModelConcept = &IID_IDataModelConcept_Value;
pub const IDataModelConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelConcept,
                modelObject: ?*IModelObject,
                matchingTypeSignature: ?*IDebugHostTypeSignature,
                wildcardMatches: ?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelConcept,
                modelObject: ?*IModelObject,
                matchingTypeSignature: ?*IDebugHostTypeSignature,
                wildcardMatches: ?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelConcept,
                modelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelConcept,
                modelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelConcept_InitializeObject(self: *const T, modelObject: ?*IModelObject, matchingTypeSignature: ?*IDebugHostTypeSignature, wildcardMatches: ?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelConcept.VTable, @ptrCast(self.vtable)).InitializeObject(@as(*const IDataModelConcept, @ptrCast(self)), modelObject, matchingTypeSignature, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelConcept_GetName(self: *const T, modelName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelConcept.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelConcept, @ptrCast(self)), modelName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStringDisplayableConcept_Value = Guid.initString("d28e8d70-6c00-4205-940d-501016601ea3");
pub const IID_IStringDisplayableConcept = &IID_IStringDisplayableConcept_Value;
pub const IStringDisplayableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ToDisplayString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStringDisplayableConcept,
                contextObject: ?*IModelObject,
                metadata: ?*IKeyStore,
                displayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStringDisplayableConcept,
                contextObject: ?*IModelObject,
                metadata: ?*IKeyStore,
                displayString: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringDisplayableConcept_ToDisplayString(self: *const T, contextObject: ?*IModelObject, metadata: ?*IKeyStore, displayString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IStringDisplayableConcept.VTable, @ptrCast(self.vtable)).ToDisplayString(@as(*const IStringDisplayableConcept, @ptrCast(self)), contextObject, metadata, displayString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICodeAddressConcept_Value = Guid.initString("c7371568-5c78-4a00-a4ab-6ef8823184cb");
pub const IID_ICodeAddressConcept = &IID_ICodeAddressConcept_Value;
pub const ICodeAddressConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContainingSymbol: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICodeAddressConcept,
                pContextObject: ?*IModelObject,
                ppSymbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICodeAddressConcept,
                pContextObject: ?*IModelObject,
                ppSymbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodeAddressConcept_GetContainingSymbol(self: *const T, pContextObject: ?*IModelObject, ppSymbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @as(*const ICodeAddressConcept.VTable, @ptrCast(self.vtable)).GetContainingSymbol(@as(*const ICodeAddressConcept, @ptrCast(self)), pContextObject, ppSymbol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelIterator_Value = Guid.initString("e4622136-927d-4490-874f-581f3e4e3688");
pub const IID_IModelIterator = &IID_IModelIterator_Value;
pub const IModelIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelIterator,
                object: ?*?*IModelObject,
                dimensions: u64,
                indexers: ?[*]?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelIterator,
                object: ?*?*IModelObject,
                dimensions: u64,
                indexers: ?[*]?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelIterator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IModelIterator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IModelIterator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelIterator_GetNext(self: *const T, object: ?*?*IModelObject, dimensions: u64, indexers: ?[*]?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IModelIterator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IModelIterator, @ptrCast(self)), object, dimensions, indexers, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIterableConcept_Value = Guid.initString("f5d49d0c-0b02-4301-9c9b-b3a6037628f3");
pub const IID_IIterableConcept = &IID_IIterableConcept_Value;
pub const IIterableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultIndexDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIterator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                iterator: ?*?*IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIterableConcept,
                contextObject: ?*IModelObject,
                iterator: ?*?*IModelIterator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIterableConcept_GetDefaultIndexDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IIterableConcept.VTable, @ptrCast(self.vtable)).GetDefaultIndexDimensionality(@as(*const IIterableConcept, @ptrCast(self)), contextObject, dimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIterableConcept_GetIterator(self: *const T, contextObject: ?*IModelObject, iterator: ?*?*IModelIterator) callconv(.Inline) HRESULT {
            return @as(*const IIterableConcept.VTable, @ptrCast(self.vtable)).GetIterator(@as(*const IIterableConcept, @ptrCast(self)), contextObject, iterator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexableConcept_Value = Guid.initString("d1fad99f-3f53-4457-850c-8051df2d3fb5");
pub const IID_IIndexableConcept = &IID_IIndexableConcept_Value;
pub const IIndexableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                dimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                object: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IIndexableConcept,
                contextObject: ?*IModelObject,
                indexerCount: u64,
                indexers: [*]?*IModelObject,
                value: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_GetDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).GetDimensionality(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, dimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_GetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).GetAt(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, indexerCount, indexers, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_SetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, value: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IIndexableConcept.VTable, @ptrCast(self.vtable)).SetAt(@as(*const IIndexableConcept, @ptrCast(self)), contextObject, indexerCount, indexers, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPreferredRuntimeTypeConcept_Value = Guid.initString("9d6c1d7b-a76f-4618-8068-5f76bd9a4e8a");
pub const IID_IPreferredRuntimeTypeConcept = &IID_IPreferredRuntimeTypeConcept_Value;
pub const IPreferredRuntimeTypeConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CastToPreferredRuntimeType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPreferredRuntimeTypeConcept,
                contextObject: ?*IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPreferredRuntimeTypeConcept,
                contextObject: ?*IModelObject,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreferredRuntimeTypeConcept_CastToPreferredRuntimeType(self: *const T, contextObject: ?*IModelObject, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IPreferredRuntimeTypeConcept.VTable, @ptrCast(self.vtable)).CastToPreferredRuntimeType(@as(*const IPreferredRuntimeTypeConcept, @ptrCast(self)), contextObject, object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHost_Value = Guid.initString("b8c74943-6b2c-4eeb-b5c5-35d378a6d99d");
pub const IID_IDebugHost = &IID_IDebugHost_Value;
pub const IDebugHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHostDefinedInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHost,
                hostUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHost,
                hostUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHost,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHost,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMetadata: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHost,
                defaultMetadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHost,
                defaultMetadataStore: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetHostDefinedInterface(self: *const T, hostUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetHostDefinedInterface(@as(*const IDebugHost, @ptrCast(self)), hostUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetCurrentContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetCurrentContext(@as(*const IDebugHost, @ptrCast(self)), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetDefaultMetadata(self: *const T, defaultMetadataStore: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDebugHost.VTable, @ptrCast(self.vtable)).GetDefaultMetadata(@as(*const IDebugHost, @ptrCast(self)), defaultMetadataStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostContext_Value = Guid.initString("a68c70d8-5ec0-46e5-b775-3134a48ea2e3");
pub const IID_IDebugHostContext = &IID_IDebugHostContext_Value;
pub const IDebugHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEqualTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostContext,
                pContext: ?*IDebugHostContext,
                pIsEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostContext,
                pContext: ?*IDebugHostContext,
                pIsEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostContext_IsEqualTo(self: *const T, pContext: ?*IDebugHostContext, pIsEqual: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostContext.VTable, @ptrCast(self.vtable)).IsEqualTo(@as(*const IDebugHostContext, @ptrCast(self)), pContext, pIsEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ErrorClass = enum(i32) {
    Warning = 0,
    Error = 1,
};
pub const ErrorClassWarning = ErrorClass.Warning;
pub const ErrorClassError = ErrorClass.Error;

const IID_IDebugHostErrorSink_Value = Guid.initString("c8ff0f0b-fce9-467e-8bb3-5d69ef109c00");
pub const IID_IDebugHostErrorSink = &IID_IDebugHostErrorSink_Value;
pub const IDebugHostErrorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostErrorSink,
                errClass: ErrorClass,
                hrError: HRESULT,
                message: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostErrorSink,
                errClass: ErrorClass,
                hrError: HRESULT,
                message: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostErrorSink_ReportError(self: *const T, errClass: ErrorClass, hrError: HRESULT, message: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostErrorSink.VTable, @ptrCast(self.vtable)).ReportError(@as(*const IDebugHostErrorSink, @ptrCast(self)), errClass, hrError, message);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbol_Value = Guid.initString("0f819103-87de-4e96-8277-e05cd441fb22");
pub const IID_IDebugHostSymbol = &IID_IDebugHostSymbol_Value;
pub const IDebugHostSymbol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                context: ?*?*IDebugHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateChildren: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                ppEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                kind: SymbolKind,
                name: ?[*:0]align(1) const u16,
                ppEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSymbolKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                kind: ?*SymbolKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                kind: ?*SymbolKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                symbolName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                symbolName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContainingModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                containingModule: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                containingModule: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareAgainst: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol,
                pComparisonSymbol: ?*IDebugHostSymbol,
                comparisonFlags: u32,
                pMatches: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol,
                pComparisonSymbol: ?*IDebugHostSymbol,
                comparisonFlags: u32,
                pMatches: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetContext(@as(*const IDebugHostSymbol, @ptrCast(self)), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_EnumerateChildren(self: *const T, kind: SymbolKind, name: ?[*:0]align(1) const u16, ppEnum: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).EnumerateChildren(@as(*const IDebugHostSymbol, @ptrCast(self)), kind, name, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetSymbolKind(self: *const T, kind: ?*SymbolKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetSymbolKind(@as(*const IDebugHostSymbol, @ptrCast(self)), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetName(self: *const T, symbolName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugHostSymbol, @ptrCast(self)), symbolName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetType(self: *const T, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugHostSymbol, @ptrCast(self)), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetContainingModule(self: *const T, containingModule: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).GetContainingModule(@as(*const IDebugHostSymbol, @ptrCast(self)), containingModule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_CompareAgainst(self: *const T, pComparisonSymbol: ?*IDebugHostSymbol, comparisonFlags: u32, pMatches: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol.VTable, @ptrCast(self.vtable)).CompareAgainst(@as(*const IDebugHostSymbol, @ptrCast(self)), pComparisonSymbol, comparisonFlags, pMatches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbolEnumerator_Value = Guid.initString("28d96c86-10a3-4976-b14e-eaef4790aa1f");
pub const IID_IDebugHostSymbolEnumerator = &IID_IDebugHostSymbolEnumerator_Value;
pub const IDebugHostSymbolEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbolEnumerator,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbolEnumerator,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbolEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbolEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDebugHostSymbolEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbolEnumerator_GetNext(self: *const T, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbolEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDebugHostSymbolEnumerator, @ptrCast(self)), symbol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule_Value = Guid.initString("c9ba3e18-d070-4378-bbd0-34613b346e1e");
pub const IID_IDebugHostModule = &IID_IDebugHostModule_Value;
pub const IDebugHostModule = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetImageName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                allowPath: u8,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                allowPath: u8,
                imageName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                moduleBaseLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                moduleBaseLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                fileVersion: ?*u64,
                productVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                fileVersion: ?*u64,
                productVersion: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindTypeByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                typeName: ?[*:0]align(1) const u16,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                typeName: ?[*:0]align(1) const u16,
                type: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSymbolByRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindSymbolByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule,
                symbolName: ?[*:0]align(1) const u16,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule,
                symbolName: ?[*:0]align(1) const u16,
                symbol: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetImageName(self: *const T, allowPath: u8, imageName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetImageName(@as(*const IDebugHostModule, @ptrCast(self)), allowPath, imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetBaseLocation(self: *const T, moduleBaseLocation: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetBaseLocation(@as(*const IDebugHostModule, @ptrCast(self)), moduleBaseLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetVersion(self: *const T, fileVersion: ?*u64, productVersion: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).GetVersion(@as(*const IDebugHostModule, @ptrCast(self)), fileVersion, productVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindTypeByName(self: *const T, typeName: ?[*:0]align(1) const u16, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindTypeByName(@as(*const IDebugHostModule, @ptrCast(self)), typeName, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindSymbolByRVA(@as(*const IDebugHostModule, @ptrCast(self)), rva, symbol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindSymbolByName(self: *const T, symbolName: ?[*:0]align(1) const u16, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule.VTable, @ptrCast(self.vtable)).FindSymbolByName(@as(*const IDebugHostModule, @ptrCast(self)), symbolName, symbol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ArrayDimension = extern struct {
    LowerBound: i64,
    Length: u64,
    Stride: u64,
};

const IID_IDebugHostType_Value = Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostType = &IID_IDebugHostType_Value;
pub const IDebugHostType = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetTypeKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                kind: ?*TypeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                kind: ?*TypeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                size: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                size: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                baseType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                baseType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIntrinsicType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                intrinsicKind: ?*IntrinsicKind,
                carrierType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                intrinsicKind: ?*IntrinsicKind,
                carrierType: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBitField: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                lsbOfField: ?*u32,
                lengthOfField: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                lsbOfField: ?*u32,
                lengthOfField: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPointerKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                pointerKind: ?*PointerKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                pointerKind: ?*PointerKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemberType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                memberType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                memberType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePointerTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                kind: PointerKind,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                kind: PointerKind,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrayDimensionality: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                arrayDimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                arrayDimensionality: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetArrayDimensions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateArrayOf: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                dimensions: u64,
                pDimensions: [*]ArrayDimension,
                newType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionCallingConvention: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                conventionKind: ?*CallingConventionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                conventionKind: ?*CallingConventionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionReturnType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                returnType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                returnType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionParameterTypeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                count: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                count: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionParameterTypeAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                i: u64,
                parameterType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                i: u64,
                parameterType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsGeneric: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                isGeneric: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                isGeneric: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericArgumentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                argCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                argCount: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGenericArgumentAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType,
                i: u64,
                argument: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType,
                i: u64,
                argument: ?*?*IDebugHostSymbol,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetTypeKind(self: *const T, kind: ?*TypeKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetTypeKind(@as(*const IDebugHostType, @ptrCast(self)), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetSize(self: *const T, size: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IDebugHostType, @ptrCast(self)), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetBaseType(self: *const T, baseType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetBaseType(@as(*const IDebugHostType, @ptrCast(self)), baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetHashCode(self: *const T, hashCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetHashCode(@as(*const IDebugHostType, @ptrCast(self)), hashCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetIntrinsicType(self: *const T, intrinsicKind: ?*IntrinsicKind, carrierType: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetIntrinsicType(@as(*const IDebugHostType, @ptrCast(self)), intrinsicKind, carrierType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetBitField(self: *const T, lsbOfField: ?*u32, lengthOfField: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetBitField(@as(*const IDebugHostType, @ptrCast(self)), lsbOfField, lengthOfField);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetPointerKind(self: *const T, pointerKind: ?*PointerKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetPointerKind(@as(*const IDebugHostType, @ptrCast(self)), pointerKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetMemberType(self: *const T, memberType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetMemberType(@as(*const IDebugHostType, @ptrCast(self)), memberType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_CreatePointerTo(self: *const T, kind: PointerKind, newType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).CreatePointerTo(@as(*const IDebugHostType, @ptrCast(self)), kind, newType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetArrayDimensionality(self: *const T, arrayDimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetArrayDimensionality(@as(*const IDebugHostType, @ptrCast(self)), arrayDimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetArrayDimensions(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetArrayDimensions(@as(*const IDebugHostType, @ptrCast(self)), dimensions, pDimensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_CreateArrayOf(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension, newType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).CreateArrayOf(@as(*const IDebugHostType, @ptrCast(self)), dimensions, pDimensions, newType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionCallingConvention(self: *const T, conventionKind: ?*CallingConventionKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionCallingConvention(@as(*const IDebugHostType, @ptrCast(self)), conventionKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionReturnType(self: *const T, returnType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionReturnType(@as(*const IDebugHostType, @ptrCast(self)), returnType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionParameterTypeCount(self: *const T, count: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionParameterTypeCount(@as(*const IDebugHostType, @ptrCast(self)), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionParameterTypeAt(self: *const T, i: u64, parameterType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetFunctionParameterTypeAt(@as(*const IDebugHostType, @ptrCast(self)), i, parameterType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_IsGeneric(self: *const T, isGeneric: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).IsGeneric(@as(*const IDebugHostType, @ptrCast(self)), isGeneric);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetGenericArgumentCount(self: *const T, argCount: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetGenericArgumentCount(@as(*const IDebugHostType, @ptrCast(self)), argCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetGenericArgumentAt(self: *const T, i: u64, argument: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType.VTable, @ptrCast(self.vtable)).GetGenericArgumentAt(@as(*const IDebugHostType, @ptrCast(self)), i, argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostConstant_Value = Guid.initString("62787edc-fa76-4690-bd71-5e8c3e2937ec");
pub const IID_IDebugHostConstant = &IID_IDebugHostConstant_Value;
pub const IDebugHostConstant = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostConstant,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostConstant,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostConstant_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostConstant.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostConstant, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostField_Value = Guid.initString("e06f6495-16bc-4cc9-b11d-2a6b23fa72f3");
pub const IID_IDebugHostField = &IID_IDebugHostField_Value;
pub const IDebugHostField = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostField,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostField,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostField,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostField,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostField,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostField,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostField,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostField,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostField, @ptrCast(self)), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetOffset(self: *const T, offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugHostField, @ptrCast(self)), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostField, @ptrCast(self)), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostField.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostField, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostData_Value = Guid.initString("a3d64993-826c-44fa-897d-926f2fe7ad0b");
pub const IID_IDebugHostData = &IID_IDebugHostData_Value;
pub const IDebugHostData = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostData,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostData,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostData,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostData,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostData,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostData,
                value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostData, @ptrCast(self)), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostData, @ptrCast(self)), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostData.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IDebugHostData, @ptrCast(self)), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostPublic_Value = Guid.initString("6c597ac9-fb4d-4f6d-9f39-22488539f8f4");
pub const IID_IDebugHostPublic = &IID_IDebugHostPublic_Value;
pub const IDebugHostPublic = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostPublic,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostPublic,
                locationKind: ?*LocationKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostPublic,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostPublic,
                location: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostPublic_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostPublic.VTable, @ptrCast(self.vtable)).GetLocationKind(@as(*const IDebugHostPublic, @ptrCast(self)), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostPublic_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostPublic.VTable, @ptrCast(self.vtable)).GetLocation(@as(*const IDebugHostPublic, @ptrCast(self)), location);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostBaseClass_Value = Guid.initString("b94d57d2-390b-40f7-b5b4-b6db897d974b");
pub const IID_IDebugHostBaseClass = &IID_IDebugHostBaseClass_Value;
pub const IDebugHostBaseClass = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostBaseClass,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostBaseClass,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostBaseClass_GetOffset(self: *const T, offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostBaseClass.VTable, @ptrCast(self.vtable)).GetOffset(@as(*const IDebugHostBaseClass, @ptrCast(self)), offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbols_Value = Guid.initString("854fd751-c2e1-4eb2-b525-6619cb97a588");
pub const IID_IDebugHostSymbols = &IID_IDebugHostSymbols_Value;
pub const IDebugHostSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateModuleSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                pwszModuleName: ?[*:0]align(1) const u16,
                pwszMinVersion: ?[*:0]align(1) const u16,
                pwszMaxVersion: ?[*:0]align(1) const u16,
                ppModuleSignature: ?*?*IDebugHostModuleSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                pwszModuleName: ?[*:0]align(1) const u16,
                pwszMinVersion: ?[*:0]align(1) const u16,
                pwszMaxVersion: ?[*:0]align(1) const u16,
                ppModuleSignature: ?*?*IDebugHostModuleSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypeSignature: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]align(1) const u16,
                module: ?*IDebugHostModule,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]align(1) const u16,
                module: ?*IDebugHostModule,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypeSignatureForModuleRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]align(1) const u16,
                moduleName: ?[*:0]align(1) const u16,
                minVersion: ?[*:0]align(1) const u16,
                maxVersion: ?[*:0]align(1) const u16,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                signatureSpecification: ?[*:0]align(1) const u16,
                moduleName: ?[*:0]align(1) const u16,
                minVersion: ?[*:0]align(1) const u16,
                maxVersion: ?[*:0]align(1) const u16,
                typeSignature: ?*?*IDebugHostTypeSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateModules: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleEnum: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindModuleByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleName: ?[*:0]align(1) const u16,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleName: ?[*:0]align(1) const u16,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindModuleByLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleLocation: Location,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                context: ?*IDebugHostContext,
                moduleLocation: Location,
                module: ?*?*IDebugHostModule,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMostDerivedObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbols,
                pContext: ?*IDebugHostContext,
                location: Location,
                objectType: ?*IDebugHostType,
                derivedLocation: ?*Location,
                derivedType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbols,
                pContext: ?*IDebugHostContext,
                location: Location,
                objectType: ?*IDebugHostType,
                derivedLocation: ?*Location,
                derivedType: ?*?*IDebugHostType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateModuleSignature(self: *const T, pwszModuleName: ?[*:0]align(1) const u16, pwszMinVersion: ?[*:0]align(1) const u16, pwszMaxVersion: ?[*:0]align(1) const u16, ppModuleSignature: ?*?*IDebugHostModuleSignature) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateModuleSignature(@as(*const IDebugHostSymbols, @ptrCast(self)), pwszModuleName, pwszMinVersion, pwszMaxVersion, ppModuleSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateTypeSignature(self: *const T, signatureSpecification: ?[*:0]align(1) const u16, module: ?*IDebugHostModule, typeSignature: ?*?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateTypeSignature(@as(*const IDebugHostSymbols, @ptrCast(self)), signatureSpecification, module, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateTypeSignatureForModuleRange(self: *const T, signatureSpecification: ?[*:0]align(1) const u16, moduleName: ?[*:0]align(1) const u16, minVersion: ?[*:0]align(1) const u16, maxVersion: ?[*:0]align(1) const u16, typeSignature: ?*?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).CreateTypeSignatureForModuleRange(@as(*const IDebugHostSymbols, @ptrCast(self)), signatureSpecification, moduleName, minVersion, maxVersion, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_EnumerateModules(self: *const T, context: ?*IDebugHostContext, moduleEnum: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).EnumerateModules(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_FindModuleByName(self: *const T, context: ?*IDebugHostContext, moduleName: ?[*:0]align(1) const u16, module: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).FindModuleByName(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleName, module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_FindModuleByLocation(self: *const T, context: ?*IDebugHostContext, moduleLocation: Location, module: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).FindModuleByLocation(@as(*const IDebugHostSymbols, @ptrCast(self)), context, moduleLocation, module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_GetMostDerivedObject(self: *const T, pContext: ?*IDebugHostContext, location: Location, objectType: ?*IDebugHostType, derivedLocation: ?*Location, derivedType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbols.VTable, @ptrCast(self.vtable)).GetMostDerivedObject(@as(*const IDebugHostSymbols, @ptrCast(self)), pContext, location, objectType, derivedLocation, derivedType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory_Value = Guid.initString("212149c9-9183-4a3e-b00e-4fd1dc95339b");
pub const IID_IDebugHostMemory = &IID_IDebugHostMemory_Value;
pub const IDebugHostMemory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesRead: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesRead: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteBytes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesWritten: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                // TODO: what to do with BytesParamIndex 3?
                buffer: ?*anyopaque,
                bufferSize: u64,
                bytesWritten: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReadPointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WritePointers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                count: u64,
                pointers: [*]u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisplayStringForLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                verbose: u8,
                locationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory,
                context: ?*IDebugHostContext,
                location: Location,
                verbose: u8,
                locationName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_ReadBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*anyopaque, bufferSize: u64, bytesRead: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).ReadBytes(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, buffer, bufferSize, bytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_WriteBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*anyopaque, bufferSize: u64, bytesWritten: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).WriteBytes(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, buffer, bufferSize, bytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_ReadPointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).ReadPointers(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, count, pointers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_WritePointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).WritePointers(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, count, pointers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_GetDisplayStringForLocation(self: *const T, context: ?*IDebugHostContext, location: Location, verbose: u8, locationName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory.VTable, @ptrCast(self.vtable)).GetDisplayStringForLocation(@as(*const IDebugHostMemory, @ptrCast(self)), context, location, verbose, locationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator_Value = Guid.initString("0fef9a21-577e-4997-ac7b-1c4883241d99");
pub const IID_IDebugHostEvaluator = &IID_IDebugHostEvaluator_Value;
pub const IDebugHostEvaluator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]align(1) const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]align(1) const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluateExtendedExpression: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]align(1) const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostEvaluator,
                context: ?*IDebugHostContext,
                expression: ?[*:0]align(1) const u16,
                bindingContext: ?*IModelObject,
                result: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator_EvaluateExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]align(1) const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostEvaluator.VTable, @ptrCast(self.vtable)).EvaluateExpression(@as(*const IDebugHostEvaluator, @ptrCast(self)), context, expression, bindingContext, result, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator_EvaluateExtendedExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]align(1) const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostEvaluator.VTable, @ptrCast(self.vtable)).EvaluateExtendedExpression(@as(*const IDebugHostEvaluator, @ptrCast(self)), context, expression, bindingContext, result, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SignatureComparison = enum(i32) {
    Unrelated = 0,
    Ambiguous = 1,
    LessSpecific = 2,
    MoreSpecific = 3,
    Identical = 4,
};
pub const Unrelated = SignatureComparison.Unrelated;
pub const Ambiguous = SignatureComparison.Ambiguous;
pub const LessSpecific = SignatureComparison.LessSpecific;
pub const MoreSpecific = SignatureComparison.MoreSpecific;
pub const Identical = SignatureComparison.Identical;

const IID_IDebugHostModuleSignature_Value = Guid.initString("31e53a5a-01ee-4bbb-b899-4b46ae7d595c");
pub const IID_IDebugHostModuleSignature = &IID_IDebugHostModuleSignature_Value;
pub const IDebugHostModuleSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModuleSignature,
                pModule: ?*IDebugHostModule,
                isMatch: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModuleSignature,
                pModule: ?*IDebugHostModule,
                isMatch: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModuleSignature_IsMatch(self: *const T, pModule: ?*IDebugHostModule, isMatch: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModuleSignature.VTable, @ptrCast(self.vtable)).IsMatch(@as(*const IDebugHostModuleSignature, @ptrCast(self)), pModule, isMatch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostTypeSignature_Value = Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostTypeSignature = &IID_IDebugHostTypeSignature_Value;
pub const IDebugHostTypeSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHashCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostTypeSignature,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostTypeSignature,
                hashCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsMatch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostTypeSignature,
                type: ?*IDebugHostType,
                isMatch: ?*bool,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostTypeSignature,
                type: ?*IDebugHostType,
                isMatch: ?*bool,
                wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompareAgainst: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostTypeSignature,
                typeSignature: ?*IDebugHostTypeSignature,
                result: ?*SignatureComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostTypeSignature,
                typeSignature: ?*IDebugHostTypeSignature,
                result: ?*SignatureComparison,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_GetHashCode(self: *const T, hashCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).GetHashCode(@as(*const IDebugHostTypeSignature, @ptrCast(self)), hashCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_IsMatch(self: *const T, type_: ?*IDebugHostType, isMatch: ?*bool, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).IsMatch(@as(*const IDebugHostTypeSignature, @ptrCast(self)), type_, isMatch, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_CompareAgainst(self: *const T, typeSignature: ?*IDebugHostTypeSignature, result: ?*SignatureComparison) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostTypeSignature.VTable, @ptrCast(self.vtable)).CompareAgainst(@as(*const IDebugHostTypeSignature, @ptrCast(self)), typeSignature, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SymbolSearchOptions = enum(i32) {
    None = 0,
    Completion = 1,
    CaseInsensitive = 2,
};
pub const SymbolSearchNone = SymbolSearchOptions.None;
pub const SymbolSearchCompletion = SymbolSearchOptions.Completion;
pub const SymbolSearchCaseInsensitive = SymbolSearchOptions.CaseInsensitive;

pub const LanguageKind = enum(i32) {
    Unknown = 0,
    C = 1,
    CPP = 2,
    Assembly = 3,
};
pub const LanguageUnknown = LanguageKind.Unknown;
pub const LanguageC = LanguageKind.C;
pub const LanguageCPP = LanguageKind.CPP;
pub const LanguageAssembly = LanguageKind.Assembly;

const IID_IDebugHostSymbol2_Value = Guid.initString("21515b67-6720-4257-8a68-077dc944471c");
pub const IID_IDebugHostSymbol2 = &IID_IDebugHostSymbol2_Value;
pub const IDebugHostSymbol2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostSymbol2,
                pKind: ?*LanguageKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostSymbol2,
                pKind: ?*LanguageKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol2_GetLanguage(self: *const T, pKind: ?*LanguageKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostSymbol2.VTable, @ptrCast(self.vtable)).GetLanguage(@as(*const IDebugHostSymbol2, @ptrCast(self)), pKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VarArgsKind = enum(i32) {
    None = 0,
    CStyle = 1,
};
pub const VarArgsNone = VarArgsKind.None;
pub const VarArgsCStyle = VarArgsKind.CStyle;

const IID_IDebugHostType2_Value = Guid.initString("b28632b9-8506-4676-87ce-8f7e05e59876");
pub const IID_IDebugHostType2 = &IID_IDebugHostType2_Value;
pub const IDebugHostType2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostType.VTable,
        IsTypedef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType2,
                isTypedef: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType2,
                isTypedef: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypedefBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType2,
                baseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType2,
                baseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypedefFinalBaseType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType2,
                finalBaseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType2,
                finalBaseType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionVarArgsKind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType2,
                varArgsKind: ?*VarArgsKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType2,
                varArgsKind: ?*VarArgsKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFunctionInstancePointerType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostType2,
                instancePointerType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostType2,
                instancePointerType: ?*?*IDebugHostType2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_IsTypedef(self: *const T, isTypedef: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).IsTypedef(@as(*const IDebugHostType2, @ptrCast(self)), isTypedef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetTypedefBaseType(self: *const T, baseType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetTypedefBaseType(@as(*const IDebugHostType2, @ptrCast(self)), baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetTypedefFinalBaseType(self: *const T, finalBaseType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetTypedefFinalBaseType(@as(*const IDebugHostType2, @ptrCast(self)), finalBaseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetFunctionVarArgsKind(self: *const T, varArgsKind: ?*VarArgsKind) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetFunctionVarArgsKind(@as(*const IDebugHostType2, @ptrCast(self)), varArgsKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetFunctionInstancePointerType(self: *const T, instancePointerType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostType2.VTable, @ptrCast(self.vtable)).GetFunctionInstancePointerType(@as(*const IDebugHostType2, @ptrCast(self)), instancePointerType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostStatus_Value = Guid.initString("4f3e1ce2-86b2-4c7a-9c65-d0a9d0eecf44");
pub const IID_IDebugHostStatus = &IID_IDebugHostStatus_Value;
pub const IDebugHostStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PollUserInterrupt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostStatus,
                interruptRequested: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostStatus,
                interruptRequested: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostStatus_PollUserInterrupt(self: *const T, interruptRequested: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostStatus.VTable, @ptrCast(self.vtable)).PollUserInterrupt(@as(*const IDebugHostStatus, @ptrCast(self)), interruptRequested);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptClient_Value = Guid.initString("3b362b0e-89f0-46c6-a663-dfdc95194aef");
pub const IID_IDataModelScriptClient = &IID_IDataModelScriptClient_Value;
pub const IDataModelScriptClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptClient,
                errClass: ErrorClass,
                hrFail: HRESULT,
                message: ?[*:0]align(1) const u16,
                line: u32,
                position: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptClient,
                errClass: ErrorClass,
                hrFail: HRESULT,
                message: ?[*:0]align(1) const u16,
                line: u32,
                position: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptClient_ReportError(self: *const T, errClass: ErrorClass, hrFail: HRESULT, message: ?[*:0]align(1) const u16, line: u32, position: u32) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptClient.VTable, @ptrCast(self.vtable)).ReportError(@as(*const IDataModelScriptClient, @ptrCast(self)), errClass, hrFail, message, line, position);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplate_Value = Guid.initString("1303dec4-fa3b-4f1b-9224-b953d16babb5");
pub const IID_IDataModelScriptTemplate = &IID_IDataModelScriptTemplate_Value;
pub const IDataModelScriptTemplate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptTemplate,
                templateName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptTemplate,
                templateName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptTemplate,
                templateDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptTemplate,
                templateDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptTemplate,
                contentStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptTemplate,
                contentStream: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetName(self: *const T, templateName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptTemplate, @ptrCast(self)), templateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetDescription(self: *const T, templateDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetDescription(@as(*const IDataModelScriptTemplate, @ptrCast(self)), templateDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetContent(self: *const T, contentStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptTemplate.VTable, @ptrCast(self.vtable)).GetContent(@as(*const IDataModelScriptTemplate, @ptrCast(self)), contentStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScript_Value = Guid.initString("7b4d30fc-b14a-49f8-8d87-d9a1480c97f7");
pub const IID_IDataModelScript = &IID_IDataModelScript_Value;
pub const IDataModelScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                scriptName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                scriptName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Rename: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                scriptName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                scriptName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Populate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                contentStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                contentStream: ?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unlink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsInvocable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                isInvocable: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                isInvocable: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeMain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScript,
                client: ?*IDataModelScriptClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_GetName(self: *const T, scriptName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScript, @ptrCast(self)), scriptName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Rename(self: *const T, scriptName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Rename(@as(*const IDataModelScript, @ptrCast(self)), scriptName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Populate(self: *const T, contentStream: ?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Populate(@as(*const IDataModelScript, @ptrCast(self)), contentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Execute(self: *const T, client: ?*IDataModelScriptClient) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Execute(@as(*const IDataModelScript, @ptrCast(self)), client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Unlink(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).Unlink(@as(*const IDataModelScript, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_IsInvocable(self: *const T, isInvocable: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).IsInvocable(@as(*const IDataModelScript, @ptrCast(self)), isInvocable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_InvokeMain(self: *const T, client: ?*IDataModelScriptClient) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScript.VTable, @ptrCast(self.vtable)).InvokeMain(@as(*const IDataModelScript, @ptrCast(self)), client);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplateEnumerator_Value = Guid.initString("69ce6ae2-2268-4e6f-b062-20ce62bfe677");
pub const IID_IDataModelScriptTemplateEnumerator = &IID_IDataModelScriptTemplateEnumerator_Value;
pub const IDataModelScriptTemplateEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptTemplateEnumerator,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptTemplateEnumerator,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplateEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptTemplateEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptTemplateEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplateEnumerator_GetNext(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptTemplateEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptTemplateEnumerator, @ptrCast(self)), templateContent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProvider_Value = Guid.initString("513461e0-4fca-48ce-8658-32f3e2056f3b");
pub const IID_IDataModelScriptProvider = &IID_IDataModelScriptProvider_Value;
pub const IDataModelScriptProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProvider,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProvider,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProvider,
                extension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProvider,
                extension: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateScript: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProvider,
                script: ?*?*IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProvider,
                script: ?*?*IDataModelScript,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultTemplateContent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProvider,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProvider,
                templateContent: ?*?*IDataModelScriptTemplate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateTemplates: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProvider,
                enumerator: ?*?*IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProvider,
                enumerator: ?*?*IDataModelScriptTemplateEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptProvider, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetExtension(self: *const T, extension: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetExtension(@as(*const IDataModelScriptProvider, @ptrCast(self)), extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_CreateScript(self: *const T, script: ?*?*IDataModelScript) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).CreateScript(@as(*const IDataModelScriptProvider, @ptrCast(self)), script);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetDefaultTemplateContent(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).GetDefaultTemplateContent(@as(*const IDataModelScriptProvider, @ptrCast(self)), templateContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_EnumerateTemplates(self: *const T, enumerator: ?*?*IDataModelScriptTemplateEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProvider.VTable, @ptrCast(self.vtable)).EnumerateTemplates(@as(*const IDataModelScriptProvider, @ptrCast(self)), enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProviderEnumerator_Value = Guid.initString("95ba00e2-704a-4fe2-a8f1-a7e7d8fb0941");
pub const IID_IDataModelScriptProviderEnumerator = &IID_IDataModelScriptProviderEnumerator_Value;
pub const IDataModelScriptProviderEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptProviderEnumerator,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptProviderEnumerator,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProviderEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProviderEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptProviderEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProviderEnumerator_GetNext(self: *const T, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptProviderEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptProviderEnumerator, @ptrCast(self)), provider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptManager_Value = Guid.initString("6fd11e33-e5ad-410b-8011-68c6bc4bf80d");
pub const IID_IDataModelScriptManager = &IID_IDataModelScriptManager_Value;
pub const IDataModelScriptManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultNameBinder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                ppNameBinder: ?*?*IDataModelNameBinder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                ppNameBinder: ?*?*IDataModelNameBinder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterScriptProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterScriptProvider: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                provider: ?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProviderForScriptType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                scriptType: ?[*:0]align(1) const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                scriptType: ?[*:0]align(1) const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindProviderForScriptExtension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                scriptExtension: ?[*:0]align(1) const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                scriptExtension: ?[*:0]align(1) const u16,
                provider: ?*?*IDataModelScriptProvider,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateScriptProviders: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptManager,
                enumerator: ?*?*IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptManager,
                enumerator: ?*?*IDataModelScriptProviderEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_GetDefaultNameBinder(self: *const T, ppNameBinder: ?*?*IDataModelNameBinder) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).GetDefaultNameBinder(@as(*const IDataModelScriptManager, @ptrCast(self)), ppNameBinder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_RegisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).RegisterScriptProvider(@as(*const IDataModelScriptManager, @ptrCast(self)), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_UnregisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).UnregisterScriptProvider(@as(*const IDataModelScriptManager, @ptrCast(self)), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_FindProviderForScriptType(self: *const T, scriptType: ?[*:0]align(1) const u16, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).FindProviderForScriptType(@as(*const IDataModelScriptManager, @ptrCast(self)), scriptType, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_FindProviderForScriptExtension(self: *const T, scriptExtension: ?[*:0]align(1) const u16, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).FindProviderForScriptExtension(@as(*const IDataModelScriptManager, @ptrCast(self)), scriptExtension, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_EnumerateScriptProviders(self: *const T, enumerator: ?*?*IDataModelScriptProviderEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptManager.VTable, @ptrCast(self.vtable)).EnumerateScriptProviders(@as(*const IDataModelScriptManager, @ptrCast(self)), enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicKeyProviderConcept_Value = Guid.initString("e7983fa1-80a7-498c-988f-518ddc5d4025");
pub const IID_IDynamicKeyProviderConcept = &IID_IDynamicKeyProviderConcept_Value;
pub const IDynamicKeyProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]align(1) const u16,
                keyValue: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
                hasKey: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]align(1) const u16,
                keyValue: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
                hasKey: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]align(1) const u16,
                keyValue: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                key: ?[*:0]align(1) const u16,
                keyValue: ?*IModelObject,
                metadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateKeys: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                ppEnumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicKeyProviderConcept,
                contextObject: ?*IModelObject,
                ppEnumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_GetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]align(1) const u16, keyValue: ?*?*IModelObject, metadata: ?*?*IKeyStore, hasKey: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).GetKey(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, key, keyValue, metadata, hasKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_SetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]align(1) const u16, keyValue: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).SetKey(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, key, keyValue, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_EnumerateKeys(self: *const T, contextObject: ?*IModelObject, ppEnumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDynamicKeyProviderConcept.VTable, @ptrCast(self.vtable)).EnumerateKeys(@as(*const IDynamicKeyProviderConcept, @ptrCast(self)), contextObject, ppEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicConceptProviderConcept_Value = Guid.initString("95a7f7dd-602e-483f-9d06-a15c0ee13174");
pub const IID_IDynamicConceptProviderConcept = &IID_IDynamicConceptProviderConcept_Value;
pub const IDynamicConceptProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
                hasConcept: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*?*IUnknown,
                conceptMetadata: ?*?*IKeyStore,
                hasConcept: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConcept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicConceptProviderConcept,
                contextObject: ?*IModelObject,
                conceptId: ?*const Guid,
                conceptInterface: ?*IUnknown,
                conceptMetadata: ?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyParentChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicConceptProviderConcept,
                parentModel: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyDestruct: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDynamicConceptProviderConcept,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDynamicConceptProviderConcept,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_GetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore, hasConcept: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).GetConcept(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), contextObject, conceptId, conceptInterface, conceptMetadata, hasConcept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_SetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).SetConcept(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), contextObject, conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyParent(self: *const T, parentModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyParent(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), parentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyParentChange(self: *const T, parentModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyParentChange(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)), parentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyDestruct(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDynamicConceptProviderConcept.VTable, @ptrCast(self.vtable)).NotifyDestruct(@as(*const IDynamicConceptProviderConcept, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptChangeKind = enum(i32) {
    e = 0,
};
pub const ScriptRename = ScriptChangeKind.e;

const IID_IDataModelScriptHostContext_Value = Guid.initString("014d366a-1f23-4981-9219-b2db8b402054");
pub const IID_IDataModelScriptHostContext = &IID_IDataModelScriptHostContext_Value;
pub const IDataModelScriptHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyScriptChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptHostContext,
                script: ?*IDataModelScript,
                changeKind: ScriptChangeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptHostContext,
                script: ?*IDataModelScript,
                changeKind: ScriptChangeKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamespaceObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptHostContext,
                namespaceObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptHostContext,
                namespaceObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptHostContext_NotifyScriptChange(self: *const T, script: ?*IDataModelScript, changeKind: ScriptChangeKind) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptHostContext.VTable, @ptrCast(self.vtable)).NotifyScriptChange(@as(*const IDataModelScriptHostContext, @ptrCast(self)), script, changeKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptHostContext_GetNamespaceObject(self: *const T, namespaceObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptHostContext.VTable, @ptrCast(self.vtable)).GetNamespaceObject(@as(*const IDataModelScriptHostContext, @ptrCast(self)), namespaceObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostScriptHost_Value = Guid.initString("b70334a4-b92c-4570-93a1-d3eb686649a0");
pub const IID_IDebugHostScriptHost = &IID_IDebugHostScriptHost_Value;
pub const IDebugHostScriptHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostScriptHost,
                script: ?*IDataModelScript,
                scriptContext: ?*?*IDataModelScriptHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostScriptHost,
                script: ?*IDataModelScript,
                scriptContext: ?*?*IDataModelScriptHostContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostScriptHost_CreateContext(self: *const T, script: ?*IDataModelScript, scriptContext: ?*?*IDataModelScriptHostContext) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostScriptHost.VTable, @ptrCast(self.vtable)).CreateContext(@as(*const IDebugHostScriptHost, @ptrCast(self)), script, scriptContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelNameBinder_Value = Guid.initString("af352b7b-8292-4c01-b360-2dc3696c65e7");
pub const IID_IDataModelNameBinder = &IID_IDataModelNameBinder_Value;
pub const IDataModelNameBinder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]align(1) const u16,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]align(1) const u16,
                value: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]align(1) const u16,
                reference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                name: ?[*:0]align(1) const u16,
                reference: ?*?*IModelObject,
                metadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateReferences: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelNameBinder,
                contextObject: ?*IModelObject,
                enumerator: ?*?*IKeyEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_BindValue(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]align(1) const u16, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).BindValue(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, name, value, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_BindReference(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]align(1) const u16, reference: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).BindReference(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, name, reference, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_EnumerateValues(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).EnumerateValues(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_EnumerateReferences(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelNameBinder.VTable, @ptrCast(self.vtable)).EnumerateReferences(@as(*const IDataModelNameBinder, @ptrCast(self)), contextObject, enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference2_Value = Guid.initString("80e2f7c5-7159-4e92-887e-7e0347e88406");
pub const IID_IModelKeyReference2 = &IID_IModelKeyReference2_Value;
pub const IModelKeyReference2 = extern struct {
    pub const VTable = extern struct {
        base: IModelKeyReference.VTable,
        OverrideContextObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IModelKeyReference2,
                newContextObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IModelKeyReference2,
                newContextObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IModelKeyReference.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference2_OverrideContextObject(self: *const T, newContextObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IModelKeyReference2.VTable, @ptrCast(self.vtable)).OverrideContextObject(@as(*const IModelKeyReference2, @ptrCast(self)), newContextObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator2_Value = Guid.initString("a117a435-1fb4-4092-a2ab-a929576c1e87");
pub const IID_IDebugHostEvaluator2 = &IID_IDebugHostEvaluator2_Value;
pub const IDebugHostEvaluator2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostEvaluator.VTable,
        AssignTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostEvaluator2,
                assignmentReference: ?*IModelObject,
                assignmentValue: ?*IModelObject,
                assignmentResult: ?*?*IModelObject,
                assignmentMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostEvaluator2,
                assignmentReference: ?*IModelObject,
                assignmentValue: ?*IModelObject,
                assignmentResult: ?*?*IModelObject,
                assignmentMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostEvaluator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator2_AssignTo(self: *const T, assignmentReference: ?*IModelObject, assignmentValue: ?*IModelObject, assignmentResult: ?*?*IModelObject, assignmentMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostEvaluator2.VTable, @ptrCast(self.vtable)).AssignTo(@as(*const IDebugHostEvaluator2, @ptrCast(self)), assignmentReference, assignmentValue, assignmentResult, assignmentMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager2_Value = Guid.initString("f412c5ea-2284-4622-a660-a697160d3312");
pub const IID_IDataModelManager2 = &IID_IDataModelManager2_Value;
pub const IDataModelManager2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelManager.VTable,
        AcquireSubNamespace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager2,
                modelName: ?[*:0]align(1) const u16,
                subNamespaceModelName: ?[*:0]align(1) const u16,
                accessName: ?[*:0]align(1) const u16,
                metadata: ?*IKeyStore,
                namespaceModelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager2,
                modelName: ?[*:0]align(1) const u16,
                subNamespaceModelName: ?[*:0]align(1) const u16,
                accessName: ?[*:0]align(1) const u16,
                metadata: ?*IKeyStore,
                namespaceModelObject: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTypedIntrinsicObjectEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelManager2,
                context: ?*IDebugHostContext,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelManager2,
                context: ?*IDebugHostContext,
                intrinsicData: ?*VARIANT,
                type: ?*IDebugHostType,
                object: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataModelManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager2_AcquireSubNamespace(self: *const T, modelName: ?[*:0]align(1) const u16, subNamespaceModelName: ?[*:0]align(1) const u16, accessName: ?[*:0]align(1) const u16, metadata: ?*IKeyStore, namespaceModelObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager2.VTable, @ptrCast(self.vtable)).AcquireSubNamespace(@as(*const IDataModelManager2, @ptrCast(self)), modelName, subNamespaceModelName, accessName, metadata, namespaceModelObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager2_CreateTypedIntrinsicObjectEx(self: *const T, context: ?*IDebugHostContext, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelManager2.VTable, @ptrCast(self.vtable)).CreateTypedIntrinsicObjectEx(@as(*const IDataModelManager2, @ptrCast(self)), context, intrinsicData, type_, object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory2_Value = Guid.initString("eea033de-38f6-416b-a251-1d3771001270");
pub const IID_IDebugHostMemory2 = &IID_IDebugHostMemory2_Value;
pub const IDebugHostMemory2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostMemory.VTable,
        LinearizeLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostMemory2,
                context: ?*IDebugHostContext,
                location: Location,
                pLinearizedLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostMemory2,
                context: ?*IDebugHostContext,
                location: Location,
                pLinearizedLocation: ?*Location,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostMemory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory2_LinearizeLocation(self: *const T, context: ?*IDebugHostContext, location: Location, pLinearizedLocation: ?*Location) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostMemory2.VTable, @ptrCast(self.vtable)).LinearizeLocation(@as(*const IDebugHostMemory2, @ptrCast(self)), context, location, pLinearizedLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostExtensibility_Value = Guid.initString("3c2b24e1-11d0-4f86-8ae5-4df166f73253");
pub const IID_IDebugHostExtensibility = &IID_IDebugHostExtensibility_Value;
pub const IDebugHostExtensibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateFunctionAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]align(1) const u16,
                functionObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]align(1) const u16,
                functionObject: ?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DestroyFunctionAlias: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostExtensibility,
                aliasName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostExtensibility_CreateFunctionAlias(self: *const T, aliasName: ?[*:0]align(1) const u16, functionObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostExtensibility.VTable, @ptrCast(self.vtable)).CreateFunctionAlias(@as(*const IDebugHostExtensibility, @ptrCast(self)), aliasName, functionObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostExtensibility_DestroyFunctionAlias(self: *const T, aliasName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostExtensibility.VTable, @ptrCast(self.vtable)).DestroyFunctionAlias(@as(*const IDebugHostExtensibility, @ptrCast(self)), aliasName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptDebugState = enum(i32) {
    NoDebugger = 0,
    NotExecuting = 1,
    Executing = 2,
    Break = 3,
};
pub const ScriptDebugNoDebugger = ScriptDebugState.NoDebugger;
pub const ScriptDebugNotExecuting = ScriptDebugState.NotExecuting;
pub const ScriptDebugExecuting = ScriptDebugState.Executing;
pub const ScriptDebugBreak = ScriptDebugState.Break;

pub const ScriptDebugEventFilter = enum(i32) {
    Entry = 0,
    Exception = 1,
    UnhandledException = 2,
    Abort = 3,
};
pub const ScriptDebugEventFilterEntry = ScriptDebugEventFilter.Entry;
pub const ScriptDebugEventFilterException = ScriptDebugEventFilter.Exception;
pub const ScriptDebugEventFilterUnhandledException = ScriptDebugEventFilter.UnhandledException;
pub const ScriptDebugEventFilterAbort = ScriptDebugEventFilter.Abort;

pub const ScriptDebugEvent = enum(i32) {
    Breakpoint = 0,
    Step = 1,
    Exception = 2,
    AsyncBreak = 3,
};
pub const ScriptDebugBreakpoint = ScriptDebugEvent.Breakpoint;
pub const ScriptDebugStep = ScriptDebugEvent.Step;
pub const ScriptDebugException = ScriptDebugEvent.Exception;
pub const ScriptDebugAsyncBreak = ScriptDebugEvent.AsyncBreak;

pub const ScriptExecutionKind = enum(i32) {
    Normal = 0,
    StepIn = 1,
    StepOut = 2,
    StepOver = 3,
};
pub const ScriptExecutionNormal = ScriptExecutionKind.Normal;
pub const ScriptExecutionStepIn = ScriptExecutionKind.StepIn;
pub const ScriptExecutionStepOut = ScriptExecutionKind.StepOut;
pub const ScriptExecutionStepOver = ScriptExecutionKind.StepOver;

pub const ScriptDebugPosition = extern struct {
    Line: u32,
    Column: u32,
};

pub const ScriptDebugEventInformation = extern struct {
    DebugEvent: ScriptDebugEvent,
    EventPosition: ScriptDebugPosition,
    EventSpanEnd: ScriptDebugPosition,
    u: extern union {
        ExceptionInformation: extern struct {
            IsUncaught: u8,
        },
        BreakpointInformation: extern struct {
            BreakpointId: u64,
        },
    },
};

const IID_IDataModelScriptDebugClient_Value = Guid.initString("53159b6d-d4c4-471b-a863-5b110ca800ca");
pub const IID_IDataModelScriptDebugClient = &IID_IDataModelScriptDebugClient_Value;
pub const IDataModelScriptDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyDebugEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugClient,
                pEventInfo: ?*ScriptDebugEventInformation,
                pScript: ?*IDataModelScript,
                pEventDataObject: ?*IModelObject,
                resumeEventKind: ?*ScriptExecutionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugClient,
                pEventInfo: ?*ScriptDebugEventInformation,
                pScript: ?*IDataModelScript,
                pEventDataObject: ?*IModelObject,
                resumeEventKind: ?*ScriptExecutionKind,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugClient_NotifyDebugEvent(self: *const T, pEventInfo: ?*ScriptDebugEventInformation, pScript: ?*IDataModelScript, pEventDataObject: ?*IModelObject, resumeEventKind: ?*ScriptExecutionKind) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugClient.VTable, @ptrCast(self.vtable)).NotifyDebugEvent(@as(*const IDataModelScriptDebugClient, @ptrCast(self)), pEventInfo, pScript, pEventDataObject, resumeEventKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugVariableSetEnumerator_Value = Guid.initString("0f9feed7-d045-4ac3-98a8-a98942cf6a35");
pub const IID_IDataModelScriptDebugVariableSetEnumerator = &IID_IDataModelScriptDebugVariableSetEnumerator_Value;
pub const IDataModelScriptDebugVariableSetEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugVariableSetEnumerator,
                variableName: ?*?BSTR,
                variableValue: ?*?*IModelObject,
                variableMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugVariableSetEnumerator,
                variableName: ?*?BSTR,
                variableValue: ?*?*IModelObject,
                variableMetadata: ?*?*IKeyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugVariableSetEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugVariableSetEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptDebugVariableSetEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugVariableSetEnumerator_GetNext(self: *const T, variableName: ?*?BSTR, variableValue: ?*?*IModelObject, variableMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugVariableSetEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptDebugVariableSetEnumerator, @ptrCast(self)), variableName, variableValue, variableMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStackFrame_Value = Guid.initString("dec6ed5e-6360-4941-ab4c-a26409de4f82");
pub const IID_IDataModelScriptDebugStackFrame = &IID_IDataModelScriptDebugStackFrame_Value;
pub const IDataModelScriptDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                name: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTransitionPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                isTransitionPoint: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                isTransitionPoint: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                transitionScript: ?*?*IDataModelScript,
                isTransitionContiguous: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                transitionScript: ?*?*IDataModelScript,
                isTransitionContiguous: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Evaluate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                pwszExpression: ?[*:0]align(1) const u16,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                pwszExpression: ?[*:0]align(1) const u16,
                ppResult: ?*?*IModelObject,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateLocals: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStackFrame,
                variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), position, positionSpanEnd, lineText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_IsTransitionPoint(self: *const T, isTransitionPoint: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).IsTransitionPoint(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), isTransitionPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetTransition(self: *const T, transitionScript: ?*?*IDataModelScript, isTransitionContiguous: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).GetTransition(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), transitionScript, isTransitionContiguous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_Evaluate(self: *const T, pwszExpression: ?[*:0]align(1) const u16, ppResult: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).Evaluate(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), pwszExpression, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_EnumerateLocals(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).EnumerateLocals(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), variablesEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_EnumerateArguments(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStackFrame.VTable, @ptrCast(self.vtable)).EnumerateArguments(@as(*const IDataModelScriptDebugStackFrame, @ptrCast(self)), variablesEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStack_Value = Guid.initString("051364dd-e449-443e-9762-fe578f4a5473");
pub const IID_IDataModelScriptDebugStack = &IID_IDataModelScriptDebugStack_Value;
pub const IDataModelScriptDebugStack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        GetStackFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugStack,
                frameNumber: u64,
                stackFrame: ?*?*IDataModelScriptDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugStack,
                frameNumber: u64,
                stackFrame: ?*?*IDataModelScriptDebugStackFrame,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStack_GetFrameCount(self: *const T) callconv(.Inline) u64 {
            return @as(*const IDataModelScriptDebugStack.VTable, @ptrCast(self.vtable)).GetFrameCount(@as(*const IDataModelScriptDebugStack, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStack_GetStackFrame(self: *const T, frameNumber: u64, stackFrame: ?*?*IDataModelScriptDebugStackFrame) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugStack.VTable, @ptrCast(self.vtable)).GetStackFrame(@as(*const IDataModelScriptDebugStack, @ptrCast(self)), frameNumber, stackFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpoint_Value = Guid.initString("6bb27b35-02e6-47cb-90a0-5371244032de");
pub const IID_IDataModelScriptDebugBreakpoint = &IID_IDataModelScriptDebugBreakpoint_Value;
pub const IDataModelScriptDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) u64,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) u64,
        },
        IsEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) bool,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) bool,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Disable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        Remove: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) void,
        },
        GetPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpoint,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpoint,
                position: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_GetId(self: *const T) callconv(.Inline) u64 {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetId(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_IsEnabled(self: *const T) callconv(.Inline) bool {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).IsEnabled(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Enable(self: *const T) callconv(.Inline) void {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Enable(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Disable(self: *const T) callconv(.Inline) void {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Disable(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Remove(self: *const T) callconv(.Inline) void {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).Remove(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugBreakpoint.VTable, @ptrCast(self.vtable)).GetPosition(@as(*const IDataModelScriptDebugBreakpoint, @ptrCast(self)), position, positionSpanEnd, lineText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpointEnumerator_Value = Guid.initString("39484a75-b4f3-4799-86da-691afa57b299");
pub const IID_IDataModelScriptDebugBreakpointEnumerator = &IID_IDataModelScriptDebugBreakpointEnumerator_Value;
pub const IDataModelScriptDebugBreakpointEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebugBreakpointEnumerator,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebugBreakpointEnumerator,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpointEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugBreakpointEnumerator.VTable, @ptrCast(self.vtable)).Reset(@as(*const IDataModelScriptDebugBreakpointEnumerator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpointEnumerator_GetNext(self: *const T, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebugBreakpointEnumerator.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDataModelScriptDebugBreakpointEnumerator, @ptrCast(self)), breakpoint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug_Value = Guid.initString("de8e0945-9750-4471-ab76-a8f79d6ec350");
pub const IID_IDataModelScriptDebug = &IID_IDataModelScriptDebug_Value;
pub const IDataModelScriptDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDebugState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
            ) callconv(@import("std").os.windows.WINAPI) ScriptDebugState,
            else => *const fn(
                self: *const IDataModelScriptDebug,
            ) callconv(@import("std").os.windows.WINAPI) ScriptDebugState,
        },
        GetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                currentPosition: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                currentPosition: ?*ScriptDebugPosition,
                positionSpanEnd: ?*ScriptDebugPosition,
                lineText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                stack: ?*?*IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                stack: ?*?*IDataModelScriptDebugStack,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBreakpoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                linePosition: u32,
                columnPosition: u32,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                linePosition: u32,
                columnPosition: u32,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindBreakpointById: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                breakpointId: u64,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                breakpointId: u64,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateBreakpoints: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEventFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                eventFilter: ScriptDebugEventFilter,
                isBreakEnabled: u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopDebugging: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug,
                debugClient: ?*IDataModelScriptDebugClient,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetDebugState(self: *const T) callconv(.Inline) ScriptDebugState {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetDebugState(@as(*const IDataModelScriptDebug, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetCurrentPosition(self: *const T, currentPosition: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IDataModelScriptDebug, @ptrCast(self)), currentPosition, positionSpanEnd, lineText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetStack(self: *const T, stack: ?*?*IDataModelScriptDebugStack) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetStack(@as(*const IDataModelScriptDebug, @ptrCast(self)), stack);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_SetBreakpoint(self: *const T, linePosition: u32, columnPosition: u32, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).SetBreakpoint(@as(*const IDataModelScriptDebug, @ptrCast(self)), linePosition, columnPosition, breakpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_FindBreakpointById(self: *const T, breakpointId: u64, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).FindBreakpointById(@as(*const IDataModelScriptDebug, @ptrCast(self)), breakpointId, breakpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_EnumerateBreakpoints(self: *const T, breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).EnumerateBreakpoints(@as(*const IDataModelScriptDebug, @ptrCast(self)), breakpointEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).GetEventFilter(@as(*const IDataModelScriptDebug, @ptrCast(self)), eventFilter, isBreakEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_SetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: u8) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).SetEventFilter(@as(*const IDataModelScriptDebug, @ptrCast(self)), eventFilter, isBreakEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_StartDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).StartDebugging(@as(*const IDataModelScriptDebug, @ptrCast(self)), debugClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_StopDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug.VTable, @ptrCast(self.vtable)).StopDebugging(@as(*const IDataModelScriptDebug, @ptrCast(self)), debugClient);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug2_Value = Guid.initString("cbb10ed3-839e-426c-9243-e23535c1ae1a");
pub const IID_IDataModelScriptDebug2 = &IID_IDataModelScriptDebug2_Value;
pub const IDataModelScriptDebug2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelScriptDebug.VTable,
        SetBreakpointAtFunction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDataModelScriptDebug2,
                functionName: ?[*:0]align(1) const u16,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDataModelScriptDebug2,
                functionName: ?[*:0]align(1) const u16,
                breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataModelScriptDebug.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug2_SetBreakpointAtFunction(self: *const T, functionName: ?[*:0]align(1) const u16, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @as(*const IDataModelScriptDebug2.VTable, @ptrCast(self.vtable)).SetBreakpointAtFunction(@as(*const IDataModelScriptDebug2, @ptrCast(self)), functionName, breakpoint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule2_Value = Guid.initString("b51887e8-bcd0-4e8f-a8c7-434398b78c37");
pub const IID_IDebugHostModule2 = &IID_IDebugHostModule2_Value;
pub const IDebugHostModule2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostModule.VTable,
        FindContainingSymbolByRVA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugHostModule2,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugHostModule2,
                rva: u64,
                symbol: ?*?*IDebugHostSymbol,
                offset: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostModule.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule2_FindContainingSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol, offset: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugHostModule2.VTable, @ptrCast(self.vtable)).FindContainingSymbolByRVA(@as(*const IDebugHostModule2, @ptrCast(self)), rva, symbol, offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IComparableConcept_Value = Guid.initString("a7830646-9f0c-4a31-ba19-503f33e6c8a3");
pub const IID_IComparableConcept = &IID_IComparableConcept_Value;
pub const IComparableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareObjects: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IComparableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                comparisonResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IComparableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                comparisonResult: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComparableConcept_CompareObjects(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, comparisonResult: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IComparableConcept.VTable, @ptrCast(self.vtable)).CompareObjects(@as(*const IComparableConcept, @ptrCast(self)), contextObject, otherObject, comparisonResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEquatableConcept_Value = Guid.initString("c52d5d3d-609d-4d5d-8a82-46b0acdec4f4");
pub const IID_IEquatableConcept = &IID_IEquatableConcept_Value;
pub const IEquatableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreObjectsEqual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEquatableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                isEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEquatableConcept,
                contextObject: ?*IModelObject,
                otherObject: ?*IModelObject,
                isEqual: ?*bool,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEquatableConcept_AreObjectsEqual(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, isEqual: ?*bool) callconv(.Inline) HRESULT {
            return @as(*const IEquatableConcept.VTable, @ptrCast(self.vtable)).AreObjectsEqual(@as(*const IEquatableConcept, @ptrCast(self)), contextObject, otherObject, isEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PWINDBG_OUTPUT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpFormat: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpFormat: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_GET_EXPRESSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) usize,
} ;

pub const PWINDBG_GET_EXPRESSION32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_GET_EXPRESSION64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn(
        lpExpression: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) u64,
} ;

pub const PWINDBG_GET_SYMBOL = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: ?*anyopaque,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        offset: ?*anyopaque,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*usize,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_GET_SYMBOL32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u32,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        offset: u32,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_GET_SYMBOL64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u64,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        offset: u64,
        pchBuffer: ?[*]align(1) u8,
        pDisplacement: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_DISASM = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpOffset: ?*usize,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        lpOffset: ?*usize,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_DISASM32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpOffset: ?*u32,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        lpOffset: ?*u32,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_DISASM64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpOffset: ?*u64,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        lpOffset: ?*u64,
        lpBuffer: ?[*:0]align(1) const u8,
        fShowEffectiveAddress: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_CHECK_CONTROL_C = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: usize,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: usize,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u32,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: u32,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u64,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: u64,
        lpBuffer: ?*anyopaque,
        cb: u32,
        lpcbBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: usize,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: usize,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u32,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: u32,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        offset: u64,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        offset: u64,
        lpBuffer: ?*const anyopaque,
        cb: u32,
        lpcbBytesWritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_GET_THREAD_CONTEXT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_SET_THREAD_CONTEXT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        Processor: u32,
        lpContext: ?*CONTEXT,
        cbSizeOfContext: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_IOCTL_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        IoctlType: u16,
        lpvData: ?*anyopaque,
        cbSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        IoctlType: u16,
        lpvData: ?*anyopaque,
        cbSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_OLDKD_READ_PHYSICAL_MEMORY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        address: u64,
        buffer: ?*anyopaque,
        count: u32,
        bytesread: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        address: u64,
        buffer: ?*anyopaque,
        count: u32,
        bytesread: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        address: u64,
        buffer: ?*anyopaque,
        length: u32,
        byteswritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        address: u64,
        buffer: ?*anyopaque,
        length: u32,
        byteswritten: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const EXTSTACKTRACE = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE32 = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE64 = extern struct {
    FramePointer: u64,
    ProgramCounter: u64,
    ReturnAddress: u64,
    Args: [4]u64,
};

pub const PWINDBG_STACKTRACE_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_STACKTRACE_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE32,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        FramePointer: u32,
        StackPointer: u32,
        ProgramCounter: u32,
        StackFrames: ?*EXTSTACKTRACE32,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PWINDBG_STACKTRACE_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FramePointer: u64,
        StackPointer: u64,
        ProgramCounter: u64,
        StackFrames: ?*EXTSTACKTRACE64,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        FramePointer: u64,
        StackPointer: u64,
        ProgramCounter: u64,
        StackFrames: ?*EXTSTACKTRACE64,
        Frames: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const WINDBG_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE,
};

pub const WINDBG_EXTENSION_APIS32 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE32,
};

pub const WINDBG_EXTENSION_APIS64 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION64,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL64,
    lpDisasmRoutine: ?PWINDBG_DISASM64,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE64,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE64,
};

pub const WINDBG_OLD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
};

pub const WINDBG_OLDKD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadVirtualMemRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteVirtualMemRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpReadPhysicalMemRoutine: ?PWINDBG_OLDKD_READ_PHYSICAL_MEMORY,
    lpWritePhysicalMemRoutine: ?PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY,
};

pub const PWINDBG_OLD_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u32,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u64,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        hCurrentProcess: ?HANDLE,
        hCurrentThread: ?HANDLE,
        dwCurrentPc: u64,
        dwProcessor: u32,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_OLDKD_EXTENSION_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_OLDKD_EXTENSION_APIS,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        dwCurrentPc: u32,
        lpExtensionApis: ?*WINDBG_OLDKD_EXTENSION_APIS,
        lpArgumentString: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_DLL_INIT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_DLL_INIT32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS32,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS32,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_EXTENSION_DLL_INIT64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS64,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        lpExtensionApis: ?*WINDBG_EXTENSION_APIS64,
        MajorVersion: u16,
        MinorVersion: u16,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PWINDBG_CHECK_VERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const EXT_API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PWINDBG_EXTENSION_API_VERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) ?*EXT_API_VERSION,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) ?*EXT_API_VERSION,
} ;

pub const PROCESSORINFO = extern struct {
    Processor: u16,
    NumberProcessors: u16,
};

pub const READCONTROLSPACE = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE32 = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE64 = extern struct {
    Processor: u16,
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const IOSPACE = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
};

pub const IOSPACE_EX = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const BUSDATA = extern struct {
    BusDataType: u32,
    BusNumber: u32,
    SlotNumber: u32,
    Buffer: ?*anyopaque,
    Offset: u32,
    Length: u32,
};

pub const SEARCHMEMORY = extern struct {
    SearchAddress: u64,
    SearchLength: u64,
    FoundAddress: u64,
    PatternLength: u32,
    Pattern: ?*anyopaque,
};

pub const PHYSICAL = extern struct {
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const PHYSICAL_WITH_FLAGS = extern struct {
    Address: u64,
    BufLen: u32,
    Flags: u32,
    Buf: [1]u8,
};

pub const READ_WRITE_MSR = extern struct {
    Msr: u32,
    Value: i64,
};

pub const GET_SET_SYMPATH = extern struct {
    Args: ?[*:0]align(1) const u8,
    Result: ?PSTR,
    Length: i32,
};

pub const GET_TEB_ADDRESS = extern struct {
    Address: u64,
};

pub const GET_PEB_ADDRESS = extern struct {
    CurrentThread: u64,
    Address: u64,
};

pub const GET_CURRENT_THREAD_ADDRESS = extern struct {
    Processor: u32,
    Address: u64,
};

pub const GET_CURRENT_PROCESS_ADDRESS = extern struct {
    Processor: u32,
    CurrentThread: u64,
    Address: u64,
};

pub const GET_INPUT_LINE = extern struct {
    Prompt: ?[*:0]align(1) const u8,
    Buffer: ?PSTR,
    BufferSize: u32,
    InputSize: u32,
};

pub const GET_EXPRESSION_EX = extern struct {
    Expression: ?[*:0]align(1) const u8,
    Remainder: ?[*:0]align(1) const u8,
    Value: u64,
};

pub const TRANSLATE_VIRTUAL_TO_PHYSICAL = extern struct {
    Virtual: u64,
    Physical: u64,
};

pub const VIRTUAL_TO_PHYSICAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
    Virtual: u64,
    Physical: u64,
};

pub const PHYSICAL_TO_VIRTUAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
};

pub const GET_CONTEXT_EX = extern struct {
    Status: u32,
    ContextSize: u32,
    pContext: ?*anyopaque,
};

pub const POINTER_SEARCH_PHYSICAL = extern struct {
    Offset: u64,
    Length: u64,
    PointerMin: u64,
    PointerMax: u64,
    Flags: u32,
    MatchOffsets: ?*u64,
    MatchOffsetsSize: u32,
    MatchOffsetsCount: u32,
};

pub const WDBGEXTS_THREAD_OS_INFO = extern struct {
    ThreadId: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

pub const WDBGEXTS_CLR_DATA_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*anyopaque,
};

pub const EXT_MATCH_PATTERN_A = extern struct {
    Str: ?[*:0]align(1) const u8,
    Pattern: ?[*:0]align(1) const u8,
    CaseSensitive: u32,
};

pub const EXT_FIND_FILE = extern struct {
    FileName: ?[*:0]align(1) const u16,
    IndexedSize: u64,
    ImageTimeDateStamp: u32,
    ImageCheckSum: u32,
    ExtraInfo: ?*anyopaque,
    ExtraInfoSize: u32,
    Flags: u32,
    FileMapping: ?*anyopaque,
    FileMappingSize: u64,
    FileHandle: ?HANDLE,
    FoundFileName: ?PWSTR,
    FoundFileNameChars: u32,
};

pub const DEBUG_TYPED_DATA = extern struct {
    ModBase: u64,
    Offset: u64,
    EngineHandle: u64,
    Data: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    BaseTypeId: u32,
    Tag: u32,
    Register: u32,
    Internal: [9]u64,
};

pub const EXT_TDOP = enum(i32) {
    COPY = 0,
    RELEASE = 1,
    SET_FROM_EXPR = 2,
    SET_FROM_U64_EXPR = 3,
    GET_FIELD = 4,
    EVALUATE = 5,
    GET_TYPE_NAME = 6,
    OUTPUT_TYPE_NAME = 7,
    OUTPUT_SIMPLE_VALUE = 8,
    OUTPUT_FULL_VALUE = 9,
    HAS_FIELD = 10,
    GET_FIELD_OFFSET = 11,
    GET_ARRAY_ELEMENT = 12,
    GET_DEREFERENCE = 13,
    GET_TYPE_SIZE = 14,
    OUTPUT_TYPE_DEFINITION = 15,
    GET_POINTER_TO = 16,
    SET_FROM_TYPE_ID_AND_U64 = 17,
    SET_PTR_FROM_TYPE_ID_AND_U64 = 18,
    COUNT = 19,
};
pub const EXT_TDOP_COPY = EXT_TDOP.COPY;
pub const EXT_TDOP_RELEASE = EXT_TDOP.RELEASE;
pub const EXT_TDOP_SET_FROM_EXPR = EXT_TDOP.SET_FROM_EXPR;
pub const EXT_TDOP_SET_FROM_U64_EXPR = EXT_TDOP.SET_FROM_U64_EXPR;
pub const EXT_TDOP_GET_FIELD = EXT_TDOP.GET_FIELD;
pub const EXT_TDOP_EVALUATE = EXT_TDOP.EVALUATE;
pub const EXT_TDOP_GET_TYPE_NAME = EXT_TDOP.GET_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_TYPE_NAME = EXT_TDOP.OUTPUT_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_SIMPLE_VALUE = EXT_TDOP.OUTPUT_SIMPLE_VALUE;
pub const EXT_TDOP_OUTPUT_FULL_VALUE = EXT_TDOP.OUTPUT_FULL_VALUE;
pub const EXT_TDOP_HAS_FIELD = EXT_TDOP.HAS_FIELD;
pub const EXT_TDOP_GET_FIELD_OFFSET = EXT_TDOP.GET_FIELD_OFFSET;
pub const EXT_TDOP_GET_ARRAY_ELEMENT = EXT_TDOP.GET_ARRAY_ELEMENT;
pub const EXT_TDOP_GET_DEREFERENCE = EXT_TDOP.GET_DEREFERENCE;
pub const EXT_TDOP_GET_TYPE_SIZE = EXT_TDOP.GET_TYPE_SIZE;
pub const EXT_TDOP_OUTPUT_TYPE_DEFINITION = EXT_TDOP.OUTPUT_TYPE_DEFINITION;
pub const EXT_TDOP_GET_POINTER_TO = EXT_TDOP.GET_POINTER_TO;
pub const EXT_TDOP_SET_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_SET_PTR_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_PTR_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_COUNT = EXT_TDOP.COUNT;

pub const EXT_TYPED_DATA = extern struct {
    Operation: EXT_TDOP,
    Flags: u32,
    InData: DEBUG_TYPED_DATA,
    OutData: DEBUG_TYPED_DATA,
    InStrIndex: u32,
    In32: u32,
    Out32: u32,
    In64: u64,
    Out64: u64,
    StrBufferIndex: u32,
    StrBufferChars: u32,
    StrCharsNeeded: u32,
    DataBufferIndex: u32,
    DataBufferBytes: u32,
    DataBytesNeeded: u32,
    Status: HRESULT,
    Reserved: [8]u64,
};

pub const WDBGEXTS_QUERY_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*anyopaque,
};

pub const WDBGEXTS_DISASSEMBLE_BUFFER = extern struct {
    InOffset: u64,
    OutOffset: u64,
    AddrFlags: u32,
    FormatFlags: u32,
    DataBufferBytes: u32,
    DisasmBufferChars: u32,
    DataBuffer: ?*anyopaque,
    DisasmBuffer: ?PWSTR,
    Reserved0: [3]u64,
};

pub const WDBGEXTS_MODULE_IN_RANGE = extern struct {
    Start: u64,
    End: u64,
    FoundModBase: u64,
    FoundModSize: u32,
};

pub const DBGKD_MAJOR_TYPES = enum(i32) {
    NT = 0,
    XBOX = 1,
    BIG = 2,
    EXDI = 3,
    NTBD = 4,
    EFI = 5,
    TNT = 6,
    SINGULARITY = 7,
    HYPERVISOR = 8,
    MIDORI = 9,
    CE = 10,
    COUNT = 11,
};
pub const DBGKD_MAJOR_NT = DBGKD_MAJOR_TYPES.NT;
pub const DBGKD_MAJOR_XBOX = DBGKD_MAJOR_TYPES.XBOX;
pub const DBGKD_MAJOR_BIG = DBGKD_MAJOR_TYPES.BIG;
pub const DBGKD_MAJOR_EXDI = DBGKD_MAJOR_TYPES.EXDI;
pub const DBGKD_MAJOR_NTBD = DBGKD_MAJOR_TYPES.NTBD;
pub const DBGKD_MAJOR_EFI = DBGKD_MAJOR_TYPES.EFI;
pub const DBGKD_MAJOR_TNT = DBGKD_MAJOR_TYPES.TNT;
pub const DBGKD_MAJOR_SINGULARITY = DBGKD_MAJOR_TYPES.SINGULARITY;
pub const DBGKD_MAJOR_HYPERVISOR = DBGKD_MAJOR_TYPES.HYPERVISOR;
pub const DBGKD_MAJOR_MIDORI = DBGKD_MAJOR_TYPES.MIDORI;
pub const DBGKD_MAJOR_CE = DBGKD_MAJOR_TYPES.CE;
pub const DBGKD_MAJOR_COUNT = DBGKD_MAJOR_TYPES.COUNT;

pub const DBGKD_GET_VERSION32 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u16,
    Flags: u16,
    KernBase: u32,
    PsLoadedModuleList: u32,
    MachineType: u16,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    BreakpointWithStatus: u32,
    DebuggerDataList: u32,
};

pub const DBGKD_DEBUG_DATA_HEADER32 = extern struct {
    List: LIST_ENTRY32,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA32 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER32,
    KernBase: u32,
    BreakpointWithStatus: u32,
    SavedContext: u32,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    PsLoadedModuleList: u32,
    PsActiveProcessHead: u32,
    PspCidTable: u32,
    ExpSystemResourcesList: u32,
    ExpPagedPoolDescriptor: u32,
    ExpNumberOfPagedPools: u32,
    KeTimeIncrement: u32,
    KeBugCheckCallbackListHead: u32,
    KiBugcheckData: u32,
    IopErrorLogListHead: u32,
    ObpRootDirectoryObject: u32,
    ObpTypeObjectType: u32,
    MmSystemCacheStart: u32,
    MmSystemCacheEnd: u32,
    MmSystemCacheWs: u32,
    MmPfnDatabase: u32,
    MmSystemPtesStart: u32,
    MmSystemPtesEnd: u32,
    MmSubsectionBase: u32,
    MmNumberOfPagingFiles: u32,
    MmLowestPhysicalPage: u32,
    MmHighestPhysicalPage: u32,
    MmNumberOfPhysicalPages: u32,
    MmMaximumNonPagedPoolInBytes: u32,
    MmNonPagedSystemStart: u32,
    MmNonPagedPoolStart: u32,
    MmNonPagedPoolEnd: u32,
    MmPagedPoolStart: u32,
    MmPagedPoolEnd: u32,
    MmPagedPoolInformation: u32,
    MmPageSize: u32,
    MmSizeOfPagedPoolInBytes: u32,
    MmTotalCommitLimit: u32,
    MmTotalCommittedPages: u32,
    MmSharedCommit: u32,
    MmDriverCommit: u32,
    MmProcessCommit: u32,
    MmPagedPoolCommit: u32,
    MmExtendedCommit: u32,
    MmZeroedPageListHead: u32,
    MmFreePageListHead: u32,
    MmStandbyPageListHead: u32,
    MmModifiedPageListHead: u32,
    MmModifiedNoWritePageListHead: u32,
    MmAvailablePages: u32,
    MmResidentAvailablePages: u32,
    PoolTrackTable: u32,
    NonPagedPoolDescriptor: u32,
    MmHighestUserAddress: u32,
    MmSystemRangeStart: u32,
    MmUserProbeAddress: u32,
    KdPrintCircularBuffer: u32,
    KdPrintCircularBufferEnd: u32,
    KdPrintWritePointer: u32,
    KdPrintRolloverCount: u32,
    MmLoadedUserImageList: u32,
};

pub const DBGKD_GET_VERSION64 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u8,
    KdSecondaryVersion: u8,
    Flags: u16,
    MachineType: u16,
    MaxPacketType: u8,
    MaxStateChange: u8,
    MaxManipulate: u8,
    Simulation: u8,
    Unused: [1]u16,
    KernBase: u64,
    PsLoadedModuleList: u64,
    DebuggerDataList: u64,
};

pub const DBGKD_DEBUG_DATA_HEADER64 = extern struct {
    List: LIST_ENTRY64,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA64 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER64,
    KernBase: u64,
    BreakpointWithStatus: u64,
    SavedContext: u64,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    PsLoadedModuleList: u64,
    PsActiveProcessHead: u64,
    PspCidTable: u64,
    ExpSystemResourcesList: u64,
    ExpPagedPoolDescriptor: u64,
    ExpNumberOfPagedPools: u64,
    KeTimeIncrement: u64,
    KeBugCheckCallbackListHead: u64,
    KiBugcheckData: u64,
    IopErrorLogListHead: u64,
    ObpRootDirectoryObject: u64,
    ObpTypeObjectType: u64,
    MmSystemCacheStart: u64,
    MmSystemCacheEnd: u64,
    MmSystemCacheWs: u64,
    MmPfnDatabase: u64,
    MmSystemPtesStart: u64,
    MmSystemPtesEnd: u64,
    MmSubsectionBase: u64,
    MmNumberOfPagingFiles: u64,
    MmLowestPhysicalPage: u64,
    MmHighestPhysicalPage: u64,
    MmNumberOfPhysicalPages: u64,
    MmMaximumNonPagedPoolInBytes: u64,
    MmNonPagedSystemStart: u64,
    MmNonPagedPoolStart: u64,
    MmNonPagedPoolEnd: u64,
    MmPagedPoolStart: u64,
    MmPagedPoolEnd: u64,
    MmPagedPoolInformation: u64,
    MmPageSize: u64,
    MmSizeOfPagedPoolInBytes: u64,
    MmTotalCommitLimit: u64,
    MmTotalCommittedPages: u64,
    MmSharedCommit: u64,
    MmDriverCommit: u64,
    MmProcessCommit: u64,
    MmPagedPoolCommit: u64,
    MmExtendedCommit: u64,
    MmZeroedPageListHead: u64,
    MmFreePageListHead: u64,
    MmStandbyPageListHead: u64,
    MmModifiedPageListHead: u64,
    MmModifiedNoWritePageListHead: u64,
    MmAvailablePages: u64,
    MmResidentAvailablePages: u64,
    PoolTrackTable: u64,
    NonPagedPoolDescriptor: u64,
    MmHighestUserAddress: u64,
    MmSystemRangeStart: u64,
    MmUserProbeAddress: u64,
    KdPrintCircularBuffer: u64,
    KdPrintCircularBufferEnd: u64,
    KdPrintWritePointer: u64,
    KdPrintRolloverCount: u64,
    MmLoadedUserImageList: u64,
    NtBuildLab: u64,
    KiNormalSystemCall: u64,
    KiProcessorBlock: u64,
    MmUnloadedDrivers: u64,
    MmLastUnloadedDriver: u64,
    MmTriageActionTaken: u64,
    MmSpecialPoolTag: u64,
    KernelVerifier: u64,
    MmVerifierData: u64,
    MmAllocatedNonPagedPool: u64,
    MmPeakCommitment: u64,
    MmTotalCommitLimitMaximum: u64,
    CmNtCSDVersion: u64,
    MmPhysicalMemoryBlock: u64,
    MmSessionBase: u64,
    MmSessionSize: u64,
    MmSystemParentTablePage: u64,
    MmVirtualTranslationBase: u64,
    OffsetKThreadNextProcessor: u16,
    OffsetKThreadTeb: u16,
    OffsetKThreadKernelStack: u16,
    OffsetKThreadInitialStack: u16,
    OffsetKThreadApcProcess: u16,
    OffsetKThreadState: u16,
    OffsetKThreadBStore: u16,
    OffsetKThreadBStoreLimit: u16,
    SizeEProcess: u16,
    OffsetEprocessPeb: u16,
    OffsetEprocessParentCID: u16,
    OffsetEprocessDirectoryTableBase: u16,
    SizePrcb: u16,
    OffsetPrcbDpcRoutine: u16,
    OffsetPrcbCurrentThread: u16,
    OffsetPrcbMhz: u16,
    OffsetPrcbCpuType: u16,
    OffsetPrcbVendorString: u16,
    OffsetPrcbProcStateContext: u16,
    OffsetPrcbNumber: u16,
    SizeEThread: u16,
    L1tfHighPhysicalBitIndex: u8,
    L1tfSwizzleBitIndex: u8,
    Padding0: u32,
    KdPrintCircularBufferPtr: u64,
    KdPrintBufferSize: u64,
    KeLoaderBlock: u64,
    SizePcr: u16,
    OffsetPcrSelfPcr: u16,
    OffsetPcrCurrentPrcb: u16,
    OffsetPcrContainedPrcb: u16,
    OffsetPcrInitialBStore: u16,
    OffsetPcrBStoreLimit: u16,
    OffsetPcrInitialStack: u16,
    OffsetPcrStackLimit: u16,
    OffsetPrcbPcrPage: u16,
    OffsetPrcbProcStateSpecialReg: u16,
    GdtR0Code: u16,
    GdtR0Data: u16,
    GdtR0Pcr: u16,
    GdtR3Code: u16,
    GdtR3Data: u16,
    GdtR3Teb: u16,
    GdtLdt: u16,
    GdtTss: u16,
    Gdt64R3CmCode: u16,
    Gdt64R3CmTeb: u16,
    IopNumTriageDumpDataBlocks: u64,
    IopTriageDumpDataBlocks: u64,
    VfCrashDataBlock: u64,
    MmBadPagesDetected: u64,
    MmZeroedPageSingleBitErrorsDetected: u64,
    EtwpDebuggerData: u64,
    OffsetPrcbContext: u16,
    OffsetPrcbMaxBreakpoints: u16,
    OffsetPrcbMaxWatchpoints: u16,
    OffsetKThreadStackLimit: u32,
    OffsetKThreadStackBase: u32,
    OffsetKThreadQueueListEntry: u32,
    OffsetEThreadIrpList: u32,
    OffsetPrcbIdleThread: u16,
    OffsetPrcbNormalDpcState: u16,
    OffsetPrcbDpcStack: u16,
    OffsetPrcbIsrStack: u16,
    SizeKDPC_STACK_FRAME: u16,
    OffsetKPriQueueThreadListHead: u16,
    OffsetKThreadWaitReason: u16,
    Padding1: u16,
    PteBase: u64,
    RetpolineStubFunctionTable: u64,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
    OffsetEProcessMmHotPatchContext: u16,
    OffsetKThreadShadowStackLimit: u32,
    OffsetKThreadShadowStackBase: u32,
    ShadowStackEnabled: u64,
    PointerAuthMask: u64,
    OffsetPrcbExceptionStack: u16,
};

pub const PSYM_DUMP_FIELD_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pField: ?*FIELD_INFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        pField: ?*FIELD_INFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const FIELD_INFO = extern struct {
    pub const _BitField = extern struct {
        Position: u16,
        Size: u16,
    };
    fName: ?*u8,
    printName: ?*u8,
    size: u32,
    fOptions: u32,
    address: u64,
    Anonymous: extern union {
        fieldCallBack: ?*anyopaque,
        pBuffer: ?*anyopaque,
    },
    TypeId: u32,
    FieldOffset: u32,
    BufferSize: u32,
    BitField: _BitField,
    _bitfield: u32,
};

pub const SYM_DUMP_PARAM = extern struct {
    size: u32,
    sName: ?*u8,
    Options: u32,
    addr: u64,
    listLink: ?*FIELD_INFO,
    Anonymous: extern union {
        Context: ?*anyopaque,
        pBuffer: ?*anyopaque,
    },
    CallbackRoutine: ?PSYM_DUMP_FIELD_CALLBACK,
    nFields: u32,
    Fields: ?*FIELD_INFO,
    ModBase: u64,
    TypeId: u32,
    TypeSize: u32,
    BufferSize: u32,
    _bitfield: u32,
};

pub const DEBUG_DEVICE_OBJECT_INFO = extern struct {
    SizeOfStruct: u32,
    DevObjAddress: u64,
    ReferenceCount: u32,
    QBusy: BOOL,
    DriverObject: u64,
    CurrentIrp: u64,
    DevExtension: u64,
    DevObjExtension: u64,
};

pub const PGET_DEVICE_OBJECT_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        DeviceObject: u64,
        pDevObjInfo: ?*DEBUG_DEVICE_OBJECT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        DeviceObject: u64,
        pDevObjInfo: ?*DEBUG_DEVICE_OBJECT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_DRIVER_OBJECT_INFO = extern struct {
    SizeOfStruct: u32,
    DriverSize: u32,
    DriverObjAddress: u64,
    DriverStart: u64,
    DriverExtension: u64,
    DeviceObject: u64,
    DriverName: extern struct {
        Length: u16,
        MaximumLength: u16,
        Buffer: u64,
    },
};

pub const PGET_DRIVER_OBJECT_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        DriverObject: u64,
        pDrvObjInfo: ?*DEBUG_DRIVER_OBJECT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        DriverObject: u64,
        pDrvObjInfo: ?*DEBUG_DRIVER_OBJECT_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PROCESS_COMMIT_USAGE = extern struct {
    ImageFileName: [16]u8,
    ClientId: u64,
    ProcessAddress: u64,
    CommitCharge: u64,
    SharedCommitCharge: u64,
    ReleasedCommitDebt: u64,
    Reserved: u64,
};

pub const PGET_PROCESS_COMMIT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        TotalCommitCharge: ?*u64,
        NumberOfProcesses: ?*u32,
        CommitData: ?*?*PROCESS_COMMIT_USAGE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        TotalCommitCharge: ?*u64,
        NumberOfProcesses: ?*u32,
        CommitData: ?*?*PROCESS_COMMIT_USAGE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PGET_FULL_IMAGE_NAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Process: u64,
        FullImageName: ?*?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Process: u64,
        FullImageName: ?*?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_CPU_SPEED_INFO = extern struct {
    SizeOfStruct: u32,
    CurrentSpeed: u32,
    RatedSpeed: u32,
    NameString: [256]u16,
};

pub const PGET_CPU_PSPEED_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        pCpuSpeedInfo: ?*DEBUG_CPU_SPEED_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        pCpuSpeedInfo: ?*DEBUG_CPU_SPEED_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_CPU_MICROCODE_VERSION = extern struct {
    SizeOfStruct: u32,
    CachedSignature: i64,
    InitialSignature: i64,
    ProcessorModel: u32,
    ProcessorFamily: u32,
    ProcessorStepping: u32,
    ProcessorArchRev: u32,
};

pub const PGET_CPU_MICROCODE_VERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        pCpuMicrocodeVersion: ?*DEBUG_CPU_MICROCODE_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        pCpuMicrocodeVersion: ?*DEBUG_CPU_MICROCODE_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_SMBIOS_INFO = extern struct {
    SizeOfStruct: u32,
    SmbiosMajorVersion: u8,
    SmbiosMinorVersion: u8,
    DMIVersion: u8,
    TableSize: u32,
    BiosMajorRelease: u8,
    BiosMinorRelease: u8,
    FirmwareMajorRelease: u8,
    FirmwareMinorRelease: u8,
    BaseBoardManufacturer: [64]CHAR,
    BaseBoardProduct: [64]CHAR,
    BaseBoardVersion: [64]CHAR,
    BiosReleaseDate: [64]CHAR,
    BiosVendor: [64]CHAR,
    BiosVersion: [64]CHAR,
    SystemFamily: [64]CHAR,
    SystemManufacturer: [64]CHAR,
    SystemProductName: [64]CHAR,
    SystemSKU: [64]CHAR,
    SystemVersion: [64]CHAR,
};

pub const PGET_SMBIOS_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        pSmbiosInfo: ?*DEBUG_SMBIOS_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        pSmbiosInfo: ?*DEBUG_SMBIOS_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_IRP_STACK_INFO = extern struct {
    Major: u8,
    Minor: u8,
    DeviceObject: u64,
    FileObject: u64,
    CompletionRoutine: u64,
    StackAddress: u64,
};

pub const DEBUG_IRP_INFO = extern struct {
    SizeOfStruct: u32,
    IrpAddress: u64,
    IoStatus: u32,
    StackCount: u32,
    CurrentLocation: u32,
    MdlAddress: u64,
    Thread: u64,
    CancelRoutine: u64,
    CurrentStack: DEBUG_IRP_STACK_INFO,
    Stack: [10]DEBUG_IRP_STACK_INFO,
};

pub const PGET_IRP_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Irp: u64,
        IrpInfo: ?*DEBUG_IRP_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Irp: u64,
        IrpInfo: ?*DEBUG_IRP_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_PNP_TRIAGE_INFO = extern struct {
    SizeOfStruct: u32,
    Lock_Address: u64,
    Lock_ActiveCount: i32,
    Lock_ContentionCount: u32,
    Lock_NumberOfExclusiveWaiters: u32,
    Lock_NumberOfSharedWaiters: u32,
    Lock_Flag: u16,
    TriagedThread: u64,
    ThreadCount: i32,
    TriagedThread_WaitTime: u64,
};

pub const PGET_PNP_TRIAGE_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        pPNPTriageInfo: ?*DEBUG_PNP_TRIAGE_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        pPNPTriageInfo: ?*DEBUG_PNP_TRIAGE_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_POOL_DATA = extern struct {
    SizeofStruct: u32,
    PoolBlock: u64,
    Pool: u64,
    PreviousSize: u32,
    Size: u32,
    PoolTag: u32,
    ProcessBilled: u64,
    Anonymous: extern union {
        Anonymous: extern struct {
            _bitfield: u32,
        },
        AsUlong: u32,
    },
    Reserved2: [4]u64,
    PoolTagDescription: [64]CHAR,
};

pub const PGET_POOL_DATA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Pool: u64,
        PoolData: ?*DEBUG_POOL_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Pool: u64,
        PoolData: ?*DEBUG_POOL_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_POOL_REGION = enum(i32) {
    Unknown = 0,
    Special = 1,
    Paged = 2,
    NonPaged = 3,
    NonPagedExpansion = 4,
    SessionPaged = 5,
    Max = 6,
};
pub const DbgPoolRegionUnknown = DEBUG_POOL_REGION.Unknown;
pub const DbgPoolRegionSpecial = DEBUG_POOL_REGION.Special;
pub const DbgPoolRegionPaged = DEBUG_POOL_REGION.Paged;
pub const DbgPoolRegionNonPaged = DEBUG_POOL_REGION.NonPaged;
pub const DbgPoolRegionNonPagedExpansion = DEBUG_POOL_REGION.NonPagedExpansion;
pub const DbgPoolRegionSessionPaged = DEBUG_POOL_REGION.SessionPaged;
pub const DbgPoolRegionMax = DEBUG_POOL_REGION.Max;

pub const PGET_POOL_REGION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Pool: u64,
        PoolRegion: ?*DEBUG_POOL_REGION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Pool: u64,
        PoolRegion: ?*DEBUG_POOL_REGION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXT_THREAD_FIND_PARAMS = extern struct {
    SizeofStruct: u32,
    StackPointer: u64,
    Cid: u32,
    Thread: u64,
};

pub const PFIND_MATCHING_THREAD = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        ThreadInfo: ?*KDEXT_THREAD_FIND_PARAMS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        ThreadInfo: ?*KDEXT_THREAD_FIND_PARAMS,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXT_PROCESS_FIND_PARAMS = extern struct {
    SizeofStruct: u32,
    Pid: u32,
    Session: u32,
    ImageName: ?[*]align(1) u8,
};

pub const PFIND_MATCHING_PROCESS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        ProcessInfo: ?*KDEXT_PROCESS_FIND_PARAMS,
        Process: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        ProcessInfo: ?*KDEXT_PROCESS_FIND_PARAMS,
        Process: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXTS_JOB_PROCESS_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Job: u64,
        Process: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
    else => *const fn(
        Job: u64,
        Process: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
} ;

pub const PENUMERATE_JOB_PROCESSES = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Job: u64,
        Callback: ?EXTS_JOB_PROCESS_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Job: u64,
        Callback: ?EXTS_JOB_PROCESS_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXTS_TABLE_ENTRY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Entry: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
    else => *const fn(
        Entry: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
} ;

pub const PENUMERATE_HASH_TABLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        HashTable: u64,
        Callback: ?EXTS_TABLE_ENTRY_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        HashTable: u64,
        Callback: ?EXTS_TABLE_ENTRY_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXT_HANDLE_INFORMATION = extern struct {
    HandleTableEntry: u64,
    Handle: u64,
    Object: u64,
    ObjectBody: u64,
    GrantedAccess: u64,
    HandleAttributes: u32,
    PagedOut: BOOLEAN,
};

pub const KDEXT_DUMP_HANDLE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        HandleInfo: ?*KDEXT_HANDLE_INFORMATION,
        Flags: u32,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
    else => *const fn(
        HandleInfo: ?*KDEXT_HANDLE_INFORMATION,
        Flags: u32,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOLEAN,
} ;

pub const PENUMERATE_HANDLES = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Process: u64,
        HandleToDump: u64,
        Flags: u32,
        Callback: ?KDEXT_DUMP_HANDLE_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Process: u64,
        HandleToDump: u64,
        Flags: u32,
        Callback: ?KDEXT_DUMP_HANDLE_CALLBACK,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXT_FILELOCK_OWNER = extern struct {
    Sizeofstruct: u32,
    FileObject: u64,
    OwnerThread: u64,
    WaitIrp: u64,
    DeviceObject: u64,
    BlockingDirver: [32]CHAR,
};

pub const PFIND_FILELOCK_OWNERINFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        pFileLockOwner: ?*KDEXT_FILELOCK_OWNER,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        pFileLockOwner: ?*KDEXT_FILELOCK_OWNER,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXTS_LOCK_INFO = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    OwningThread: u64,
    ExclusiveOwned: BOOL,
    NumOwners: u32,
    ContentionCount: u32,
    NumExclusiveWaiters: u32,
    NumSharedWaiters: u32,
    pOwnerThreads: ?*u64,
    pWaiterThreads: ?*u64,
};

pub const KDEXTS_LOCK_CALLBACKROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pLock: ?*KDEXTS_LOCK_INFO,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pLock: ?*KDEXTS_LOCK_INFO,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PENUMERATE_SYSTEM_LOCKS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Callback: ?KDEXTS_LOCK_CALLBACKROUTINE,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Flags: u32,
        Callback: ?KDEXTS_LOCK_CALLBACKROUTINE,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const KDEXTS_PTE_INFO = extern struct {
    SizeOfStruct: u32,
    VirtualAddress: u64,
    PpeAddress: u64,
    PdeAddress: u64,
    PteAddress: u64,
    Pfn: u64,
    Levels: u64,
    _bitfield1: u32,
    _bitfield2: u32,
};

pub const PKDEXTS_GET_PTE_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Virtual: u64,
        PteInfo: ?*KDEXTS_PTE_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Virtual: u64,
        PteInfo: ?*KDEXTS_PTE_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_POOLTAG_DESCRIPTION = extern struct {
    SizeOfStruct: u32,
    PoolTag: u32,
    Description: [260]CHAR,
    Binary: [32]CHAR,
    Owner: [32]CHAR,
};

pub const PGET_POOL_TAG_DESCRIPTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        PoolTag: u32,
        pDescription: ?*DEBUG_POOLTAG_DESCRIPTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        PoolTag: u32,
        pDescription: ?*DEBUG_POOLTAG_DESCRIPTION,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_FAILURE_TYPE = enum(i32) {
    UNKNOWN = 0,
    KERNEL = 1,
    USER = 2,
};
pub const DEBUG_FLR_UNKNOWN = DEBUG_FAILURE_TYPE.UNKNOWN;
pub const DEBUG_FLR_KERNEL = DEBUG_FAILURE_TYPE.KERNEL;
pub const DEBUG_FLR_USER = DEBUG_FAILURE_TYPE.USER;

pub const DEBUG_FLR_PARAM_TYPE = enum(i32) {
    INVALID = 0,
    RESERVED = 1,
    DRIVER_OBJECT = 2,
    DEVICE_OBJECT = 3,
    INVALID_PFN = 4,
    WORKER_ROUTINE = 5,
    WORK_ITEM = 6,
    INVALID_DPC_FOUND = 7,
    PROCESS_OBJECT = 8,
    FAILED_INSTRUCTION_ADDRESS = 9,
    LAST_CONTROL_TRANSFER = 10,
    ACPI_EXTENSION = 11,
    ACPI_RESCONFLICT = 12,
    ACPI_OBJECT = 13,
    READ_ADDRESS = 14,
    WRITE_ADDRESS = 15,
    CRITICAL_SECTION = 16,
    BAD_HANDLE = 17,
    INVALID_HEAP_ADDRESS = 18,
    CHKIMG_EXTENSION = 19,
    USBPORT_OCADATA = 20,
    WORK_QUEUE_ITEM = 21,
    ERESOURCE_ADDRESS = 22,
    PNP_TRIAGE_DATA_DEPRECATED = 23,
    HANDLE_VALUE = 24,
    WHEA_ERROR_RECORD = 25,
    VERIFIER_FOUND_DEADLOCK = 26,
    PG_MISMATCH = 27,
    DEVICE_NODE = 28,
    POWERREQUEST_ADDRESS = 29,
    EXECUTE_ADDRESS = 30,
    IRP_ADDRESS = 256,
    IRP_MAJOR_FN = 257,
    IRP_MINOR_FN = 258,
    IRP_CANCEL_ROUTINE = 259,
    IOSB_ADDRESS = 260,
    INVALID_USEREVENT = 261,
    VIDEO_TDR_CONTEXT = 262,
    VERIFIER_DRIVER_ENTRY = 263,
    PNP_IRP_ADDRESS_DEPRECATED = 264,
    PREVIOUS_MODE = 265,
    CURRENT_IRQL = 512,
    PREVIOUS_IRQL = 513,
    REQUESTED_IRQL = 514,
    ASSERT_DATA = 768,
    ASSERT_FILE = 769,
    EXCEPTION_PARAMETER1 = 770,
    EXCEPTION_PARAMETER2 = 771,
    EXCEPTION_PARAMETER3 = 772,
    EXCEPTION_PARAMETER4 = 773,
    EXCEPTION_RECORD = 774,
    IO_ERROR_CODE = 775,
    EXCEPTION_STR = 776,
    EXCEPTION_DOESNOT_MATCH_CODE = 777,
    ASSERT_INSTRUCTION = 778,
    POOL_ADDRESS = 1024,
    SPECIAL_POOL_CORRUPTION_TYPE = 1025,
    CORRUPTING_POOL_ADDRESS = 1026,
    CORRUPTING_POOL_TAG = 1027,
    FREED_POOL_TAG = 1028,
    LEAKED_SESSION_POOL_TAG = 1029,
    INSTR_SESSION_POOL_TAG = 1030,
    CLIENT_DRIVER = 1031,
    FILE_ID = 1280,
    FILE_LINE = 1281,
    BUGCHECK_STR = 1536,
    BUGCHECK_SPECIFIER = 1537,
    BUGCHECK_DESC = 1538,
    MANAGED_CODE = 1792,
    MANAGED_OBJECT = 1793,
    MANAGED_EXCEPTION_OBJECT = 1794,
    MANAGED_EXCEPTION_MESSAGE_deprecated = 1795,
    MANAGED_STACK_STRING = 1796,
    MANAGED_BITNESS_MISMATCH = 1797,
    MANAGED_OBJECT_NAME = 1798,
    MANAGED_EXCEPTION_CONTEXT_MESSAGE = 1799,
    MANAGED_STACK_COMMAND = 1800,
    MANAGED_KERNEL_DEBUGGER = 1801,
    MANAGED_HRESULT_STRING = 1802,
    MANAGED_ENGINE_MODULE = 1803,
    MANAGED_ANALYSIS_PROVIDER = 1804,
    MANAGED_EXCEPTION_ADDRESS = 2048,
    MANAGED_EXCEPTION_HRESULT = 2049,
    MANAGED_EXCEPTION_TYPE = 2050,
    MANAGED_EXCEPTION_MESSAGE = 2051,
    MANAGED_EXCEPTION_CALLSTACK = 2052,
    MANAGED_EXCEPTION_INNER_ADDRESS = 2064,
    MANAGED_EXCEPTION_INNER_HRESULT = 2065,
    MANAGED_EXCEPTION_INNER_TYPE = 2066,
    MANAGED_EXCEPTION_INNER_MESSAGE = 2067,
    MANAGED_EXCEPTION_INNER_CALLSTACK = 2068,
    MANAGED_EXCEPTION_NESTED_ADDRESS = 2080,
    MANAGED_EXCEPTION_NESTED_HRESULT = 2081,
    MANAGED_EXCEPTION_NESTED_TYPE = 2082,
    MANAGED_EXCEPTION_NESTED_MESSAGE = 2083,
    MANAGED_EXCEPTION_NESTED_CALLSTACK = 2084,
    MANAGED_EXCEPTION_CMD = 2288,
    MANAGED_THREAD_ID = 2304,
    MANAGED_THREAD_CMD_CALLSTACK = 2544,
    MANAGED_THREAD_CMD_STACKOBJECTS = 2545,
    DRIVER_VERIFIER_IO_VIOLATION_TYPE = 4096,
    EXCEPTION_CODE = 4097,
    EXCEPTION_CODE_STR = 4098,
    IOCONTROL_CODE = 4099,
    MM_INTERNAL_CODE = 4100,
    DRVPOWERSTATE_SUBCODE = 4101,
    STATUS_CODE = 4102,
    SYMBOL_STACK_INDEX = 4103,
    SYMBOL_ON_RAW_STACK = 4104,
    SECURITY_COOKIES = 4105,
    THREADPOOL_WAITER = 4106,
    TARGET_MODE = 4107,
    BUGCHECK_CODE = 4108,
    BADPAGES_DETECTED = 4109,
    DPC_TIMEOUT_TYPE = 4110,
    DPC_RUNTIME = 4111,
    DPC_TIMELIMIT = 4112,
    DUMP_FILE_ATTRIBUTES = 4113,
    PAGE_HASH_ERRORS = 4114,
    BUGCHECK_P1 = 4115,
    BUGCHECK_P2 = 4116,
    BUGCHECK_P3 = 4117,
    BUGCHECK_P4 = 4118,
    CRITICAL_PROCESS = 4119,
    RESOURCE_CALL_TYPE = 4352,
    RESOURCE_CALL_TYPE_STR = 4353,
    CORRUPT_MODULE_LIST = 8192,
    BAD_STACK = 8193,
    ZEROED_STACK = 8194,
    WRONG_SYMBOLS = 8195,
    FOLLOWUP_DRIVER_ONLY = 8196,
    UNUSED001 = 8197,
    CPU_OVERCLOCKED = 8198,
    POSSIBLE_INVALID_CONTROL_TRANSFER = 8199,
    POISONED_TB = 8200,
    UNKNOWN_MODULE = 8201,
    ANALYZABLE_POOL_CORRUPTION = 8202,
    SINGLE_BIT_ERROR = 8203,
    TWO_BIT_ERROR = 8204,
    INVALID_KERNEL_CONTEXT = 8205,
    DISK_HARDWARE_ERROR = 8206,
    SHOW_ERRORLOG = 8207,
    MANUAL_BREAKIN = 8208,
    HANG = 8209,
    BAD_MEMORY_REFERENCE = 8210,
    BAD_OBJECT_REFERENCE = 8211,
    APPKILL = 8212,
    SINGLE_BIT_PFN_PAGE_ERROR = 8213,
    HARDWARE_ERROR = 8214,
    NO_IMAGE_IN_BUCKET = 8215,
    NO_BUGCHECK_IN_BUCKET = 8216,
    SKIP_STACK_ANALYSIS = 8217,
    INVALID_OPCODE = 8218,
    ADD_PROCESS_IN_BUCKET = 8219,
    RAISED_IRQL_USER_FAULT = 8220,
    USE_DEFAULT_CONTEXT = 8221,
    BOOST_FOLLOWUP_TO_SPECIFIC = 8222,
    SWITCH_PROCESS_CONTEXT = 8223,
    VERIFIER_STOP = 8224,
    USERBREAK_PEB_PAGEDOUT = 8225,
    MOD_SPECIFIC_DATA_ONLY = 8226,
    OVERLAPPED_MODULE = 8227,
    CPU_MICROCODE_ZERO_INTEL = 8228,
    INTEL_CPU_BIOS_UPGRADE_NEEDED = 8229,
    OVERLAPPED_UNLOADED_MODULE = 8230,
    INVALID_USER_CONTEXT = 8231,
    MILCORE_BREAK = 8232,
    NO_IMAGE_TIMESTAMP_IN_BUCKET = 8233,
    KERNEL_VERIFIER_ENABLED = 8234,
    SKIP_CORRUPT_MODULE_DETECTION = 8235,
    GSFAILURE_FALSE_POSITIVE = 8236,
    IGNORE_LARGE_MODULE_CORRUPTION = 8237,
    IGNORE_BUCKET_ID_OFFSET = 8238,
    NO_ARCH_IN_BUCKET = 8239,
    IGNORE_MODULE_HARDWARE_ID = 8240,
    ARM_WRITE_AV_CAVEAT = 8241,
    ON_DPC_STACK = 8242,
    LIVE_KERNEL_DUMP = 8243,
    COVERAGE_BUILD = 8244,
    POSSIBLE_STACK_OVERFLOW = 8245,
    WRONG_SYMBOLS_TIMESTAMP = 8246,
    WRONG_SYMBOLS_SIZE = 8247,
    MISSING_IMPORTANT_SYMBOL = 8248,
    MISSING_CLR_SYMBOL = 8249,
    TARGET_TIME = 8250,
    LOW_SYSTEM_COMMIT = 8251,
    LEGACY_PAGE_TABLE_ACCESS = 8252,
    HIGH_PROCESS_COMMIT = 8253,
    HIGH_SERVICE_COMMIT = 8254,
    HIGH_NONPAGED_POOL_USAGE = 8255,
    HIGH_PAGED_POOL_USAGE = 8256,
    HIGH_SHARED_COMMIT_USAGE = 8257,
    APPS_NOT_TERMINATED = 8258,
    POOL_CORRUPTOR = 12288,
    MEMORY_CORRUPTOR = 12289,
    UNALIGNED_STACK_POINTER = 12290,
    OS_VERSION_deprecated = 12291,
    BUGCHECKING_DRIVER = 12292,
    SOLUTION_ID = 12293,
    DEFAULT_SOLUTION_ID = 12294,
    SOLUTION_TYPE = 12295,
    RECURRING_STACK = 12296,
    FAULTING_INSTR_CODE = 12297,
    SYSTEM_LOCALE_deprecated = 12298,
    CUSTOMER_CRASH_COUNT = 12299,
    TRAP_FRAME_RECURSION = 12300,
    STACK_OVERFLOW = 12301,
    STACK_POINTER_ERROR = 12302,
    STACK_POINTER_ONEBIT_ERROR = 12303,
    STACK_POINTER_MISALIGNED = 12304,
    INSTR_POINTER_MISALIGNED = 12305,
    INSTR_POINTER_CLIFAULT = 12306,
    REGISTRYTXT_STRESS_ID = 12307,
    CORRUPT_SERVICE_TABLE = 12308,
    LOP_STACKHASH = 12309,
    GSFAILURE_FUNCTION = 12310,
    GSFAILURE_MODULE_COOKIE = 12311,
    GSFAILURE_FRAME_COOKIE = 12312,
    GSFAILURE_FRAME_COOKIE_COMPLEMENT = 12313,
    GSFAILURE_CORRUPTED_COOKIE = 12314,
    GSFAILURE_CORRUPTED_EBP = 12315,
    GSFAILURE_OVERRUN_LOCAL = 12316,
    GSFAILURE_OVERRUN_LOCAL_NAME = 12317,
    GSFAILURE_CORRUPTED_EBPESP = 12318,
    GSFAILURE_POSITIVELY_CORRUPTED_EBPESP = 12319,
    GSFAILURE_MEMORY_READ_ERROR = 12320,
    GSFAILURE_PROBABLY_NOT_USING_GS = 12321,
    GSFAILURE_POSITIVE_BUFFER_OVERFLOW = 12322,
    GSFAILURE_ANALYSIS_TEXT = 12323,
    GSFAILURE_OFF_BY_ONE_OVERRUN = 12324,
    GSFAILURE_RA_SMASHED = 12325,
    GSFAILURE_NOT_UP2DATE = 12326,
    GSFAILURE_UP2DATE_UNKNOWN = 12327,
    TRIAGER_OS_BUILD_NAME = 12328,
    CPU_MICROCODE_VERSION = 12329,
    CPU_COUNT = 12330,
    CPU_SPEED = 12331,
    CPU_VENDOR = 12332,
    CPU_FAMILY = 12333,
    CPU_MODEL = 12334,
    CPU_STEPPING = 12335,
    INSTR_POINTER_ON_STACK = 12336,
    INSTR_POINTER_ON_HEAP = 12337,
    EVENT_CODE_DATA_MISMATCH = 12338,
    PROCESSOR_INFO = 12339,
    INSTR_POINTER_IN_UNLOADED_MODULE = 12340,
    MEMDIAG_LASTRUN_STATUS = 12341,
    MEMDIAG_LASTRUN_TIME = 12342,
    INSTR_POINTER_IN_FREE_BLOCK = 12343,
    INSTR_POINTER_IN_RESERVED_BLOCK = 12344,
    INSTR_POINTER_IN_VM_MAPPED_MODULE = 12345,
    INSTR_POINTER_IN_MODULE_NOT_IN_LIST = 12346,
    INSTR_POINTER_NOT_IN_STREAM = 12347,
    MEMORY_CORRUPTION_SIGNATURE = 12348,
    BUILDNAME_IN_BUCKET = 12349,
    CANCELLATION_NOT_SUPPORTED = 12350,
    DETOURED_IMAGE = 12351,
    EXCEPTION_CONTEXT_RECURSION = 12352,
    DISKIO_READ_FAILURE = 12353,
    DISKIO_WRITE_FAILURE = 12354,
    GSFAILURE_MISSING_ESTABLISHER_FRAME = 12355,
    GSFAILURE_COOKIES_MATCH_EXH = 12356,
    GSFAILURE_MANAGED = 12357,
    MANAGED_FRAME_CHAIN_CORRUPTION = 12358,
    GSFAILURE_MANAGED_THREADID = 12359,
    GSFAILURE_MANAGED_FRAMEID = 12360,
    STACKUSAGE_IMAGE = 12361,
    STACKUSAGE_IMAGE_SIZE = 12362,
    STACKUSAGE_FUNCTION = 12363,
    STACKUSAGE_FUNCTION_SIZE = 12364,
    STACKUSAGE_RECURSION_COUNT = 12365,
    XBOX_SYSTEM_UPTIME = 12366,
    XBOX_SYSTEM_CRASHTIME = 12367,
    XBOX_LIVE_ENVIRONMENT = 12368,
    LARGE_TICK_INCREMENT = 12369,
    INSTR_POINTER_IN_PAGED_CODE = 12370,
    SERVICETABLE_MODIFIED = 12371,
    ALUREON = 12372,
    INTERNAL_RAID_BUG = 16384,
    INTERNAL_BUCKET_URL = 16385,
    INTERNAL_SOLUTION_TEXT = 16386,
    INTERNAL_BUCKET_HITCOUNT = 16387,
    INTERNAL_RAID_BUG_DATABASE_STRING = 16388,
    INTERNAL_BUCKET_CONTINUABLE = 16389,
    INTERNAL_BUCKET_STATUS_TEXT = 16390,
    WATSON_MODULE = 16640,
    WATSON_MODULE_VERSION = 16641,
    WATSON_MODULE_OFFSET = 16642,
    WATSON_PROCESS_VERSION = 16643,
    WATSON_IBUCKET = 16644,
    WATSON_MODULE_TIMESTAMP = 16645,
    WATSON_PROCESS_TIMESTAMP = 16646,
    WATSON_GENERIC_EVENT_NAME = 16647,
    WATSON_GENERIC_BUCKETING_00 = 16648,
    WATSON_GENERIC_BUCKETING_01 = 16649,
    WATSON_GENERIC_BUCKETING_02 = 16650,
    WATSON_GENERIC_BUCKETING_03 = 16651,
    WATSON_GENERIC_BUCKETING_04 = 16652,
    WATSON_GENERIC_BUCKETING_05 = 16653,
    WATSON_GENERIC_BUCKETING_06 = 16654,
    WATSON_GENERIC_BUCKETING_07 = 16655,
    WATSON_GENERIC_BUCKETING_08 = 16656,
    WATSON_GENERIC_BUCKETING_09 = 16657,
    SYSXML_LOCALEID = 16896,
    SYSXML_CHECKSUM = 16897,
    WQL_EVENT_COUNT = 16898,
    WQL_EVENTLOG_INFO = 16899,
    SYSINFO_SYSTEM_MANUFACTURER = 17152,
    SYSINFO_SYSTEM_PRODUCT = 17153,
    SYSINFO_SYSTEM_SKU = 17154,
    SYSINFO_SYSTEM_VERSION = 17155,
    SYSINFO_BASEBOARD_MANUFACTURER = 17156,
    SYSINFO_BASEBOARD_PRODUCT = 17157,
    SYSINFO_BASEBOARD_VERSION = 17158,
    SYSINFO_BIOS_VENDOR = 17159,
    SYSINFO_BIOS_VERSION = 17160,
    SYSINFO_BIOS_DATE = 17161,
    VIRTUAL_MACHINE = 17162,
    SERVICE = 20480,
    SERVICE_NAME = 20481,
    SERVICE_GROUP = 20482,
    SERVICE_DISPLAYNAME = 20483,
    SERVICE_DESCRIPTION = 20484,
    SERVICE_DEPENDONSERVICE = 20485,
    SERVICE_DEPENDONGROUP = 20486,
    SVCHOST = 20736,
    SVCHOST_GROUP = 20737,
    SVCHOST_IMAGEPATH = 20738,
    SVCHOST_SERVICEDLL = 20739,
    SCM = 20992,
    SCM_BLACKBOX = 21232,
    SCM_BLACKBOX_ENTRY = 21233,
    SCM_BLACKBOX_ENTRY_CONTROLCODE = 21234,
    SCM_BLACKBOX_ENTRY_STARTTIME = 21235,
    SCM_BLACKBOX_ENTRY_SERVICENAME = 21236,
    ACPI = 24576,
    ACPI_BLACKBOX = 24832,
    PO_BLACKBOX = 24833,
    BOOTSTAT = 28672,
    BOOTSTAT_BLACKBOX = 28928,
    STORAGE = 29696,
    STORAGE_ORGID = 29697,
    STORAGE_MODEL = 29698,
    STORAGE_MFGID = 29699,
    STORAGE_ISSUEDESCSTRING = 29700,
    STORAGE_PUBLIC_TOTSIZE = 29701,
    STORAGE_PUBLIC_OFFSET = 29702,
    STORAGE_PUBLIC_DATASIZE = 29703,
    STORAGE_PRIVATE_TOTSIZE = 29704,
    STORAGE_PRIVATE_OFFSET = 29705,
    STORAGE_PRIVATE_DATASIZE = 29706,
    STORAGE_TOTALSIZE = 29707,
    STORAGE_REASON = 29708,
    STORAGE_BLACKBOX = 29936,
    FILESYSTEMS_NTFS = 30208,
    FILESYSTEMS_NTFS_BLACKBOX = 30448,
    FILESYSTEMS_REFS = 30720,
    FILESYSTEMS_REFS_BLACKBOX = 30960,
    PNP = 32768,
    PNP_TRIAGE_DATA = 32769,
    PNP_IRP_ADDRESS = 32770,
    PNP_BLACKBOX = 33024,
    BUCKET_ID = 65536,
    IMAGE_NAME = 65537,
    SYMBOL_NAME = 65538,
    FOLLOWUP_NAME = 65539,
    STACK_COMMAND = 65540,
    STACK_TEXT = 65541,
    MODULE_NAME = 65542,
    FIXED_IN_OSVERSION = 65543,
    DEFAULT_BUCKET_ID = 65544,
    MODULE_BUCKET_ID = 65545,
    ADDITIONAL_DEBUGTEXT = 65546,
    PROCESS_NAME = 65547,
    USER_NAME = 65548,
    MARKER_FILE = 65549,
    INTERNAL_RESPONSE = 65550,
    CONTEXT_RESTORE_COMMAND = 65551,
    DRIVER_HARDWAREID = 65552,
    DRIVER_HARDWARE_VENDOR_ID = 65553,
    DRIVER_HARDWARE_DEVICE_ID = 65554,
    DRIVER_HARDWARE_SUBSYS_ID = 65555,
    DRIVER_HARDWARE_REV_ID = 65556,
    DRIVER_HARDWARE_ID_BUS_TYPE = 65557,
    MARKER_MODULE_FILE = 65558,
    BUGCHECKING_DRIVER_IDTAG = 65559,
    MARKER_BUCKET = 65560,
    FAILURE_BUCKET_ID = 65561,
    DRIVER_XML_DESCRIPTION = 65562,
    DRIVER_XML_PRODUCTNAME = 65563,
    DRIVER_XML_MANUFACTURER = 65564,
    DRIVER_XML_VERSION = 65565,
    BUILD_VERSION_STRING = 65566,
    BUILD_OS_FULL_VERSION_STRING = 65567,
    ORIGINAL_CAB_NAME = 65568,
    FAULTING_SOURCE_CODE = 65569,
    FAULTING_SERVICE_NAME = 65570,
    FILE_IN_CAB = 65571,
    UNRESPONSIVE_UI_SYMBOL_NAME = 65572,
    UNRESPONSIVE_UI_FOLLOWUP_NAME = 65573,
    UNRESPONSIVE_UI_STACK = 65574,
    PROCESS_PRODUCTNAME = 65575,
    MODULE_PRODUCTNAME = 65576,
    COLLECT_DATA_FOR_BUCKET = 65577,
    COMPUTER_NAME = 65578,
    IMAGE_CLASS = 65579,
    SYMBOL_ROUTINE_NAME = 65580,
    HARDWARE_BUCKET_TAG = 65581,
    KERNEL_LOG_PROCESS_NAME = 65582,
    KERNEL_LOG_STATUS = 65583,
    REGISTRYTXT_SOURCE = 65584,
    FAULTING_SOURCE_LINE = 65585,
    FAULTING_SOURCE_FILE = 65586,
    FAULTING_SOURCE_LINE_NUMBER = 65587,
    SKIP_MODULE_SPECIFIC_BUCKET_INFO = 65588,
    BUCKET_ID_FUNC_OFFSET = 65589,
    XHCI_FIRMWARE_VERSION = 65590,
    FAILURE_ANALYSIS_SOURCE = 65591,
    FAILURE_ID_HASH = 65592,
    FAILURE_ID_HASH_STRING = 65593,
    FAILURE_ID_REPORT_LINK = 65594,
    HOLDINFO = 65595,
    HOLDINFO_ACTIVE_HOLD_COUNT = 65596,
    HOLDINFO_TENET_SOCRE = 65597,
    HOLDINFO_HISTORIC_HOLD_COUNT = 65598,
    HOLDINFO_ALWAYS_IGNORE = 65599,
    HOLDINFO_ALWAYS_HOLD = 65600,
    HOLDINFO_MAX_HOLD_LIMIT = 65601,
    HOLDINFO_MANUAL_HOLD = 65602,
    HOLDINFO_NOTIFICATION_ALIASES = 65603,
    HOLDINFO_LAST_SEEN_HOLD_DATE = 65604,
    HOLDINFO_RECOMMEND_HOLD = 65605,
    FAILURE_PROBLEM_CLASS = 65606,
    FAILURE_EXCEPTION_CODE = 65607,
    FAILURE_IMAGE_NAME = 65608,
    FAILURE_FUNCTION_NAME = 65609,
    FAILURE_SYMBOL_NAME = 65610,
    FOLLOWUP_BEFORE_RETRACER = 65611,
    END_MESSAGE = 65612,
    FEATURE_PATH = 65613,
    USER_MODE_BUCKET = 65614,
    USER_MODE_BUCKET_INDEX = 65615,
    USER_MODE_BUCKET_EVENTTYPE = 65616,
    USER_MODE_BUCKET_REPORTGUID = 65617,
    USER_MODE_BUCKET_REPORTCREATIONTIME = 65618,
    USER_MODE_BUCKET_P0 = 65619,
    USER_MODE_BUCKET_P1 = 65620,
    USER_MODE_BUCKET_P2 = 65621,
    USER_MODE_BUCKET_P3 = 65622,
    USER_MODE_BUCKET_P4 = 65623,
    USER_MODE_BUCKET_P5 = 65624,
    USER_MODE_BUCKET_P6 = 65625,
    USER_MODE_BUCKET_P7 = 65626,
    USER_MODE_BUCKET_STRING = 65627,
    CRITICAL_PROCESS_REPORTGUID = 65628,
    FAILURE_MODULE_NAME = 65629,
    PLATFORM_BUCKET_STRING = 65630,
    DRIVER_HARDWARE_VENDOR_NAME = 65631,
    DRIVER_HARDWARE_SUBVENDOR_NAME = 65632,
    DRIVER_HARDWARE_DEVICE_NAME = 65633,
    FAULTING_SOURCE_COMMIT_ID = 65634,
    FAULTING_SOURCE_CONTROL_TYPE = 65635,
    FAULTING_SOURCE_PROJECT = 65636,
    FAULTING_SOURCE_REPO_ID = 65637,
    FAULTING_SOURCE_REPO_URL = 65638,
    FAULTING_SOURCE_SRV_COMMAND = 65639,
    USERMODE_DATA = 1048576,
    THREAD_ATTRIBUTES = 1048577,
    PROBLEM_CLASSES = 1048578,
    PRIMARY_PROBLEM_CLASS = 1048579,
    PRIMARY_PROBLEM_CLASS_DATA = 1048580,
    UNRESPONSIVE_UI_PROBLEM_CLASS = 1048581,
    UNRESPONSIVE_UI_PROBLEM_CLASS_DATA = 1048582,
    DERIVED_WAIT_CHAIN = 1048583,
    HANG_DATA_NEEDED = 1048584,
    PROBLEM_CODE_PATH_HASH = 1048585,
    SUSPECT_CODE_PATH_HASH = 1048586,
    LOADERLOCK_IN_WAIT_CHAIN = 1048587,
    XPROC_HANG = 1048588,
    DEADLOCK_INPROC = 1048589,
    DEADLOCK_XPROC = 1048590,
    WCT_XML_AVAILABLE = 1048591,
    XPROC_DUMP_AVAILABLE = 1048592,
    DESKTOP_HEAP_MISSING = 1048593,
    HANG_REPORT_THREAD_IS_IDLE = 1048594,
    FAULT_THREAD_SHA1_HASH_MF = 1048595,
    FAULT_THREAD_SHA1_HASH_MFO = 1048596,
    FAULT_THREAD_SHA1_HASH_M = 1048597,
    WAIT_CHAIN_COMMAND = 1048598,
    NTGLOBALFLAG = 1048599,
    APPVERIFERFLAGS = 1048600,
    MODLIST_SHA1_HASH = 1048601,
    DUMP_TYPE = 1048602,
    XCS_PATH = 1048603,
    LOADERLOCK_OWNER_API = 1048604,
    LOADERLOCK_BLOCKED_API = 1048605,
    MODLIST_TSCHKSUM_SHA1_HASH = 1048606,
    MODLIST_UNLOADED_SHA1_HASH = 1048607,
    MACHINE_INFO_SHA1_HASH = 1048608,
    URLS_DISCOVERED = 1048609,
    URLS = 1048610,
    URL_ENTRY = 1048611,
    WATSON_IBUCKET_S1_RESP = 1048612,
    WATSON_IBUCKETTABLE_S1_RESP = 1048613,
    SEARCH_HANG = 1048614,
    WER_DATA_COLLECTION_INFO = 1048615,
    WER_MACHINE_ID = 1048616,
    ULS_SCRIPT_EXCEPTION = 1048617,
    LCIE_ISO_AVAILABLE = 1048618,
    SHOW_LCIE_ISO_DATA = 1048619,
    URL_LCIE_ENTRY = 1048620,
    URL_URLMON_ENTRY = 1048621,
    URL_XMLHTTPREQ_SYNC_ENTRY = 1048622,
    FAULTING_LOCAL_VARIABLE_NAME = 1048623,
    MODULE_LIST = 1048624,
    DUMP_FLAGS = 1048625,
    APPLICATION_VERIFIER_LOADED = 1048626,
    DUMP_CLASS = 1048627,
    DUMP_QUALIFIER = 1048628,
    KM_MODULE_LIST = 1048629,
    EXCEPTION_CODE_STR_deprecated = 1052672,
    BUCKET_ID_PREFIX_STR = 1052673,
    BUCKET_ID_MODULE_STR = 1052674,
    BUCKET_ID_MODVER_STR = 1052675,
    BUCKET_ID_FUNCTION_STR = 1052676,
    BUCKET_ID_OFFSET = 1052677,
    OS_BUILD = 1052678,
    OS_SERVICEPACK = 1052679,
    OS_BRANCH = 1052680,
    OS_BUILD_TIMESTAMP_LAB = 1052681,
    OS_VERSION = 1052682,
    BUCKET_ID_TIMEDATESTAMP = 1052683,
    BUCKET_ID_CHECKSUM = 1052684,
    OS_FLAVOR = 1052685,
    BUCKET_ID_FLAVOR_STR = 1052686,
    OS_SKU = 1052687,
    OS_PRODUCT_TYPE = 1052688,
    OS_SUITE_MASK = 1052689,
    USER_LCID = 1052690,
    OS_REVISION = 1052691,
    OS_NAME = 1052692,
    OS_NAME_EDITION = 1052693,
    OS_PLATFORM_ARCH = 1052694,
    OS_SERVICEPACK_deprecated = 1052695,
    OS_LOCALE = 1052696,
    OS_BUILD_TIMESTAMP_ISO = 1052697,
    USER_LCID_STR = 1052698,
    ANALYSIS_SESSION_TIME = 1052699,
    ANALYSIS_SESSION_HOST = 1052700,
    ANALYSIS_SESSION_ELAPSED_TIME = 1052701,
    ANALYSIS_VERSION = 1052702,
    BUCKET_ID_IMAGE_STR = 1052703,
    BUCKET_ID_PRIVATE = 1052704,
    ANALYSIS_REPROCESS = 1052705,
    OS_MAJOR = 1052706,
    OS_MINOR = 1052707,
    OS_BUILD_STRING = 1052708,
    OS_LOCALE_LCID = 1052709,
    OS_PLATFORM_ID = 1052710,
    OS_BUILD_LAYERS_XML = 1052711,
    OSBUILD_deprecated = 1052928,
    BUILDOSVER_STR_deprecated = 1052929,
    DEBUG_ANALYSIS = 1118208,
    KEYVALUE_ANALYSIS = 1122304,
    KEY_VALUES_STRING = 1122560,
    KEY_VALUES_VARIANT = 1122816,
    TIMELINE_ANALYSIS = 1126400,
    TIMELINE_TIMES = 1126401,
    STREAM_ANALYSIS = 1130496,
    MEMORY_ANALYSIS = 1134592,
    STACKHASH_ANALYSIS = 1138688,
    PROCESSES_ANALYSIS = 1142784,
    SERVICE_ANALYSIS = 1146880,
    ADDITIONAL_XML = 1150976,
    STACK = 2097152,
    FOLLOWUP_CONTEXT = 2097153,
    XML_MODULE_LIST = 2097154,
    STACK_FRAME = 2097155,
    STACK_FRAME_NUMBER = 2097156,
    STACK_FRAME_INSTRUCTION = 2097157,
    STACK_FRAME_SYMBOL = 2097158,
    STACK_FRAME_SYMBOL_OFFSET = 2097159,
    STACK_FRAME_MODULE = 2097160,
    STACK_FRAME_IMAGE = 2097161,
    STACK_FRAME_FUNCTION = 2097162,
    STACK_FRAME_FLAGS = 2097163,
    CONTEXT_COMMAND = 2097164,
    CONTEXT_FLAGS = 2097165,
    CONTEXT_ORDER = 2097166,
    CONTEXT_SYSTEM = 2097167,
    CONTEXT_ID = 2097168,
    XML_MODULE_INFO = 2097169,
    XML_MODULE_INFO_INDEX = 2097170,
    XML_MODULE_INFO_NAME = 2097171,
    XML_MODULE_INFO_IMAGE_NAME = 2097172,
    XML_MODULE_INFO_IMAGE_PATH = 2097173,
    XML_MODULE_INFO_CHECKSUM = 2097174,
    XML_MODULE_INFO_TIMESTAMP = 2097175,
    XML_MODULE_INFO_UNLOADED = 2097176,
    XML_MODULE_INFO_ON_STACK = 2097177,
    XML_MODULE_INFO_FIXED_FILE_VER = 2097178,
    XML_MODULE_INFO_FIXED_PROD_VER = 2097179,
    XML_MODULE_INFO_STRING_FILE_VER = 2097180,
    XML_MODULE_INFO_STRING_PROD_VER = 2097181,
    XML_MODULE_INFO_COMPANY_NAME = 2097182,
    XML_MODULE_INFO_FILE_DESCRIPTION = 2097183,
    XML_MODULE_INFO_INTERNAL_NAME = 2097184,
    XML_MODULE_INFO_ORIG_FILE_NAME = 2097185,
    XML_MODULE_INFO_BASE = 2097186,
    XML_MODULE_INFO_SIZE = 2097187,
    XML_MODULE_INFO_PRODUCT_NAME = 2097188,
    PROCESS_INFO = 2097189,
    EXCEPTION_MODULE_INFO = 2097190,
    CONTEXT_FOLLOWUP_INDEX = 2097191,
    XML_GLOBALATTRIBUTE_LIST = 2097192,
    XML_ATTRIBUTE_LIST = 2097193,
    XML_ATTRIBUTE = 2097194,
    XML_ATTRIBUTE_NAME = 2097195,
    XML_ATTRIBUTE_VALUE = 2097196,
    XML_ATTRIBUTE_D1VALUE = 2097197,
    XML_ATTRIBUTE_D2VALUE = 2097198,
    XML_ATTRIBUTE_DOVALUE = 2097199,
    XML_ATTRIBUTE_VALUE_TYPE = 2097200,
    XML_ATTRIBUTE_FRAME_NUMBER = 2097201,
    XML_ATTRIBUTE_THREAD_INDEX = 2097202,
    XML_PROBLEMCLASS_LIST = 2097203,
    XML_PROBLEMCLASS = 2097204,
    XML_PROBLEMCLASS_NAME = 2097205,
    XML_PROBLEMCLASS_VALUE = 2097206,
    XML_PROBLEMCLASS_VALUE_TYPE = 2097207,
    XML_PROBLEMCLASS_FRAME_NUMBER = 2097208,
    XML_PROBLEMCLASS_THREAD_INDEX = 2097209,
    XML_STACK_FRAME_TRIAGE_STATUS = 2097210,
    CONTEXT_METADATA = 2097211,
    STACK_FRAMES = 2097212,
    XML_ENCODED_OFFSETS = 2097213,
    FA_PERF_DATA = 2097214,
    FA_PERF_ITEM = 2097215,
    FA_PERF_ITEM_NAME = 2097216,
    FA_PERF_ITERATIONS = 2097217,
    FA_PERF_ELAPSED_MS = 2097218,
    STACK_SHA1_HASH_MF = 2097219,
    STACK_SHA1_HASH_MFO = 2097220,
    STACK_SHA1_HASH_M = 2097221,
    XML_MODULE_INFO_SYMBOL_TYPE = 2097222,
    XML_MODULE_INFO_FILE_FLAGS = 2097223,
    STACK_FRAME_MODULE_BASE = 2097224,
    STACK_FRAME_SRC = 2097225,
    XML_SYSTEMINFO = 2097226,
    XML_SYSTEMINFO_SYSTEMMANUFACTURER = 2097227,
    XML_SYSTEMINFO_SYSTEMMODEL = 2097228,
    XML_SYSTEMINFO_SYSTEMMARKER = 2097229,
    FA_ADHOC_ANALYSIS_ITEMS = 2097230,
    XML_APPLICATION_NAME = 2097231,
    XML_PACKAGE_MONIKER = 2097232,
    XML_PACKAGE_RELATIVE_APPLICATION_ID = 2097233,
    XML_MODERN_ASYNC_REQUEST_OUTSTANDING = 2097234,
    XML_EVENTTYPE = 2097235,
    XML_PACKAGE_NAME = 2097236,
    XML_PACKAGE_VERSION = 2097237,
    FAILURE_LIST = 2097238,
    FAILURE_DISPLAY_NAME = 2097239,
    FRAME_SOURCE_FILE_NAME = 2097240,
    FRAME_SOURCE_FILE_PATH = 2097241,
    FRAME_SOURCE_LINE_NUMBER = 2097242,
    XML_MODULE_INFO_SYMSRV_IMAGE_STATUS = 2097243,
    XML_MODULE_INFO_SYMSRV_IMAGE_ERROR = 2097244,
    XML_MODULE_INFO_SYMSRV_IMAGE_DETAIL = 2097245,
    XML_MODULE_INFO_SYMSRV_IMAGE_SEC = 2097246,
    XML_MODULE_INFO_SYMSRV_PDB_STATUS = 2097247,
    XML_MODULE_INFO_SYMSRV_PDB_ERROR = 2097248,
    XML_MODULE_INFO_SYMSRV_PDB_DETAIL = 2097249,
    XML_MODULE_INFO_SYMSRV_PDB_SEC = 2097250,
    XML_MODULE_INFO_DRIVER_GROUP = 2097251,
    REGISTRY_DATA = 3145728,
    WMI_QUERY_DATA = 3149824,
    USER_GLOBAL_ATTRIBUTES = 3153920,
    USER_THREAD_ATTRIBUTES = 3158016,
    USER_PROBLEM_CLASSES = 3162112,
    SM_COMPRESSION_FORMAT = 1342177280,
    SM_SOURCE_PFN1 = 1342177281,
    SM_SOURCE_PFN2 = 1342177282,
    SM_SOURCE_OFFSET = 1342177283,
    SM_SOURCE_SIZE = 1342177284,
    SM_TARGET_PFN = 1342177285,
    SM_BUFFER_HASH = 1342177286,
    SM_ONEBIT_SOLUTION_COUNT = 1342177287,
    STORE_PRODUCT_ID = 1610612736,
    STORE_PRODUCT_DISPLAY_NAME = 1610612737,
    STORE_PRODUCT_DESCRIPTION = 1610612738,
    STORE_PRODUCT_EXTENDED_NAME = 1610612739,
    STORE_PUBLISHER_ID = 1610612740,
    STORE_PUBLISHER_NAME = 1610612741,
    STORE_PUBLISHER_CERTIFICATE_NAME = 1610612742,
    STORE_DEVELOPER_NAME = 1610612743,
    STORE_PACKAGE_FAMILY_NAME = 1610612744,
    STORE_PACKAGE_IDENTITY_NAME = 1610612745,
    STORE_PRIMARY_PARENT_PRODUCT_ID = 1610612746,
    STORE_LEGACY_PARENT_PRODUCT_ID = 1610612747,
    STORE_LEGACY_WINDOWS_STORE_PRODUCT_ID = 1610612748,
    STORE_LEGACY_WINDOWS_PHONE_PRODUCT_ID = 1610612749,
    STORE_LEGACY_XBOX_ONE_PRODUCT_ID = 1610612750,
    STORE_LEGACY_XBOX_360_PRODUCT_ID = 1610612751,
    STORE_XBOX_TITLE_ID = 1610612752,
    STORE_PREFERRED_SKU_ID = 1610612753,
    STORE_IS_MICROSOFT_PRODUCT = 1610612754,
    STORE_URL_APP = 1610612755,
    STORE_URL_APPHEALTH = 1610612756,
    PHONE_VERSIONMAJOR = 1879048192,
    PHONE_VERSIONMINOR = 1879048193,
    PHONE_BUILDNUMBER = 1879048194,
    PHONE_BUILDTIMESTAMP = 1879048195,
    PHONE_BUILDBRANCH = 1879048196,
    PHONE_BUILDER = 1879048197,
    PHONE_LCID = 1879048198,
    PHONE_QFE = 1879048199,
    PHONE_OPERATOR = 1879048200,
    PHONE_MCCMNC = 1879048201,
    PHONE_FIRMWAREREVISION = 1879048202,
    PHONE_RAM = 1879048203,
    PHONE_ROMVERSION = 1879048204,
    PHONE_SOCVERSION = 1879048205,
    PHONE_HARDWAREREVISION = 1879048206,
    PHONE_RADIOHARDWAREREVISION = 1879048207,
    PHONE_RADIOSOFTWAREREVISION = 1879048208,
    PHONE_BOOTLOADERVERSION = 1879048209,
    PHONE_REPORTGUID = 1879048210,
    PHONE_SOURCE = 1879048211,
    PHONE_SOURCEEXTERNAL = 1879048212,
    PHONE_USERALIAS = 1879048213,
    PHONE_REPORTTIMESTAMP = 1879048214,
    PHONE_APPID = 1879048215,
    PHONE_SKUID = 1879048216,
    PHONE_APPVERSION = 1879048217,
    PHONE_UIF_COMMENT = 1879048218,
    PHONE_UIF_APPNAME = 1879048219,
    PHONE_UIF_APPID = 1879048220,
    PHONE_UIF_CATEGORY = 1879048221,
    PHONE_UIF_ORIGIN = 1879048222,
    SIMULTANEOUS_TELSVC_INSTANCES = 1879048223,
    SIMULTANEOUS_TELWP_INSTANCES = 1879048224,
    MINUTES_SINCE_LAST_EVENT = 1879048225,
    MINUTES_SINCE_LAST_EVENT_OF_THIS_TYPE = 1879048226,
    REPORT_INFO_GUID = 1879048227,
    REPORT_INFO_SOURCE = 1879048228,
    REPORT_INFO_CREATION_TIME = 1879048229,
    FAULTING_IP = -2147483648,
    FAULTING_MODULE = -2147483647,
    IMAGE_TIMESTAMP = -2147483646,
    FOLLOWUP_IP = -2147483645,
    FRAME_ONE_INVALID = -2147483644,
    SYMBOL_FROM_RAW_STACK_ADDRESS = -2147483643,
    IMAGE_VERSION = -2147483642,
    FOLLOWUP_BUCKET_ID = -2147483641,
    CUSTOM_ANALYSIS_TAG_MIN = -1610612736,
    CUSTOM_ANALYSIS_TAG_MAX = -1342177280,
    FAULTING_THREAD = -1073741824,
    CONTEXT = -1073741823,
    TRAP_FRAME = -1073741822,
    TSS = -1073741821,
    BLOCKING_THREAD = -1073741820,
    UNRESPONSIVE_UI_THREAD = -1073741819,
    BLOCKED_THREAD0 = -1073741818,
    BLOCKED_THREAD1 = -1073741817,
    BLOCKED_THREAD2 = -1073741816,
    BLOCKING_PROCESSID = -1073741815,
    PROCESSOR_ID = -1073741814,
    XDV_VIOLATED_CONDITION = -1073741813,
    XDV_STATE_VARIABLE = -1073741812,
    XDV_HELP_LINK = -1073741811,
    XDV_RULE_INFO = -1073741810,
    DPC_STACK_BASE = -1073741809,
    TESTRESULTSERVER = -268435456,
    TESTRESULTGUID = -268435455,
    CUSTOMREPORTTAG = -268435454,
    DISKSEC_ORGID_DEPRECATED = -268435453,
    DISKSEC_MODEL_DEPRECATED = -268435452,
    DISKSEC_MFGID_DEPRECATED = -268435451,
    DISKSEC_ISSUEDESCSTRING_DEPRECATED = -268435450,
    DISKSEC_PUBLIC_TOTSIZE_DEPRECATED = -268435449,
    DISKSEC_PUBLIC_OFFSET_DEPRECATED = -268435448,
    DISKSEC_PUBLIC_DATASIZE_DEPRECATED = -268435447,
    DISKSEC_PRIVATE_TOTSIZE_DEPRECATED = -268435446,
    DISKSEC_PRIVATE_OFFSET_DEPRECATED = -268435445,
    DISKSEC_PRIVATE_DATASIZE_DEPRECATED = -268435444,
    DISKSEC_TOTALSIZE_DEPRECATED = -268435443,
    DISKSEC_REASON_DEPRECATED = -268435442,
    WERCOLLECTION_PROCESSTERMINATED = -268435441,
    WERCOLLECTION_PROCESSHEAPDUMP_REQUEST_FAILURE = -268435440,
    WERCOLLECTION_MINIDUMP_WRITE_FAILURE = -268435439,
    WERCOLLECTION_DEFAULTCOLLECTION_FAILURE = -268435438,
    PROCESS_BAM_CURRENT_THROTTLED = -268435437,
    PROCESS_BAM_PREVIOUS_THROTTLED = -268435436,
    DUMPSTREAM_COMMENTA = -268435435,
    DUMPSTREAM_COMMENTW = -268435434,
    CHPE_PROCESS = -268435433,
    WINLOGON_BLACKBOX = -268435432,
    CUSTOM_COMMAND = -268435431,
    CUSTOM_COMMAND_OUTPUT = -268435430,
    MASK_ALL = -1,
};
pub const DEBUG_FLR_INVALID = DEBUG_FLR_PARAM_TYPE.INVALID;
pub const DEBUG_FLR_RESERVED = DEBUG_FLR_PARAM_TYPE.RESERVED;
pub const DEBUG_FLR_DRIVER_OBJECT = DEBUG_FLR_PARAM_TYPE.DRIVER_OBJECT;
pub const DEBUG_FLR_DEVICE_OBJECT = DEBUG_FLR_PARAM_TYPE.DEVICE_OBJECT;
pub const DEBUG_FLR_INVALID_PFN = DEBUG_FLR_PARAM_TYPE.INVALID_PFN;
pub const DEBUG_FLR_WORKER_ROUTINE = DEBUG_FLR_PARAM_TYPE.WORKER_ROUTINE;
pub const DEBUG_FLR_WORK_ITEM = DEBUG_FLR_PARAM_TYPE.WORK_ITEM;
pub const DEBUG_FLR_INVALID_DPC_FOUND = DEBUG_FLR_PARAM_TYPE.INVALID_DPC_FOUND;
pub const DEBUG_FLR_PROCESS_OBJECT = DEBUG_FLR_PARAM_TYPE.PROCESS_OBJECT;
pub const DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS = DEBUG_FLR_PARAM_TYPE.FAILED_INSTRUCTION_ADDRESS;
pub const DEBUG_FLR_LAST_CONTROL_TRANSFER = DEBUG_FLR_PARAM_TYPE.LAST_CONTROL_TRANSFER;
pub const DEBUG_FLR_ACPI_EXTENSION = DEBUG_FLR_PARAM_TYPE.ACPI_EXTENSION;
pub const DEBUG_FLR_ACPI_RESCONFLICT = DEBUG_FLR_PARAM_TYPE.ACPI_RESCONFLICT;
pub const DEBUG_FLR_ACPI_OBJECT = DEBUG_FLR_PARAM_TYPE.ACPI_OBJECT;
pub const DEBUG_FLR_READ_ADDRESS = DEBUG_FLR_PARAM_TYPE.READ_ADDRESS;
pub const DEBUG_FLR_WRITE_ADDRESS = DEBUG_FLR_PARAM_TYPE.WRITE_ADDRESS;
pub const DEBUG_FLR_CRITICAL_SECTION = DEBUG_FLR_PARAM_TYPE.CRITICAL_SECTION;
pub const DEBUG_FLR_BAD_HANDLE = DEBUG_FLR_PARAM_TYPE.BAD_HANDLE;
pub const DEBUG_FLR_INVALID_HEAP_ADDRESS = DEBUG_FLR_PARAM_TYPE.INVALID_HEAP_ADDRESS;
pub const DEBUG_FLR_CHKIMG_EXTENSION = DEBUG_FLR_PARAM_TYPE.CHKIMG_EXTENSION;
pub const DEBUG_FLR_USBPORT_OCADATA = DEBUG_FLR_PARAM_TYPE.USBPORT_OCADATA;
pub const DEBUG_FLR_WORK_QUEUE_ITEM = DEBUG_FLR_PARAM_TYPE.WORK_QUEUE_ITEM;
pub const DEBUG_FLR_ERESOURCE_ADDRESS = DEBUG_FLR_PARAM_TYPE.ERESOURCE_ADDRESS;
pub const DEBUG_FLR_PNP_TRIAGE_DATA_DEPRECATED = DEBUG_FLR_PARAM_TYPE.PNP_TRIAGE_DATA_DEPRECATED;
pub const DEBUG_FLR_HANDLE_VALUE = DEBUG_FLR_PARAM_TYPE.HANDLE_VALUE;
pub const DEBUG_FLR_WHEA_ERROR_RECORD = DEBUG_FLR_PARAM_TYPE.WHEA_ERROR_RECORD;
pub const DEBUG_FLR_VERIFIER_FOUND_DEADLOCK = DEBUG_FLR_PARAM_TYPE.VERIFIER_FOUND_DEADLOCK;
pub const DEBUG_FLR_PG_MISMATCH = DEBUG_FLR_PARAM_TYPE.PG_MISMATCH;
pub const DEBUG_FLR_DEVICE_NODE = DEBUG_FLR_PARAM_TYPE.DEVICE_NODE;
pub const DEBUG_FLR_POWERREQUEST_ADDRESS = DEBUG_FLR_PARAM_TYPE.POWERREQUEST_ADDRESS;
pub const DEBUG_FLR_EXECUTE_ADDRESS = DEBUG_FLR_PARAM_TYPE.EXECUTE_ADDRESS;
pub const DEBUG_FLR_IRP_ADDRESS = DEBUG_FLR_PARAM_TYPE.IRP_ADDRESS;
pub const DEBUG_FLR_IRP_MAJOR_FN = DEBUG_FLR_PARAM_TYPE.IRP_MAJOR_FN;
pub const DEBUG_FLR_IRP_MINOR_FN = DEBUG_FLR_PARAM_TYPE.IRP_MINOR_FN;
pub const DEBUG_FLR_IRP_CANCEL_ROUTINE = DEBUG_FLR_PARAM_TYPE.IRP_CANCEL_ROUTINE;
pub const DEBUG_FLR_IOSB_ADDRESS = DEBUG_FLR_PARAM_TYPE.IOSB_ADDRESS;
pub const DEBUG_FLR_INVALID_USEREVENT = DEBUG_FLR_PARAM_TYPE.INVALID_USEREVENT;
pub const DEBUG_FLR_VIDEO_TDR_CONTEXT = DEBUG_FLR_PARAM_TYPE.VIDEO_TDR_CONTEXT;
pub const DEBUG_FLR_VERIFIER_DRIVER_ENTRY = DEBUG_FLR_PARAM_TYPE.VERIFIER_DRIVER_ENTRY;
pub const DEBUG_FLR_PNP_IRP_ADDRESS_DEPRECATED = DEBUG_FLR_PARAM_TYPE.PNP_IRP_ADDRESS_DEPRECATED;
pub const DEBUG_FLR_PREVIOUS_MODE = DEBUG_FLR_PARAM_TYPE.PREVIOUS_MODE;
pub const DEBUG_FLR_CURRENT_IRQL = DEBUG_FLR_PARAM_TYPE.CURRENT_IRQL;
pub const DEBUG_FLR_PREVIOUS_IRQL = DEBUG_FLR_PARAM_TYPE.PREVIOUS_IRQL;
pub const DEBUG_FLR_REQUESTED_IRQL = DEBUG_FLR_PARAM_TYPE.REQUESTED_IRQL;
pub const DEBUG_FLR_ASSERT_DATA = DEBUG_FLR_PARAM_TYPE.ASSERT_DATA;
pub const DEBUG_FLR_ASSERT_FILE = DEBUG_FLR_PARAM_TYPE.ASSERT_FILE;
pub const DEBUG_FLR_EXCEPTION_PARAMETER1 = DEBUG_FLR_PARAM_TYPE.EXCEPTION_PARAMETER1;
pub const DEBUG_FLR_EXCEPTION_PARAMETER2 = DEBUG_FLR_PARAM_TYPE.EXCEPTION_PARAMETER2;
pub const DEBUG_FLR_EXCEPTION_PARAMETER3 = DEBUG_FLR_PARAM_TYPE.EXCEPTION_PARAMETER3;
pub const DEBUG_FLR_EXCEPTION_PARAMETER4 = DEBUG_FLR_PARAM_TYPE.EXCEPTION_PARAMETER4;
pub const DEBUG_FLR_EXCEPTION_RECORD = DEBUG_FLR_PARAM_TYPE.EXCEPTION_RECORD;
pub const DEBUG_FLR_IO_ERROR_CODE = DEBUG_FLR_PARAM_TYPE.IO_ERROR_CODE;
pub const DEBUG_FLR_EXCEPTION_STR = DEBUG_FLR_PARAM_TYPE.EXCEPTION_STR;
pub const DEBUG_FLR_EXCEPTION_DOESNOT_MATCH_CODE = DEBUG_FLR_PARAM_TYPE.EXCEPTION_DOESNOT_MATCH_CODE;
pub const DEBUG_FLR_ASSERT_INSTRUCTION = DEBUG_FLR_PARAM_TYPE.ASSERT_INSTRUCTION;
pub const DEBUG_FLR_POOL_ADDRESS = DEBUG_FLR_PARAM_TYPE.POOL_ADDRESS;
pub const DEBUG_FLR_SPECIAL_POOL_CORRUPTION_TYPE = DEBUG_FLR_PARAM_TYPE.SPECIAL_POOL_CORRUPTION_TYPE;
pub const DEBUG_FLR_CORRUPTING_POOL_ADDRESS = DEBUG_FLR_PARAM_TYPE.CORRUPTING_POOL_ADDRESS;
pub const DEBUG_FLR_CORRUPTING_POOL_TAG = DEBUG_FLR_PARAM_TYPE.CORRUPTING_POOL_TAG;
pub const DEBUG_FLR_FREED_POOL_TAG = DEBUG_FLR_PARAM_TYPE.FREED_POOL_TAG;
pub const DEBUG_FLR_LEAKED_SESSION_POOL_TAG = DEBUG_FLR_PARAM_TYPE.LEAKED_SESSION_POOL_TAG;
pub const DEBUG_FLR_INSTR_SESSION_POOL_TAG = DEBUG_FLR_PARAM_TYPE.INSTR_SESSION_POOL_TAG;
pub const DEBUG_FLR_CLIENT_DRIVER = DEBUG_FLR_PARAM_TYPE.CLIENT_DRIVER;
pub const DEBUG_FLR_FILE_ID = DEBUG_FLR_PARAM_TYPE.FILE_ID;
pub const DEBUG_FLR_FILE_LINE = DEBUG_FLR_PARAM_TYPE.FILE_LINE;
pub const DEBUG_FLR_BUGCHECK_STR = DEBUG_FLR_PARAM_TYPE.BUGCHECK_STR;
pub const DEBUG_FLR_BUGCHECK_SPECIFIER = DEBUG_FLR_PARAM_TYPE.BUGCHECK_SPECIFIER;
pub const DEBUG_FLR_BUGCHECK_DESC = DEBUG_FLR_PARAM_TYPE.BUGCHECK_DESC;
pub const DEBUG_FLR_MANAGED_CODE = DEBUG_FLR_PARAM_TYPE.MANAGED_CODE;
pub const DEBUG_FLR_MANAGED_OBJECT = DEBUG_FLR_PARAM_TYPE.MANAGED_OBJECT;
pub const DEBUG_FLR_MANAGED_EXCEPTION_OBJECT = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_OBJECT;
pub const DEBUG_FLR_MANAGED_EXCEPTION_MESSAGE_deprecated = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_MESSAGE_deprecated;
pub const DEBUG_FLR_MANAGED_STACK_STRING = DEBUG_FLR_PARAM_TYPE.MANAGED_STACK_STRING;
pub const DEBUG_FLR_MANAGED_BITNESS_MISMATCH = DEBUG_FLR_PARAM_TYPE.MANAGED_BITNESS_MISMATCH;
pub const DEBUG_FLR_MANAGED_OBJECT_NAME = DEBUG_FLR_PARAM_TYPE.MANAGED_OBJECT_NAME;
pub const DEBUG_FLR_MANAGED_EXCEPTION_CONTEXT_MESSAGE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_CONTEXT_MESSAGE;
pub const DEBUG_FLR_MANAGED_STACK_COMMAND = DEBUG_FLR_PARAM_TYPE.MANAGED_STACK_COMMAND;
pub const DEBUG_FLR_MANAGED_KERNEL_DEBUGGER = DEBUG_FLR_PARAM_TYPE.MANAGED_KERNEL_DEBUGGER;
pub const DEBUG_FLR_MANAGED_HRESULT_STRING = DEBUG_FLR_PARAM_TYPE.MANAGED_HRESULT_STRING;
pub const DEBUG_FLR_MANAGED_ENGINE_MODULE = DEBUG_FLR_PARAM_TYPE.MANAGED_ENGINE_MODULE;
pub const DEBUG_FLR_MANAGED_ANALYSIS_PROVIDER = DEBUG_FLR_PARAM_TYPE.MANAGED_ANALYSIS_PROVIDER;
pub const DEBUG_FLR_MANAGED_EXCEPTION_ADDRESS = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_ADDRESS;
pub const DEBUG_FLR_MANAGED_EXCEPTION_HRESULT = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_HRESULT;
pub const DEBUG_FLR_MANAGED_EXCEPTION_TYPE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_TYPE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_MESSAGE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_MESSAGE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_CALLSTACK = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_CALLSTACK;
pub const DEBUG_FLR_MANAGED_EXCEPTION_INNER_ADDRESS = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_INNER_ADDRESS;
pub const DEBUG_FLR_MANAGED_EXCEPTION_INNER_HRESULT = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_INNER_HRESULT;
pub const DEBUG_FLR_MANAGED_EXCEPTION_INNER_TYPE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_INNER_TYPE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_INNER_MESSAGE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_INNER_MESSAGE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_INNER_CALLSTACK = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_INNER_CALLSTACK;
pub const DEBUG_FLR_MANAGED_EXCEPTION_NESTED_ADDRESS = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_NESTED_ADDRESS;
pub const DEBUG_FLR_MANAGED_EXCEPTION_NESTED_HRESULT = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_NESTED_HRESULT;
pub const DEBUG_FLR_MANAGED_EXCEPTION_NESTED_TYPE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_NESTED_TYPE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_NESTED_MESSAGE = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_NESTED_MESSAGE;
pub const DEBUG_FLR_MANAGED_EXCEPTION_NESTED_CALLSTACK = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_NESTED_CALLSTACK;
pub const DEBUG_FLR_MANAGED_EXCEPTION_CMD = DEBUG_FLR_PARAM_TYPE.MANAGED_EXCEPTION_CMD;
pub const DEBUG_FLR_MANAGED_THREAD_ID = DEBUG_FLR_PARAM_TYPE.MANAGED_THREAD_ID;
pub const DEBUG_FLR_MANAGED_THREAD_CMD_CALLSTACK = DEBUG_FLR_PARAM_TYPE.MANAGED_THREAD_CMD_CALLSTACK;
pub const DEBUG_FLR_MANAGED_THREAD_CMD_STACKOBJECTS = DEBUG_FLR_PARAM_TYPE.MANAGED_THREAD_CMD_STACKOBJECTS;
pub const DEBUG_FLR_DRIVER_VERIFIER_IO_VIOLATION_TYPE = DEBUG_FLR_PARAM_TYPE.DRIVER_VERIFIER_IO_VIOLATION_TYPE;
pub const DEBUG_FLR_EXCEPTION_CODE = DEBUG_FLR_PARAM_TYPE.EXCEPTION_CODE;
pub const DEBUG_FLR_EXCEPTION_CODE_STR = DEBUG_FLR_PARAM_TYPE.EXCEPTION_CODE_STR;
pub const DEBUG_FLR_IOCONTROL_CODE = DEBUG_FLR_PARAM_TYPE.IOCONTROL_CODE;
pub const DEBUG_FLR_MM_INTERNAL_CODE = DEBUG_FLR_PARAM_TYPE.MM_INTERNAL_CODE;
pub const DEBUG_FLR_DRVPOWERSTATE_SUBCODE = DEBUG_FLR_PARAM_TYPE.DRVPOWERSTATE_SUBCODE;
pub const DEBUG_FLR_STATUS_CODE = DEBUG_FLR_PARAM_TYPE.STATUS_CODE;
pub const DEBUG_FLR_SYMBOL_STACK_INDEX = DEBUG_FLR_PARAM_TYPE.SYMBOL_STACK_INDEX;
pub const DEBUG_FLR_SYMBOL_ON_RAW_STACK = DEBUG_FLR_PARAM_TYPE.SYMBOL_ON_RAW_STACK;
pub const DEBUG_FLR_SECURITY_COOKIES = DEBUG_FLR_PARAM_TYPE.SECURITY_COOKIES;
pub const DEBUG_FLR_THREADPOOL_WAITER = DEBUG_FLR_PARAM_TYPE.THREADPOOL_WAITER;
pub const DEBUG_FLR_TARGET_MODE = DEBUG_FLR_PARAM_TYPE.TARGET_MODE;
pub const DEBUG_FLR_BUGCHECK_CODE = DEBUG_FLR_PARAM_TYPE.BUGCHECK_CODE;
pub const DEBUG_FLR_BADPAGES_DETECTED = DEBUG_FLR_PARAM_TYPE.BADPAGES_DETECTED;
pub const DEBUG_FLR_DPC_TIMEOUT_TYPE = DEBUG_FLR_PARAM_TYPE.DPC_TIMEOUT_TYPE;
pub const DEBUG_FLR_DPC_RUNTIME = DEBUG_FLR_PARAM_TYPE.DPC_RUNTIME;
pub const DEBUG_FLR_DPC_TIMELIMIT = DEBUG_FLR_PARAM_TYPE.DPC_TIMELIMIT;
pub const DEBUG_FLR_DUMP_FILE_ATTRIBUTES = DEBUG_FLR_PARAM_TYPE.DUMP_FILE_ATTRIBUTES;
pub const DEBUG_FLR_PAGE_HASH_ERRORS = DEBUG_FLR_PARAM_TYPE.PAGE_HASH_ERRORS;
pub const DEBUG_FLR_BUGCHECK_P1 = DEBUG_FLR_PARAM_TYPE.BUGCHECK_P1;
pub const DEBUG_FLR_BUGCHECK_P2 = DEBUG_FLR_PARAM_TYPE.BUGCHECK_P2;
pub const DEBUG_FLR_BUGCHECK_P3 = DEBUG_FLR_PARAM_TYPE.BUGCHECK_P3;
pub const DEBUG_FLR_BUGCHECK_P4 = DEBUG_FLR_PARAM_TYPE.BUGCHECK_P4;
pub const DEBUG_FLR_CRITICAL_PROCESS = DEBUG_FLR_PARAM_TYPE.CRITICAL_PROCESS;
pub const DEBUG_FLR_RESOURCE_CALL_TYPE = DEBUG_FLR_PARAM_TYPE.RESOURCE_CALL_TYPE;
pub const DEBUG_FLR_RESOURCE_CALL_TYPE_STR = DEBUG_FLR_PARAM_TYPE.RESOURCE_CALL_TYPE_STR;
pub const DEBUG_FLR_CORRUPT_MODULE_LIST = DEBUG_FLR_PARAM_TYPE.CORRUPT_MODULE_LIST;
pub const DEBUG_FLR_BAD_STACK = DEBUG_FLR_PARAM_TYPE.BAD_STACK;
pub const DEBUG_FLR_ZEROED_STACK = DEBUG_FLR_PARAM_TYPE.ZEROED_STACK;
pub const DEBUG_FLR_WRONG_SYMBOLS = DEBUG_FLR_PARAM_TYPE.WRONG_SYMBOLS;
pub const DEBUG_FLR_FOLLOWUP_DRIVER_ONLY = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_DRIVER_ONLY;
pub const DEBUG_FLR_UNUSED001 = DEBUG_FLR_PARAM_TYPE.UNUSED001;
pub const DEBUG_FLR_CPU_OVERCLOCKED = DEBUG_FLR_PARAM_TYPE.CPU_OVERCLOCKED;
pub const DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER = DEBUG_FLR_PARAM_TYPE.POSSIBLE_INVALID_CONTROL_TRANSFER;
pub const DEBUG_FLR_POISONED_TB = DEBUG_FLR_PARAM_TYPE.POISONED_TB;
pub const DEBUG_FLR_UNKNOWN_MODULE = DEBUG_FLR_PARAM_TYPE.UNKNOWN_MODULE;
pub const DEBUG_FLR_ANALYZABLE_POOL_CORRUPTION = DEBUG_FLR_PARAM_TYPE.ANALYZABLE_POOL_CORRUPTION;
pub const DEBUG_FLR_SINGLE_BIT_ERROR = DEBUG_FLR_PARAM_TYPE.SINGLE_BIT_ERROR;
pub const DEBUG_FLR_TWO_BIT_ERROR = DEBUG_FLR_PARAM_TYPE.TWO_BIT_ERROR;
pub const DEBUG_FLR_INVALID_KERNEL_CONTEXT = DEBUG_FLR_PARAM_TYPE.INVALID_KERNEL_CONTEXT;
pub const DEBUG_FLR_DISK_HARDWARE_ERROR = DEBUG_FLR_PARAM_TYPE.DISK_HARDWARE_ERROR;
pub const DEBUG_FLR_SHOW_ERRORLOG = DEBUG_FLR_PARAM_TYPE.SHOW_ERRORLOG;
pub const DEBUG_FLR_MANUAL_BREAKIN = DEBUG_FLR_PARAM_TYPE.MANUAL_BREAKIN;
pub const DEBUG_FLR_HANG = DEBUG_FLR_PARAM_TYPE.HANG;
pub const DEBUG_FLR_BAD_MEMORY_REFERENCE = DEBUG_FLR_PARAM_TYPE.BAD_MEMORY_REFERENCE;
pub const DEBUG_FLR_BAD_OBJECT_REFERENCE = DEBUG_FLR_PARAM_TYPE.BAD_OBJECT_REFERENCE;
pub const DEBUG_FLR_APPKILL = DEBUG_FLR_PARAM_TYPE.APPKILL;
pub const DEBUG_FLR_SINGLE_BIT_PFN_PAGE_ERROR = DEBUG_FLR_PARAM_TYPE.SINGLE_BIT_PFN_PAGE_ERROR;
pub const DEBUG_FLR_HARDWARE_ERROR = DEBUG_FLR_PARAM_TYPE.HARDWARE_ERROR;
pub const DEBUG_FLR_NO_IMAGE_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.NO_IMAGE_IN_BUCKET;
pub const DEBUG_FLR_NO_BUGCHECK_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.NO_BUGCHECK_IN_BUCKET;
pub const DEBUG_FLR_SKIP_STACK_ANALYSIS = DEBUG_FLR_PARAM_TYPE.SKIP_STACK_ANALYSIS;
pub const DEBUG_FLR_INVALID_OPCODE = DEBUG_FLR_PARAM_TYPE.INVALID_OPCODE;
pub const DEBUG_FLR_ADD_PROCESS_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.ADD_PROCESS_IN_BUCKET;
pub const DEBUG_FLR_RAISED_IRQL_USER_FAULT = DEBUG_FLR_PARAM_TYPE.RAISED_IRQL_USER_FAULT;
pub const DEBUG_FLR_USE_DEFAULT_CONTEXT = DEBUG_FLR_PARAM_TYPE.USE_DEFAULT_CONTEXT;
pub const DEBUG_FLR_BOOST_FOLLOWUP_TO_SPECIFIC = DEBUG_FLR_PARAM_TYPE.BOOST_FOLLOWUP_TO_SPECIFIC;
pub const DEBUG_FLR_SWITCH_PROCESS_CONTEXT = DEBUG_FLR_PARAM_TYPE.SWITCH_PROCESS_CONTEXT;
pub const DEBUG_FLR_VERIFIER_STOP = DEBUG_FLR_PARAM_TYPE.VERIFIER_STOP;
pub const DEBUG_FLR_USERBREAK_PEB_PAGEDOUT = DEBUG_FLR_PARAM_TYPE.USERBREAK_PEB_PAGEDOUT;
pub const DEBUG_FLR_MOD_SPECIFIC_DATA_ONLY = DEBUG_FLR_PARAM_TYPE.MOD_SPECIFIC_DATA_ONLY;
pub const DEBUG_FLR_OVERLAPPED_MODULE = DEBUG_FLR_PARAM_TYPE.OVERLAPPED_MODULE;
pub const DEBUG_FLR_CPU_MICROCODE_ZERO_INTEL = DEBUG_FLR_PARAM_TYPE.CPU_MICROCODE_ZERO_INTEL;
pub const DEBUG_FLR_INTEL_CPU_BIOS_UPGRADE_NEEDED = DEBUG_FLR_PARAM_TYPE.INTEL_CPU_BIOS_UPGRADE_NEEDED;
pub const DEBUG_FLR_OVERLAPPED_UNLOADED_MODULE = DEBUG_FLR_PARAM_TYPE.OVERLAPPED_UNLOADED_MODULE;
pub const DEBUG_FLR_INVALID_USER_CONTEXT = DEBUG_FLR_PARAM_TYPE.INVALID_USER_CONTEXT;
pub const DEBUG_FLR_MILCORE_BREAK = DEBUG_FLR_PARAM_TYPE.MILCORE_BREAK;
pub const DEBUG_FLR_NO_IMAGE_TIMESTAMP_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.NO_IMAGE_TIMESTAMP_IN_BUCKET;
pub const DEBUG_FLR_KERNEL_VERIFIER_ENABLED = DEBUG_FLR_PARAM_TYPE.KERNEL_VERIFIER_ENABLED;
pub const DEBUG_FLR_SKIP_CORRUPT_MODULE_DETECTION = DEBUG_FLR_PARAM_TYPE.SKIP_CORRUPT_MODULE_DETECTION;
pub const DEBUG_FLR_GSFAILURE_FALSE_POSITIVE = DEBUG_FLR_PARAM_TYPE.GSFAILURE_FALSE_POSITIVE;
pub const DEBUG_FLR_IGNORE_LARGE_MODULE_CORRUPTION = DEBUG_FLR_PARAM_TYPE.IGNORE_LARGE_MODULE_CORRUPTION;
pub const DEBUG_FLR_IGNORE_BUCKET_ID_OFFSET = DEBUG_FLR_PARAM_TYPE.IGNORE_BUCKET_ID_OFFSET;
pub const DEBUG_FLR_NO_ARCH_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.NO_ARCH_IN_BUCKET;
pub const DEBUG_FLR_IGNORE_MODULE_HARDWARE_ID = DEBUG_FLR_PARAM_TYPE.IGNORE_MODULE_HARDWARE_ID;
pub const DEBUG_FLR_ARM_WRITE_AV_CAVEAT = DEBUG_FLR_PARAM_TYPE.ARM_WRITE_AV_CAVEAT;
pub const DEBUG_FLR_ON_DPC_STACK = DEBUG_FLR_PARAM_TYPE.ON_DPC_STACK;
pub const DEBUG_FLR_LIVE_KERNEL_DUMP = DEBUG_FLR_PARAM_TYPE.LIVE_KERNEL_DUMP;
pub const DEBUG_FLR_COVERAGE_BUILD = DEBUG_FLR_PARAM_TYPE.COVERAGE_BUILD;
pub const DEBUG_FLR_POSSIBLE_STACK_OVERFLOW = DEBUG_FLR_PARAM_TYPE.POSSIBLE_STACK_OVERFLOW;
pub const DEBUG_FLR_WRONG_SYMBOLS_TIMESTAMP = DEBUG_FLR_PARAM_TYPE.WRONG_SYMBOLS_TIMESTAMP;
pub const DEBUG_FLR_WRONG_SYMBOLS_SIZE = DEBUG_FLR_PARAM_TYPE.WRONG_SYMBOLS_SIZE;
pub const DEBUG_FLR_MISSING_IMPORTANT_SYMBOL = DEBUG_FLR_PARAM_TYPE.MISSING_IMPORTANT_SYMBOL;
pub const DEBUG_FLR_MISSING_CLR_SYMBOL = DEBUG_FLR_PARAM_TYPE.MISSING_CLR_SYMBOL;
pub const DEBUG_FLR_TARGET_TIME = DEBUG_FLR_PARAM_TYPE.TARGET_TIME;
pub const DEBUG_FLR_LOW_SYSTEM_COMMIT = DEBUG_FLR_PARAM_TYPE.LOW_SYSTEM_COMMIT;
pub const DEBUG_FLR_LEGACY_PAGE_TABLE_ACCESS = DEBUG_FLR_PARAM_TYPE.LEGACY_PAGE_TABLE_ACCESS;
pub const DEBUG_FLR_HIGH_PROCESS_COMMIT = DEBUG_FLR_PARAM_TYPE.HIGH_PROCESS_COMMIT;
pub const DEBUG_FLR_HIGH_SERVICE_COMMIT = DEBUG_FLR_PARAM_TYPE.HIGH_SERVICE_COMMIT;
pub const DEBUG_FLR_HIGH_NONPAGED_POOL_USAGE = DEBUG_FLR_PARAM_TYPE.HIGH_NONPAGED_POOL_USAGE;
pub const DEBUG_FLR_HIGH_PAGED_POOL_USAGE = DEBUG_FLR_PARAM_TYPE.HIGH_PAGED_POOL_USAGE;
pub const DEBUG_FLR_HIGH_SHARED_COMMIT_USAGE = DEBUG_FLR_PARAM_TYPE.HIGH_SHARED_COMMIT_USAGE;
pub const DEBUG_FLR_APPS_NOT_TERMINATED = DEBUG_FLR_PARAM_TYPE.APPS_NOT_TERMINATED;
pub const DEBUG_FLR_POOL_CORRUPTOR = DEBUG_FLR_PARAM_TYPE.POOL_CORRUPTOR;
pub const DEBUG_FLR_MEMORY_CORRUPTOR = DEBUG_FLR_PARAM_TYPE.MEMORY_CORRUPTOR;
pub const DEBUG_FLR_UNALIGNED_STACK_POINTER = DEBUG_FLR_PARAM_TYPE.UNALIGNED_STACK_POINTER;
pub const DEBUG_FLR_OS_VERSION_deprecated = DEBUG_FLR_PARAM_TYPE.OS_VERSION_deprecated;
pub const DEBUG_FLR_BUGCHECKING_DRIVER = DEBUG_FLR_PARAM_TYPE.BUGCHECKING_DRIVER;
pub const DEBUG_FLR_SOLUTION_ID = DEBUG_FLR_PARAM_TYPE.SOLUTION_ID;
pub const DEBUG_FLR_DEFAULT_SOLUTION_ID = DEBUG_FLR_PARAM_TYPE.DEFAULT_SOLUTION_ID;
pub const DEBUG_FLR_SOLUTION_TYPE = DEBUG_FLR_PARAM_TYPE.SOLUTION_TYPE;
pub const DEBUG_FLR_RECURRING_STACK = DEBUG_FLR_PARAM_TYPE.RECURRING_STACK;
pub const DEBUG_FLR_FAULTING_INSTR_CODE = DEBUG_FLR_PARAM_TYPE.FAULTING_INSTR_CODE;
pub const DEBUG_FLR_SYSTEM_LOCALE_deprecated = DEBUG_FLR_PARAM_TYPE.SYSTEM_LOCALE_deprecated;
pub const DEBUG_FLR_CUSTOMER_CRASH_COUNT = DEBUG_FLR_PARAM_TYPE.CUSTOMER_CRASH_COUNT;
pub const DEBUG_FLR_TRAP_FRAME_RECURSION = DEBUG_FLR_PARAM_TYPE.TRAP_FRAME_RECURSION;
pub const DEBUG_FLR_STACK_OVERFLOW = DEBUG_FLR_PARAM_TYPE.STACK_OVERFLOW;
pub const DEBUG_FLR_STACK_POINTER_ERROR = DEBUG_FLR_PARAM_TYPE.STACK_POINTER_ERROR;
pub const DEBUG_FLR_STACK_POINTER_ONEBIT_ERROR = DEBUG_FLR_PARAM_TYPE.STACK_POINTER_ONEBIT_ERROR;
pub const DEBUG_FLR_STACK_POINTER_MISALIGNED = DEBUG_FLR_PARAM_TYPE.STACK_POINTER_MISALIGNED;
pub const DEBUG_FLR_INSTR_POINTER_MISALIGNED = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_MISALIGNED;
pub const DEBUG_FLR_INSTR_POINTER_CLIFAULT = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_CLIFAULT;
pub const DEBUG_FLR_REGISTRYTXT_STRESS_ID = DEBUG_FLR_PARAM_TYPE.REGISTRYTXT_STRESS_ID;
pub const DEBUG_FLR_CORRUPT_SERVICE_TABLE = DEBUG_FLR_PARAM_TYPE.CORRUPT_SERVICE_TABLE;
pub const DEBUG_FLR_LOP_STACKHASH = DEBUG_FLR_PARAM_TYPE.LOP_STACKHASH;
pub const DEBUG_FLR_GSFAILURE_FUNCTION = DEBUG_FLR_PARAM_TYPE.GSFAILURE_FUNCTION;
pub const DEBUG_FLR_GSFAILURE_MODULE_COOKIE = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MODULE_COOKIE;
pub const DEBUG_FLR_GSFAILURE_FRAME_COOKIE = DEBUG_FLR_PARAM_TYPE.GSFAILURE_FRAME_COOKIE;
pub const DEBUG_FLR_GSFAILURE_FRAME_COOKIE_COMPLEMENT = DEBUG_FLR_PARAM_TYPE.GSFAILURE_FRAME_COOKIE_COMPLEMENT;
pub const DEBUG_FLR_GSFAILURE_CORRUPTED_COOKIE = DEBUG_FLR_PARAM_TYPE.GSFAILURE_CORRUPTED_COOKIE;
pub const DEBUG_FLR_GSFAILURE_CORRUPTED_EBP = DEBUG_FLR_PARAM_TYPE.GSFAILURE_CORRUPTED_EBP;
pub const DEBUG_FLR_GSFAILURE_OVERRUN_LOCAL = DEBUG_FLR_PARAM_TYPE.GSFAILURE_OVERRUN_LOCAL;
pub const DEBUG_FLR_GSFAILURE_OVERRUN_LOCAL_NAME = DEBUG_FLR_PARAM_TYPE.GSFAILURE_OVERRUN_LOCAL_NAME;
pub const DEBUG_FLR_GSFAILURE_CORRUPTED_EBPESP = DEBUG_FLR_PARAM_TYPE.GSFAILURE_CORRUPTED_EBPESP;
pub const DEBUG_FLR_GSFAILURE_POSITIVELY_CORRUPTED_EBPESP = DEBUG_FLR_PARAM_TYPE.GSFAILURE_POSITIVELY_CORRUPTED_EBPESP;
pub const DEBUG_FLR_GSFAILURE_MEMORY_READ_ERROR = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MEMORY_READ_ERROR;
pub const DEBUG_FLR_GSFAILURE_PROBABLY_NOT_USING_GS = DEBUG_FLR_PARAM_TYPE.GSFAILURE_PROBABLY_NOT_USING_GS;
pub const DEBUG_FLR_GSFAILURE_POSITIVE_BUFFER_OVERFLOW = DEBUG_FLR_PARAM_TYPE.GSFAILURE_POSITIVE_BUFFER_OVERFLOW;
pub const DEBUG_FLR_GSFAILURE_ANALYSIS_TEXT = DEBUG_FLR_PARAM_TYPE.GSFAILURE_ANALYSIS_TEXT;
pub const DEBUG_FLR_GSFAILURE_OFF_BY_ONE_OVERRUN = DEBUG_FLR_PARAM_TYPE.GSFAILURE_OFF_BY_ONE_OVERRUN;
pub const DEBUG_FLR_GSFAILURE_RA_SMASHED = DEBUG_FLR_PARAM_TYPE.GSFAILURE_RA_SMASHED;
pub const DEBUG_FLR_GSFAILURE_NOT_UP2DATE = DEBUG_FLR_PARAM_TYPE.GSFAILURE_NOT_UP2DATE;
pub const DEBUG_FLR_GSFAILURE_UP2DATE_UNKNOWN = DEBUG_FLR_PARAM_TYPE.GSFAILURE_UP2DATE_UNKNOWN;
pub const DEBUG_FLR_TRIAGER_OS_BUILD_NAME = DEBUG_FLR_PARAM_TYPE.TRIAGER_OS_BUILD_NAME;
pub const DEBUG_FLR_CPU_MICROCODE_VERSION = DEBUG_FLR_PARAM_TYPE.CPU_MICROCODE_VERSION;
pub const DEBUG_FLR_CPU_COUNT = DEBUG_FLR_PARAM_TYPE.CPU_COUNT;
pub const DEBUG_FLR_CPU_SPEED = DEBUG_FLR_PARAM_TYPE.CPU_SPEED;
pub const DEBUG_FLR_CPU_VENDOR = DEBUG_FLR_PARAM_TYPE.CPU_VENDOR;
pub const DEBUG_FLR_CPU_FAMILY = DEBUG_FLR_PARAM_TYPE.CPU_FAMILY;
pub const DEBUG_FLR_CPU_MODEL = DEBUG_FLR_PARAM_TYPE.CPU_MODEL;
pub const DEBUG_FLR_CPU_STEPPING = DEBUG_FLR_PARAM_TYPE.CPU_STEPPING;
pub const DEBUG_FLR_INSTR_POINTER_ON_STACK = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_ON_STACK;
pub const DEBUG_FLR_INSTR_POINTER_ON_HEAP = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_ON_HEAP;
pub const DEBUG_FLR_EVENT_CODE_DATA_MISMATCH = DEBUG_FLR_PARAM_TYPE.EVENT_CODE_DATA_MISMATCH;
pub const DEBUG_FLR_PROCESSOR_INFO = DEBUG_FLR_PARAM_TYPE.PROCESSOR_INFO;
pub const DEBUG_FLR_INSTR_POINTER_IN_UNLOADED_MODULE = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_UNLOADED_MODULE;
pub const DEBUG_FLR_MEMDIAG_LASTRUN_STATUS = DEBUG_FLR_PARAM_TYPE.MEMDIAG_LASTRUN_STATUS;
pub const DEBUG_FLR_MEMDIAG_LASTRUN_TIME = DEBUG_FLR_PARAM_TYPE.MEMDIAG_LASTRUN_TIME;
pub const DEBUG_FLR_INSTR_POINTER_IN_FREE_BLOCK = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_FREE_BLOCK;
pub const DEBUG_FLR_INSTR_POINTER_IN_RESERVED_BLOCK = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_RESERVED_BLOCK;
pub const DEBUG_FLR_INSTR_POINTER_IN_VM_MAPPED_MODULE = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_VM_MAPPED_MODULE;
pub const DEBUG_FLR_INSTR_POINTER_IN_MODULE_NOT_IN_LIST = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_MODULE_NOT_IN_LIST;
pub const DEBUG_FLR_INSTR_POINTER_NOT_IN_STREAM = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_NOT_IN_STREAM;
pub const DEBUG_FLR_MEMORY_CORRUPTION_SIGNATURE = DEBUG_FLR_PARAM_TYPE.MEMORY_CORRUPTION_SIGNATURE;
pub const DEBUG_FLR_BUILDNAME_IN_BUCKET = DEBUG_FLR_PARAM_TYPE.BUILDNAME_IN_BUCKET;
pub const DEBUG_FLR_CANCELLATION_NOT_SUPPORTED = DEBUG_FLR_PARAM_TYPE.CANCELLATION_NOT_SUPPORTED;
pub const DEBUG_FLR_DETOURED_IMAGE = DEBUG_FLR_PARAM_TYPE.DETOURED_IMAGE;
pub const DEBUG_FLR_EXCEPTION_CONTEXT_RECURSION = DEBUG_FLR_PARAM_TYPE.EXCEPTION_CONTEXT_RECURSION;
pub const DEBUG_FLR_DISKIO_READ_FAILURE = DEBUG_FLR_PARAM_TYPE.DISKIO_READ_FAILURE;
pub const DEBUG_FLR_DISKIO_WRITE_FAILURE = DEBUG_FLR_PARAM_TYPE.DISKIO_WRITE_FAILURE;
pub const DEBUG_FLR_GSFAILURE_MISSING_ESTABLISHER_FRAME = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MISSING_ESTABLISHER_FRAME;
pub const DEBUG_FLR_GSFAILURE_COOKIES_MATCH_EXH = DEBUG_FLR_PARAM_TYPE.GSFAILURE_COOKIES_MATCH_EXH;
pub const DEBUG_FLR_GSFAILURE_MANAGED = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MANAGED;
pub const DEBUG_FLR_MANAGED_FRAME_CHAIN_CORRUPTION = DEBUG_FLR_PARAM_TYPE.MANAGED_FRAME_CHAIN_CORRUPTION;
pub const DEBUG_FLR_GSFAILURE_MANAGED_THREADID = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MANAGED_THREADID;
pub const DEBUG_FLR_GSFAILURE_MANAGED_FRAMEID = DEBUG_FLR_PARAM_TYPE.GSFAILURE_MANAGED_FRAMEID;
pub const DEBUG_FLR_STACKUSAGE_IMAGE = DEBUG_FLR_PARAM_TYPE.STACKUSAGE_IMAGE;
pub const DEBUG_FLR_STACKUSAGE_IMAGE_SIZE = DEBUG_FLR_PARAM_TYPE.STACKUSAGE_IMAGE_SIZE;
pub const DEBUG_FLR_STACKUSAGE_FUNCTION = DEBUG_FLR_PARAM_TYPE.STACKUSAGE_FUNCTION;
pub const DEBUG_FLR_STACKUSAGE_FUNCTION_SIZE = DEBUG_FLR_PARAM_TYPE.STACKUSAGE_FUNCTION_SIZE;
pub const DEBUG_FLR_STACKUSAGE_RECURSION_COUNT = DEBUG_FLR_PARAM_TYPE.STACKUSAGE_RECURSION_COUNT;
pub const DEBUG_FLR_XBOX_SYSTEM_UPTIME = DEBUG_FLR_PARAM_TYPE.XBOX_SYSTEM_UPTIME;
pub const DEBUG_FLR_XBOX_SYSTEM_CRASHTIME = DEBUG_FLR_PARAM_TYPE.XBOX_SYSTEM_CRASHTIME;
pub const DEBUG_FLR_XBOX_LIVE_ENVIRONMENT = DEBUG_FLR_PARAM_TYPE.XBOX_LIVE_ENVIRONMENT;
pub const DEBUG_FLR_LARGE_TICK_INCREMENT = DEBUG_FLR_PARAM_TYPE.LARGE_TICK_INCREMENT;
pub const DEBUG_FLR_INSTR_POINTER_IN_PAGED_CODE = DEBUG_FLR_PARAM_TYPE.INSTR_POINTER_IN_PAGED_CODE;
pub const DEBUG_FLR_SERVICETABLE_MODIFIED = DEBUG_FLR_PARAM_TYPE.SERVICETABLE_MODIFIED;
pub const DEBUG_FLR_ALUREON = DEBUG_FLR_PARAM_TYPE.ALUREON;
pub const DEBUG_FLR_INTERNAL_RAID_BUG = DEBUG_FLR_PARAM_TYPE.INTERNAL_RAID_BUG;
pub const DEBUG_FLR_INTERNAL_BUCKET_URL = DEBUG_FLR_PARAM_TYPE.INTERNAL_BUCKET_URL;
pub const DEBUG_FLR_INTERNAL_SOLUTION_TEXT = DEBUG_FLR_PARAM_TYPE.INTERNAL_SOLUTION_TEXT;
pub const DEBUG_FLR_INTERNAL_BUCKET_HITCOUNT = DEBUG_FLR_PARAM_TYPE.INTERNAL_BUCKET_HITCOUNT;
pub const DEBUG_FLR_INTERNAL_RAID_BUG_DATABASE_STRING = DEBUG_FLR_PARAM_TYPE.INTERNAL_RAID_BUG_DATABASE_STRING;
pub const DEBUG_FLR_INTERNAL_BUCKET_CONTINUABLE = DEBUG_FLR_PARAM_TYPE.INTERNAL_BUCKET_CONTINUABLE;
pub const DEBUG_FLR_INTERNAL_BUCKET_STATUS_TEXT = DEBUG_FLR_PARAM_TYPE.INTERNAL_BUCKET_STATUS_TEXT;
pub const DEBUG_FLR_WATSON_MODULE = DEBUG_FLR_PARAM_TYPE.WATSON_MODULE;
pub const DEBUG_FLR_WATSON_MODULE_VERSION = DEBUG_FLR_PARAM_TYPE.WATSON_MODULE_VERSION;
pub const DEBUG_FLR_WATSON_MODULE_OFFSET = DEBUG_FLR_PARAM_TYPE.WATSON_MODULE_OFFSET;
pub const DEBUG_FLR_WATSON_PROCESS_VERSION = DEBUG_FLR_PARAM_TYPE.WATSON_PROCESS_VERSION;
pub const DEBUG_FLR_WATSON_IBUCKET = DEBUG_FLR_PARAM_TYPE.WATSON_IBUCKET;
pub const DEBUG_FLR_WATSON_MODULE_TIMESTAMP = DEBUG_FLR_PARAM_TYPE.WATSON_MODULE_TIMESTAMP;
pub const DEBUG_FLR_WATSON_PROCESS_TIMESTAMP = DEBUG_FLR_PARAM_TYPE.WATSON_PROCESS_TIMESTAMP;
pub const DEBUG_FLR_WATSON_GENERIC_EVENT_NAME = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_EVENT_NAME;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_00 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_00;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_01 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_01;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_02 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_02;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_03 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_03;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_04 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_04;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_05 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_05;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_06 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_06;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_07 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_07;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_08 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_08;
pub const DEBUG_FLR_WATSON_GENERIC_BUCKETING_09 = DEBUG_FLR_PARAM_TYPE.WATSON_GENERIC_BUCKETING_09;
pub const DEBUG_FLR_SYSXML_LOCALEID = DEBUG_FLR_PARAM_TYPE.SYSXML_LOCALEID;
pub const DEBUG_FLR_SYSXML_CHECKSUM = DEBUG_FLR_PARAM_TYPE.SYSXML_CHECKSUM;
pub const DEBUG_FLR_WQL_EVENT_COUNT = DEBUG_FLR_PARAM_TYPE.WQL_EVENT_COUNT;
pub const DEBUG_FLR_WQL_EVENTLOG_INFO = DEBUG_FLR_PARAM_TYPE.WQL_EVENTLOG_INFO;
pub const DEBUG_FLR_SYSINFO_SYSTEM_MANUFACTURER = DEBUG_FLR_PARAM_TYPE.SYSINFO_SYSTEM_MANUFACTURER;
pub const DEBUG_FLR_SYSINFO_SYSTEM_PRODUCT = DEBUG_FLR_PARAM_TYPE.SYSINFO_SYSTEM_PRODUCT;
pub const DEBUG_FLR_SYSINFO_SYSTEM_SKU = DEBUG_FLR_PARAM_TYPE.SYSINFO_SYSTEM_SKU;
pub const DEBUG_FLR_SYSINFO_SYSTEM_VERSION = DEBUG_FLR_PARAM_TYPE.SYSINFO_SYSTEM_VERSION;
pub const DEBUG_FLR_SYSINFO_BASEBOARD_MANUFACTURER = DEBUG_FLR_PARAM_TYPE.SYSINFO_BASEBOARD_MANUFACTURER;
pub const DEBUG_FLR_SYSINFO_BASEBOARD_PRODUCT = DEBUG_FLR_PARAM_TYPE.SYSINFO_BASEBOARD_PRODUCT;
pub const DEBUG_FLR_SYSINFO_BASEBOARD_VERSION = DEBUG_FLR_PARAM_TYPE.SYSINFO_BASEBOARD_VERSION;
pub const DEBUG_FLR_SYSINFO_BIOS_VENDOR = DEBUG_FLR_PARAM_TYPE.SYSINFO_BIOS_VENDOR;
pub const DEBUG_FLR_SYSINFO_BIOS_VERSION = DEBUG_FLR_PARAM_TYPE.SYSINFO_BIOS_VERSION;
pub const DEBUG_FLR_SYSINFO_BIOS_DATE = DEBUG_FLR_PARAM_TYPE.SYSINFO_BIOS_DATE;
pub const DEBUG_FLR_VIRTUAL_MACHINE = DEBUG_FLR_PARAM_TYPE.VIRTUAL_MACHINE;
pub const DEBUG_FLR_SERVICE = DEBUG_FLR_PARAM_TYPE.SERVICE;
pub const DEBUG_FLR_SERVICE_NAME = DEBUG_FLR_PARAM_TYPE.SERVICE_NAME;
pub const DEBUG_FLR_SERVICE_GROUP = DEBUG_FLR_PARAM_TYPE.SERVICE_GROUP;
pub const DEBUG_FLR_SERVICE_DISPLAYNAME = DEBUG_FLR_PARAM_TYPE.SERVICE_DISPLAYNAME;
pub const DEBUG_FLR_SERVICE_DESCRIPTION = DEBUG_FLR_PARAM_TYPE.SERVICE_DESCRIPTION;
pub const DEBUG_FLR_SERVICE_DEPENDONSERVICE = DEBUG_FLR_PARAM_TYPE.SERVICE_DEPENDONSERVICE;
pub const DEBUG_FLR_SERVICE_DEPENDONGROUP = DEBUG_FLR_PARAM_TYPE.SERVICE_DEPENDONGROUP;
pub const DEBUG_FLR_SVCHOST = DEBUG_FLR_PARAM_TYPE.SVCHOST;
pub const DEBUG_FLR_SVCHOST_GROUP = DEBUG_FLR_PARAM_TYPE.SVCHOST_GROUP;
pub const DEBUG_FLR_SVCHOST_IMAGEPATH = DEBUG_FLR_PARAM_TYPE.SVCHOST_IMAGEPATH;
pub const DEBUG_FLR_SVCHOST_SERVICEDLL = DEBUG_FLR_PARAM_TYPE.SVCHOST_SERVICEDLL;
pub const DEBUG_FLR_SCM = DEBUG_FLR_PARAM_TYPE.SCM;
pub const DEBUG_FLR_SCM_BLACKBOX = DEBUG_FLR_PARAM_TYPE.SCM_BLACKBOX;
pub const DEBUG_FLR_SCM_BLACKBOX_ENTRY = DEBUG_FLR_PARAM_TYPE.SCM_BLACKBOX_ENTRY;
pub const DEBUG_FLR_SCM_BLACKBOX_ENTRY_CONTROLCODE = DEBUG_FLR_PARAM_TYPE.SCM_BLACKBOX_ENTRY_CONTROLCODE;
pub const DEBUG_FLR_SCM_BLACKBOX_ENTRY_STARTTIME = DEBUG_FLR_PARAM_TYPE.SCM_BLACKBOX_ENTRY_STARTTIME;
pub const DEBUG_FLR_SCM_BLACKBOX_ENTRY_SERVICENAME = DEBUG_FLR_PARAM_TYPE.SCM_BLACKBOX_ENTRY_SERVICENAME;
pub const DEBUG_FLR_ACPI = DEBUG_FLR_PARAM_TYPE.ACPI;
pub const DEBUG_FLR_ACPI_BLACKBOX = DEBUG_FLR_PARAM_TYPE.ACPI_BLACKBOX;
pub const DEBUG_FLR_PO_BLACKBOX = DEBUG_FLR_PARAM_TYPE.PO_BLACKBOX;
pub const DEBUG_FLR_BOOTSTAT = DEBUG_FLR_PARAM_TYPE.BOOTSTAT;
pub const DEBUG_FLR_BOOTSTAT_BLACKBOX = DEBUG_FLR_PARAM_TYPE.BOOTSTAT_BLACKBOX;
pub const DEBUG_FLR_STORAGE = DEBUG_FLR_PARAM_TYPE.STORAGE;
pub const DEBUG_FLR_STORAGE_ORGID = DEBUG_FLR_PARAM_TYPE.STORAGE_ORGID;
pub const DEBUG_FLR_STORAGE_MODEL = DEBUG_FLR_PARAM_TYPE.STORAGE_MODEL;
pub const DEBUG_FLR_STORAGE_MFGID = DEBUG_FLR_PARAM_TYPE.STORAGE_MFGID;
pub const DEBUG_FLR_STORAGE_ISSUEDESCSTRING = DEBUG_FLR_PARAM_TYPE.STORAGE_ISSUEDESCSTRING;
pub const DEBUG_FLR_STORAGE_PUBLIC_TOTSIZE = DEBUG_FLR_PARAM_TYPE.STORAGE_PUBLIC_TOTSIZE;
pub const DEBUG_FLR_STORAGE_PUBLIC_OFFSET = DEBUG_FLR_PARAM_TYPE.STORAGE_PUBLIC_OFFSET;
pub const DEBUG_FLR_STORAGE_PUBLIC_DATASIZE = DEBUG_FLR_PARAM_TYPE.STORAGE_PUBLIC_DATASIZE;
pub const DEBUG_FLR_STORAGE_PRIVATE_TOTSIZE = DEBUG_FLR_PARAM_TYPE.STORAGE_PRIVATE_TOTSIZE;
pub const DEBUG_FLR_STORAGE_PRIVATE_OFFSET = DEBUG_FLR_PARAM_TYPE.STORAGE_PRIVATE_OFFSET;
pub const DEBUG_FLR_STORAGE_PRIVATE_DATASIZE = DEBUG_FLR_PARAM_TYPE.STORAGE_PRIVATE_DATASIZE;
pub const DEBUG_FLR_STORAGE_TOTALSIZE = DEBUG_FLR_PARAM_TYPE.STORAGE_TOTALSIZE;
pub const DEBUG_FLR_STORAGE_REASON = DEBUG_FLR_PARAM_TYPE.STORAGE_REASON;
pub const DEBUG_FLR_STORAGE_BLACKBOX = DEBUG_FLR_PARAM_TYPE.STORAGE_BLACKBOX;
pub const DEBUG_FLR_FILESYSTEMS_NTFS = DEBUG_FLR_PARAM_TYPE.FILESYSTEMS_NTFS;
pub const DEBUG_FLR_FILESYSTEMS_NTFS_BLACKBOX = DEBUG_FLR_PARAM_TYPE.FILESYSTEMS_NTFS_BLACKBOX;
pub const DEBUG_FLR_FILESYSTEMS_REFS = DEBUG_FLR_PARAM_TYPE.FILESYSTEMS_REFS;
pub const DEBUG_FLR_FILESYSTEMS_REFS_BLACKBOX = DEBUG_FLR_PARAM_TYPE.FILESYSTEMS_REFS_BLACKBOX;
pub const DEBUG_FLR_PNP = DEBUG_FLR_PARAM_TYPE.PNP;
pub const DEBUG_FLR_PNP_TRIAGE_DATA = DEBUG_FLR_PARAM_TYPE.PNP_TRIAGE_DATA;
pub const DEBUG_FLR_PNP_IRP_ADDRESS = DEBUG_FLR_PARAM_TYPE.PNP_IRP_ADDRESS;
pub const DEBUG_FLR_PNP_BLACKBOX = DEBUG_FLR_PARAM_TYPE.PNP_BLACKBOX;
pub const DEBUG_FLR_BUCKET_ID = DEBUG_FLR_PARAM_TYPE.BUCKET_ID;
pub const DEBUG_FLR_IMAGE_NAME = DEBUG_FLR_PARAM_TYPE.IMAGE_NAME;
pub const DEBUG_FLR_SYMBOL_NAME = DEBUG_FLR_PARAM_TYPE.SYMBOL_NAME;
pub const DEBUG_FLR_FOLLOWUP_NAME = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_NAME;
pub const DEBUG_FLR_STACK_COMMAND = DEBUG_FLR_PARAM_TYPE.STACK_COMMAND;
pub const DEBUG_FLR_STACK_TEXT = DEBUG_FLR_PARAM_TYPE.STACK_TEXT;
pub const DEBUG_FLR_MODULE_NAME = DEBUG_FLR_PARAM_TYPE.MODULE_NAME;
pub const DEBUG_FLR_FIXED_IN_OSVERSION = DEBUG_FLR_PARAM_TYPE.FIXED_IN_OSVERSION;
pub const DEBUG_FLR_DEFAULT_BUCKET_ID = DEBUG_FLR_PARAM_TYPE.DEFAULT_BUCKET_ID;
pub const DEBUG_FLR_MODULE_BUCKET_ID = DEBUG_FLR_PARAM_TYPE.MODULE_BUCKET_ID;
pub const DEBUG_FLR_ADDITIONAL_DEBUGTEXT = DEBUG_FLR_PARAM_TYPE.ADDITIONAL_DEBUGTEXT;
pub const DEBUG_FLR_PROCESS_NAME = DEBUG_FLR_PARAM_TYPE.PROCESS_NAME;
pub const DEBUG_FLR_USER_NAME = DEBUG_FLR_PARAM_TYPE.USER_NAME;
pub const DEBUG_FLR_MARKER_FILE = DEBUG_FLR_PARAM_TYPE.MARKER_FILE;
pub const DEBUG_FLR_INTERNAL_RESPONSE = DEBUG_FLR_PARAM_TYPE.INTERNAL_RESPONSE;
pub const DEBUG_FLR_CONTEXT_RESTORE_COMMAND = DEBUG_FLR_PARAM_TYPE.CONTEXT_RESTORE_COMMAND;
pub const DEBUG_FLR_DRIVER_HARDWAREID = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWAREID;
pub const DEBUG_FLR_DRIVER_HARDWARE_VENDOR_ID = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_VENDOR_ID;
pub const DEBUG_FLR_DRIVER_HARDWARE_DEVICE_ID = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_DEVICE_ID;
pub const DEBUG_FLR_DRIVER_HARDWARE_SUBSYS_ID = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_SUBSYS_ID;
pub const DEBUG_FLR_DRIVER_HARDWARE_REV_ID = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_REV_ID;
pub const DEBUG_FLR_DRIVER_HARDWARE_ID_BUS_TYPE = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_ID_BUS_TYPE;
pub const DEBUG_FLR_MARKER_MODULE_FILE = DEBUG_FLR_PARAM_TYPE.MARKER_MODULE_FILE;
pub const DEBUG_FLR_BUGCHECKING_DRIVER_IDTAG = DEBUG_FLR_PARAM_TYPE.BUGCHECKING_DRIVER_IDTAG;
pub const DEBUG_FLR_MARKER_BUCKET = DEBUG_FLR_PARAM_TYPE.MARKER_BUCKET;
pub const DEBUG_FLR_FAILURE_BUCKET_ID = DEBUG_FLR_PARAM_TYPE.FAILURE_BUCKET_ID;
pub const DEBUG_FLR_DRIVER_XML_DESCRIPTION = DEBUG_FLR_PARAM_TYPE.DRIVER_XML_DESCRIPTION;
pub const DEBUG_FLR_DRIVER_XML_PRODUCTNAME = DEBUG_FLR_PARAM_TYPE.DRIVER_XML_PRODUCTNAME;
pub const DEBUG_FLR_DRIVER_XML_MANUFACTURER = DEBUG_FLR_PARAM_TYPE.DRIVER_XML_MANUFACTURER;
pub const DEBUG_FLR_DRIVER_XML_VERSION = DEBUG_FLR_PARAM_TYPE.DRIVER_XML_VERSION;
pub const DEBUG_FLR_BUILD_VERSION_STRING = DEBUG_FLR_PARAM_TYPE.BUILD_VERSION_STRING;
pub const DEBUG_FLR_BUILD_OS_FULL_VERSION_STRING = DEBUG_FLR_PARAM_TYPE.BUILD_OS_FULL_VERSION_STRING;
pub const DEBUG_FLR_ORIGINAL_CAB_NAME = DEBUG_FLR_PARAM_TYPE.ORIGINAL_CAB_NAME;
pub const DEBUG_FLR_FAULTING_SOURCE_CODE = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_CODE;
pub const DEBUG_FLR_FAULTING_SERVICE_NAME = DEBUG_FLR_PARAM_TYPE.FAULTING_SERVICE_NAME;
pub const DEBUG_FLR_FILE_IN_CAB = DEBUG_FLR_PARAM_TYPE.FILE_IN_CAB;
pub const DEBUG_FLR_UNRESPONSIVE_UI_SYMBOL_NAME = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_SYMBOL_NAME;
pub const DEBUG_FLR_UNRESPONSIVE_UI_FOLLOWUP_NAME = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_FOLLOWUP_NAME;
pub const DEBUG_FLR_UNRESPONSIVE_UI_STACK = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_STACK;
pub const DEBUG_FLR_PROCESS_PRODUCTNAME = DEBUG_FLR_PARAM_TYPE.PROCESS_PRODUCTNAME;
pub const DEBUG_FLR_MODULE_PRODUCTNAME = DEBUG_FLR_PARAM_TYPE.MODULE_PRODUCTNAME;
pub const DEBUG_FLR_COLLECT_DATA_FOR_BUCKET = DEBUG_FLR_PARAM_TYPE.COLLECT_DATA_FOR_BUCKET;
pub const DEBUG_FLR_COMPUTER_NAME = DEBUG_FLR_PARAM_TYPE.COMPUTER_NAME;
pub const DEBUG_FLR_IMAGE_CLASS = DEBUG_FLR_PARAM_TYPE.IMAGE_CLASS;
pub const DEBUG_FLR_SYMBOL_ROUTINE_NAME = DEBUG_FLR_PARAM_TYPE.SYMBOL_ROUTINE_NAME;
pub const DEBUG_FLR_HARDWARE_BUCKET_TAG = DEBUG_FLR_PARAM_TYPE.HARDWARE_BUCKET_TAG;
pub const DEBUG_FLR_KERNEL_LOG_PROCESS_NAME = DEBUG_FLR_PARAM_TYPE.KERNEL_LOG_PROCESS_NAME;
pub const DEBUG_FLR_KERNEL_LOG_STATUS = DEBUG_FLR_PARAM_TYPE.KERNEL_LOG_STATUS;
pub const DEBUG_FLR_REGISTRYTXT_SOURCE = DEBUG_FLR_PARAM_TYPE.REGISTRYTXT_SOURCE;
pub const DEBUG_FLR_FAULTING_SOURCE_LINE = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_LINE;
pub const DEBUG_FLR_FAULTING_SOURCE_FILE = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_FILE;
pub const DEBUG_FLR_FAULTING_SOURCE_LINE_NUMBER = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_LINE_NUMBER;
pub const DEBUG_FLR_SKIP_MODULE_SPECIFIC_BUCKET_INFO = DEBUG_FLR_PARAM_TYPE.SKIP_MODULE_SPECIFIC_BUCKET_INFO;
pub const DEBUG_FLR_BUCKET_ID_FUNC_OFFSET = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_FUNC_OFFSET;
pub const DEBUG_FLR_XHCI_FIRMWARE_VERSION = DEBUG_FLR_PARAM_TYPE.XHCI_FIRMWARE_VERSION;
pub const DEBUG_FLR_FAILURE_ANALYSIS_SOURCE = DEBUG_FLR_PARAM_TYPE.FAILURE_ANALYSIS_SOURCE;
pub const DEBUG_FLR_FAILURE_ID_HASH = DEBUG_FLR_PARAM_TYPE.FAILURE_ID_HASH;
pub const DEBUG_FLR_FAILURE_ID_HASH_STRING = DEBUG_FLR_PARAM_TYPE.FAILURE_ID_HASH_STRING;
pub const DEBUG_FLR_FAILURE_ID_REPORT_LINK = DEBUG_FLR_PARAM_TYPE.FAILURE_ID_REPORT_LINK;
pub const DEBUG_FLR_HOLDINFO = DEBUG_FLR_PARAM_TYPE.HOLDINFO;
pub const DEBUG_FLR_HOLDINFO_ACTIVE_HOLD_COUNT = DEBUG_FLR_PARAM_TYPE.HOLDINFO_ACTIVE_HOLD_COUNT;
pub const DEBUG_FLR_HOLDINFO_TENET_SOCRE = DEBUG_FLR_PARAM_TYPE.HOLDINFO_TENET_SOCRE;
pub const DEBUG_FLR_HOLDINFO_HISTORIC_HOLD_COUNT = DEBUG_FLR_PARAM_TYPE.HOLDINFO_HISTORIC_HOLD_COUNT;
pub const DEBUG_FLR_HOLDINFO_ALWAYS_IGNORE = DEBUG_FLR_PARAM_TYPE.HOLDINFO_ALWAYS_IGNORE;
pub const DEBUG_FLR_HOLDINFO_ALWAYS_HOLD = DEBUG_FLR_PARAM_TYPE.HOLDINFO_ALWAYS_HOLD;
pub const DEBUG_FLR_HOLDINFO_MAX_HOLD_LIMIT = DEBUG_FLR_PARAM_TYPE.HOLDINFO_MAX_HOLD_LIMIT;
pub const DEBUG_FLR_HOLDINFO_MANUAL_HOLD = DEBUG_FLR_PARAM_TYPE.HOLDINFO_MANUAL_HOLD;
pub const DEBUG_FLR_HOLDINFO_NOTIFICATION_ALIASES = DEBUG_FLR_PARAM_TYPE.HOLDINFO_NOTIFICATION_ALIASES;
pub const DEBUG_FLR_HOLDINFO_LAST_SEEN_HOLD_DATE = DEBUG_FLR_PARAM_TYPE.HOLDINFO_LAST_SEEN_HOLD_DATE;
pub const DEBUG_FLR_HOLDINFO_RECOMMEND_HOLD = DEBUG_FLR_PARAM_TYPE.HOLDINFO_RECOMMEND_HOLD;
pub const DEBUG_FLR_FAILURE_PROBLEM_CLASS = DEBUG_FLR_PARAM_TYPE.FAILURE_PROBLEM_CLASS;
pub const DEBUG_FLR_FAILURE_EXCEPTION_CODE = DEBUG_FLR_PARAM_TYPE.FAILURE_EXCEPTION_CODE;
pub const DEBUG_FLR_FAILURE_IMAGE_NAME = DEBUG_FLR_PARAM_TYPE.FAILURE_IMAGE_NAME;
pub const DEBUG_FLR_FAILURE_FUNCTION_NAME = DEBUG_FLR_PARAM_TYPE.FAILURE_FUNCTION_NAME;
pub const DEBUG_FLR_FAILURE_SYMBOL_NAME = DEBUG_FLR_PARAM_TYPE.FAILURE_SYMBOL_NAME;
pub const DEBUG_FLR_FOLLOWUP_BEFORE_RETRACER = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_BEFORE_RETRACER;
pub const DEBUG_FLR_END_MESSAGE = DEBUG_FLR_PARAM_TYPE.END_MESSAGE;
pub const DEBUG_FLR_FEATURE_PATH = DEBUG_FLR_PARAM_TYPE.FEATURE_PATH;
pub const DEBUG_FLR_USER_MODE_BUCKET = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET;
pub const DEBUG_FLR_USER_MODE_BUCKET_INDEX = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_INDEX;
pub const DEBUG_FLR_USER_MODE_BUCKET_EVENTTYPE = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_EVENTTYPE;
pub const DEBUG_FLR_USER_MODE_BUCKET_REPORTGUID = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_REPORTGUID;
pub const DEBUG_FLR_USER_MODE_BUCKET_REPORTCREATIONTIME = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_REPORTCREATIONTIME;
pub const DEBUG_FLR_USER_MODE_BUCKET_P0 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P0;
pub const DEBUG_FLR_USER_MODE_BUCKET_P1 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P1;
pub const DEBUG_FLR_USER_MODE_BUCKET_P2 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P2;
pub const DEBUG_FLR_USER_MODE_BUCKET_P3 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P3;
pub const DEBUG_FLR_USER_MODE_BUCKET_P4 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P4;
pub const DEBUG_FLR_USER_MODE_BUCKET_P5 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P5;
pub const DEBUG_FLR_USER_MODE_BUCKET_P6 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P6;
pub const DEBUG_FLR_USER_MODE_BUCKET_P7 = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_P7;
pub const DEBUG_FLR_USER_MODE_BUCKET_STRING = DEBUG_FLR_PARAM_TYPE.USER_MODE_BUCKET_STRING;
pub const DEBUG_FLR_CRITICAL_PROCESS_REPORTGUID = DEBUG_FLR_PARAM_TYPE.CRITICAL_PROCESS_REPORTGUID;
pub const DEBUG_FLR_FAILURE_MODULE_NAME = DEBUG_FLR_PARAM_TYPE.FAILURE_MODULE_NAME;
pub const DEBUG_FLR_PLATFORM_BUCKET_STRING = DEBUG_FLR_PARAM_TYPE.PLATFORM_BUCKET_STRING;
pub const DEBUG_FLR_DRIVER_HARDWARE_VENDOR_NAME = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_VENDOR_NAME;
pub const DEBUG_FLR_DRIVER_HARDWARE_SUBVENDOR_NAME = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_SUBVENDOR_NAME;
pub const DEBUG_FLR_DRIVER_HARDWARE_DEVICE_NAME = DEBUG_FLR_PARAM_TYPE.DRIVER_HARDWARE_DEVICE_NAME;
pub const DEBUG_FLR_FAULTING_SOURCE_COMMIT_ID = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_COMMIT_ID;
pub const DEBUG_FLR_FAULTING_SOURCE_CONTROL_TYPE = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_CONTROL_TYPE;
pub const DEBUG_FLR_FAULTING_SOURCE_PROJECT = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_PROJECT;
pub const DEBUG_FLR_FAULTING_SOURCE_REPO_ID = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_REPO_ID;
pub const DEBUG_FLR_FAULTING_SOURCE_REPO_URL = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_REPO_URL;
pub const DEBUG_FLR_FAULTING_SOURCE_SRV_COMMAND = DEBUG_FLR_PARAM_TYPE.FAULTING_SOURCE_SRV_COMMAND;
pub const DEBUG_FLR_USERMODE_DATA = DEBUG_FLR_PARAM_TYPE.USERMODE_DATA;
pub const DEBUG_FLR_THREAD_ATTRIBUTES = DEBUG_FLR_PARAM_TYPE.THREAD_ATTRIBUTES;
pub const DEBUG_FLR_PROBLEM_CLASSES = DEBUG_FLR_PARAM_TYPE.PROBLEM_CLASSES;
pub const DEBUG_FLR_PRIMARY_PROBLEM_CLASS = DEBUG_FLR_PARAM_TYPE.PRIMARY_PROBLEM_CLASS;
pub const DEBUG_FLR_PRIMARY_PROBLEM_CLASS_DATA = DEBUG_FLR_PARAM_TYPE.PRIMARY_PROBLEM_CLASS_DATA;
pub const DEBUG_FLR_UNRESPONSIVE_UI_PROBLEM_CLASS = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_PROBLEM_CLASS;
pub const DEBUG_FLR_UNRESPONSIVE_UI_PROBLEM_CLASS_DATA = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_PROBLEM_CLASS_DATA;
pub const DEBUG_FLR_DERIVED_WAIT_CHAIN = DEBUG_FLR_PARAM_TYPE.DERIVED_WAIT_CHAIN;
pub const DEBUG_FLR_HANG_DATA_NEEDED = DEBUG_FLR_PARAM_TYPE.HANG_DATA_NEEDED;
pub const DEBUG_FLR_PROBLEM_CODE_PATH_HASH = DEBUG_FLR_PARAM_TYPE.PROBLEM_CODE_PATH_HASH;
pub const DEBUG_FLR_SUSPECT_CODE_PATH_HASH = DEBUG_FLR_PARAM_TYPE.SUSPECT_CODE_PATH_HASH;
pub const DEBUG_FLR_LOADERLOCK_IN_WAIT_CHAIN = DEBUG_FLR_PARAM_TYPE.LOADERLOCK_IN_WAIT_CHAIN;
pub const DEBUG_FLR_XPROC_HANG = DEBUG_FLR_PARAM_TYPE.XPROC_HANG;
pub const DEBUG_FLR_DEADLOCK_INPROC = DEBUG_FLR_PARAM_TYPE.DEADLOCK_INPROC;
pub const DEBUG_FLR_DEADLOCK_XPROC = DEBUG_FLR_PARAM_TYPE.DEADLOCK_XPROC;
pub const DEBUG_FLR_WCT_XML_AVAILABLE = DEBUG_FLR_PARAM_TYPE.WCT_XML_AVAILABLE;
pub const DEBUG_FLR_XPROC_DUMP_AVAILABLE = DEBUG_FLR_PARAM_TYPE.XPROC_DUMP_AVAILABLE;
pub const DEBUG_FLR_DESKTOP_HEAP_MISSING = DEBUG_FLR_PARAM_TYPE.DESKTOP_HEAP_MISSING;
pub const DEBUG_FLR_HANG_REPORT_THREAD_IS_IDLE = DEBUG_FLR_PARAM_TYPE.HANG_REPORT_THREAD_IS_IDLE;
pub const DEBUG_FLR_FAULT_THREAD_SHA1_HASH_MF = DEBUG_FLR_PARAM_TYPE.FAULT_THREAD_SHA1_HASH_MF;
pub const DEBUG_FLR_FAULT_THREAD_SHA1_HASH_MFO = DEBUG_FLR_PARAM_TYPE.FAULT_THREAD_SHA1_HASH_MFO;
pub const DEBUG_FLR_FAULT_THREAD_SHA1_HASH_M = DEBUG_FLR_PARAM_TYPE.FAULT_THREAD_SHA1_HASH_M;
pub const DEBUG_FLR_WAIT_CHAIN_COMMAND = DEBUG_FLR_PARAM_TYPE.WAIT_CHAIN_COMMAND;
pub const DEBUG_FLR_NTGLOBALFLAG = DEBUG_FLR_PARAM_TYPE.NTGLOBALFLAG;
pub const DEBUG_FLR_APPVERIFERFLAGS = DEBUG_FLR_PARAM_TYPE.APPVERIFERFLAGS;
pub const DEBUG_FLR_MODLIST_SHA1_HASH = DEBUG_FLR_PARAM_TYPE.MODLIST_SHA1_HASH;
pub const DEBUG_FLR_DUMP_TYPE = DEBUG_FLR_PARAM_TYPE.DUMP_TYPE;
pub const DEBUG_FLR_XCS_PATH = DEBUG_FLR_PARAM_TYPE.XCS_PATH;
pub const DEBUG_FLR_LOADERLOCK_OWNER_API = DEBUG_FLR_PARAM_TYPE.LOADERLOCK_OWNER_API;
pub const DEBUG_FLR_LOADERLOCK_BLOCKED_API = DEBUG_FLR_PARAM_TYPE.LOADERLOCK_BLOCKED_API;
pub const DEBUG_FLR_MODLIST_TSCHKSUM_SHA1_HASH = DEBUG_FLR_PARAM_TYPE.MODLIST_TSCHKSUM_SHA1_HASH;
pub const DEBUG_FLR_MODLIST_UNLOADED_SHA1_HASH = DEBUG_FLR_PARAM_TYPE.MODLIST_UNLOADED_SHA1_HASH;
pub const DEBUG_FLR_MACHINE_INFO_SHA1_HASH = DEBUG_FLR_PARAM_TYPE.MACHINE_INFO_SHA1_HASH;
pub const DEBUG_FLR_URLS_DISCOVERED = DEBUG_FLR_PARAM_TYPE.URLS_DISCOVERED;
pub const DEBUG_FLR_URLS = DEBUG_FLR_PARAM_TYPE.URLS;
pub const DEBUG_FLR_URL_ENTRY = DEBUG_FLR_PARAM_TYPE.URL_ENTRY;
pub const DEBUG_FLR_WATSON_IBUCKET_S1_RESP = DEBUG_FLR_PARAM_TYPE.WATSON_IBUCKET_S1_RESP;
pub const DEBUG_FLR_WATSON_IBUCKETTABLE_S1_RESP = DEBUG_FLR_PARAM_TYPE.WATSON_IBUCKETTABLE_S1_RESP;
pub const DEBUG_FLR_SEARCH_HANG = DEBUG_FLR_PARAM_TYPE.SEARCH_HANG;
pub const DEBUG_FLR_WER_DATA_COLLECTION_INFO = DEBUG_FLR_PARAM_TYPE.WER_DATA_COLLECTION_INFO;
pub const DEBUG_FLR_WER_MACHINE_ID = DEBUG_FLR_PARAM_TYPE.WER_MACHINE_ID;
pub const DEBUG_FLR_ULS_SCRIPT_EXCEPTION = DEBUG_FLR_PARAM_TYPE.ULS_SCRIPT_EXCEPTION;
pub const DEBUG_FLR_LCIE_ISO_AVAILABLE = DEBUG_FLR_PARAM_TYPE.LCIE_ISO_AVAILABLE;
pub const DEBUG_FLR_SHOW_LCIE_ISO_DATA = DEBUG_FLR_PARAM_TYPE.SHOW_LCIE_ISO_DATA;
pub const DEBUG_FLR_URL_LCIE_ENTRY = DEBUG_FLR_PARAM_TYPE.URL_LCIE_ENTRY;
pub const DEBUG_FLR_URL_URLMON_ENTRY = DEBUG_FLR_PARAM_TYPE.URL_URLMON_ENTRY;
pub const DEBUG_FLR_URL_XMLHTTPREQ_SYNC_ENTRY = DEBUG_FLR_PARAM_TYPE.URL_XMLHTTPREQ_SYNC_ENTRY;
pub const DEBUG_FLR_FAULTING_LOCAL_VARIABLE_NAME = DEBUG_FLR_PARAM_TYPE.FAULTING_LOCAL_VARIABLE_NAME;
pub const DEBUG_FLR_MODULE_LIST = DEBUG_FLR_PARAM_TYPE.MODULE_LIST;
pub const DEBUG_FLR_DUMP_FLAGS = DEBUG_FLR_PARAM_TYPE.DUMP_FLAGS;
pub const DEBUG_FLR_APPLICATION_VERIFIER_LOADED = DEBUG_FLR_PARAM_TYPE.APPLICATION_VERIFIER_LOADED;
pub const DEBUG_FLR_DUMP_CLASS = DEBUG_FLR_PARAM_TYPE.DUMP_CLASS;
pub const DEBUG_FLR_DUMP_QUALIFIER = DEBUG_FLR_PARAM_TYPE.DUMP_QUALIFIER;
pub const DEBUG_FLR_KM_MODULE_LIST = DEBUG_FLR_PARAM_TYPE.KM_MODULE_LIST;
pub const DEBUG_FLR_EXCEPTION_CODE_STR_deprecated = DEBUG_FLR_PARAM_TYPE.EXCEPTION_CODE_STR_deprecated;
pub const DEBUG_FLR_BUCKET_ID_PREFIX_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_PREFIX_STR;
pub const DEBUG_FLR_BUCKET_ID_MODULE_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_MODULE_STR;
pub const DEBUG_FLR_BUCKET_ID_MODVER_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_MODVER_STR;
pub const DEBUG_FLR_BUCKET_ID_FUNCTION_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_FUNCTION_STR;
pub const DEBUG_FLR_BUCKET_ID_OFFSET = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_OFFSET;
pub const DEBUG_FLR_OS_BUILD = DEBUG_FLR_PARAM_TYPE.OS_BUILD;
pub const DEBUG_FLR_OS_SERVICEPACK = DEBUG_FLR_PARAM_TYPE.OS_SERVICEPACK;
pub const DEBUG_FLR_OS_BRANCH = DEBUG_FLR_PARAM_TYPE.OS_BRANCH;
pub const DEBUG_FLR_OS_BUILD_TIMESTAMP_LAB = DEBUG_FLR_PARAM_TYPE.OS_BUILD_TIMESTAMP_LAB;
pub const DEBUG_FLR_OS_VERSION = DEBUG_FLR_PARAM_TYPE.OS_VERSION;
pub const DEBUG_FLR_BUCKET_ID_TIMEDATESTAMP = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_TIMEDATESTAMP;
pub const DEBUG_FLR_BUCKET_ID_CHECKSUM = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_CHECKSUM;
pub const DEBUG_FLR_OS_FLAVOR = DEBUG_FLR_PARAM_TYPE.OS_FLAVOR;
pub const DEBUG_FLR_BUCKET_ID_FLAVOR_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_FLAVOR_STR;
pub const DEBUG_FLR_OS_SKU = DEBUG_FLR_PARAM_TYPE.OS_SKU;
pub const DEBUG_FLR_OS_PRODUCT_TYPE = DEBUG_FLR_PARAM_TYPE.OS_PRODUCT_TYPE;
pub const DEBUG_FLR_OS_SUITE_MASK = DEBUG_FLR_PARAM_TYPE.OS_SUITE_MASK;
pub const DEBUG_FLR_USER_LCID = DEBUG_FLR_PARAM_TYPE.USER_LCID;
pub const DEBUG_FLR_OS_REVISION = DEBUG_FLR_PARAM_TYPE.OS_REVISION;
pub const DEBUG_FLR_OS_NAME = DEBUG_FLR_PARAM_TYPE.OS_NAME;
pub const DEBUG_FLR_OS_NAME_EDITION = DEBUG_FLR_PARAM_TYPE.OS_NAME_EDITION;
pub const DEBUG_FLR_OS_PLATFORM_ARCH = DEBUG_FLR_PARAM_TYPE.OS_PLATFORM_ARCH;
pub const DEBUG_FLR_OS_SERVICEPACK_deprecated = DEBUG_FLR_PARAM_TYPE.OS_SERVICEPACK_deprecated;
pub const DEBUG_FLR_OS_LOCALE = DEBUG_FLR_PARAM_TYPE.OS_LOCALE;
pub const DEBUG_FLR_OS_BUILD_TIMESTAMP_ISO = DEBUG_FLR_PARAM_TYPE.OS_BUILD_TIMESTAMP_ISO;
pub const DEBUG_FLR_USER_LCID_STR = DEBUG_FLR_PARAM_TYPE.USER_LCID_STR;
pub const DEBUG_FLR_ANALYSIS_SESSION_TIME = DEBUG_FLR_PARAM_TYPE.ANALYSIS_SESSION_TIME;
pub const DEBUG_FLR_ANALYSIS_SESSION_HOST = DEBUG_FLR_PARAM_TYPE.ANALYSIS_SESSION_HOST;
pub const DEBUG_FLR_ANALYSIS_SESSION_ELAPSED_TIME = DEBUG_FLR_PARAM_TYPE.ANALYSIS_SESSION_ELAPSED_TIME;
pub const DEBUG_FLR_ANALYSIS_VERSION = DEBUG_FLR_PARAM_TYPE.ANALYSIS_VERSION;
pub const DEBUG_FLR_BUCKET_ID_IMAGE_STR = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_IMAGE_STR;
pub const DEBUG_FLR_BUCKET_ID_PRIVATE = DEBUG_FLR_PARAM_TYPE.BUCKET_ID_PRIVATE;
pub const DEBUG_FLR_ANALYSIS_REPROCESS = DEBUG_FLR_PARAM_TYPE.ANALYSIS_REPROCESS;
pub const DEBUG_FLR_OS_MAJOR = DEBUG_FLR_PARAM_TYPE.OS_MAJOR;
pub const DEBUG_FLR_OS_MINOR = DEBUG_FLR_PARAM_TYPE.OS_MINOR;
pub const DEBUG_FLR_OS_BUILD_STRING = DEBUG_FLR_PARAM_TYPE.OS_BUILD_STRING;
pub const DEBUG_FLR_OS_LOCALE_LCID = DEBUG_FLR_PARAM_TYPE.OS_LOCALE_LCID;
pub const DEBUG_FLR_OS_PLATFORM_ID = DEBUG_FLR_PARAM_TYPE.OS_PLATFORM_ID;
pub const DEBUG_FLR_OS_BUILD_LAYERS_XML = DEBUG_FLR_PARAM_TYPE.OS_BUILD_LAYERS_XML;
pub const DEBUG_FLR_OSBUILD_deprecated = DEBUG_FLR_PARAM_TYPE.OSBUILD_deprecated;
pub const DEBUG_FLR_BUILDOSVER_STR_deprecated = DEBUG_FLR_PARAM_TYPE.BUILDOSVER_STR_deprecated;
pub const DEBUG_FLR_DEBUG_ANALYSIS = DEBUG_FLR_PARAM_TYPE.DEBUG_ANALYSIS;
pub const DEBUG_FLR_KEYVALUE_ANALYSIS = DEBUG_FLR_PARAM_TYPE.KEYVALUE_ANALYSIS;
pub const DEBUG_FLR_KEY_VALUES_STRING = DEBUG_FLR_PARAM_TYPE.KEY_VALUES_STRING;
pub const DEBUG_FLR_KEY_VALUES_VARIANT = DEBUG_FLR_PARAM_TYPE.KEY_VALUES_VARIANT;
pub const DEBUG_FLR_TIMELINE_ANALYSIS = DEBUG_FLR_PARAM_TYPE.TIMELINE_ANALYSIS;
pub const DEBUG_FLR_TIMELINE_TIMES = DEBUG_FLR_PARAM_TYPE.TIMELINE_TIMES;
pub const DEBUG_FLR_STREAM_ANALYSIS = DEBUG_FLR_PARAM_TYPE.STREAM_ANALYSIS;
pub const DEBUG_FLR_MEMORY_ANALYSIS = DEBUG_FLR_PARAM_TYPE.MEMORY_ANALYSIS;
pub const DEBUG_FLR_STACKHASH_ANALYSIS = DEBUG_FLR_PARAM_TYPE.STACKHASH_ANALYSIS;
pub const DEBUG_FLR_PROCESSES_ANALYSIS = DEBUG_FLR_PARAM_TYPE.PROCESSES_ANALYSIS;
pub const DEBUG_FLR_SERVICE_ANALYSIS = DEBUG_FLR_PARAM_TYPE.SERVICE_ANALYSIS;
pub const DEBUG_FLR_ADDITIONAL_XML = DEBUG_FLR_PARAM_TYPE.ADDITIONAL_XML;
pub const DEBUG_FLR_STACK = DEBUG_FLR_PARAM_TYPE.STACK;
pub const DEBUG_FLR_FOLLOWUP_CONTEXT = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_CONTEXT;
pub const DEBUG_FLR_XML_MODULE_LIST = DEBUG_FLR_PARAM_TYPE.XML_MODULE_LIST;
pub const DEBUG_FLR_STACK_FRAME = DEBUG_FLR_PARAM_TYPE.STACK_FRAME;
pub const DEBUG_FLR_STACK_FRAME_NUMBER = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_NUMBER;
pub const DEBUG_FLR_STACK_FRAME_INSTRUCTION = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_INSTRUCTION;
pub const DEBUG_FLR_STACK_FRAME_SYMBOL = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_SYMBOL;
pub const DEBUG_FLR_STACK_FRAME_SYMBOL_OFFSET = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_SYMBOL_OFFSET;
pub const DEBUG_FLR_STACK_FRAME_MODULE = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_MODULE;
pub const DEBUG_FLR_STACK_FRAME_IMAGE = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_IMAGE;
pub const DEBUG_FLR_STACK_FRAME_FUNCTION = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_FUNCTION;
pub const DEBUG_FLR_STACK_FRAME_FLAGS = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_FLAGS;
pub const DEBUG_FLR_CONTEXT_COMMAND = DEBUG_FLR_PARAM_TYPE.CONTEXT_COMMAND;
pub const DEBUG_FLR_CONTEXT_FLAGS = DEBUG_FLR_PARAM_TYPE.CONTEXT_FLAGS;
pub const DEBUG_FLR_CONTEXT_ORDER = DEBUG_FLR_PARAM_TYPE.CONTEXT_ORDER;
pub const DEBUG_FLR_CONTEXT_SYSTEM = DEBUG_FLR_PARAM_TYPE.CONTEXT_SYSTEM;
pub const DEBUG_FLR_CONTEXT_ID = DEBUG_FLR_PARAM_TYPE.CONTEXT_ID;
pub const DEBUG_FLR_XML_MODULE_INFO = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO;
pub const DEBUG_FLR_XML_MODULE_INFO_INDEX = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_INDEX;
pub const DEBUG_FLR_XML_MODULE_INFO_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_NAME;
pub const DEBUG_FLR_XML_MODULE_INFO_IMAGE_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_IMAGE_NAME;
pub const DEBUG_FLR_XML_MODULE_INFO_IMAGE_PATH = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_IMAGE_PATH;
pub const DEBUG_FLR_XML_MODULE_INFO_CHECKSUM = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_CHECKSUM;
pub const DEBUG_FLR_XML_MODULE_INFO_TIMESTAMP = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_TIMESTAMP;
pub const DEBUG_FLR_XML_MODULE_INFO_UNLOADED = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_UNLOADED;
pub const DEBUG_FLR_XML_MODULE_INFO_ON_STACK = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_ON_STACK;
pub const DEBUG_FLR_XML_MODULE_INFO_FIXED_FILE_VER = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_FIXED_FILE_VER;
pub const DEBUG_FLR_XML_MODULE_INFO_FIXED_PROD_VER = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_FIXED_PROD_VER;
pub const DEBUG_FLR_XML_MODULE_INFO_STRING_FILE_VER = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_STRING_FILE_VER;
pub const DEBUG_FLR_XML_MODULE_INFO_STRING_PROD_VER = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_STRING_PROD_VER;
pub const DEBUG_FLR_XML_MODULE_INFO_COMPANY_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_COMPANY_NAME;
pub const DEBUG_FLR_XML_MODULE_INFO_FILE_DESCRIPTION = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_FILE_DESCRIPTION;
pub const DEBUG_FLR_XML_MODULE_INFO_INTERNAL_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_INTERNAL_NAME;
pub const DEBUG_FLR_XML_MODULE_INFO_ORIG_FILE_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_ORIG_FILE_NAME;
pub const DEBUG_FLR_XML_MODULE_INFO_BASE = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_BASE;
pub const DEBUG_FLR_XML_MODULE_INFO_SIZE = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SIZE;
pub const DEBUG_FLR_XML_MODULE_INFO_PRODUCT_NAME = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_PRODUCT_NAME;
pub const DEBUG_FLR_PROCESS_INFO = DEBUG_FLR_PARAM_TYPE.PROCESS_INFO;
pub const DEBUG_FLR_EXCEPTION_MODULE_INFO = DEBUG_FLR_PARAM_TYPE.EXCEPTION_MODULE_INFO;
pub const DEBUG_FLR_CONTEXT_FOLLOWUP_INDEX = DEBUG_FLR_PARAM_TYPE.CONTEXT_FOLLOWUP_INDEX;
pub const DEBUG_FLR_XML_GLOBALATTRIBUTE_LIST = DEBUG_FLR_PARAM_TYPE.XML_GLOBALATTRIBUTE_LIST;
pub const DEBUG_FLR_XML_ATTRIBUTE_LIST = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_LIST;
pub const DEBUG_FLR_XML_ATTRIBUTE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE;
pub const DEBUG_FLR_XML_ATTRIBUTE_NAME = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_NAME;
pub const DEBUG_FLR_XML_ATTRIBUTE_VALUE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_VALUE;
pub const DEBUG_FLR_XML_ATTRIBUTE_D1VALUE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_D1VALUE;
pub const DEBUG_FLR_XML_ATTRIBUTE_D2VALUE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_D2VALUE;
pub const DEBUG_FLR_XML_ATTRIBUTE_DOVALUE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_DOVALUE;
pub const DEBUG_FLR_XML_ATTRIBUTE_VALUE_TYPE = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_VALUE_TYPE;
pub const DEBUG_FLR_XML_ATTRIBUTE_FRAME_NUMBER = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_FRAME_NUMBER;
pub const DEBUG_FLR_XML_ATTRIBUTE_THREAD_INDEX = DEBUG_FLR_PARAM_TYPE.XML_ATTRIBUTE_THREAD_INDEX;
pub const DEBUG_FLR_XML_PROBLEMCLASS_LIST = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_LIST;
pub const DEBUG_FLR_XML_PROBLEMCLASS = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS;
pub const DEBUG_FLR_XML_PROBLEMCLASS_NAME = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_NAME;
pub const DEBUG_FLR_XML_PROBLEMCLASS_VALUE = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_VALUE;
pub const DEBUG_FLR_XML_PROBLEMCLASS_VALUE_TYPE = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_VALUE_TYPE;
pub const DEBUG_FLR_XML_PROBLEMCLASS_FRAME_NUMBER = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_FRAME_NUMBER;
pub const DEBUG_FLR_XML_PROBLEMCLASS_THREAD_INDEX = DEBUG_FLR_PARAM_TYPE.XML_PROBLEMCLASS_THREAD_INDEX;
pub const DEBUG_FLR_XML_STACK_FRAME_TRIAGE_STATUS = DEBUG_FLR_PARAM_TYPE.XML_STACK_FRAME_TRIAGE_STATUS;
pub const DEBUG_FLR_CONTEXT_METADATA = DEBUG_FLR_PARAM_TYPE.CONTEXT_METADATA;
pub const DEBUG_FLR_STACK_FRAMES = DEBUG_FLR_PARAM_TYPE.STACK_FRAMES;
pub const DEBUG_FLR_XML_ENCODED_OFFSETS = DEBUG_FLR_PARAM_TYPE.XML_ENCODED_OFFSETS;
pub const DEBUG_FLR_FA_PERF_DATA = DEBUG_FLR_PARAM_TYPE.FA_PERF_DATA;
pub const DEBUG_FLR_FA_PERF_ITEM = DEBUG_FLR_PARAM_TYPE.FA_PERF_ITEM;
pub const DEBUG_FLR_FA_PERF_ITEM_NAME = DEBUG_FLR_PARAM_TYPE.FA_PERF_ITEM_NAME;
pub const DEBUG_FLR_FA_PERF_ITERATIONS = DEBUG_FLR_PARAM_TYPE.FA_PERF_ITERATIONS;
pub const DEBUG_FLR_FA_PERF_ELAPSED_MS = DEBUG_FLR_PARAM_TYPE.FA_PERF_ELAPSED_MS;
pub const DEBUG_FLR_STACK_SHA1_HASH_MF = DEBUG_FLR_PARAM_TYPE.STACK_SHA1_HASH_MF;
pub const DEBUG_FLR_STACK_SHA1_HASH_MFO = DEBUG_FLR_PARAM_TYPE.STACK_SHA1_HASH_MFO;
pub const DEBUG_FLR_STACK_SHA1_HASH_M = DEBUG_FLR_PARAM_TYPE.STACK_SHA1_HASH_M;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMBOL_TYPE = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMBOL_TYPE;
pub const DEBUG_FLR_XML_MODULE_INFO_FILE_FLAGS = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_FILE_FLAGS;
pub const DEBUG_FLR_STACK_FRAME_MODULE_BASE = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_MODULE_BASE;
pub const DEBUG_FLR_STACK_FRAME_SRC = DEBUG_FLR_PARAM_TYPE.STACK_FRAME_SRC;
pub const DEBUG_FLR_XML_SYSTEMINFO = DEBUG_FLR_PARAM_TYPE.XML_SYSTEMINFO;
pub const DEBUG_FLR_XML_SYSTEMINFO_SYSTEMMANUFACTURER = DEBUG_FLR_PARAM_TYPE.XML_SYSTEMINFO_SYSTEMMANUFACTURER;
pub const DEBUG_FLR_XML_SYSTEMINFO_SYSTEMMODEL = DEBUG_FLR_PARAM_TYPE.XML_SYSTEMINFO_SYSTEMMODEL;
pub const DEBUG_FLR_XML_SYSTEMINFO_SYSTEMMARKER = DEBUG_FLR_PARAM_TYPE.XML_SYSTEMINFO_SYSTEMMARKER;
pub const DEBUG_FLR_FA_ADHOC_ANALYSIS_ITEMS = DEBUG_FLR_PARAM_TYPE.FA_ADHOC_ANALYSIS_ITEMS;
pub const DEBUG_FLR_XML_APPLICATION_NAME = DEBUG_FLR_PARAM_TYPE.XML_APPLICATION_NAME;
pub const DEBUG_FLR_XML_PACKAGE_MONIKER = DEBUG_FLR_PARAM_TYPE.XML_PACKAGE_MONIKER;
pub const DEBUG_FLR_XML_PACKAGE_RELATIVE_APPLICATION_ID = DEBUG_FLR_PARAM_TYPE.XML_PACKAGE_RELATIVE_APPLICATION_ID;
pub const DEBUG_FLR_XML_MODERN_ASYNC_REQUEST_OUTSTANDING = DEBUG_FLR_PARAM_TYPE.XML_MODERN_ASYNC_REQUEST_OUTSTANDING;
pub const DEBUG_FLR_XML_EVENTTYPE = DEBUG_FLR_PARAM_TYPE.XML_EVENTTYPE;
pub const DEBUG_FLR_XML_PACKAGE_NAME = DEBUG_FLR_PARAM_TYPE.XML_PACKAGE_NAME;
pub const DEBUG_FLR_XML_PACKAGE_VERSION = DEBUG_FLR_PARAM_TYPE.XML_PACKAGE_VERSION;
pub const DEBUG_FLR_FAILURE_LIST = DEBUG_FLR_PARAM_TYPE.FAILURE_LIST;
pub const DEBUG_FLR_FAILURE_DISPLAY_NAME = DEBUG_FLR_PARAM_TYPE.FAILURE_DISPLAY_NAME;
pub const DEBUG_FLR_FRAME_SOURCE_FILE_NAME = DEBUG_FLR_PARAM_TYPE.FRAME_SOURCE_FILE_NAME;
pub const DEBUG_FLR_FRAME_SOURCE_FILE_PATH = DEBUG_FLR_PARAM_TYPE.FRAME_SOURCE_FILE_PATH;
pub const DEBUG_FLR_FRAME_SOURCE_LINE_NUMBER = DEBUG_FLR_PARAM_TYPE.FRAME_SOURCE_LINE_NUMBER;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_IMAGE_STATUS = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_IMAGE_STATUS;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_IMAGE_ERROR = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_IMAGE_ERROR;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_IMAGE_DETAIL = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_IMAGE_DETAIL;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_IMAGE_SEC = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_IMAGE_SEC;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_PDB_STATUS = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_PDB_STATUS;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_PDB_ERROR = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_PDB_ERROR;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_PDB_DETAIL = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_PDB_DETAIL;
pub const DEBUG_FLR_XML_MODULE_INFO_SYMSRV_PDB_SEC = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_SYMSRV_PDB_SEC;
pub const DEBUG_FLR_XML_MODULE_INFO_DRIVER_GROUP = DEBUG_FLR_PARAM_TYPE.XML_MODULE_INFO_DRIVER_GROUP;
pub const DEBUG_FLR_REGISTRY_DATA = DEBUG_FLR_PARAM_TYPE.REGISTRY_DATA;
pub const DEBUG_FLR_WMI_QUERY_DATA = DEBUG_FLR_PARAM_TYPE.WMI_QUERY_DATA;
pub const DEBUG_FLR_USER_GLOBAL_ATTRIBUTES = DEBUG_FLR_PARAM_TYPE.USER_GLOBAL_ATTRIBUTES;
pub const DEBUG_FLR_USER_THREAD_ATTRIBUTES = DEBUG_FLR_PARAM_TYPE.USER_THREAD_ATTRIBUTES;
pub const DEBUG_FLR_USER_PROBLEM_CLASSES = DEBUG_FLR_PARAM_TYPE.USER_PROBLEM_CLASSES;
pub const DEBUG_FLR_SM_COMPRESSION_FORMAT = DEBUG_FLR_PARAM_TYPE.SM_COMPRESSION_FORMAT;
pub const DEBUG_FLR_SM_SOURCE_PFN1 = DEBUG_FLR_PARAM_TYPE.SM_SOURCE_PFN1;
pub const DEBUG_FLR_SM_SOURCE_PFN2 = DEBUG_FLR_PARAM_TYPE.SM_SOURCE_PFN2;
pub const DEBUG_FLR_SM_SOURCE_OFFSET = DEBUG_FLR_PARAM_TYPE.SM_SOURCE_OFFSET;
pub const DEBUG_FLR_SM_SOURCE_SIZE = DEBUG_FLR_PARAM_TYPE.SM_SOURCE_SIZE;
pub const DEBUG_FLR_SM_TARGET_PFN = DEBUG_FLR_PARAM_TYPE.SM_TARGET_PFN;
pub const DEBUG_FLR_SM_BUFFER_HASH = DEBUG_FLR_PARAM_TYPE.SM_BUFFER_HASH;
pub const DEBUG_FLR_SM_ONEBIT_SOLUTION_COUNT = DEBUG_FLR_PARAM_TYPE.SM_ONEBIT_SOLUTION_COUNT;
pub const DEBUG_FLR_STORE_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_PRODUCT_ID;
pub const DEBUG_FLR_STORE_PRODUCT_DISPLAY_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PRODUCT_DISPLAY_NAME;
pub const DEBUG_FLR_STORE_PRODUCT_DESCRIPTION = DEBUG_FLR_PARAM_TYPE.STORE_PRODUCT_DESCRIPTION;
pub const DEBUG_FLR_STORE_PRODUCT_EXTENDED_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PRODUCT_EXTENDED_NAME;
pub const DEBUG_FLR_STORE_PUBLISHER_ID = DEBUG_FLR_PARAM_TYPE.STORE_PUBLISHER_ID;
pub const DEBUG_FLR_STORE_PUBLISHER_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PUBLISHER_NAME;
pub const DEBUG_FLR_STORE_PUBLISHER_CERTIFICATE_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PUBLISHER_CERTIFICATE_NAME;
pub const DEBUG_FLR_STORE_DEVELOPER_NAME = DEBUG_FLR_PARAM_TYPE.STORE_DEVELOPER_NAME;
pub const DEBUG_FLR_STORE_PACKAGE_FAMILY_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PACKAGE_FAMILY_NAME;
pub const DEBUG_FLR_STORE_PACKAGE_IDENTITY_NAME = DEBUG_FLR_PARAM_TYPE.STORE_PACKAGE_IDENTITY_NAME;
pub const DEBUG_FLR_STORE_PRIMARY_PARENT_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_PRIMARY_PARENT_PRODUCT_ID;
pub const DEBUG_FLR_STORE_LEGACY_PARENT_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_LEGACY_PARENT_PRODUCT_ID;
pub const DEBUG_FLR_STORE_LEGACY_WINDOWS_STORE_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_LEGACY_WINDOWS_STORE_PRODUCT_ID;
pub const DEBUG_FLR_STORE_LEGACY_WINDOWS_PHONE_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_LEGACY_WINDOWS_PHONE_PRODUCT_ID;
pub const DEBUG_FLR_STORE_LEGACY_XBOX_ONE_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_LEGACY_XBOX_ONE_PRODUCT_ID;
pub const DEBUG_FLR_STORE_LEGACY_XBOX_360_PRODUCT_ID = DEBUG_FLR_PARAM_TYPE.STORE_LEGACY_XBOX_360_PRODUCT_ID;
pub const DEBUG_FLR_STORE_XBOX_TITLE_ID = DEBUG_FLR_PARAM_TYPE.STORE_XBOX_TITLE_ID;
pub const DEBUG_FLR_STORE_PREFERRED_SKU_ID = DEBUG_FLR_PARAM_TYPE.STORE_PREFERRED_SKU_ID;
pub const DEBUG_FLR_STORE_IS_MICROSOFT_PRODUCT = DEBUG_FLR_PARAM_TYPE.STORE_IS_MICROSOFT_PRODUCT;
pub const DEBUG_FLR_STORE_URL_APP = DEBUG_FLR_PARAM_TYPE.STORE_URL_APP;
pub const DEBUG_FLR_STORE_URL_APPHEALTH = DEBUG_FLR_PARAM_TYPE.STORE_URL_APPHEALTH;
pub const DEBUG_FLR_PHONE_VERSIONMAJOR = DEBUG_FLR_PARAM_TYPE.PHONE_VERSIONMAJOR;
pub const DEBUG_FLR_PHONE_VERSIONMINOR = DEBUG_FLR_PARAM_TYPE.PHONE_VERSIONMINOR;
pub const DEBUG_FLR_PHONE_BUILDNUMBER = DEBUG_FLR_PARAM_TYPE.PHONE_BUILDNUMBER;
pub const DEBUG_FLR_PHONE_BUILDTIMESTAMP = DEBUG_FLR_PARAM_TYPE.PHONE_BUILDTIMESTAMP;
pub const DEBUG_FLR_PHONE_BUILDBRANCH = DEBUG_FLR_PARAM_TYPE.PHONE_BUILDBRANCH;
pub const DEBUG_FLR_PHONE_BUILDER = DEBUG_FLR_PARAM_TYPE.PHONE_BUILDER;
pub const DEBUG_FLR_PHONE_LCID = DEBUG_FLR_PARAM_TYPE.PHONE_LCID;
pub const DEBUG_FLR_PHONE_QFE = DEBUG_FLR_PARAM_TYPE.PHONE_QFE;
pub const DEBUG_FLR_PHONE_OPERATOR = DEBUG_FLR_PARAM_TYPE.PHONE_OPERATOR;
pub const DEBUG_FLR_PHONE_MCCMNC = DEBUG_FLR_PARAM_TYPE.PHONE_MCCMNC;
pub const DEBUG_FLR_PHONE_FIRMWAREREVISION = DEBUG_FLR_PARAM_TYPE.PHONE_FIRMWAREREVISION;
pub const DEBUG_FLR_PHONE_RAM = DEBUG_FLR_PARAM_TYPE.PHONE_RAM;
pub const DEBUG_FLR_PHONE_ROMVERSION = DEBUG_FLR_PARAM_TYPE.PHONE_ROMVERSION;
pub const DEBUG_FLR_PHONE_SOCVERSION = DEBUG_FLR_PARAM_TYPE.PHONE_SOCVERSION;
pub const DEBUG_FLR_PHONE_HARDWAREREVISION = DEBUG_FLR_PARAM_TYPE.PHONE_HARDWAREREVISION;
pub const DEBUG_FLR_PHONE_RADIOHARDWAREREVISION = DEBUG_FLR_PARAM_TYPE.PHONE_RADIOHARDWAREREVISION;
pub const DEBUG_FLR_PHONE_RADIOSOFTWAREREVISION = DEBUG_FLR_PARAM_TYPE.PHONE_RADIOSOFTWAREREVISION;
pub const DEBUG_FLR_PHONE_BOOTLOADERVERSION = DEBUG_FLR_PARAM_TYPE.PHONE_BOOTLOADERVERSION;
pub const DEBUG_FLR_PHONE_REPORTGUID = DEBUG_FLR_PARAM_TYPE.PHONE_REPORTGUID;
pub const DEBUG_FLR_PHONE_SOURCE = DEBUG_FLR_PARAM_TYPE.PHONE_SOURCE;
pub const DEBUG_FLR_PHONE_SOURCEEXTERNAL = DEBUG_FLR_PARAM_TYPE.PHONE_SOURCEEXTERNAL;
pub const DEBUG_FLR_PHONE_USERALIAS = DEBUG_FLR_PARAM_TYPE.PHONE_USERALIAS;
pub const DEBUG_FLR_PHONE_REPORTTIMESTAMP = DEBUG_FLR_PARAM_TYPE.PHONE_REPORTTIMESTAMP;
pub const DEBUG_FLR_PHONE_APPID = DEBUG_FLR_PARAM_TYPE.PHONE_APPID;
pub const DEBUG_FLR_PHONE_SKUID = DEBUG_FLR_PARAM_TYPE.PHONE_SKUID;
pub const DEBUG_FLR_PHONE_APPVERSION = DEBUG_FLR_PARAM_TYPE.PHONE_APPVERSION;
pub const DEBUG_FLR_PHONE_UIF_COMMENT = DEBUG_FLR_PARAM_TYPE.PHONE_UIF_COMMENT;
pub const DEBUG_FLR_PHONE_UIF_APPNAME = DEBUG_FLR_PARAM_TYPE.PHONE_UIF_APPNAME;
pub const DEBUG_FLR_PHONE_UIF_APPID = DEBUG_FLR_PARAM_TYPE.PHONE_UIF_APPID;
pub const DEBUG_FLR_PHONE_UIF_CATEGORY = DEBUG_FLR_PARAM_TYPE.PHONE_UIF_CATEGORY;
pub const DEBUG_FLR_PHONE_UIF_ORIGIN = DEBUG_FLR_PARAM_TYPE.PHONE_UIF_ORIGIN;
pub const DEBUG_FLR_SIMULTANEOUS_TELSVC_INSTANCES = DEBUG_FLR_PARAM_TYPE.SIMULTANEOUS_TELSVC_INSTANCES;
pub const DEBUG_FLR_SIMULTANEOUS_TELWP_INSTANCES = DEBUG_FLR_PARAM_TYPE.SIMULTANEOUS_TELWP_INSTANCES;
pub const DEBUG_FLR_MINUTES_SINCE_LAST_EVENT = DEBUG_FLR_PARAM_TYPE.MINUTES_SINCE_LAST_EVENT;
pub const DEBUG_FLR_MINUTES_SINCE_LAST_EVENT_OF_THIS_TYPE = DEBUG_FLR_PARAM_TYPE.MINUTES_SINCE_LAST_EVENT_OF_THIS_TYPE;
pub const DEBUG_FLR_REPORT_INFO_GUID = DEBUG_FLR_PARAM_TYPE.REPORT_INFO_GUID;
pub const DEBUG_FLR_REPORT_INFO_SOURCE = DEBUG_FLR_PARAM_TYPE.REPORT_INFO_SOURCE;
pub const DEBUG_FLR_REPORT_INFO_CREATION_TIME = DEBUG_FLR_PARAM_TYPE.REPORT_INFO_CREATION_TIME;
pub const DEBUG_FLR_FAULTING_IP = DEBUG_FLR_PARAM_TYPE.FAULTING_IP;
pub const DEBUG_FLR_FAULTING_MODULE = DEBUG_FLR_PARAM_TYPE.FAULTING_MODULE;
pub const DEBUG_FLR_IMAGE_TIMESTAMP = DEBUG_FLR_PARAM_TYPE.IMAGE_TIMESTAMP;
pub const DEBUG_FLR_FOLLOWUP_IP = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_IP;
pub const DEBUG_FLR_FRAME_ONE_INVALID = DEBUG_FLR_PARAM_TYPE.FRAME_ONE_INVALID;
pub const DEBUG_FLR_SYMBOL_FROM_RAW_STACK_ADDRESS = DEBUG_FLR_PARAM_TYPE.SYMBOL_FROM_RAW_STACK_ADDRESS;
pub const DEBUG_FLR_IMAGE_VERSION = DEBUG_FLR_PARAM_TYPE.IMAGE_VERSION;
pub const DEBUG_FLR_FOLLOWUP_BUCKET_ID = DEBUG_FLR_PARAM_TYPE.FOLLOWUP_BUCKET_ID;
pub const DEBUG_FLR_CUSTOM_ANALYSIS_TAG_MIN = DEBUG_FLR_PARAM_TYPE.CUSTOM_ANALYSIS_TAG_MIN;
pub const DEBUG_FLR_CUSTOM_ANALYSIS_TAG_MAX = DEBUG_FLR_PARAM_TYPE.CUSTOM_ANALYSIS_TAG_MAX;
pub const DEBUG_FLR_FAULTING_THREAD = DEBUG_FLR_PARAM_TYPE.FAULTING_THREAD;
pub const DEBUG_FLR_CONTEXT = DEBUG_FLR_PARAM_TYPE.CONTEXT;
pub const DEBUG_FLR_TRAP_FRAME = DEBUG_FLR_PARAM_TYPE.TRAP_FRAME;
pub const DEBUG_FLR_TSS = DEBUG_FLR_PARAM_TYPE.TSS;
pub const DEBUG_FLR_BLOCKING_THREAD = DEBUG_FLR_PARAM_TYPE.BLOCKING_THREAD;
pub const DEBUG_FLR_UNRESPONSIVE_UI_THREAD = DEBUG_FLR_PARAM_TYPE.UNRESPONSIVE_UI_THREAD;
pub const DEBUG_FLR_BLOCKED_THREAD0 = DEBUG_FLR_PARAM_TYPE.BLOCKED_THREAD0;
pub const DEBUG_FLR_BLOCKED_THREAD1 = DEBUG_FLR_PARAM_TYPE.BLOCKED_THREAD1;
pub const DEBUG_FLR_BLOCKED_THREAD2 = DEBUG_FLR_PARAM_TYPE.BLOCKED_THREAD2;
pub const DEBUG_FLR_BLOCKING_PROCESSID = DEBUG_FLR_PARAM_TYPE.BLOCKING_PROCESSID;
pub const DEBUG_FLR_PROCESSOR_ID = DEBUG_FLR_PARAM_TYPE.PROCESSOR_ID;
pub const DEBUG_FLR_XDV_VIOLATED_CONDITION = DEBUG_FLR_PARAM_TYPE.XDV_VIOLATED_CONDITION;
pub const DEBUG_FLR_XDV_STATE_VARIABLE = DEBUG_FLR_PARAM_TYPE.XDV_STATE_VARIABLE;
pub const DEBUG_FLR_XDV_HELP_LINK = DEBUG_FLR_PARAM_TYPE.XDV_HELP_LINK;
pub const DEBUG_FLR_XDV_RULE_INFO = DEBUG_FLR_PARAM_TYPE.XDV_RULE_INFO;
pub const DEBUG_FLR_DPC_STACK_BASE = DEBUG_FLR_PARAM_TYPE.DPC_STACK_BASE;
pub const DEBUG_FLR_TESTRESULTSERVER = DEBUG_FLR_PARAM_TYPE.TESTRESULTSERVER;
pub const DEBUG_FLR_TESTRESULTGUID = DEBUG_FLR_PARAM_TYPE.TESTRESULTGUID;
pub const DEBUG_FLR_CUSTOMREPORTTAG = DEBUG_FLR_PARAM_TYPE.CUSTOMREPORTTAG;
pub const DEBUG_FLR_DISKSEC_ORGID_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_ORGID_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_MODEL_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_MODEL_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_MFGID_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_MFGID_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_ISSUEDESCSTRING_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_ISSUEDESCSTRING_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PUBLIC_TOTSIZE_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PUBLIC_TOTSIZE_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PUBLIC_OFFSET_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PUBLIC_OFFSET_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PUBLIC_DATASIZE_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PUBLIC_DATASIZE_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PRIVATE_TOTSIZE_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PRIVATE_TOTSIZE_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PRIVATE_OFFSET_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PRIVATE_OFFSET_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_PRIVATE_DATASIZE_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_PRIVATE_DATASIZE_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_TOTALSIZE_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_TOTALSIZE_DEPRECATED;
pub const DEBUG_FLR_DISKSEC_REASON_DEPRECATED = DEBUG_FLR_PARAM_TYPE.DISKSEC_REASON_DEPRECATED;
pub const DEBUG_FLR_WERCOLLECTION_PROCESSTERMINATED = DEBUG_FLR_PARAM_TYPE.WERCOLLECTION_PROCESSTERMINATED;
pub const DEBUG_FLR_WERCOLLECTION_PROCESSHEAPDUMP_REQUEST_FAILURE = DEBUG_FLR_PARAM_TYPE.WERCOLLECTION_PROCESSHEAPDUMP_REQUEST_FAILURE;
pub const DEBUG_FLR_WERCOLLECTION_MINIDUMP_WRITE_FAILURE = DEBUG_FLR_PARAM_TYPE.WERCOLLECTION_MINIDUMP_WRITE_FAILURE;
pub const DEBUG_FLR_WERCOLLECTION_DEFAULTCOLLECTION_FAILURE = DEBUG_FLR_PARAM_TYPE.WERCOLLECTION_DEFAULTCOLLECTION_FAILURE;
pub const DEBUG_FLR_PROCESS_BAM_CURRENT_THROTTLED = DEBUG_FLR_PARAM_TYPE.PROCESS_BAM_CURRENT_THROTTLED;
pub const DEBUG_FLR_PROCESS_BAM_PREVIOUS_THROTTLED = DEBUG_FLR_PARAM_TYPE.PROCESS_BAM_PREVIOUS_THROTTLED;
pub const DEBUG_FLR_DUMPSTREAM_COMMENTA = DEBUG_FLR_PARAM_TYPE.DUMPSTREAM_COMMENTA;
pub const DEBUG_FLR_DUMPSTREAM_COMMENTW = DEBUG_FLR_PARAM_TYPE.DUMPSTREAM_COMMENTW;
pub const DEBUG_FLR_CHPE_PROCESS = DEBUG_FLR_PARAM_TYPE.CHPE_PROCESS;
pub const DEBUG_FLR_WINLOGON_BLACKBOX = DEBUG_FLR_PARAM_TYPE.WINLOGON_BLACKBOX;
pub const DEBUG_FLR_CUSTOM_COMMAND = DEBUG_FLR_PARAM_TYPE.CUSTOM_COMMAND;
pub const DEBUG_FLR_CUSTOM_COMMAND_OUTPUT = DEBUG_FLR_PARAM_TYPE.CUSTOM_COMMAND_OUTPUT;
pub const DEBUG_FLR_MASK_ALL = DEBUG_FLR_PARAM_TYPE.MASK_ALL;

pub const DBG_THREAD_ATTRIBUTES = extern struct {
    ThreadIndex: u32,
    ProcessID: u64,
    ThreadID: u64,
    AttributeBits: u64,
    BoolBits: u32,
    BlockedOnPID: u64,
    BlockedOnTID: u64,
    CritSecAddress: u64,
    Timeout_msec: u32,
    StringData: [100]CHAR,
    SymName: [100]CHAR,
};

pub const FA_ENTRY_TYPE = enum(i32) {
    NO_TYPE = 0,
    ULONG = 1,
    ULONG64 = 2,
    INSTRUCTION_OFFSET = 3,
    POINTER = 4,
    ANSI_STRING = 5,
    ANSI_STRINGs = 6,
    EXTENSION_CMD = 7,
    STRUCTURED_DATA = 8,
    UNICODE_STRING = 9,
    ARRAY = 32768,
};
pub const DEBUG_FA_ENTRY_NO_TYPE = FA_ENTRY_TYPE.NO_TYPE;
pub const DEBUG_FA_ENTRY_ULONG = FA_ENTRY_TYPE.ULONG;
pub const DEBUG_FA_ENTRY_ULONG64 = FA_ENTRY_TYPE.ULONG64;
pub const DEBUG_FA_ENTRY_INSTRUCTION_OFFSET = FA_ENTRY_TYPE.INSTRUCTION_OFFSET;
pub const DEBUG_FA_ENTRY_POINTER = FA_ENTRY_TYPE.POINTER;
pub const DEBUG_FA_ENTRY_ANSI_STRING = FA_ENTRY_TYPE.ANSI_STRING;
pub const DEBUG_FA_ENTRY_ANSI_STRINGs = FA_ENTRY_TYPE.ANSI_STRINGs;
pub const DEBUG_FA_ENTRY_EXTENSION_CMD = FA_ENTRY_TYPE.EXTENSION_CMD;
pub const DEBUG_FA_ENTRY_STRUCTURED_DATA = FA_ENTRY_TYPE.STRUCTURED_DATA;
pub const DEBUG_FA_ENTRY_UNICODE_STRING = FA_ENTRY_TYPE.UNICODE_STRING;
pub const DEBUG_FA_ENTRY_ARRAY = FA_ENTRY_TYPE.ARRAY;

pub const IDebugFAEntryTags = extern struct {
    pub const VTable = extern struct {
        GetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) FA_ENTRY_TYPE,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) FA_ENTRY_TYPE,
        },
        SetType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Name: ?PSTR,
                NameSize: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Description: ?PSTR,
                DescSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Name: ?PSTR,
                NameSize: ?*u32,
                // TODO: what to do with BytesParamIndex 4?
                Description: ?PSTR,
                DescSize: ?*u32,
                Flags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Name: ?[*:0]align(1) const u8,
                Description: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Name: ?[*:0]align(1) const u8,
                Description: ?[*:0]align(1) const u8,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTagByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                PluginId: ?[*:0]align(1) const u8,
                TagName: ?[*:0]align(1) const u8,
                Tag: ?*DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                PluginId: ?[*:0]align(1) const u8,
                TagName: ?[*:0]align(1) const u8,
                Tag: ?*DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsValidTagToSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
            else => *const fn(
                self: *const IDebugFAEntryTags,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) BOOL,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_GetType(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) FA_ENTRY_TYPE {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).GetType(@as(*const IDebugFAEntryTags, @ptrCast(self)), Tag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_SetType(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, EntryType: FA_ENTRY_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).SetType(@as(*const IDebugFAEntryTags, @ptrCast(self)), Tag, EntryType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_GetProperties(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Name: ?PSTR, NameSize: ?*u32, Description: ?PSTR, DescSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IDebugFAEntryTags, @ptrCast(self)), Tag, Name, NameSize, Description, DescSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_SetProperties(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Name: ?[*:0]align(1) const u8, Description: ?[*:0]align(1) const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IDebugFAEntryTags, @ptrCast(self)), Tag, Name, Description, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_GetTagByName(self: *const T, PluginId: ?[*:0]align(1) const u8, TagName: ?[*:0]align(1) const u8, Tag: ?*DEBUG_FLR_PARAM_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).GetTagByName(@as(*const IDebugFAEntryTags, @ptrCast(self)), PluginId, TagName, Tag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFAEntryTags_IsValidTagToSet(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) BOOL {
            return @as(*const IDebugFAEntryTags.VTable, @ptrCast(self.vtable)).IsValidTagToSet(@as(*const IDebugFAEntryTags, @ptrCast(self)), Tag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FA_ENTRY = extern struct {
    Tag: DEBUG_FLR_PARAM_TYPE,
    FullSize: u16,
    DataSize: u16,
};

const IID_IDebugFailureAnalysis_Value = Guid.initString("ed0de363-451f-4943-820c-62dccdfa7e6d");
pub const IID_IDebugFailureAnalysis = &IID_IDebugFailureAnalysis_Value;
pub const IDebugFailureAnalysis = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFailureClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetFailureType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
        },
        GetFailureCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Str: ?PSTR,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Str: ?PSTR,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        NextEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetFailureClass(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetFailureClass(@as(*const IDebugFailureAnalysis, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetFailureType(self: *const T) callconv(.Inline) DEBUG_FAILURE_TYPE {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetFailureType(@as(*const IDebugFailureAnalysis, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetFailureCode(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetFailureCode(@as(*const IDebugFailureAnalysis, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_Get(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).Get(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Tag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetNext(self: *const T, Entry: ?*FA_ENTRY, Tag: DEBUG_FLR_PARAM_TYPE, TagMask: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Entry, Tag, TagMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: ?PSTR, MaxSize: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetString(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Tag, Str, MaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Buf: ?*anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Tag, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetUlong(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_GetUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).GetUlong64(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis_NextEntry(self: *const T, Entry: ?*FA_ENTRY) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis.VTable, @ptrCast(self.vtable)).NextEntry(@as(*const IDebugFailureAnalysis, @ptrCast(self)), Entry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFailureAnalysis2_Value = Guid.initString("ea15c288-8226-4b70-acf6-0be6b189e3ad");
pub const IID_IDebugFailureAnalysis2 = &IID_IDebugFailureAnalysis2_Value;
pub const IDebugFailureAnalysis2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFailureClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetFailureType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
        },
        GetFailureCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: [*:0]u8,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: [*:0]u8,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        NextEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetDebugFATagControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                FATagControl: ?*?*IDebugFAEntryTags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                FATagControl: ?*?*IDebugFAEntryTags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnalysisXml: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                ppXMLDOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                ppXMLDOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStructuredAnalysisData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Analysis: ?*IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis2,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Analysis: ?*IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetFailureClass(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetFailureClass(@as(*const IDebugFailureAnalysis2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetFailureType(self: *const T) callconv(.Inline) DEBUG_FAILURE_TYPE {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetFailureType(@as(*const IDebugFailureAnalysis2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetFailureCode(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetFailureCode(@as(*const IDebugFailureAnalysis2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_Get(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).Get(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetNext(self: *const T, Entry: ?*FA_ENTRY, Tag: DEBUG_FLR_PARAM_TYPE, TagMask: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Entry, Tag, TagMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: [*:0]u8, MaxSize: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetString(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Str, MaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Buf: ?*anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetUlong(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetUlong64(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_NextEntry(self: *const T, Entry: ?*FA_ENTRY) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).NextEntry(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Entry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_SetString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).SetString(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_SetExtensionCommand(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Extension: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).SetExtensionCommand(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_SetUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).SetUlong(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_SetUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).SetUlong64(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_SetBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, EntryType: FA_ENTRY_TYPE, Buf: ?*anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).SetBuffer(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, EntryType, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddString(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddExtensionCommand(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Extension: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddExtensionCommand(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddUlong(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddUlong64(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, EntryType: FA_ENTRY_TYPE, Buf: ?*const anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddBuffer(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, EntryType, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetDebugFATagControl(self: *const T, FATagControl: ?*?*IDebugFAEntryTags) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetDebugFATagControl(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), FATagControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_GetAnalysisXml(self: *const T, ppXMLDOMElement: ?*?*IXMLDOMElement) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).GetAnalysisXml(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), ppXMLDOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis2_AddStructuredAnalysisData(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Analysis: ?*IDebugFailureAnalysis2) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis2.VTable, @ptrCast(self.vtable)).AddStructuredAnalysisData(@as(*const IDebugFailureAnalysis2, @ptrCast(self)), Tag, Analysis);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFailureAnalysis3_Value = Guid.initString("3627dc67-fd45-42ff-9ba4-4a67ee64619f");
pub const IID_IDebugFailureAnalysis3 = &IID_IDebugFailureAnalysis3_Value;
pub const IDebugFailureAnalysis3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFailureClass: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        GetFailureType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) DEBUG_FAILURE_TYPE,
        },
        GetFailureCode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Entry: ?*FA_ENTRY,
                Tag: DEBUG_FLR_PARAM_TYPE,
                TagMask: DEBUG_FLR_PARAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: [*:0]u8,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: [*:0]u8,
                MaxSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                // TODO: what to do with BytesParamIndex 2?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        NextEntry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Entry: ?*FA_ENTRY,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        SetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Str: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddExtensionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Extension: ?[*:0]align(1) const u8,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddUlong: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddUlong64: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Value: u64,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        AddBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                EntryType: FA_ENTRY_TYPE,
                // TODO: what to do with BytesParamIndex 3?
                Buf: ?*const anyopaque,
                Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) ?*FA_ENTRY,
        },
        GetDebugFATagControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                FATagControl: ?*?*IDebugFAEntryTags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                FATagControl: ?*?*IDebugFAEntryTags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnalysisXml: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                ppXMLDOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                ppXMLDOMElement: ?*?*IXMLDOMElement,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddStructuredAnalysisData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Analysis: ?*IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Tag: DEBUG_FLR_PARAM_TYPE,
                Analysis: ?*IDebugFailureAnalysis2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                pDebugFailureThreadEnum: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                pDebugFailureThreadEnum: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttributeGet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttributeGetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AttributeSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                Value: VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Postfix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Postfix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Postfix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Postfix: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                pThread: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                pThread: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameStitch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                pThread: ?*IUnknown,
                Stitch: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                pThread: ?*IUnknown,
                Stitch: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameTEB: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Address: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Address: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BlameETHREAD: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Address: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Address: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProblemClassIsSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pSet: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                pSet: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProblemClassDelete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProblemClassSet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProblemClassSetBSTR: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                Value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                nIndex: u32,
                Value: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAdditionalXML: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
                pXMLDOMElement: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
                pXMLDOMElement: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdditionalXML: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
                ppXMLDOMElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
                ppXMLDOMElement: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteAdditionalXML: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugFailureAnalysis3,
                Key: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetFailureClass(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetFailureClass(@as(*const IDebugFailureAnalysis3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetFailureType(self: *const T) callconv(.Inline) DEBUG_FAILURE_TYPE {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetFailureType(@as(*const IDebugFailureAnalysis3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetFailureCode(self: *const T) callconv(.Inline) u32 {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetFailureCode(@as(*const IDebugFailureAnalysis3, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_Get(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).Get(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetNext(self: *const T, Entry: ?*FA_ENTRY, Tag: DEBUG_FLR_PARAM_TYPE, TagMask: DEBUG_FLR_PARAM_TYPE) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetNext(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Entry, Tag, TagMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: [*:0]u8, MaxSize: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetString(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Str, MaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Buf: ?*anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetUlong(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: ?*u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetUlong64(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_NextEntry(self: *const T, Entry: ?*FA_ENTRY) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).NextEntry(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Entry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetString(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetExtensionCommand(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Extension: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetExtensionCommand(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetUlong(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetUlong64(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, EntryType: FA_ENTRY_TYPE, Buf: ?*anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetBuffer(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, EntryType, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddString(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Str: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddString(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddExtensionCommand(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Extension: ?[*:0]align(1) const u8) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddExtensionCommand(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddUlong(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddUlong(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddUlong64(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Value: u64) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddUlong64(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddBuffer(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, EntryType: FA_ENTRY_TYPE, Buf: ?*const anyopaque, Size: u32) callconv(.Inline) ?*FA_ENTRY {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddBuffer(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, EntryType, Buf, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetDebugFATagControl(self: *const T, FATagControl: ?*?*IDebugFAEntryTags) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetDebugFATagControl(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), FATagControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetAnalysisXml(self: *const T, ppXMLDOMElement: ?*?*IXMLDOMElement) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetAnalysisXml(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), ppXMLDOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddStructuredAnalysisData(self: *const T, Tag: DEBUG_FLR_PARAM_TYPE, Analysis: ?*IDebugFailureAnalysis2) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddStructuredAnalysisData(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Tag, Analysis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AddThreads(self: *const T, pDebugFailureThreadEnum: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AddThreads(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), pDebugFailureThreadEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AttributeGet(self: *const T, nIndex: u32, pValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AttributeGet(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AttributeGetName(self: *const T, nIndex: u32, pName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AttributeGetName(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_AttributeSet(self: *const T, nIndex: u32, Value: VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).AttributeSet(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameApplication(self: *const T, Postfix: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameApplication(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Postfix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameProcess(self: *const T, Postfix: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameProcess(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Postfix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameThread(self: *const T, pThread: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameThread(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), pThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameStitch(self: *const T, pThread: ?*IUnknown, Stitch: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameStitch(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), pThread, Stitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameTEB(self: *const T, Address: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameTEB(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Address);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_BlameETHREAD(self: *const T, Address: u64) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).BlameETHREAD(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Address);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_ProblemClassIsSet(self: *const T, nIndex: u32, pSet: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).ProblemClassIsSet(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex, pSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_ProblemClassDelete(self: *const T, nIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).ProblemClassDelete(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_ProblemClassSet(self: *const T, nIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).ProblemClassSet(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_ProblemClassSetBSTR(self: *const T, nIndex: u32, Value: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).ProblemClassSetBSTR(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), nIndex, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_SetAdditionalXML(self: *const T, Key: ?BSTR, pXMLDOMElement: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).SetAdditionalXML(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Key, pXMLDOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_GetAdditionalXML(self: *const T, Key: ?BSTR, ppXMLDOMElement: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).GetAdditionalXML(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Key, ppXMLDOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFailureAnalysis3_DeleteAdditionalXML(self: *const T, Key: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugFailureAnalysis3.VTable, @ptrCast(self.vtable)).DeleteAdditionalXML(@as(*const IDebugFailureAnalysis3, @ptrCast(self)), Key);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EXT_GET_FAILURE_ANALYSIS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        Flags: u32,
        ppAnalysis: ?*?*IDebugFailureAnalysis,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        Flags: u32,
        ppAnalysis: ?*?*IDebugFailureAnalysis,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXT_GET_DEBUG_FAILURE_ANALYSIS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        Flags: u32,
        ClassId: Guid,
        ppAnalysis: ?*?*IDebugFailureAnalysis2,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        Flags: u32,
        ClassId: Guid,
        ppAnalysis: ?*?*IDebugFailureAnalysis2,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const fnDebugFailureAnalysisCreateInstance = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        Args: ?[*:0]align(1) const u16,
        Flags: u32,
        rclsid: ?*const Guid,
        riid: ?*const Guid,
        ppv: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        Args: ?[*:0]align(1) const u16,
        Flags: u32,
        rclsid: ?*const Guid,
        riid: ?*const Guid,
        ppv: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const FA_EXTENSION_PLUGIN_PHASE = enum(i32) {
    INITIALIZATION = 1,
    STACK_ANALYSIS = 2,
    PRE_BUCKETING = 4,
    POST_BUCKETING = 8,
};
pub const FA_PLUGIN_INITIALIZATION = FA_EXTENSION_PLUGIN_PHASE.INITIALIZATION;
pub const FA_PLUGIN_STACK_ANALYSIS = FA_EXTENSION_PLUGIN_PHASE.STACK_ANALYSIS;
pub const FA_PLUGIN_PRE_BUCKETING = FA_EXTENSION_PLUGIN_PHASE.PRE_BUCKETING;
pub const FA_PLUGIN_POST_BUCKETING = FA_EXTENSION_PLUGIN_PHASE.POST_BUCKETING;

pub const EXT_ANALYSIS_PLUGIN = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        CallPhase: FA_EXTENSION_PLUGIN_PHASE,
        pAnalysis: ?*IDebugFailureAnalysis2,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        CallPhase: FA_EXTENSION_PLUGIN_PHASE,
        pAnalysis: ?*IDebugFailureAnalysis2,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXT_GET_FA_ENTRIES_DATA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        Count: ?*u32,
        Entries: ?*?*FA_ENTRY,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        Count: ?*u32,
        Entries: ?*?*FA_ENTRY,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const OS_TYPE = enum(i32) {
    @"95" = 0,
    @"98" = 1,
    ME = 2,
    NT4 = 3,
    NT5 = 4,
    NT5_1 = 5,
    NT5_2 = 6,
    NT6_0 = 7,
    NT6_1 = 8,
    UNDEFINED = 255,
};
pub const WIN_95 = OS_TYPE.@"95";
pub const WIN_98 = OS_TYPE.@"98";
pub const WIN_ME = OS_TYPE.ME;
pub const WIN_NT4 = OS_TYPE.NT4;
pub const WIN_NT5 = OS_TYPE.NT5;
pub const WIN_NT5_1 = OS_TYPE.NT5_1;
pub const WIN_NT5_2 = OS_TYPE.NT5_2;
pub const WIN_NT6_0 = OS_TYPE.NT6_0;
pub const WIN_NT6_1 = OS_TYPE.NT6_1;
pub const WIN_UNDEFINED = OS_TYPE.UNDEFINED;

pub const OS_INFO = extern struct {
    MajorVer: u32,
    MinorVer: u32,
    Build: u32,
    BuildQfe: u32,
    ProductType: u32,
    Suite: u32,
    Revision: u32,
    s: extern struct {
        _bitfield: u32,
    },
    SrvPackNumber: u32,
    ServicePackBuild: u32,
    Architecture: u32,
    Lcid: u32,
    Name: [64]CHAR,
    FullName: [256]CHAR,
    Language: [30]CHAR,
    BuildVersion: [64]CHAR,
    ServicePackString: [64]CHAR,
};

pub const CPU_INFO = extern struct {
    Type: u32,
    NumCPUs: u32,
    CurrentProc: u32,
    ProcInfo: [2048]DEBUG_PROCESSOR_IDENTIFICATION_ALL,
    Mhz: u32,
};

pub const TARGET_DEBUG_INFO = extern struct {
    SizeOfStruct: u32,
    EntryDate: u64,
    DebugeeClass: u32,
    SysUpTime: u64,
    AppUpTime: u64,
    CrashTime: u64,
    OsInfo: OS_INFO,
    Cpu: CPU_INFO,
    DumpFile: [260]CHAR,
};

pub const CPU_INFO_v2 = extern struct {
    Type: u32,
    NumCPUs: u32,
    CurrentProc: u32,
    ProcInfo: [1280]DEBUG_PROCESSOR_IDENTIFICATION_ALL,
    Mhz: u32,
};

pub const TARGET_DEBUG_INFO_v2 = extern struct {
    SizeOfStruct: u32,
    EntryDate: u64,
    DebugeeClass: u32,
    SysUpTime: u64,
    AppUpTime: u64,
    CrashTime: u64,
    OsInfo: OS_INFO,
    Cpu: CPU_INFO_v2,
    DumpFile: [260]CHAR,
};

pub const OS_INFO_v1 = extern struct {
    Type: OS_TYPE,
    Anonymous: extern union {
        Version: extern struct {
            Major: u32,
            Minor: u32,
        },
        Ver64: u64,
    },
    ProductType: u32,
    Suite: u32,
    s: extern struct {
        _bitfield: u32,
    },
    SrvPackNumber: u32,
    Language: [30]CHAR,
    OsString: [64]CHAR,
    ServicePackString: [64]CHAR,
};

pub const CPU_INFO_v1 = extern struct {
    Type: u32,
    NumCPUs: u32,
    CurrentProc: u32,
    ProcInfo: [32]DEBUG_PROCESSOR_IDENTIFICATION_ALL,
    Mhz: u32,
};

pub const TARGET_DEBUG_INFO_v1 = extern struct {
    SizeOfStruct: u32,
    Id: u64,
    Source: u64,
    EntryDate: u64,
    SysUpTime: u64,
    AppUpTime: u64,
    CrashTime: u64,
    Mode: u64,
    OsInfo: OS_INFO_v1,
    Cpu: CPU_INFO_v1,
    DumpFile: [260]CHAR,
    FailureData: ?*anyopaque,
    StackTr: [4096]CHAR,
};

pub const EXT_TARGET_INFO = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        pTargetInfo: ?*TARGET_DEBUG_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        pTargetInfo: ?*TARGET_DEBUG_INFO,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_DECODE_ERROR = extern struct {
    SizeOfStruct: u32,
    Code: u32,
    TreatAsStatus: BOOL,
    Source: [64]CHAR,
    Message: [260]CHAR,
};

pub const EXT_DECODE_ERROR = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pDecodeError: ?*DEBUG_DECODE_ERROR,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        pDecodeError: ?*DEBUG_DECODE_ERROR,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const DEBUG_TRIAGE_FOLLOWUP_INFO = extern struct {
    SizeOfStruct: u32,
    OwnerNameSize: u32,
    OwnerName: ?[*]align(1) u8,
};

pub const DEBUG_TRIAGE_FOLLOWUP_INFO_2 = extern struct {
    SizeOfStruct: u32,
    OwnerNameSize: u32,
    OwnerName: ?[*]align(1) u8,
    FeaturePathSize: u32,
    FeaturePath: ?[*]align(1) u8,
};

pub const EXT_TRIAGE_FOLLOWUP = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        SymbolName: ?[*:0]align(1) const u8,
        OwnerInfo: ?*DEBUG_TRIAGE_FOLLOWUP_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
        Client: ?*IDebugClient4,
        SymbolName: ?[*:0]align(1) const u8,
        OwnerInfo: ?*DEBUG_TRIAGE_FOLLOWUP_INFO,
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const EXT_RELOAD_TRIAGER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXT_CAB_XML_DATA = extern struct {
    pub const _SUBTAGS = extern struct {
        SubTag: ?[*:0]align(1) const u16,
        MatchPattern: ?[*:0]align(1) const u16,
        ReturnText: ?PWSTR,
        ReturnTextSize: u32,
        _bitfield: u32,
        Reserved2: u32,
    };
    SizeOfStruct: u32,
    XmlObjectTag: ?[*:0]align(1) const u16,
    NumSubTags: u32,
    SubTags: [1]_SUBTAGS,
};

pub const EXT_XML_DATA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        pXmpData: ?*EXT_CAB_XML_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        pXmpData: ?*EXT_CAB_XML_DATA,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const XML_DRIVER_NODE_INFO = extern struct {
    FileName: [64]CHAR,
    FileSize: u64,
    CreationDate: u64,
    Version: [64]CHAR,
    Manufacturer: [260]CHAR,
    ProductName: [260]CHAR,
    Group: [260]CHAR,
    Altitude: [260]CHAR,
};

pub const EXT_ANALYZER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        // TODO: what to do with BytesParamIndex 2?
        BucketSuffix: ?PSTR,
        cbBucketSuffix: u32,
        // TODO: what to do with BytesParamIndex 4?
        DebugText: ?PSTR,
        cbDebugText: u32,
        Flags: ?*u32,
        pAnalysis: ?*IDebugFailureAnalysis,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        // TODO: what to do with BytesParamIndex 2?
        BucketSuffix: ?PSTR,
        cbBucketSuffix: u32,
        // TODO: what to do with BytesParamIndex 4?
        DebugText: ?PSTR,
        cbDebugText: u32,
        Flags: ?*u32,
        pAnalysis: ?*IDebugFailureAnalysis,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DEBUG_ANALYSIS_PROCESSOR_INFO = extern struct {
    SizeOfStruct: u32,
    Model: u32,
    Family: u32,
    Stepping: u32,
    Architecture: u32,
    Revision: u32,
    CurrentClockSpeed: u32,
    CurrentVoltage: u32,
    MaxClockSpeed: u32,
    ProcessorType: u32,
    DeviceID: [32]CHAR,
    Manufacturer: [64]CHAR,
    Name: [64]CHAR,
    Version: [64]CHAR,
    Description: [64]CHAR,
};

pub const EXTDLL_QUERYDATABYTAG = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        dwDataTag: u32,
        pQueryInfo: ?*anyopaque,
        // TODO: what to do with BytesParamIndex 4?
        pData: ?*u8,
        cbData: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        dwDataTag: u32,
        pQueryInfo: ?*anyopaque,
        // TODO: what to do with BytesParamIndex 4?
        pData: ?*u8,
        cbData: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXTDLL_QUERYDATABYTAGEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient4,
        dwDataTag: u32,
        pQueryInfo: ?*anyopaque,
        // TODO: what to do with BytesParamIndex 4?
        pData: ?*u8,
        cbData: u32,
        // TODO: what to do with BytesParamIndex 6?
        pDataEx: ?*u8,
        cbDataEx: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient4,
        dwDataTag: u32,
        pQueryInfo: ?*anyopaque,
        // TODO: what to do with BytesParamIndex 4?
        pData: ?*u8,
        cbData: u32,
        // TODO: what to do with BytesParamIndex 6?
        pDataEx: ?*u8,
        cbDataEx: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const ENTRY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        EntryAddress: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        EntryAddress: u64,
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXTDLL_ITERATERTLBALANCEDNODES = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        RootNode: u64,
        EntryOffset: u32,
        Callback: ?ENTRY_CALLBACK,
        CallbackContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        RootNode: u64,
        EntryOffset: u32,
        Callback: ?ENTRY_CALLBACK,
        CallbackContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const EXT_GET_HANDLE_TRACE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Client: ?*IDebugClient,
        TraceType: u32,
        StartIndex: u32,
        HandleValue: ?*u64,
        StackFunctions: ?*u64,
        StackTraceSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Client: ?*IDebugClient,
        TraceType: u32,
        StartIndex: u32,
        HandleValue: ?*u64,
        StackFunctions: ?*u64,
        StackTraceSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const EXT_GET_ENVIRONMENT_VARIABLE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Peb: u64,
        Variable: ?PSTR,
        Buffer: ?PSTR,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        Peb: u64,
        Variable: ?PSTR,
        Buffer: ?PSTR,
        BufferSize: u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const TANALYZE_RETURN = enum(i32) {
    NO_TYPE = 0,
    PROCESS_END = 1,
    EXIT_STATUS = 2,
    DISK_READ_0_BYTES = 3,
    DISK_WRITE = 4,
    NT_STATUS_CODE = 5,
};
pub const NO_TYPE = TANALYZE_RETURN.NO_TYPE;
pub const PROCESS_END = TANALYZE_RETURN.PROCESS_END;
pub const EXIT_STATUS = TANALYZE_RETURN.EXIT_STATUS;
pub const DISK_READ_0_BYTES = TANALYZE_RETURN.DISK_READ_0_BYTES;
pub const DISK_WRITE = TANALYZE_RETURN.DISK_WRITE;
pub const NT_STATUS_CODE = TANALYZE_RETURN.NT_STATUS_CODE;

pub const CKCL_DATA = extern struct {
    NextLogEvent: ?*anyopaque,
    TAnalyzeString: ?PSTR,
    TAnalyzeReturnType: TANALYZE_RETURN,
};

pub const CKCL_LISTHEAD = extern struct {
    LogEventListHead: ?*CKCL_DATA,
    Heap: ?HANDLE,
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "dbgeng" fn DebugConnect(
    RemoteOptions: ?[*:0]align(1) const u8,
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugConnectWide(
    RemoteOptions: ?[*:0]align(1) const u16,
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreate(
    InterfaceId: ?*const Guid,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreateEx(
    InterfaceId: ?*const Guid,
    DbgEngOptions: u32,
    Interface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgmodel" fn CreateDataModelManager(
    debugHost: ?*IDebugHost,
    manager: ?*?*IDataModelManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (22)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../../zig.zig").Guid;
const BOOL = @import("../../../../../windows/win32/foundation.zig").BOOL;
const BOOLEAN = @import("../../../../../windows/win32/foundation.zig").BOOLEAN;
const BSTR = @import("../../../../../windows/win32/foundation.zig").BSTR;
const CHAR = @import("../../../../../windows/win32/foundation.zig").CHAR;
const CONTEXT = @import("../../../../../windows/win32/system/diagnostics/debug.zig").CONTEXT;
const EXCEPTION_RECORD64 = @import("../../../../../windows/win32/system/diagnostics/debug.zig").EXCEPTION_RECORD64;
const FARPROC = @import("../../../../../windows/win32/foundation.zig").FARPROC;
const HANDLE = @import("../../../../../windows/win32/foundation.zig").HANDLE;
const HRESULT = @import("../../../../../windows/win32/foundation.zig").HRESULT;
const IMAGE_NT_HEADERS64 = @import("../../../../../windows/win32/system/diagnostics/debug.zig").IMAGE_NT_HEADERS64;
const IStream = @import("../../../../../windows/win32/system/com.zig").IStream;
const IUnknown = @import("../../../../../windows/win32/system/com.zig").IUnknown;
const IXMLDOMElement = @import("../../../../../windows/win32/data/xml/ms_xml.zig").IXMLDOMElement;
const LIST_ENTRY32 = @import("../../../../../windows/win32/system/kernel.zig").LIST_ENTRY32;
const LIST_ENTRY64 = @import("../../../../../windows/win32/system/kernel.zig").LIST_ENTRY64;
const MEMORY_BASIC_INFORMATION64 = @import("../../../../../windows/win32/system/memory.zig").MEMORY_BASIC_INFORMATION64;
const PSTR = @import("../../../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../../../windows/win32/foundation.zig").PWSTR;
const VARENUM = @import("../../../../../windows/win32/system/variant.zig").VARENUM;
const VARIANT = @import("../../../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../../../windows/win32/foundation.zig").VARIANT_BOOL;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_INITIALIZE")) { _ = PDEBUG_EXTENSION_INITIALIZE; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNINITIALIZE")) { _ = PDEBUG_EXTENSION_UNINITIALIZE; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CANUNLOAD")) { _ = PDEBUG_EXTENSION_CANUNLOAD; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNLOAD")) { _ = PDEBUG_EXTENSION_UNLOAD; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_NOTIFY")) { _ = PDEBUG_EXTENSION_NOTIFY; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CALL")) { _ = PDEBUG_EXTENSION_CALL; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT")) { _ = PDEBUG_EXTENSION_KNOWN_STRUCT; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT_EX")) { _ = PDEBUG_EXTENSION_KNOWN_STRUCT_EX; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_QUERY_VALUE_NAMES")) { _ = PDEBUG_EXTENSION_QUERY_VALUE_NAMES; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_PROVIDE_VALUE")) { _ = PDEBUG_EXTENSION_PROVIDE_VALUE; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION")) { _ = PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK")) { _ = PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES")) { _ = PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION")) { _ = PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION; }
    if (@hasDecl(@This(), "PWINDBG_OUTPUT_ROUTINE")) { _ = PWINDBG_OUTPUT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION")) { _ = PWINDBG_GET_EXPRESSION; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION32")) { _ = PWINDBG_GET_EXPRESSION32; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION64")) { _ = PWINDBG_GET_EXPRESSION64; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL")) { _ = PWINDBG_GET_SYMBOL; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL32")) { _ = PWINDBG_GET_SYMBOL32; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL64")) { _ = PWINDBG_GET_SYMBOL64; }
    if (@hasDecl(@This(), "PWINDBG_DISASM")) { _ = PWINDBG_DISASM; }
    if (@hasDecl(@This(), "PWINDBG_DISASM32")) { _ = PWINDBG_DISASM32; }
    if (@hasDecl(@This(), "PWINDBG_DISASM64")) { _ = PWINDBG_DISASM64; }
    if (@hasDecl(@This(), "PWINDBG_CHECK_CONTROL_C")) { _ = PWINDBG_CHECK_CONTROL_C; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE32")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE64")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_GET_THREAD_CONTEXT_ROUTINE")) { _ = PWINDBG_GET_THREAD_CONTEXT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_SET_THREAD_CONTEXT_ROUTINE")) { _ = PWINDBG_SET_THREAD_CONTEXT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_IOCTL_ROUTINE")) { _ = PWINDBG_IOCTL_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_READ_PHYSICAL_MEMORY")) { _ = PWINDBG_OLDKD_READ_PHYSICAL_MEMORY; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY")) { _ = PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE")) { _ = PWINDBG_STACKTRACE_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE32")) { _ = PWINDBG_STACKTRACE_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE64")) { _ = PWINDBG_STACKTRACE_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_OLD_EXTENSION_ROUTINE")) { _ = PWINDBG_OLD_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE")) { _ = PWINDBG_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE32")) { _ = PWINDBG_EXTENSION_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE64")) { _ = PWINDBG_EXTENSION_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_EXTENSION_ROUTINE")) { _ = PWINDBG_OLDKD_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT")) { _ = PWINDBG_EXTENSION_DLL_INIT; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT32")) { _ = PWINDBG_EXTENSION_DLL_INIT32; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT64")) { _ = PWINDBG_EXTENSION_DLL_INIT64; }
    if (@hasDecl(@This(), "PWINDBG_CHECK_VERSION")) { _ = PWINDBG_CHECK_VERSION; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_API_VERSION")) { _ = PWINDBG_EXTENSION_API_VERSION; }
    if (@hasDecl(@This(), "PSYM_DUMP_FIELD_CALLBACK")) { _ = PSYM_DUMP_FIELD_CALLBACK; }
    if (@hasDecl(@This(), "PGET_DEVICE_OBJECT_INFO")) { _ = PGET_DEVICE_OBJECT_INFO; }
    if (@hasDecl(@This(), "PGET_DRIVER_OBJECT_INFO")) { _ = PGET_DRIVER_OBJECT_INFO; }
    if (@hasDecl(@This(), "PGET_PROCESS_COMMIT")) { _ = PGET_PROCESS_COMMIT; }
    if (@hasDecl(@This(), "PGET_FULL_IMAGE_NAME")) { _ = PGET_FULL_IMAGE_NAME; }
    if (@hasDecl(@This(), "PGET_CPU_PSPEED_INFO")) { _ = PGET_CPU_PSPEED_INFO; }
    if (@hasDecl(@This(), "PGET_CPU_MICROCODE_VERSION")) { _ = PGET_CPU_MICROCODE_VERSION; }
    if (@hasDecl(@This(), "PGET_SMBIOS_INFO")) { _ = PGET_SMBIOS_INFO; }
    if (@hasDecl(@This(), "PGET_IRP_INFO")) { _ = PGET_IRP_INFO; }
    if (@hasDecl(@This(), "PGET_PNP_TRIAGE_INFO")) { _ = PGET_PNP_TRIAGE_INFO; }
    if (@hasDecl(@This(), "PGET_POOL_DATA")) { _ = PGET_POOL_DATA; }
    if (@hasDecl(@This(), "PGET_POOL_REGION")) { _ = PGET_POOL_REGION; }
    if (@hasDecl(@This(), "PFIND_MATCHING_THREAD")) { _ = PFIND_MATCHING_THREAD; }
    if (@hasDecl(@This(), "PFIND_MATCHING_PROCESS")) { _ = PFIND_MATCHING_PROCESS; }
    if (@hasDecl(@This(), "EXTS_JOB_PROCESS_CALLBACK")) { _ = EXTS_JOB_PROCESS_CALLBACK; }
    if (@hasDecl(@This(), "PENUMERATE_JOB_PROCESSES")) { _ = PENUMERATE_JOB_PROCESSES; }
    if (@hasDecl(@This(), "EXTS_TABLE_ENTRY_CALLBACK")) { _ = EXTS_TABLE_ENTRY_CALLBACK; }
    if (@hasDecl(@This(), "PENUMERATE_HASH_TABLE")) { _ = PENUMERATE_HASH_TABLE; }
    if (@hasDecl(@This(), "KDEXT_DUMP_HANDLE_CALLBACK")) { _ = KDEXT_DUMP_HANDLE_CALLBACK; }
    if (@hasDecl(@This(), "PENUMERATE_HANDLES")) { _ = PENUMERATE_HANDLES; }
    if (@hasDecl(@This(), "PFIND_FILELOCK_OWNERINFO")) { _ = PFIND_FILELOCK_OWNERINFO; }
    if (@hasDecl(@This(), "KDEXTS_LOCK_CALLBACKROUTINE")) { _ = KDEXTS_LOCK_CALLBACKROUTINE; }
    if (@hasDecl(@This(), "PENUMERATE_SYSTEM_LOCKS")) { _ = PENUMERATE_SYSTEM_LOCKS; }
    if (@hasDecl(@This(), "PKDEXTS_GET_PTE_INFO")) { _ = PKDEXTS_GET_PTE_INFO; }
    if (@hasDecl(@This(), "PGET_POOL_TAG_DESCRIPTION")) { _ = PGET_POOL_TAG_DESCRIPTION; }
    if (@hasDecl(@This(), "EXT_GET_FAILURE_ANALYSIS")) { _ = EXT_GET_FAILURE_ANALYSIS; }
    if (@hasDecl(@This(), "EXT_GET_DEBUG_FAILURE_ANALYSIS")) { _ = EXT_GET_DEBUG_FAILURE_ANALYSIS; }
    if (@hasDecl(@This(), "fnDebugFailureAnalysisCreateInstance")) { _ = fnDebugFailureAnalysisCreateInstance; }
    if (@hasDecl(@This(), "EXT_ANALYSIS_PLUGIN")) { _ = EXT_ANALYSIS_PLUGIN; }
    if (@hasDecl(@This(), "EXT_GET_FA_ENTRIES_DATA")) { _ = EXT_GET_FA_ENTRIES_DATA; }
    if (@hasDecl(@This(), "EXT_TARGET_INFO")) { _ = EXT_TARGET_INFO; }
    if (@hasDecl(@This(), "EXT_DECODE_ERROR")) { _ = EXT_DECODE_ERROR; }
    if (@hasDecl(@This(), "EXT_TRIAGE_FOLLOWUP")) { _ = EXT_TRIAGE_FOLLOWUP; }
    if (@hasDecl(@This(), "EXT_RELOAD_TRIAGER")) { _ = EXT_RELOAD_TRIAGER; }
    if (@hasDecl(@This(), "EXT_XML_DATA")) { _ = EXT_XML_DATA; }
    if (@hasDecl(@This(), "EXT_ANALYZER")) { _ = EXT_ANALYZER; }
    if (@hasDecl(@This(), "EXTDLL_QUERYDATABYTAG")) { _ = EXTDLL_QUERYDATABYTAG; }
    if (@hasDecl(@This(), "EXTDLL_QUERYDATABYTAGEX")) { _ = EXTDLL_QUERYDATABYTAGEX; }
    if (@hasDecl(@This(), "ENTRY_CALLBACK")) { _ = ENTRY_CALLBACK; }
    if (@hasDecl(@This(), "EXTDLL_ITERATERTLBALANCEDNODES")) { _ = EXTDLL_ITERATERTLBALANCEDNODES; }
    if (@hasDecl(@This(), "EXT_GET_HANDLE_TRACE")) { _ = EXT_GET_HANDLE_TRACE; }
    if (@hasDecl(@This(), "EXT_GET_ENVIRONMENT_VARIABLE")) { _ = EXT_GET_ENVIRONMENT_VARIABLE; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
