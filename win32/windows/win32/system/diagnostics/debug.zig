//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (331)
//--------------------------------------------------------------------------------
pub const WOW64_SIZE_OF_80387_REGISTERS = @as(u32, 80);
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const RESTORE_LAST_ERROR_NAME_A = "RestoreLastError";
pub const RESTORE_LAST_ERROR_NAME_W = "RestoreLastError";
pub const RESTORE_LAST_ERROR_NAME = "RestoreLastError";
pub const MAX_SYM_NAME = @as(u32, 2000);
pub const BIND_NO_BOUND_IMPORTS = @as(u32, 1);
pub const BIND_NO_UPDATE = @as(u32, 2);
pub const BIND_ALL_IMAGES = @as(u32, 4);
pub const BIND_CACHE_IMPORT_DLLS = @as(u32, 8);
pub const BIND_REPORT_64BIT_VA = @as(u32, 16);
pub const CHECKSUM_SUCCESS = @as(u32, 0);
pub const CHECKSUM_OPEN_FAILURE = @as(u32, 1);
pub const CHECKSUM_MAP_FAILURE = @as(u32, 2);
pub const CHECKSUM_MAPVIEW_FAILURE = @as(u32, 3);
pub const CHECKSUM_UNICODE_FAILURE = @as(u32, 4);
pub const SPLITSYM_REMOVE_PRIVATE = @as(u32, 1);
pub const SPLITSYM_EXTRACT_ALL = @as(u32, 2);
pub const SPLITSYM_SYMBOLPATH_IS_SRC = @as(u32, 4);
pub const CERT_PE_IMAGE_DIGEST_DEBUG_INFO = @as(u32, 1);
pub const CERT_PE_IMAGE_DIGEST_RESOURCES = @as(u32, 2);
pub const CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO = @as(u32, 4);
pub const CERT_PE_IMAGE_DIGEST_NON_PE_INFO = @as(u32, 8);
pub const CERT_SECTION_TYPE_ANY = @as(u32, 255);
pub const ERROR_IMAGE_NOT_STRIPPED = @as(u32, 34816);
pub const ERROR_NO_DBG_POINTER = @as(u32, 34817);
pub const ERROR_NO_PDB_POINTER = @as(u32, 34818);
pub const UNDNAME_COMPLETE = @as(u32, 0);
pub const UNDNAME_NO_LEADING_UNDERSCORES = @as(u32, 1);
pub const UNDNAME_NO_MS_KEYWORDS = @as(u32, 2);
pub const UNDNAME_NO_FUNCTION_RETURNS = @as(u32, 4);
pub const UNDNAME_NO_ALLOCATION_MODEL = @as(u32, 8);
pub const UNDNAME_NO_ALLOCATION_LANGUAGE = @as(u32, 16);
pub const UNDNAME_NO_MS_THISTYPE = @as(u32, 32);
pub const UNDNAME_NO_CV_THISTYPE = @as(u32, 64);
pub const UNDNAME_NO_THISTYPE = @as(u32, 96);
pub const UNDNAME_NO_ACCESS_SPECIFIERS = @as(u32, 128);
pub const UNDNAME_NO_THROW_SIGNATURES = @as(u32, 256);
pub const UNDNAME_NO_MEMBER_TYPE = @as(u32, 512);
pub const UNDNAME_NO_RETURN_UDT_MODEL = @as(u32, 1024);
pub const UNDNAME_32_BIT_DECODE = @as(u32, 2048);
pub const UNDNAME_NAME_ONLY = @as(u32, 4096);
pub const UNDNAME_NO_ARGUMENTS = @as(u32, 8192);
pub const UNDNAME_NO_SPECIAL_SYMS = @as(u32, 16384);
pub const DBHHEADER_PDBGUID = @as(u32, 3);
pub const INLINE_FRAME_CONTEXT_INIT = @as(u32, 0);
pub const INLINE_FRAME_CONTEXT_IGNORE = @as(u32, 4294967295);
pub const TARGET_ATTRIBUTE_PACMASK = @as(u32, 1);
pub const SYM_STKWALK_DEFAULT = @as(u32, 0);
pub const SYM_STKWALK_FORCE_FRAMEPTR = @as(u32, 1);
pub const SYM_STKWALK_ZEROEXTEND_PTRS = @as(u32, 2);
pub const API_VERSION_NUMBER = @as(u32, 12);
pub const SYMFLAG_NULL = @as(u32, 524288);
pub const SYMFLAG_FUNC_NO_RETURN = @as(u32, 1048576);
pub const SYMFLAG_SYNTHETIC_ZEROBASE = @as(u32, 2097152);
pub const SYMFLAG_PUBLIC_CODE = @as(u32, 4194304);
pub const SYMFLAG_REGREL_ALIASINDIR = @as(u32, 8388608);
pub const SYMFLAG_FIXUP_ARM64X = @as(u32, 16777216);
pub const SYMFLAG_GLOBAL = @as(u32, 33554432);
pub const SYMFLAG_RESET = @as(u32, 2147483648);
pub const IMAGEHLP_MODULE_REGION_DLLBASE = @as(u32, 1);
pub const IMAGEHLP_MODULE_REGION_DLLRANGE = @as(u32, 2);
pub const IMAGEHLP_MODULE_REGION_ADDITIONAL = @as(u32, 4);
pub const IMAGEHLP_MODULE_REGION_JIT = @as(u32, 8);
pub const IMAGEHLP_MODULE_REGION_ALL = @as(u32, 255);
pub const CBA_DEFERRED_SYMBOL_LOAD_START = @as(u32, 1);
pub const CBA_DEFERRED_SYMBOL_LOAD_COMPLETE = @as(u32, 2);
pub const CBA_DEFERRED_SYMBOL_LOAD_FAILURE = @as(u32, 3);
pub const CBA_SYMBOLS_UNLOADED = @as(u32, 4);
pub const CBA_DUPLICATE_SYMBOL = @as(u32, 5);
pub const CBA_READ_MEMORY = @as(u32, 6);
pub const CBA_DEFERRED_SYMBOL_LOAD_CANCEL = @as(u32, 7);
pub const CBA_SET_OPTIONS = @as(u32, 8);
pub const CBA_EVENT = @as(u32, 16);
pub const CBA_DEFERRED_SYMBOL_LOAD_PARTIAL = @as(u32, 32);
pub const CBA_DEBUG_INFO = @as(u32, 268435456);
pub const CBA_SRCSRV_INFO = @as(u32, 536870912);
pub const CBA_SRCSRV_EVENT = @as(u32, 1073741824);
pub const CBA_UPDATE_STATUS_BAR = @as(u32, 1342177280);
pub const CBA_ENGINE_PRESENT = @as(u32, 1610612736);
pub const CBA_CHECK_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 1879048192);
pub const CBA_CHECK_ARM_MACHINE_THUMB_TYPE_OVERRIDE = @as(u32, 2147483648);
pub const CBA_XML_LOG = @as(u32, 2415919104);
pub const CBA_MAP_JIT_SYMBOL = @as(u32, 2684354560);
pub const EVENT_SRCSPEW_START = @as(u32, 100);
pub const EVENT_SRCSPEW = @as(u32, 100);
pub const EVENT_SRCSPEW_END = @as(u32, 199);
pub const DSLFLAG_MISMATCHED_PDB = @as(u32, 1);
pub const DSLFLAG_MISMATCHED_DBG = @as(u32, 2);
pub const FLAG_ENGINE_PRESENT = @as(u32, 4);
pub const FLAG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const FLAG_OVERRIDE_ARM_MACHINE_TYPE = @as(u32, 16);
pub const SYMOPT_CASE_INSENSITIVE = @as(u32, 1);
pub const SYMOPT_UNDNAME = @as(u32, 2);
pub const SYMOPT_DEFERRED_LOADS = @as(u32, 4);
pub const SYMOPT_NO_CPP = @as(u32, 8);
pub const SYMOPT_LOAD_LINES = @as(u32, 16);
pub const SYMOPT_OMAP_FIND_NEAREST = @as(u32, 32);
pub const SYMOPT_LOAD_ANYTHING = @as(u32, 64);
pub const SYMOPT_IGNORE_CVREC = @as(u32, 128);
pub const SYMOPT_NO_UNQUALIFIED_LOADS = @as(u32, 256);
pub const SYMOPT_FAIL_CRITICAL_ERRORS = @as(u32, 512);
pub const SYMOPT_EXACT_SYMBOLS = @as(u32, 1024);
pub const SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = @as(u32, 2048);
pub const SYMOPT_IGNORE_NT_SYMPATH = @as(u32, 4096);
pub const SYMOPT_INCLUDE_32BIT_MODULES = @as(u32, 8192);
pub const SYMOPT_PUBLICS_ONLY = @as(u32, 16384);
pub const SYMOPT_NO_PUBLICS = @as(u32, 32768);
pub const SYMOPT_AUTO_PUBLICS = @as(u32, 65536);
pub const SYMOPT_NO_IMAGE_SEARCH = @as(u32, 131072);
pub const SYMOPT_SECURE = @as(u32, 262144);
pub const SYMOPT_NO_PROMPTS = @as(u32, 524288);
pub const SYMOPT_OVERWRITE = @as(u32, 1048576);
pub const SYMOPT_IGNORE_IMAGEDIR = @as(u32, 2097152);
pub const SYMOPT_FLAT_DIRECTORY = @as(u32, 4194304);
pub const SYMOPT_FAVOR_COMPRESSED = @as(u32, 8388608);
pub const SYMOPT_ALLOW_ZERO_ADDRESS = @as(u32, 16777216);
pub const SYMOPT_DISABLE_SYMSRV_AUTODETECT = @as(u32, 33554432);
pub const SYMOPT_READONLY_CACHE = @as(u32, 67108864);
pub const SYMOPT_SYMPATH_LAST = @as(u32, 134217728);
pub const SYMOPT_DISABLE_FAST_SYMBOLS = @as(u32, 268435456);
pub const SYMOPT_DISABLE_SYMSRV_TIMEOUT = @as(u32, 536870912);
pub const SYMOPT_DISABLE_SRVSTAR_ON_STARTUP = @as(u32, 1073741824);
pub const SYMOPT_DEBUG = @as(u32, 2147483648);
pub const SYM_INLINE_COMP_ERROR = @as(u32, 0);
pub const SYM_INLINE_COMP_IDENTICAL = @as(u32, 1);
pub const SYM_INLINE_COMP_STEPIN = @as(u32, 2);
pub const SYM_INLINE_COMP_STEPOUT = @as(u32, 3);
pub const SYM_INLINE_COMP_STEPOVER = @as(u32, 4);
pub const SYM_INLINE_COMP_DIFFERENT = @as(u32, 5);
pub const ESLFLAG_FULLPATH = @as(u32, 1);
pub const ESLFLAG_NEAREST = @as(u32, 2);
pub const ESLFLAG_PREV = @as(u32, 4);
pub const ESLFLAG_NEXT = @as(u32, 8);
pub const ESLFLAG_INLINE_SITE = @as(u32, 16);
pub const SYMENUM_OPTIONS_DEFAULT = @as(u32, 1);
pub const SYMENUM_OPTIONS_INLINE = @as(u32, 2);
pub const SYMSEARCH_MASKOBJS = @as(u32, 1);
pub const SYMSEARCH_RECURSE = @as(u32, 2);
pub const SYMSEARCH_GLOBALSONLY = @as(u32, 4);
pub const SYMSEARCH_ALLITEMS = @as(u32, 8);
pub const EXT_OUTPUT_VER = @as(u32, 1);
pub const SYMSRV_VERSION = @as(u32, 2);
pub const SSRVOPT_CALLBACK = @as(u32, 1);
pub const SSRVOPT_OLDGUIDPTR = @as(u32, 16);
pub const SSRVOPT_UNATTENDED = @as(u32, 32);
pub const SSRVOPT_NOCOPY = @as(u32, 64);
pub const SSRVOPT_GETPATH = @as(u32, 64);
pub const SSRVOPT_PARENTWIN = @as(u32, 128);
pub const SSRVOPT_PARAMTYPE = @as(u32, 256);
pub const SSRVOPT_SECURE = @as(u32, 512);
pub const SSRVOPT_TRACE = @as(u32, 1024);
pub const SSRVOPT_SETCONTEXT = @as(u32, 2048);
pub const SSRVOPT_PROXY = @as(u32, 4096);
pub const SSRVOPT_DOWNSTREAM_STORE = @as(u32, 8192);
pub const SSRVOPT_OVERWRITE = @as(u32, 16384);
pub const SSRVOPT_RESETTOU = @as(u32, 32768);
pub const SSRVOPT_CALLBACKW = @as(u32, 65536);
pub const SSRVOPT_FLAT_DEFAULT_STORE = @as(u32, 131072);
pub const SSRVOPT_PROXYW = @as(u32, 262144);
pub const SSRVOPT_MESSAGE = @as(u32, 524288);
pub const SSRVOPT_SERVICE = @as(u32, 1048576);
pub const SSRVOPT_FAVOR_COMPRESSED = @as(u32, 2097152);
pub const SSRVOPT_STRING = @as(u32, 4194304);
pub const SSRVOPT_WINHTTP = @as(u32, 8388608);
pub const SSRVOPT_WININET = @as(u32, 16777216);
pub const SSRVOPT_DONT_UNCOMPRESS = @as(u32, 33554432);
pub const SSRVOPT_DISABLE_PING_HOST = @as(u32, 67108864);
pub const SSRVOPT_DISABLE_TIMEOUT = @as(u32, 134217728);
pub const SSRVOPT_ENABLE_COMM_MSG = @as(u32, 268435456);
pub const SSRVOPT_URI_FILTER = @as(u32, 536870912);
pub const SSRVOPT_URI_TIERS = @as(u32, 1073741824);
pub const SSRVOPT_RETRY_APP_HANG = @as(u32, 2147483648);
pub const SSRVOPT_MAX = @as(u32, 2147483648);
pub const NUM_SSRVOPTS = @as(u32, 32);
pub const SSRVURI_HTTP_NORMAL = @as(u32, 1);
pub const SSRVURI_HTTP_COMPRESSED = @as(u32, 2);
pub const SSRVURI_HTTP_FILEPTR = @as(u32, 4);
pub const SSRVURI_UNC_NORMAL = @as(u32, 16);
pub const SSRVURI_UNC_COMPRESSED = @as(u32, 32);
pub const SSRVURI_UNC_FILEPTR = @as(u32, 64);
pub const SSRVURI_HTTP_MASK = @as(u32, 15);
pub const SSRVURI_UNC_MASK = @as(u32, 240);
pub const SSRVURI_ALL = @as(u32, 255);
pub const SSRVURI_NORMAL = @as(u32, 1);
pub const SSRVURI_COMPRESSED = @as(u32, 2);
pub const SSRVURI_FILEPTR = @as(u32, 4);
pub const SSRVACTION_TRACE = @as(u32, 1);
pub const SSRVACTION_QUERYCANCEL = @as(u32, 2);
pub const SSRVACTION_EVENT = @as(u32, 3);
pub const SSRVACTION_EVENTW = @as(u32, 4);
pub const SSRVACTION_SIZE = @as(u32, 5);
pub const SSRVACTION_HTTPSTATUS = @as(u32, 6);
pub const SSRVACTION_XMLOUTPUT = @as(u32, 7);
pub const SSRVACTION_CHECKSUMSTATUS = @as(u32, 8);
pub const SYMSTOREOPT_ALT_INDEX = @as(u32, 16);
pub const SYMSTOREOPT_UNICODE = @as(u32, 32);
pub const SYMF_OMAP_GENERATED = @as(u32, 1);
pub const SYMF_OMAP_MODIFIED = @as(u32, 2);
pub const SYMF_REGISTER = @as(u32, 8);
pub const SYMF_REGREL = @as(u32, 16);
pub const SYMF_FRAMEREL = @as(u32, 32);
pub const SYMF_PARAMETER = @as(u32, 64);
pub const SYMF_LOCAL = @as(u32, 128);
pub const SYMF_CONSTANT = @as(u32, 256);
pub const SYMF_EXPORT = @as(u32, 512);
pub const SYMF_FORWARDER = @as(u32, 1024);
pub const SYMF_FUNCTION = @as(u32, 2048);
pub const SYMF_VIRTUAL = @as(u32, 4096);
pub const SYMF_THUNK = @as(u32, 8192);
pub const SYMF_TLSREL = @as(u32, 16384);
pub const IMAGEHLP_SYMBOL_INFO_VALUEPRESENT = @as(u32, 1);
pub const IMAGEHLP_SYMBOL_INFO_REGISTER = @as(u32, 8);
pub const IMAGEHLP_SYMBOL_INFO_REGRELATIVE = @as(u32, 16);
pub const IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE = @as(u32, 32);
pub const IMAGEHLP_SYMBOL_INFO_PARAMETER = @as(u32, 64);
pub const IMAGEHLP_SYMBOL_INFO_LOCAL = @as(u32, 128);
pub const IMAGEHLP_SYMBOL_INFO_CONSTANT = @as(u32, 256);
pub const IMAGEHLP_SYMBOL_FUNCTION = @as(u32, 2048);
pub const IMAGEHLP_SYMBOL_VIRTUAL = @as(u32, 4096);
pub const IMAGEHLP_SYMBOL_THUNK = @as(u32, 8192);
pub const IMAGEHLP_SYMBOL_INFO_TLSRELATIVE = @as(u32, 16384);
pub const IMAGEHLP_RMAP_MAPPED_FLAT = @as(u32, 1);
pub const IMAGEHLP_RMAP_BIG_ENDIAN = @as(u32, 2);
pub const IMAGEHLP_RMAP_IGNORE_MISCOMPARE = @as(u32, 4);
pub const IMAGEHLP_RMAP_FIXUP_ARM64X = @as(u32, 268435456);
pub const IMAGEHLP_RMAP_LOAD_RW_DATA_SECTIONS = @as(u32, 536870912);
pub const IMAGEHLP_RMAP_OMIT_SHARED_RW_DATA_SECTIONS = @as(u32, 1073741824);
pub const IMAGEHLP_RMAP_FIXUP_IMAGEBASE = @as(u32, 2147483648);
pub const DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32 = @as(u32, 700);
pub const DMP_CONTEXT_RECORD_SIZE_32 = @as(u32, 1200);
pub const DMP_RESERVED_0_SIZE_32 = @as(u32, 1760);
pub const DMP_RESERVED_2_SIZE_32 = @as(u32, 16);
pub const DMP_RESERVED_3_SIZE_32 = @as(u32, 56);
pub const DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64 = @as(u32, 700);
pub const DMP_CONTEXT_RECORD_SIZE_64 = @as(u32, 3000);
pub const DMP_RESERVED_0_SIZE_64 = @as(u32, 4008);
pub const DMP_HEADER_COMMENT_SIZE = @as(u32, 128);
pub const DUMP_SUMMARY_VALID_KERNEL_VA = @as(u32, 1);
pub const DUMP_SUMMARY_VALID_CURRENT_USER_VA = @as(u32, 2);
pub const MINIDUMP_VERSION = @as(u32, 42899);
pub const MINIDUMP_MISC1_PROCESSOR_POWER_INFO = @as(u32, 4);
pub const MINIDUMP_MISC3_PROCESS_INTEGRITY = @as(u32, 16);
pub const MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS = @as(u32, 32);
pub const MINIDUMP_MISC3_TIMEZONE = @as(u32, 64);
pub const MINIDUMP_MISC3_PROTECTED_PROCESS = @as(u32, 128);
pub const MINIDUMP_MISC4_BUILDSTRING = @as(u32, 256);
pub const MINIDUMP_MISC5_PROCESS_COOKIE = @as(u32, 512);
pub const MINIDUMP_SYSMEMINFO1_FILECACHE_TRANSITIONREPURPOSECOUNT_FLAGS = @as(u32, 1);
pub const MINIDUMP_SYSMEMINFO1_BASICPERF = @as(u32, 2);
pub const MINIDUMP_SYSMEMINFO1_PERF_CCTOTALDIRTYPAGES_CCDIRTYPAGETHRESHOLD = @as(u32, 4);
pub const MINIDUMP_SYSMEMINFO1_PERF_RESIDENTAVAILABLEPAGES_SHAREDCOMMITPAGES = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS = @as(u32, 1);
pub const MINIDUMP_PROCESS_VM_COUNTERS_VIRTUALSIZE = @as(u32, 2);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX = @as(u32, 4);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX2 = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS_JOB = @as(u32, 16);
pub const INTERFACESAFE_FOR_UNTRUSTED_CALLER = @as(u32, 1);
pub const INTERFACESAFE_FOR_UNTRUSTED_DATA = @as(u32, 2);
pub const INTERFACE_USES_DISPEX = @as(u32, 4);
pub const INTERFACE_USES_SECURITY_MANAGER = @as(u32, 8);
pub const WCT_MAX_NODE_COUNT = @as(u32, 16);
pub const WCT_OBJNAME_LENGTH = @as(u32, 128);
pub const WCT_NETWORK_IO_FLAG = @as(u32, 8);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10 = @as(u32, 10);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_11 = @as(u32, 11);
pub const WHEA_MAX_MC_BANKS = @as(u32, 32);
pub const WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST = @as(u32, 1);
pub const WHEA_ERROR_SOURCE_FLAG_GLOBAL = @as(u32, 2);
pub const WHEA_ERROR_SOURCE_FLAG_GHES_ASSIST = @as(u32, 4);
pub const WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE = @as(u32, 2147483648);
pub const WHEA_ERROR_SOURCE_INVALID_RELATED_SOURCE = @as(u32, 65535);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE = @as(u32, 0);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC = @as(u32, 1);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI = @as(u32, 2);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA = @as(u32, 3);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC = @as(u32, 4);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE = @as(u32, 5);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT = @as(u32, 6);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT = @as(u32, 7);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE = @as(u32, 8);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC = @as(u32, 9);
pub const WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2 = @as(u32, 10);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA = @as(u32, 0);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA = @as(u32, 1);
pub const WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA = @as(u32, 2);
pub const WHEA_NOTIFICATION_TYPE_POLLED = @as(u32, 0);
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT = @as(u32, 1);
pub const WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT = @as(u32, 2);
pub const WHEA_NOTIFICATION_TYPE_SCI = @as(u32, 3);
pub const WHEA_NOTIFICATION_TYPE_NMI = @as(u32, 4);
pub const WHEA_NOTIFICATION_TYPE_CMCI = @as(u32, 5);
pub const WHEA_NOTIFICATION_TYPE_MCE = @as(u32, 6);
pub const WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL = @as(u32, 7);
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEA = @as(u32, 8);
pub const WHEA_NOTIFICATION_TYPE_ARMV8_SEI = @as(u32, 9);
pub const WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV = @as(u32, 10);
pub const WHEA_NOTIFICATION_TYPE_SDEI = @as(u32, 11);
pub const WHEA_DEVICE_DRIVER_CONFIG_V1 = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_CONFIG_V2 = @as(u32, 2);
pub const WHEA_DEVICE_DRIVER_CONFIG_MIN = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_CONFIG_MAX = @as(u32, 2);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_V1 = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MIN = @as(u32, 1);
pub const WHEA_DEVICE_DRIVER_BUFFER_SET_MAX = @as(u32, 1);
pub const WHEA_DISABLE_OFFLINE = @as(u32, 0);
pub const WHEA_MEM_PERSISTOFFLINE = @as(u32, 1);
pub const WHEA_MEM_PFA_DISABLE = @as(u32, 2);
pub const WHEA_MEM_PFA_PAGECOUNT = @as(u32, 3);
pub const WHEA_MEM_PFA_THRESHOLD = @as(u32, 4);
pub const WHEA_MEM_PFA_TIMEOUT = @as(u32, 5);
pub const WHEA_DISABLE_DUMMY_WRITE = @as(u32, 6);
pub const WHEA_RESTORE_CMCI_ENABLED = @as(u32, 7);
pub const WHEA_RESTORE_CMCI_ATTEMPTS = @as(u32, 8);
pub const WHEA_RESTORE_CMCI_ERR_LIMIT = @as(u32, 9);
pub const WHEA_CMCI_THRESHOLD_COUNT = @as(u32, 10);
pub const WHEA_CMCI_THRESHOLD_TIME = @as(u32, 11);
pub const WHEA_CMCI_THRESHOLD_POLL_COUNT = @as(u32, 12);
pub const WHEA_PENDING_PAGE_LIST_SZ = @as(u32, 13);
pub const WHEA_BAD_PAGE_LIST_MAX_SIZE = @as(u32, 14);
pub const WHEA_BAD_PAGE_LIST_LOCATION = @as(u32, 15);
pub const WHEA_NOTIFY_ALL_OFFLINES = @as(u32, 16);
pub const WHEA_ROW_FAIL_CHECK_EXTENT = @as(u32, 17);
pub const WHEA_ROW_FAIL_CHECK_ENABLE = @as(u32, 18);
pub const WHEA_ROW_FAIL_CHECK_THRESHOLD = @as(u32, 19);
pub const IPMI_OS_SEL_RECORD_VERSION_1 = @as(u32, 1);
pub const IPMI_OS_SEL_RECORD_VERSION = @as(u32, 1);
pub const IPMI_IOCTL_INDEX = @as(u32, 1024);
pub const IOCTL_IPMI_INTERNAL_RECORD_SEL_EVENT = @as(u32, 2232320);
pub const IPMI_OS_SEL_RECORD_MASK = @as(u32, 65535);
pub const sevMax = @as(i32, 4);

//--------------------------------------------------------------------------------
// Section: Types (388)
//--------------------------------------------------------------------------------
pub const SYM_LOAD_FLAGS = enum(u32) {
    NONE = 0,
    VIRTUAL = 1,
    ALT_INDEX = 2,
    NO_SYMBOLS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        VIRTUAL: u1 = 0,
        ALT_INDEX: u1 = 0,
        NO_SYMBOLS: u1 = 0,
    }) SYM_LOAD_FLAGS {
        return @as(SYM_LOAD_FLAGS, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(SYM_LOAD_FLAGS.NONE) else 0)
            | (if (o.VIRTUAL == 1) @intFromEnum(SYM_LOAD_FLAGS.VIRTUAL) else 0)
            | (if (o.ALT_INDEX == 1) @intFromEnum(SYM_LOAD_FLAGS.ALT_INDEX) else 0)
            | (if (o.NO_SYMBOLS == 1) @intFromEnum(SYM_LOAD_FLAGS.NO_SYMBOLS) else 0)
        ));
    }
};
pub const SLMFLAG_NONE = SYM_LOAD_FLAGS.NONE;
pub const SLMFLAG_VIRTUAL = SYM_LOAD_FLAGS.VIRTUAL;
pub const SLMFLAG_ALT_INDEX = SYM_LOAD_FLAGS.ALT_INDEX;
pub const SLMFLAG_NO_SYMBOLS = SYM_LOAD_FLAGS.NO_SYMBOLS;

pub const IMAGE_SECTION_CHARACTERISTICS = enum(u32) {
    TYPE_NO_PAD = 8,
    CNT_CODE = 32,
    CNT_INITIALIZED_DATA = 64,
    CNT_UNINITIALIZED_DATA = 128,
    LNK_OTHER = 256,
    LNK_INFO = 512,
    LNK_REMOVE = 2048,
    LNK_COMDAT = 4096,
    NO_DEFER_SPEC_EXC = 16384,
    GPREL = 32768,
    // MEM_FARDATA = 32768, this enum value conflicts with GPREL
    MEM_PURGEABLE = 131072,
    // MEM_16BIT = 131072, this enum value conflicts with MEM_PURGEABLE
    MEM_LOCKED = 262144,
    MEM_PRELOAD = 524288,
    ALIGN_1BYTES = 1048576,
    ALIGN_2BYTES = 2097152,
    ALIGN_4BYTES = 3145728,
    ALIGN_8BYTES = 4194304,
    ALIGN_16BYTES = 5242880,
    ALIGN_32BYTES = 6291456,
    ALIGN_64BYTES = 7340032,
    ALIGN_128BYTES = 8388608,
    ALIGN_256BYTES = 9437184,
    ALIGN_512BYTES = 10485760,
    ALIGN_1024BYTES = 11534336,
    ALIGN_2048BYTES = 12582912,
    ALIGN_4096BYTES = 13631488,
    ALIGN_8192BYTES = 14680064,
    ALIGN_MASK = 15728640,
    LNK_NRELOC_OVFL = 16777216,
    MEM_DISCARDABLE = 33554432,
    MEM_NOT_CACHED = 67108864,
    MEM_NOT_PAGED = 134217728,
    MEM_SHARED = 268435456,
    MEM_EXECUTE = 536870912,
    MEM_READ = 1073741824,
    MEM_WRITE = 2147483648,
    SCALE_INDEX = 1,
    _,
    pub fn initFlags(o: struct {
        TYPE_NO_PAD: u1 = 0,
        CNT_CODE: u1 = 0,
        CNT_INITIALIZED_DATA: u1 = 0,
        CNT_UNINITIALIZED_DATA: u1 = 0,
        LNK_OTHER: u1 = 0,
        LNK_INFO: u1 = 0,
        LNK_REMOVE: u1 = 0,
        LNK_COMDAT: u1 = 0,
        NO_DEFER_SPEC_EXC: u1 = 0,
        GPREL: u1 = 0,
        MEM_PURGEABLE: u1 = 0,
        MEM_LOCKED: u1 = 0,
        MEM_PRELOAD: u1 = 0,
        ALIGN_1BYTES: u1 = 0,
        ALIGN_2BYTES: u1 = 0,
        ALIGN_4BYTES: u1 = 0,
        ALIGN_8BYTES: u1 = 0,
        ALIGN_16BYTES: u1 = 0,
        ALIGN_32BYTES: u1 = 0,
        ALIGN_64BYTES: u1 = 0,
        ALIGN_128BYTES: u1 = 0,
        ALIGN_256BYTES: u1 = 0,
        ALIGN_512BYTES: u1 = 0,
        ALIGN_1024BYTES: u1 = 0,
        ALIGN_2048BYTES: u1 = 0,
        ALIGN_4096BYTES: u1 = 0,
        ALIGN_8192BYTES: u1 = 0,
        ALIGN_MASK: u1 = 0,
        LNK_NRELOC_OVFL: u1 = 0,
        MEM_DISCARDABLE: u1 = 0,
        MEM_NOT_CACHED: u1 = 0,
        MEM_NOT_PAGED: u1 = 0,
        MEM_SHARED: u1 = 0,
        MEM_EXECUTE: u1 = 0,
        MEM_READ: u1 = 0,
        MEM_WRITE: u1 = 0,
        SCALE_INDEX: u1 = 0,
    }) IMAGE_SECTION_CHARACTERISTICS {
        return @as(IMAGE_SECTION_CHARACTERISTICS, @enumFromInt(
              (if (o.TYPE_NO_PAD == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD) else 0)
            | (if (o.CNT_CODE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_CODE) else 0)
            | (if (o.CNT_INITIALIZED_DATA == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA) else 0)
            | (if (o.CNT_UNINITIALIZED_DATA == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA) else 0)
            | (if (o.LNK_OTHER == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER) else 0)
            | (if (o.LNK_INFO == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_INFO) else 0)
            | (if (o.LNK_REMOVE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE) else 0)
            | (if (o.LNK_COMDAT == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT) else 0)
            | (if (o.NO_DEFER_SPEC_EXC == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC) else 0)
            | (if (o.GPREL == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.GPREL) else 0)
            | (if (o.MEM_PURGEABLE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE) else 0)
            | (if (o.MEM_LOCKED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED) else 0)
            | (if (o.MEM_PRELOAD == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD) else 0)
            | (if (o.ALIGN_1BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES) else 0)
            | (if (o.ALIGN_2BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES) else 0)
            | (if (o.ALIGN_4BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES) else 0)
            | (if (o.ALIGN_8BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES) else 0)
            | (if (o.ALIGN_16BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES) else 0)
            | (if (o.ALIGN_32BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES) else 0)
            | (if (o.ALIGN_64BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES) else 0)
            | (if (o.ALIGN_128BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES) else 0)
            | (if (o.ALIGN_256BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES) else 0)
            | (if (o.ALIGN_512BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES) else 0)
            | (if (o.ALIGN_1024BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES) else 0)
            | (if (o.ALIGN_2048BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES) else 0)
            | (if (o.ALIGN_4096BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES) else 0)
            | (if (o.ALIGN_8192BYTES == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES) else 0)
            | (if (o.ALIGN_MASK == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK) else 0)
            | (if (o.LNK_NRELOC_OVFL == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL) else 0)
            | (if (o.MEM_DISCARDABLE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE) else 0)
            | (if (o.MEM_NOT_CACHED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED) else 0)
            | (if (o.MEM_NOT_PAGED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED) else 0)
            | (if (o.MEM_SHARED == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED) else 0)
            | (if (o.MEM_EXECUTE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE) else 0)
            | (if (o.MEM_READ == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_READ) else 0)
            | (if (o.MEM_WRITE == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE) else 0)
            | (if (o.SCALE_INDEX == 1) @intFromEnum(IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX) else 0)
        ));
    }
};
pub const IMAGE_SCN_TYPE_NO_PAD = IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD;
pub const IMAGE_SCN_CNT_CODE = IMAGE_SECTION_CHARACTERISTICS.CNT_CODE;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA;
pub const IMAGE_SCN_LNK_OTHER = IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER;
pub const IMAGE_SCN_LNK_INFO = IMAGE_SECTION_CHARACTERISTICS.LNK_INFO;
pub const IMAGE_SCN_LNK_REMOVE = IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE;
pub const IMAGE_SCN_LNK_COMDAT = IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC = IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC;
pub const IMAGE_SCN_GPREL = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_FARDATA = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_PURGEABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_16BIT = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_LOCKED = IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED;
pub const IMAGE_SCN_MEM_PRELOAD = IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD;
pub const IMAGE_SCN_ALIGN_1BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES;
pub const IMAGE_SCN_ALIGN_2BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES;
pub const IMAGE_SCN_ALIGN_4BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES;
pub const IMAGE_SCN_ALIGN_8BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES;
pub const IMAGE_SCN_ALIGN_16BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES;
pub const IMAGE_SCN_ALIGN_32BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES;
pub const IMAGE_SCN_ALIGN_64BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES;
pub const IMAGE_SCN_ALIGN_128BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES;
pub const IMAGE_SCN_ALIGN_256BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES;
pub const IMAGE_SCN_ALIGN_512BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES;
pub const IMAGE_SCN_ALIGN_1024BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES;
pub const IMAGE_SCN_ALIGN_2048BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES;
pub const IMAGE_SCN_ALIGN_4096BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES;
pub const IMAGE_SCN_ALIGN_8192BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES;
pub const IMAGE_SCN_ALIGN_MASK = IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK;
pub const IMAGE_SCN_LNK_NRELOC_OVFL = IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL;
pub const IMAGE_SCN_MEM_DISCARDABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE;
pub const IMAGE_SCN_MEM_NOT_CACHED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED;
pub const IMAGE_SCN_MEM_NOT_PAGED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED;
pub const IMAGE_SCN_MEM_SHARED = IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED;
pub const IMAGE_SCN_MEM_EXECUTE = IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE;
pub const IMAGE_SCN_MEM_READ = IMAGE_SECTION_CHARACTERISTICS.MEM_READ;
pub const IMAGE_SCN_MEM_WRITE = IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE;
pub const IMAGE_SCN_SCALE_INDEX = IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX;

pub const IMAGE_SUBSYSTEM = enum(u16) {
    UNKNOWN = 0,
    NATIVE = 1,
    WINDOWS_GUI = 2,
    WINDOWS_CUI = 3,
    OS2_CUI = 5,
    POSIX_CUI = 7,
    NATIVE_WINDOWS = 8,
    WINDOWS_CE_GUI = 9,
    EFI_APPLICATION = 10,
    EFI_BOOT_SERVICE_DRIVER = 11,
    EFI_RUNTIME_DRIVER = 12,
    EFI_ROM = 13,
    XBOX = 14,
    WINDOWS_BOOT_APPLICATION = 16,
    XBOX_CODE_CATALOG = 17,
};
pub const IMAGE_SUBSYSTEM_UNKNOWN = IMAGE_SUBSYSTEM.UNKNOWN;
pub const IMAGE_SUBSYSTEM_NATIVE = IMAGE_SUBSYSTEM.NATIVE;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI = IMAGE_SUBSYSTEM.WINDOWS_GUI;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI = IMAGE_SUBSYSTEM.WINDOWS_CUI;
pub const IMAGE_SUBSYSTEM_OS2_CUI = IMAGE_SUBSYSTEM.OS2_CUI;
pub const IMAGE_SUBSYSTEM_POSIX_CUI = IMAGE_SUBSYSTEM.POSIX_CUI;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS = IMAGE_SUBSYSTEM.NATIVE_WINDOWS;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = IMAGE_SUBSYSTEM.WINDOWS_CE_GUI;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION = IMAGE_SUBSYSTEM.EFI_APPLICATION;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = IMAGE_SUBSYSTEM.EFI_BOOT_SERVICE_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = IMAGE_SUBSYSTEM.EFI_RUNTIME_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_ROM = IMAGE_SUBSYSTEM.EFI_ROM;
pub const IMAGE_SUBSYSTEM_XBOX = IMAGE_SUBSYSTEM.XBOX;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = IMAGE_SUBSYSTEM.WINDOWS_BOOT_APPLICATION;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG = IMAGE_SUBSYSTEM.XBOX_CODE_CATALOG;

pub const IMAGE_DLL_CHARACTERISTICS = enum(u16) {
    HIGH_ENTROPY_VA = 32,
    DYNAMIC_BASE = 64,
    FORCE_INTEGRITY = 128,
    NX_COMPAT = 256,
    NO_ISOLATION = 512,
    NO_SEH = 1024,
    NO_BIND = 2048,
    APPCONTAINER = 4096,
    WDM_DRIVER = 8192,
    GUARD_CF = 16384,
    TERMINAL_SERVER_AWARE = 32768,
    EX_CET_COMPAT = 1,
    EX_CET_COMPAT_STRICT_MODE = 2,
    EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE = 4,
    EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC = 8,
    EX_CET_RESERVED_1 = 16,
    // EX_CET_RESERVED_2 = 32, this enum value conflicts with HIGH_ENTROPY_VA
    _,
    pub fn initFlags(o: struct {
        HIGH_ENTROPY_VA: u1 = 0,
        DYNAMIC_BASE: u1 = 0,
        FORCE_INTEGRITY: u1 = 0,
        NX_COMPAT: u1 = 0,
        NO_ISOLATION: u1 = 0,
        NO_SEH: u1 = 0,
        NO_BIND: u1 = 0,
        APPCONTAINER: u1 = 0,
        WDM_DRIVER: u1 = 0,
        GUARD_CF: u1 = 0,
        TERMINAL_SERVER_AWARE: u1 = 0,
        EX_CET_COMPAT: u1 = 0,
        EX_CET_COMPAT_STRICT_MODE: u1 = 0,
        EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE: u1 = 0,
        EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC: u1 = 0,
        EX_CET_RESERVED_1: u1 = 0,
    }) IMAGE_DLL_CHARACTERISTICS {
        return @as(IMAGE_DLL_CHARACTERISTICS, @enumFromInt(
              (if (o.HIGH_ENTROPY_VA == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA) else 0)
            | (if (o.DYNAMIC_BASE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE) else 0)
            | (if (o.FORCE_INTEGRITY == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY) else 0)
            | (if (o.NX_COMPAT == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NX_COMPAT) else 0)
            | (if (o.NO_ISOLATION == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION) else 0)
            | (if (o.NO_SEH == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_SEH) else 0)
            | (if (o.NO_BIND == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.NO_BIND) else 0)
            | (if (o.APPCONTAINER == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.APPCONTAINER) else 0)
            | (if (o.WDM_DRIVER == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER) else 0)
            | (if (o.GUARD_CF == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.GUARD_CF) else 0)
            | (if (o.TERMINAL_SERVER_AWARE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE) else 0)
            | (if (o.EX_CET_COMPAT == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT) else 0)
            | (if (o.EX_CET_COMPAT_STRICT_MODE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT_STRICT_MODE) else 0)
            | (if (o.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE) else 0)
            | (if (o.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC) else 0)
            | (if (o.EX_CET_RESERVED_1 == 1) @intFromEnum(IMAGE_DLL_CHARACTERISTICS.EX_CET_RESERVED_1) else 0)
        ));
    }
};
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT = IMAGE_DLL_CHARACTERISTICS.NX_COMPAT;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH = IMAGE_DLL_CHARACTERISTICS.NO_SEH;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND = IMAGE_DLL_CHARACTERISTICS.NO_BIND;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER = IMAGE_DLL_CHARACTERISTICS.APPCONTAINER;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF = IMAGE_DLL_CHARACTERISTICS.GUARD_CF;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT = IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT_STRICT_MODE = IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT_STRICT_MODE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE = IMAGE_DLL_CHARACTERISTICS.EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC = IMAGE_DLL_CHARACTERISTICS.EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_1 = IMAGE_DLL_CHARACTERISTICS.EX_CET_RESERVED_1;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_2 = IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA;

pub const IMAGE_OPTIONAL_HEADER_MAGIC = enum(u16) {
    NT_OPTIONAL_HDR_MAGIC = 523,
    NT_OPTIONAL_HDR32_MAGIC = 267,
    // NT_OPTIONAL_HDR64_MAGIC = 523, this enum value conflicts with NT_OPTIONAL_HDR_MAGIC
    ROM_OPTIONAL_HDR_MAGIC = 263,
};
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR32_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.ROM_OPTIONAL_HDR_MAGIC;

pub const BUGCHECK_ERROR = enum(u32) {
    HARDWARE_PROFILE_UNDOCKED_STRING = 1073807361,
    HARDWARE_PROFILE_DOCKED_STRING = 1073807362,
    HARDWARE_PROFILE_UNKNOWN_STRING = 1073807363,
    WINDOWS_NT_BANNER = 1073741950,
    WINDOWS_NT_CSD_STRING = 1073741959,
    WINDOWS_NT_INFO_STRING = 1073741960,
    WINDOWS_NT_MP_STRING = 1073741961,
    THREAD_TERMINATE_HELD_MUTEX = 1073741962,
    WINDOWS_NT_INFO_STRING_PLURAL = 1073741981,
    WINDOWS_NT_RC_STRING = 1073741982,
    APC_INDEX_MISMATCH = 1,
    DEVICE_QUEUE_NOT_BUSY = 2,
    INVALID_AFFINITY_SET = 3,
    INVALID_DATA_ACCESS_TRAP = 4,
    INVALID_PROCESS_ATTACH_ATTEMPT = 5,
    INVALID_PROCESS_DETACH_ATTEMPT = 6,
    INVALID_SOFTWARE_INTERRUPT = 7,
    IRQL_NOT_DISPATCH_LEVEL = 8,
    IRQL_NOT_GREATER_OR_EQUAL = 9,
    IRQL_NOT_LESS_OR_EQUAL = 10,
    NO_EXCEPTION_HANDLING_SUPPORT = 11,
    MAXIMUM_WAIT_OBJECTS_EXCEEDED = 12,
    MUTEX_LEVEL_NUMBER_VIOLATION = 13,
    NO_USER_MODE_CONTEXT = 14,
    SPIN_LOCK_ALREADY_OWNED = 15,
    SPIN_LOCK_NOT_OWNED = 16,
    THREAD_NOT_MUTEX_OWNER = 17,
    TRAP_CAUSE_UNKNOWN = 18,
    EMPTY_THREAD_REAPER_LIST = 19,
    CREATE_DELETE_LOCK_NOT_LOCKED = 20,
    LAST_CHANCE_CALLED_FROM_KMODE = 21,
    CID_HANDLE_CREATION = 22,
    CID_HANDLE_DELETION = 23,
    REFERENCE_BY_POINTER = 24,
    BAD_POOL_HEADER = 25,
    MEMORY_MANAGEMENT = 26,
    PFN_SHARE_COUNT = 27,
    PFN_REFERENCE_COUNT = 28,
    NO_SPIN_LOCK_AVAILABLE = 29,
    KMODE_EXCEPTION_NOT_HANDLED = 30,
    SHARED_RESOURCE_CONV_ERROR = 31,
    KERNEL_APC_PENDING_DURING_EXIT = 32,
    QUOTA_UNDERFLOW = 33,
    FILE_SYSTEM = 34,
    FAT_FILE_SYSTEM = 35,
    NTFS_FILE_SYSTEM = 36,
    NPFS_FILE_SYSTEM = 37,
    CDFS_FILE_SYSTEM = 38,
    RDR_FILE_SYSTEM = 39,
    CORRUPT_ACCESS_TOKEN = 40,
    SECURITY_SYSTEM = 41,
    INCONSISTENT_IRP = 42,
    PANIC_STACK_SWITCH = 43,
    PORT_DRIVER_INTERNAL = 44,
    SCSI_DISK_DRIVER_INTERNAL = 45,
    DATA_BUS_ERROR = 46,
    INSTRUCTION_BUS_ERROR = 47,
    SET_OF_INVALID_CONTEXT = 48,
    PHASE0_INITIALIZATION_FAILED = 49,
    PHASE1_INITIALIZATION_FAILED = 50,
    UNEXPECTED_INITIALIZATION_CALL = 51,
    CACHE_MANAGER = 52,
    NO_MORE_IRP_STACK_LOCATIONS = 53,
    DEVICE_REFERENCE_COUNT_NOT_ZERO = 54,
    FLOPPY_INTERNAL_ERROR = 55,
    SERIAL_DRIVER_INTERNAL = 56,
    SYSTEM_EXIT_OWNED_MUTEX = 57,
    SYSTEM_UNWIND_PREVIOUS_USER = 58,
    SYSTEM_SERVICE_EXCEPTION = 59,
    INTERRUPT_UNWIND_ATTEMPTED = 60,
    INTERRUPT_EXCEPTION_NOT_HANDLED = 61,
    MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED = 62,
    NO_MORE_SYSTEM_PTES = 63,
    TARGET_MDL_TOO_SMALL = 64,
    MUST_SUCCEED_POOL_EMPTY = 65,
    ATDISK_DRIVER_INTERNAL = 66,
    NO_SUCH_PARTITION = 67,
    MULTIPLE_IRP_COMPLETE_REQUESTS = 68,
    INSUFFICIENT_SYSTEM_MAP_REGS = 69,
    DEREF_UNKNOWN_LOGON_SESSION = 70,
    REF_UNKNOWN_LOGON_SESSION = 71,
    CANCEL_STATE_IN_COMPLETED_IRP = 72,
    PAGE_FAULT_WITH_INTERRUPTS_OFF = 73,
    IRQL_GT_ZERO_AT_SYSTEM_SERVICE = 74,
    STREAMS_INTERNAL_ERROR = 75,
    FATAL_UNHANDLED_HARD_ERROR = 76,
    NO_PAGES_AVAILABLE = 77,
    PFN_LIST_CORRUPT = 78,
    NDIS_INTERNAL_ERROR = 79,
    PAGE_FAULT_IN_NONPAGED_AREA = 80,
    PAGE_FAULT_IN_NONPAGED_AREA_M = 268435536,
    REGISTRY_ERROR = 81,
    MAILSLOT_FILE_SYSTEM = 82,
    NO_BOOT_DEVICE = 83,
    LM_SERVER_INTERNAL_ERROR = 84,
    DATA_COHERENCY_EXCEPTION = 85,
    INSTRUCTION_COHERENCY_EXCEPTION = 86,
    XNS_INTERNAL_ERROR = 87,
    VOLMGRX_INTERNAL_ERROR = 88,
    PINBALL_FILE_SYSTEM = 89,
    CRITICAL_SERVICE_FAILED = 90,
    SET_ENV_VAR_FAILED = 91,
    HAL_INITIALIZATION_FAILED = 92,
    UNSUPPORTED_PROCESSOR = 93,
    OBJECT_INITIALIZATION_FAILED = 94,
    SECURITY_INITIALIZATION_FAILED = 95,
    PROCESS_INITIALIZATION_FAILED = 96,
    HAL1_INITIALIZATION_FAILED = 97,
    OBJECT1_INITIALIZATION_FAILED = 98,
    SECURITY1_INITIALIZATION_FAILED = 99,
    SYMBOLIC_INITIALIZATION_FAILED = 100,
    MEMORY1_INITIALIZATION_FAILED = 101,
    CACHE_INITIALIZATION_FAILED = 102,
    CONFIG_INITIALIZATION_FAILED = 103,
    FILE_INITIALIZATION_FAILED = 104,
    IO1_INITIALIZATION_FAILED = 105,
    LPC_INITIALIZATION_FAILED = 106,
    PROCESS1_INITIALIZATION_FAILED = 107,
    REFMON_INITIALIZATION_FAILED = 108,
    SESSION1_INITIALIZATION_FAILED = 109,
    BOOTPROC_INITIALIZATION_FAILED = 110,
    VSL_INITIALIZATION_FAILED = 111,
    SOFT_RESTART_FATAL_ERROR = 112,
    ASSIGN_DRIVE_LETTERS_FAILED = 114,
    CONFIG_LIST_FAILED = 115,
    BAD_SYSTEM_CONFIG_INFO = 116,
    CANNOT_WRITE_CONFIGURATION = 117,
    PROCESS_HAS_LOCKED_PAGES = 118,
    KERNEL_STACK_INPAGE_ERROR = 119,
    PHASE0_EXCEPTION = 120,
    MISMATCHED_HAL = 121,
    KERNEL_DATA_INPAGE_ERROR = 122,
    INACCESSIBLE_BOOT_DEVICE = 123,
    BUGCODE_NDIS_DRIVER = 124,
    INSTALL_MORE_MEMORY = 125,
    SYSTEM_THREAD_EXCEPTION_NOT_HANDLED = 126,
    SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M = 268435582,
    UNEXPECTED_KERNEL_MODE_TRAP = 127,
    UNEXPECTED_KERNEL_MODE_TRAP_M = 268435583,
    NMI_HARDWARE_FAILURE = 128,
    SPIN_LOCK_INIT_FAILURE = 129,
    DFS_FILE_SYSTEM = 130,
    OFS_FILE_SYSTEM = 131,
    RECOM_DRIVER = 132,
    SETUP_FAILURE = 133,
    AUDIT_FAILURE = 134,
    MBR_CHECKSUM_MISMATCH = 139,
    KERNEL_MODE_EXCEPTION_NOT_HANDLED = 142,
    KERNEL_MODE_EXCEPTION_NOT_HANDLED_M = 268435598,
    PP0_INITIALIZATION_FAILED = 143,
    PP1_INITIALIZATION_FAILED = 144,
    WIN32K_INIT_OR_RIT_FAILURE = 145,
    UP_DRIVER_ON_MP_SYSTEM = 146,
    INVALID_KERNEL_HANDLE = 147,
    KERNEL_STACK_LOCKED_AT_EXIT = 148,
    PNP_INTERNAL_ERROR = 149,
    INVALID_WORK_QUEUE_ITEM = 150,
    BOUND_IMAGE_UNSUPPORTED = 151,
    END_OF_NT_EVALUATION_PERIOD = 152,
    INVALID_REGION_OR_SEGMENT = 153,
    SYSTEM_LICENSE_VIOLATION = 154,
    UDFS_FILE_SYSTEM = 155,
    MACHINE_CHECK_EXCEPTION = 156,
    USER_MODE_HEALTH_MONITOR = 158,
    DRIVER_POWER_STATE_FAILURE = 159,
    INTERNAL_POWER_ERROR = 160,
    PCI_BUS_DRIVER_INTERNAL = 161,
    MEMORY_IMAGE_CORRUPT = 162,
    ACPI_DRIVER_INTERNAL = 163,
    CNSS_FILE_SYSTEM_FILTER = 164,
    ACPI_BIOS_ERROR = 165,
    FP_EMULATION_ERROR = 166,
    BAD_EXHANDLE = 167,
    BOOTING_IN_SAFEMODE_MINIMAL = 168,
    BOOTING_IN_SAFEMODE_NETWORK = 169,
    BOOTING_IN_SAFEMODE_DSREPAIR = 170,
    SESSION_HAS_VALID_POOL_ON_EXIT = 171,
    HAL_MEMORY_ALLOCATION = 172,
    VIDEO_DRIVER_DEBUG_REPORT_REQUEST = 1073741997,
    BGI_DETECTED_VIOLATION = 177,
    VIDEO_DRIVER_INIT_FAILURE = 180,
    BOOTLOG_LOADED = 181,
    BOOTLOG_NOT_LOADED = 182,
    BOOTLOG_ENABLED = 183,
    ATTEMPTED_SWITCH_FROM_DPC = 184,
    CHIPSET_DETECTED_ERROR = 185,
    SESSION_HAS_VALID_VIEWS_ON_EXIT = 186,
    NETWORK_BOOT_INITIALIZATION_FAILED = 187,
    NETWORK_BOOT_DUPLICATE_ADDRESS = 188,
    INVALID_HIBERNATED_STATE = 189,
    ATTEMPTED_WRITE_TO_READONLY_MEMORY = 190,
    MUTEX_ALREADY_OWNED = 191,
    PCI_CONFIG_SPACE_ACCESS_FAILURE = 192,
    SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION = 193,
    BAD_POOL_CALLER = 194,
    SYSTEM_IMAGE_BAD_SIGNATURE = 195,
    DRIVER_VERIFIER_DETECTED_VIOLATION = 196,
    DRIVER_CORRUPTED_EXPOOL = 197,
    DRIVER_CAUGHT_MODIFYING_FREED_POOL = 198,
    TIMER_OR_DPC_INVALID = 199,
    IRQL_UNEXPECTED_VALUE = 200,
    DRIVER_VERIFIER_IOMANAGER_VIOLATION = 201,
    PNP_DETECTED_FATAL_ERROR = 202,
    DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS = 203,
    PAGE_FAULT_IN_FREED_SPECIAL_POOL = 204,
    PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 205,
    DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS = 206,
    TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE = 207,
    DRIVER_CORRUPTED_MMPOOL = 208,
    DRIVER_IRQL_NOT_LESS_OR_EQUAL = 209,
    BUGCODE_ID_DRIVER = 210,
    DRIVER_PORTION_MUST_BE_NONPAGED = 211,
    SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD = 212,
    DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL = 213,
    DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 214,
    DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M = 268435670,
    DRIVER_UNMAPPING_INVALID_VIEW = 215,
    DRIVER_USED_EXCESSIVE_PTES = 216,
    LOCKED_PAGES_TRACKER_CORRUPTION = 217,
    SYSTEM_PTE_MISUSE = 218,
    DRIVER_CORRUPTED_SYSPTES = 219,
    DRIVER_INVALID_STACK_ACCESS = 220,
    POOL_CORRUPTION_IN_FILE_AREA = 222,
    IMPERSONATING_WORKER_THREAD = 223,
    ACPI_BIOS_FATAL_ERROR = 224,
    WORKER_THREAD_RETURNED_AT_BAD_IRQL = 225,
    MANUALLY_INITIATED_CRASH = 226,
    RESOURCE_NOT_OWNED = 227,
    WORKER_INVALID = 228,
    POWER_FAILURE_SIMULATE = 229,
    DRIVER_VERIFIER_DMA_VIOLATION = 230,
    INVALID_FLOATING_POINT_STATE = 231,
    INVALID_CANCEL_OF_FILE_OPEN = 232,
    ACTIVE_EX_WORKER_THREAD_TERMINATION = 233,
    SAVER_UNSPECIFIED = 61440,
    SAVER_BLANKSCREEN = 61442,
    SAVER_INPUT = 61443,
    SAVER_WATCHDOG = 61444,
    SAVER_STARTNOTVISIBLE = 61445,
    SAVER_NAVIGATIONMODEL = 61446,
    SAVER_OUTOFMEMORY = 61447,
    SAVER_GRAPHICS = 61448,
    SAVER_NAVSERVERTIMEOUT = 61449,
    SAVER_CHROMEPROCESSCRASH = 61450,
    SAVER_NOTIFICATIONDISMISSAL = 61451,
    SAVER_SPEECHDISMISSAL = 61452,
    SAVER_CALLDISMISSAL = 61453,
    SAVER_APPBARDISMISSAL = 61454,
    SAVER_RILADAPTATIONCRASH = 61455,
    SAVER_APPLISTUNREACHABLE = 61456,
    SAVER_REPORTNOTIFICATIONFAILURE = 61457,
    SAVER_UNEXPECTEDSHUTDOWN = 61458,
    SAVER_RPCFAILURE = 61459,
    SAVER_AUXILIARYFULLDUMP = 61460,
    SAVER_ACCOUNTPROVSVCINITFAILURE = 61461,
    SAVER_MTBFCOMMANDTIMEOUT = 789,
    SAVER_MTBFCOMMANDHANG = 61697,
    SAVER_MTBFPASSBUGCHECK = 61698,
    SAVER_MTBFIOERROR = 61699,
    SAVER_RENDERTHREADHANG = 61952,
    SAVER_RENDERMOBILEUIOOM = 61953,
    SAVER_DEVICEUPDATEUNSPECIFIED = 62208,
    SAVER_AUDIODRIVERHANG = 62464,
    SAVER_BATTERYPULLOUT = 62720,
    SAVER_MEDIACORETESTHANG = 62976,
    SAVER_RESOURCEMANAGEMENT = 63232,
    SAVER_CAPTURESERVICE = 63488,
    SAVER_WAITFORSHELLREADY = 63744,
    SAVER_NONRESPONSIVEPROCESS = 404,
    SAVER_SICKAPPLICATION = 34918,
    THREAD_STUCK_IN_DEVICE_DRIVER = 234,
    THREAD_STUCK_IN_DEVICE_DRIVER_M = 268435690,
    DIRTY_MAPPED_PAGES_CONGESTION = 235,
    SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT = 236,
    UNMOUNTABLE_BOOT_VOLUME = 237,
    CRITICAL_PROCESS_DIED = 239,
    STORAGE_MINIPORT_ERROR = 240,
    SCSI_VERIFIER_DETECTED_VIOLATION = 241,
    HARDWARE_INTERRUPT_STORM = 242,
    DISORDERLY_SHUTDOWN = 243,
    CRITICAL_OBJECT_TERMINATION = 244,
    FLTMGR_FILE_SYSTEM = 245,
    PCI_VERIFIER_DETECTED_VIOLATION = 246,
    DRIVER_OVERRAN_STACK_BUFFER = 247,
    RAMDISK_BOOT_INITIALIZATION_FAILED = 248,
    DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN = 249,
    HTTP_DRIVER_CORRUPTED = 250,
    RECURSIVE_MACHINE_CHECK = 251,
    ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY = 252,
    DIRTY_NOWRITE_PAGES_CONGESTION = 253,
    BUGCODE_USB_DRIVER = 254,
    BC_BLUETOOTH_VERIFIER_FAULT = 3070,
    BC_BTHMINI_VERIFIER_FAULT = 3071,
    RESERVE_QUEUE_OVERFLOW = 255,
    LOADER_BLOCK_MISMATCH = 256,
    CLOCK_WATCHDOG_TIMEOUT = 257,
    DPC_WATCHDOG_TIMEOUT = 258,
    MUP_FILE_SYSTEM = 259,
    AGP_INVALID_ACCESS = 260,
    AGP_GART_CORRUPTION = 261,
    AGP_ILLEGALLY_REPROGRAMMED = 262,
    KERNEL_EXPAND_STACK_ACTIVE = 263,
    THIRD_PARTY_FILE_SYSTEM_FAILURE = 264,
    CRITICAL_STRUCTURE_CORRUPTION = 265,
    APP_TAGGING_INITIALIZATION_FAILED = 266,
    DFSC_FILE_SYSTEM = 267,
    FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION = 268,
    WDF_VIOLATION = 269,
    VIDEO_MEMORY_MANAGEMENT_INTERNAL = 270,
    DRIVER_INVALID_CRUNTIME_PARAMETER = 272,
    RECURSIVE_NMI = 273,
    MSRPC_STATE_VIOLATION = 274,
    VIDEO_DXGKRNL_FATAL_ERROR = 275,
    VIDEO_SHADOW_DRIVER_FATAL_ERROR = 276,
    AGP_INTERNAL = 277,
    VIDEO_TDR_FAILURE = 278,
    VIDEO_TDR_TIMEOUT_DETECTED = 279,
    NTHV_GUEST_ERROR = 280,
    VIDEO_SCHEDULER_INTERNAL_ERROR = 281,
    EM_INITIALIZATION_ERROR = 282,
    DRIVER_RETURNED_HOLDING_CANCEL_LOCK = 283,
    ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE = 284,
    EVENT_TRACING_FATAL_ERROR = 285,
    TOO_MANY_RECURSIVE_FAULTS = 286,
    INVALID_DRIVER_HANDLE = 287,
    BITLOCKER_FATAL_ERROR = 288,
    DRIVER_VIOLATION = 289,
    WHEA_INTERNAL_ERROR = 290,
    CRYPTO_SELF_TEST_FAILURE = 291,
    WHEA_UNCORRECTABLE_ERROR = 292,
    NMR_INVALID_STATE = 293,
    NETIO_INVALID_POOL_CALLER = 294,
    PAGE_NOT_ZERO = 295,
    WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY = 296,
    WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY = 297,
    MUI_NO_VALID_SYSTEM_LANGUAGE = 298,
    FAULTY_HARDWARE_CORRUPTED_PAGE = 299,
    EXFAT_FILE_SYSTEM = 300,
    VOLSNAP_OVERLAPPED_TABLE_ACCESS = 301,
    INVALID_MDL_RANGE = 302,
    VHD_BOOT_INITIALIZATION_FAILED = 303,
    DYNAMIC_ADD_PROCESSOR_MISMATCH = 304,
    INVALID_EXTENDED_PROCESSOR_STATE = 305,
    RESOURCE_OWNER_POINTER_INVALID = 306,
    DPC_WATCHDOG_VIOLATION = 307,
    DRIVE_EXTENDER = 308,
    REGISTRY_FILTER_DRIVER_EXCEPTION = 309,
    VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE = 310,
    WIN32K_HANDLE_MANAGER = 311,
    GPIO_CONTROLLER_DRIVER_ERROR = 312,
    KERNEL_SECURITY_CHECK_FAILURE = 313,
    KERNEL_MODE_HEAP_CORRUPTION = 314,
    PASSIVE_INTERRUPT_ERROR = 315,
    INVALID_IO_BOOST_STATE = 316,
    CRITICAL_INITIALIZATION_FAILURE = 317,
    ERRATA_WORKAROUND_UNSUCCESSFUL = 318,
    REGISTRY_CALLBACK_DRIVER_EXCEPTION = 319,
    STORAGE_DEVICE_ABNORMALITY_DETECTED = 320,
    VIDEO_ENGINE_TIMEOUT_DETECTED = 321,
    VIDEO_TDR_APPLICATION_BLOCKED = 322,
    PROCESSOR_DRIVER_INTERNAL = 323,
    BUGCODE_USB3_DRIVER = 324,
    SECURE_BOOT_VIOLATION = 325,
    NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED = 326,
    ABNORMAL_RESET_DETECTED = 327,
    IO_OBJECT_INVALID = 328,
    REFS_FILE_SYSTEM = 329,
    KERNEL_WMI_INTERNAL = 330,
    SOC_SUBSYSTEM_FAILURE = 331,
    FATAL_ABNORMAL_RESET_ERROR = 332,
    EXCEPTION_SCOPE_INVALID = 333,
    SOC_CRITICAL_DEVICE_REMOVED = 334,
    PDC_WATCHDOG_TIMEOUT = 335,
    TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK = 336,
    UNSUPPORTED_INSTRUCTION_MODE = 337,
    INVALID_PUSH_LOCK_FLAGS = 338,
    KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION = 339,
    UNEXPECTED_STORE_EXCEPTION = 340,
    OS_DATA_TAMPERING = 341,
    WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP = 342,
    KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION = 343,
    ILLEGAL_IOMMU_PAGE_FAULT = 344,
    HAL_ILLEGAL_IOMMU_PAGE_FAULT = 345,
    SDBUS_INTERNAL_ERROR = 346,
    WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE = 347,
    PDC_WATCHDOG_TIMEOUT_LIVEDUMP = 348,
    SOC_SUBSYSTEM_FAILURE_LIVEDUMP = 349,
    BUGCODE_NDIS_DRIVER_LIVE_DUMP = 350,
    CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP = 351,
    WIN32K_ATOMIC_CHECK_FAILURE = 352,
    LIVE_SYSTEM_DUMP = 353,
    KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE = 354,
    WORKER_THREAD_TEST_CONDITION = 355,
    WIN32K_CRITICAL_FAILURE = 356,
    CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP = 357,
    CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP = 358,
    CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP = 359,
    CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP = 360,
    CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP = 361,
    CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP = 362,
    CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP = 363,
    INVALID_RUNDOWN_PROTECTION_FLAGS = 364,
    INVALID_SLOT_ALLOCATOR_FLAGS = 365,
    ERESOURCE_INVALID_RELEASE = 366,
    CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP = 367,
    CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG = 368,
    CRYPTO_LIBRARY_INTERNAL_ERROR = 369,
    COREMSGCALL_INTERNAL_ERROR = 371,
    COREMSG_INTERNAL_ERROR = 372,
    PREVIOUS_FATAL_ABNORMAL_RESET_ERROR = 373,
    ELAM_DRIVER_DETECTED_FATAL_ERROR = 376,
    CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP = 377,
    PROFILER_CONFIGURATION_ILLEGAL = 379,
    PDC_LOCK_WATCHDOG_LIVEDUMP = 380,
    PDC_UNEXPECTED_REVOCATION_LIVEDUMP = 381,
    MICROCODE_REVISION_MISMATCH = 382,
    HYPERGUARD_INITIALIZATION_FAILURE = 383,
    WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT = 384,
    WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT = 385,
    WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT = 386,
    WVR_LIVEDUMP_APP_IO_TIMEOUT = 387,
    WVR_LIVEDUMP_MANUALLY_INITIATED = 388,
    WVR_LIVEDUMP_STATE_FAILURE = 389,
    WVR_LIVEDUMP_CRITICAL_ERROR = 390,
    VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD = 391,
    CLUSTER_CSVFS_LIVEDUMP = 392,
    BAD_OBJECT_HEADER = 393,
    SILO_CORRUPT = 394,
    SECURE_KERNEL_ERROR = 395,
    HYPERGUARD_VIOLATION = 396,
    SECURE_FAULT_UNHANDLED = 397,
    KERNEL_PARTITION_REFERENCE_VIOLATION = 398,
    SYNTHETIC_EXCEPTION_UNHANDLED = 399,
    WIN32K_CRITICAL_FAILURE_LIVEDUMP = 400,
    PF_DETECTED_CORRUPTION = 401,
    KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL = 402,
    VIDEO_DXGKRNL_LIVEDUMP = 403,
    KERNEL_STORAGE_SLOT_IN_USE = 409,
    SMB_SERVER_LIVEDUMP = 405,
    LOADER_ROLLBACK_DETECTED = 406,
    WIN32K_SECURITY_FAILURE = 407,
    UFX_LIVEDUMP = 408,
    WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO = 410,
    TTM_FATAL_ERROR = 411,
    WIN32K_POWER_WATCHDOG_TIMEOUT = 412,
    CLUSTER_SVHDX_LIVEDUMP = 413,
    BUGCODE_NETADAPTER_DRIVER = 414,
    PDC_PRIVILEGE_CHECK_LIVEDUMP = 415,
    TTM_WATCHDOG_TIMEOUT = 416,
    WIN32K_CALLOUT_WATCHDOG_LIVEDUMP = 417,
    WIN32K_CALLOUT_WATCHDOG_BUGCHECK = 418,
    CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP = 419,
    DRIPS_SW_HW_DIVERGENCE_LIVEDUMP = 420,
    USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP = 421,
    BLUETOOTH_ERROR_RECOVERY_LIVEDUMP = 422,
    SMB_REDIRECTOR_LIVEDUMP = 423,
    VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP = 424,
    DIRECTED_FX_TRANSITION_LIVEDUMP = 425,
    EXCEPTION_ON_INVALID_STACK = 426,
    UNWIND_ON_INVALID_STACK = 427,
    VIDEO_MINIPORT_FAILED_LIVEDUMP = 432,
    VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP = 440,
    DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP = 452,
    IO_THREADPOOL_DEADLOCK_LIVEDUMP = 453,
    FAST_ERESOURCE_PRECONDITION_VIOLATION = 454,
    STORE_DATA_STRUCTURE_CORRUPTION = 455,
    MANUALLY_INITIATED_POWER_BUTTON_HOLD = 456,
    USER_MODE_HEALTH_MONITOR_LIVEDUMP = 457,
    SYNTHETIC_WATCHDOG_TIMEOUT = 458,
    INVALID_SILO_DETACH = 459,
    EXRESOURCE_TIMEOUT_LIVEDUMP = 460,
    INVALID_CALLBACK_STACK_ADDRESS = 461,
    INVALID_KERNEL_STACK_ADDRESS = 462,
    HARDWARE_WATCHDOG_TIMEOUT = 463,
    ACPI_FIRMWARE_WATCHDOG_TIMEOUT = 464,
    TELEMETRY_ASSERTS_LIVEDUMP = 465,
    WORKER_THREAD_INVALID_STATE = 466,
    WFP_INVALID_OPERATION = 467,
    UCMUCSI_LIVEDUMP = 468,
    DRIVER_PNP_WATCHDOG = 469,
    WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS = 470,
    EFS_FATAL_ERROR = 471,
    UCMUCSI_FAILURE = 472,
    HAL_IOMMU_INTERNAL_ERROR = 473,
    HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR = 474,
    IPI_WATCHDOG_TIMEOUT = 475,
    DMA_COMMON_BUFFER_VECTOR_ERROR = 476,
    BUGCODE_MBBADAPTER_DRIVER = 477,
    BUGCODE_WIFIADAPTER_DRIVER = 478,
    PROCESSOR_START_TIMEOUT = 479,
    INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION = 480,
    DEVICE_DIAGNOSTIC_LOG_LIVEDUMP = 481,
    AZURE_DEVICE_FW_DUMP = 482,
    BREAKAWAY_CABLE_TRANSITION = 483,
    VIDEO_DXGKRNL_SYSMM_FATAL_ERROR = 484,
    DRIVER_VERIFIER_TRACKING_LIVE_DUMP = 485,
    CRASHDUMP_WATCHDOG_TIMEOUT = 486,
    REGISTRY_LIVE_DUMP = 487,
    INVALID_THREAD_AFFINITY_STATE = 488,
    ILLEGAL_ATS_INITIALIZATION = 489,
    SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION = 490,
    DAM_WATCHDOG_TIMEOUT = 491,
    HANDLE_LIVE_DUMP = 492,
    HANDLE_ERROR_ON_CRITICAL_THREAD = 493,
    MPSDRV_QUERY_USER = 1073742318,
    VMBUS_LIVEDUMP = 1073742319,
    USB4_HARDWARE_VIOLATION = 496,
    KASAN_ENLIGHTENMENT_VIOLATION = 497,
    KASAN_ILLEGAL_ACCESS = 498,
    IORING = 499,
    MDL_CACHE = 500,
    MISALIGNED_POINTER_PARAMETER = 502,
    XBOX_VMCTRL_CS_TIMEOUT = 854,
    XBOX_CORRUPTED_IMAGE = 855,
    XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW = 856,
    XBOX_CORRUPTED_IMAGE_BASE = 857,
    XBOX_XDS_WATCHDOG_TIMEOUT = 858,
    XBOX_SHUTDOWN_WATCHDOG_TIMEOUT = 859,
    XBOX_360_SYSTEM_CRASH = 864,
    XBOX_360_SYSTEM_CRASH_RESERVED = 1056,
    XBOX_SECURITY_FAILUE = 1057,
    KERNEL_CFG_INIT_FAILURE = 1058,
    MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP = 4552,
    HYPERVISOR_ERROR = 131073,
    XBOX_MANUALLY_INITIATED_CRASH = 196614,
    MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP = 8648,
    WINLOGON_FATAL_ERROR = 3221226010,
    MANUALLY_INITIATED_CRASH1 = 3735936685,
    BUGCHECK_CONTEXT_MODIFIER = 2147483648,
};
pub const HARDWARE_PROFILE_UNDOCKED_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_UNDOCKED_STRING;
pub const HARDWARE_PROFILE_DOCKED_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_DOCKED_STRING;
pub const HARDWARE_PROFILE_UNKNOWN_STRING = BUGCHECK_ERROR.HARDWARE_PROFILE_UNKNOWN_STRING;
pub const WINDOWS_NT_BANNER = BUGCHECK_ERROR.WINDOWS_NT_BANNER;
pub const WINDOWS_NT_CSD_STRING = BUGCHECK_ERROR.WINDOWS_NT_CSD_STRING;
pub const WINDOWS_NT_INFO_STRING = BUGCHECK_ERROR.WINDOWS_NT_INFO_STRING;
pub const WINDOWS_NT_MP_STRING = BUGCHECK_ERROR.WINDOWS_NT_MP_STRING;
pub const THREAD_TERMINATE_HELD_MUTEX = BUGCHECK_ERROR.THREAD_TERMINATE_HELD_MUTEX;
pub const WINDOWS_NT_INFO_STRING_PLURAL = BUGCHECK_ERROR.WINDOWS_NT_INFO_STRING_PLURAL;
pub const WINDOWS_NT_RC_STRING = BUGCHECK_ERROR.WINDOWS_NT_RC_STRING;
pub const APC_INDEX_MISMATCH = BUGCHECK_ERROR.APC_INDEX_MISMATCH;
pub const DEVICE_QUEUE_NOT_BUSY = BUGCHECK_ERROR.DEVICE_QUEUE_NOT_BUSY;
pub const INVALID_AFFINITY_SET = BUGCHECK_ERROR.INVALID_AFFINITY_SET;
pub const INVALID_DATA_ACCESS_TRAP = BUGCHECK_ERROR.INVALID_DATA_ACCESS_TRAP;
pub const INVALID_PROCESS_ATTACH_ATTEMPT = BUGCHECK_ERROR.INVALID_PROCESS_ATTACH_ATTEMPT;
pub const INVALID_PROCESS_DETACH_ATTEMPT = BUGCHECK_ERROR.INVALID_PROCESS_DETACH_ATTEMPT;
pub const INVALID_SOFTWARE_INTERRUPT = BUGCHECK_ERROR.INVALID_SOFTWARE_INTERRUPT;
pub const IRQL_NOT_DISPATCH_LEVEL = BUGCHECK_ERROR.IRQL_NOT_DISPATCH_LEVEL;
pub const IRQL_NOT_GREATER_OR_EQUAL = BUGCHECK_ERROR.IRQL_NOT_GREATER_OR_EQUAL;
pub const IRQL_NOT_LESS_OR_EQUAL = BUGCHECK_ERROR.IRQL_NOT_LESS_OR_EQUAL;
pub const NO_EXCEPTION_HANDLING_SUPPORT = BUGCHECK_ERROR.NO_EXCEPTION_HANDLING_SUPPORT;
pub const MAXIMUM_WAIT_OBJECTS_EXCEEDED = BUGCHECK_ERROR.MAXIMUM_WAIT_OBJECTS_EXCEEDED;
pub const MUTEX_LEVEL_NUMBER_VIOLATION = BUGCHECK_ERROR.MUTEX_LEVEL_NUMBER_VIOLATION;
pub const NO_USER_MODE_CONTEXT = BUGCHECK_ERROR.NO_USER_MODE_CONTEXT;
pub const SPIN_LOCK_ALREADY_OWNED = BUGCHECK_ERROR.SPIN_LOCK_ALREADY_OWNED;
pub const SPIN_LOCK_NOT_OWNED = BUGCHECK_ERROR.SPIN_LOCK_NOT_OWNED;
pub const THREAD_NOT_MUTEX_OWNER = BUGCHECK_ERROR.THREAD_NOT_MUTEX_OWNER;
pub const TRAP_CAUSE_UNKNOWN = BUGCHECK_ERROR.TRAP_CAUSE_UNKNOWN;
pub const EMPTY_THREAD_REAPER_LIST = BUGCHECK_ERROR.EMPTY_THREAD_REAPER_LIST;
pub const CREATE_DELETE_LOCK_NOT_LOCKED = BUGCHECK_ERROR.CREATE_DELETE_LOCK_NOT_LOCKED;
pub const LAST_CHANCE_CALLED_FROM_KMODE = BUGCHECK_ERROR.LAST_CHANCE_CALLED_FROM_KMODE;
pub const CID_HANDLE_CREATION = BUGCHECK_ERROR.CID_HANDLE_CREATION;
pub const CID_HANDLE_DELETION = BUGCHECK_ERROR.CID_HANDLE_DELETION;
pub const REFERENCE_BY_POINTER = BUGCHECK_ERROR.REFERENCE_BY_POINTER;
pub const BAD_POOL_HEADER = BUGCHECK_ERROR.BAD_POOL_HEADER;
pub const MEMORY_MANAGEMENT = BUGCHECK_ERROR.MEMORY_MANAGEMENT;
pub const PFN_SHARE_COUNT = BUGCHECK_ERROR.PFN_SHARE_COUNT;
pub const PFN_REFERENCE_COUNT = BUGCHECK_ERROR.PFN_REFERENCE_COUNT;
pub const NO_SPIN_LOCK_AVAILABLE = BUGCHECK_ERROR.NO_SPIN_LOCK_AVAILABLE;
pub const KMODE_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.KMODE_EXCEPTION_NOT_HANDLED;
pub const SHARED_RESOURCE_CONV_ERROR = BUGCHECK_ERROR.SHARED_RESOURCE_CONV_ERROR;
pub const KERNEL_APC_PENDING_DURING_EXIT = BUGCHECK_ERROR.KERNEL_APC_PENDING_DURING_EXIT;
pub const QUOTA_UNDERFLOW = BUGCHECK_ERROR.QUOTA_UNDERFLOW;
pub const FILE_SYSTEM = BUGCHECK_ERROR.FILE_SYSTEM;
pub const FAT_FILE_SYSTEM = BUGCHECK_ERROR.FAT_FILE_SYSTEM;
pub const NTFS_FILE_SYSTEM = BUGCHECK_ERROR.NTFS_FILE_SYSTEM;
pub const NPFS_FILE_SYSTEM = BUGCHECK_ERROR.NPFS_FILE_SYSTEM;
pub const CDFS_FILE_SYSTEM = BUGCHECK_ERROR.CDFS_FILE_SYSTEM;
pub const RDR_FILE_SYSTEM = BUGCHECK_ERROR.RDR_FILE_SYSTEM;
pub const CORRUPT_ACCESS_TOKEN = BUGCHECK_ERROR.CORRUPT_ACCESS_TOKEN;
pub const SECURITY_SYSTEM = BUGCHECK_ERROR.SECURITY_SYSTEM;
pub const INCONSISTENT_IRP = BUGCHECK_ERROR.INCONSISTENT_IRP;
pub const PANIC_STACK_SWITCH = BUGCHECK_ERROR.PANIC_STACK_SWITCH;
pub const PORT_DRIVER_INTERNAL = BUGCHECK_ERROR.PORT_DRIVER_INTERNAL;
pub const SCSI_DISK_DRIVER_INTERNAL = BUGCHECK_ERROR.SCSI_DISK_DRIVER_INTERNAL;
pub const DATA_BUS_ERROR = BUGCHECK_ERROR.DATA_BUS_ERROR;
pub const INSTRUCTION_BUS_ERROR = BUGCHECK_ERROR.INSTRUCTION_BUS_ERROR;
pub const SET_OF_INVALID_CONTEXT = BUGCHECK_ERROR.SET_OF_INVALID_CONTEXT;
pub const PHASE0_INITIALIZATION_FAILED = BUGCHECK_ERROR.PHASE0_INITIALIZATION_FAILED;
pub const PHASE1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PHASE1_INITIALIZATION_FAILED;
pub const UNEXPECTED_INITIALIZATION_CALL = BUGCHECK_ERROR.UNEXPECTED_INITIALIZATION_CALL;
pub const CACHE_MANAGER = BUGCHECK_ERROR.CACHE_MANAGER;
pub const NO_MORE_IRP_STACK_LOCATIONS = BUGCHECK_ERROR.NO_MORE_IRP_STACK_LOCATIONS;
pub const DEVICE_REFERENCE_COUNT_NOT_ZERO = BUGCHECK_ERROR.DEVICE_REFERENCE_COUNT_NOT_ZERO;
pub const FLOPPY_INTERNAL_ERROR = BUGCHECK_ERROR.FLOPPY_INTERNAL_ERROR;
pub const SERIAL_DRIVER_INTERNAL = BUGCHECK_ERROR.SERIAL_DRIVER_INTERNAL;
pub const SYSTEM_EXIT_OWNED_MUTEX = BUGCHECK_ERROR.SYSTEM_EXIT_OWNED_MUTEX;
pub const SYSTEM_UNWIND_PREVIOUS_USER = BUGCHECK_ERROR.SYSTEM_UNWIND_PREVIOUS_USER;
pub const SYSTEM_SERVICE_EXCEPTION = BUGCHECK_ERROR.SYSTEM_SERVICE_EXCEPTION;
pub const INTERRUPT_UNWIND_ATTEMPTED = BUGCHECK_ERROR.INTERRUPT_UNWIND_ATTEMPTED;
pub const INTERRUPT_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.INTERRUPT_EXCEPTION_NOT_HANDLED;
pub const MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED = BUGCHECK_ERROR.MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED;
pub const NO_MORE_SYSTEM_PTES = BUGCHECK_ERROR.NO_MORE_SYSTEM_PTES;
pub const TARGET_MDL_TOO_SMALL = BUGCHECK_ERROR.TARGET_MDL_TOO_SMALL;
pub const MUST_SUCCEED_POOL_EMPTY = BUGCHECK_ERROR.MUST_SUCCEED_POOL_EMPTY;
pub const ATDISK_DRIVER_INTERNAL = BUGCHECK_ERROR.ATDISK_DRIVER_INTERNAL;
pub const NO_SUCH_PARTITION = BUGCHECK_ERROR.NO_SUCH_PARTITION;
pub const MULTIPLE_IRP_COMPLETE_REQUESTS = BUGCHECK_ERROR.MULTIPLE_IRP_COMPLETE_REQUESTS;
pub const INSUFFICIENT_SYSTEM_MAP_REGS = BUGCHECK_ERROR.INSUFFICIENT_SYSTEM_MAP_REGS;
pub const DEREF_UNKNOWN_LOGON_SESSION = BUGCHECK_ERROR.DEREF_UNKNOWN_LOGON_SESSION;
pub const REF_UNKNOWN_LOGON_SESSION = BUGCHECK_ERROR.REF_UNKNOWN_LOGON_SESSION;
pub const CANCEL_STATE_IN_COMPLETED_IRP = BUGCHECK_ERROR.CANCEL_STATE_IN_COMPLETED_IRP;
pub const PAGE_FAULT_WITH_INTERRUPTS_OFF = BUGCHECK_ERROR.PAGE_FAULT_WITH_INTERRUPTS_OFF;
pub const IRQL_GT_ZERO_AT_SYSTEM_SERVICE = BUGCHECK_ERROR.IRQL_GT_ZERO_AT_SYSTEM_SERVICE;
pub const STREAMS_INTERNAL_ERROR = BUGCHECK_ERROR.STREAMS_INTERNAL_ERROR;
pub const FATAL_UNHANDLED_HARD_ERROR = BUGCHECK_ERROR.FATAL_UNHANDLED_HARD_ERROR;
pub const NO_PAGES_AVAILABLE = BUGCHECK_ERROR.NO_PAGES_AVAILABLE;
pub const PFN_LIST_CORRUPT = BUGCHECK_ERROR.PFN_LIST_CORRUPT;
pub const NDIS_INTERNAL_ERROR = BUGCHECK_ERROR.NDIS_INTERNAL_ERROR;
pub const PAGE_FAULT_IN_NONPAGED_AREA = BUGCHECK_ERROR.PAGE_FAULT_IN_NONPAGED_AREA;
pub const PAGE_FAULT_IN_NONPAGED_AREA_M = BUGCHECK_ERROR.PAGE_FAULT_IN_NONPAGED_AREA_M;
pub const REGISTRY_ERROR = BUGCHECK_ERROR.REGISTRY_ERROR;
pub const MAILSLOT_FILE_SYSTEM = BUGCHECK_ERROR.MAILSLOT_FILE_SYSTEM;
pub const NO_BOOT_DEVICE = BUGCHECK_ERROR.NO_BOOT_DEVICE;
pub const LM_SERVER_INTERNAL_ERROR = BUGCHECK_ERROR.LM_SERVER_INTERNAL_ERROR;
pub const DATA_COHERENCY_EXCEPTION = BUGCHECK_ERROR.DATA_COHERENCY_EXCEPTION;
pub const INSTRUCTION_COHERENCY_EXCEPTION = BUGCHECK_ERROR.INSTRUCTION_COHERENCY_EXCEPTION;
pub const XNS_INTERNAL_ERROR = BUGCHECK_ERROR.XNS_INTERNAL_ERROR;
pub const VOLMGRX_INTERNAL_ERROR = BUGCHECK_ERROR.VOLMGRX_INTERNAL_ERROR;
pub const PINBALL_FILE_SYSTEM = BUGCHECK_ERROR.PINBALL_FILE_SYSTEM;
pub const CRITICAL_SERVICE_FAILED = BUGCHECK_ERROR.CRITICAL_SERVICE_FAILED;
pub const SET_ENV_VAR_FAILED = BUGCHECK_ERROR.SET_ENV_VAR_FAILED;
pub const HAL_INITIALIZATION_FAILED = BUGCHECK_ERROR.HAL_INITIALIZATION_FAILED;
pub const UNSUPPORTED_PROCESSOR = BUGCHECK_ERROR.UNSUPPORTED_PROCESSOR;
pub const OBJECT_INITIALIZATION_FAILED = BUGCHECK_ERROR.OBJECT_INITIALIZATION_FAILED;
pub const SECURITY_INITIALIZATION_FAILED = BUGCHECK_ERROR.SECURITY_INITIALIZATION_FAILED;
pub const PROCESS_INITIALIZATION_FAILED = BUGCHECK_ERROR.PROCESS_INITIALIZATION_FAILED;
pub const HAL1_INITIALIZATION_FAILED = BUGCHECK_ERROR.HAL1_INITIALIZATION_FAILED;
pub const OBJECT1_INITIALIZATION_FAILED = BUGCHECK_ERROR.OBJECT1_INITIALIZATION_FAILED;
pub const SECURITY1_INITIALIZATION_FAILED = BUGCHECK_ERROR.SECURITY1_INITIALIZATION_FAILED;
pub const SYMBOLIC_INITIALIZATION_FAILED = BUGCHECK_ERROR.SYMBOLIC_INITIALIZATION_FAILED;
pub const MEMORY1_INITIALIZATION_FAILED = BUGCHECK_ERROR.MEMORY1_INITIALIZATION_FAILED;
pub const CACHE_INITIALIZATION_FAILED = BUGCHECK_ERROR.CACHE_INITIALIZATION_FAILED;
pub const CONFIG_INITIALIZATION_FAILED = BUGCHECK_ERROR.CONFIG_INITIALIZATION_FAILED;
pub const FILE_INITIALIZATION_FAILED = BUGCHECK_ERROR.FILE_INITIALIZATION_FAILED;
pub const IO1_INITIALIZATION_FAILED = BUGCHECK_ERROR.IO1_INITIALIZATION_FAILED;
pub const LPC_INITIALIZATION_FAILED = BUGCHECK_ERROR.LPC_INITIALIZATION_FAILED;
pub const PROCESS1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PROCESS1_INITIALIZATION_FAILED;
pub const REFMON_INITIALIZATION_FAILED = BUGCHECK_ERROR.REFMON_INITIALIZATION_FAILED;
pub const SESSION1_INITIALIZATION_FAILED = BUGCHECK_ERROR.SESSION1_INITIALIZATION_FAILED;
pub const BOOTPROC_INITIALIZATION_FAILED = BUGCHECK_ERROR.BOOTPROC_INITIALIZATION_FAILED;
pub const VSL_INITIALIZATION_FAILED = BUGCHECK_ERROR.VSL_INITIALIZATION_FAILED;
pub const SOFT_RESTART_FATAL_ERROR = BUGCHECK_ERROR.SOFT_RESTART_FATAL_ERROR;
pub const ASSIGN_DRIVE_LETTERS_FAILED = BUGCHECK_ERROR.ASSIGN_DRIVE_LETTERS_FAILED;
pub const CONFIG_LIST_FAILED = BUGCHECK_ERROR.CONFIG_LIST_FAILED;
pub const BAD_SYSTEM_CONFIG_INFO = BUGCHECK_ERROR.BAD_SYSTEM_CONFIG_INFO;
pub const CANNOT_WRITE_CONFIGURATION = BUGCHECK_ERROR.CANNOT_WRITE_CONFIGURATION;
pub const PROCESS_HAS_LOCKED_PAGES = BUGCHECK_ERROR.PROCESS_HAS_LOCKED_PAGES;
pub const KERNEL_STACK_INPAGE_ERROR = BUGCHECK_ERROR.KERNEL_STACK_INPAGE_ERROR;
pub const PHASE0_EXCEPTION = BUGCHECK_ERROR.PHASE0_EXCEPTION;
pub const MISMATCHED_HAL = BUGCHECK_ERROR.MISMATCHED_HAL;
pub const KERNEL_DATA_INPAGE_ERROR = BUGCHECK_ERROR.KERNEL_DATA_INPAGE_ERROR;
pub const INACCESSIBLE_BOOT_DEVICE = BUGCHECK_ERROR.INACCESSIBLE_BOOT_DEVICE;
pub const BUGCODE_NDIS_DRIVER = BUGCHECK_ERROR.BUGCODE_NDIS_DRIVER;
pub const INSTALL_MORE_MEMORY = BUGCHECK_ERROR.INSTALL_MORE_MEMORY;
pub const SYSTEM_THREAD_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.SYSTEM_THREAD_EXCEPTION_NOT_HANDLED;
pub const SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M = BUGCHECK_ERROR.SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M;
pub const UNEXPECTED_KERNEL_MODE_TRAP = BUGCHECK_ERROR.UNEXPECTED_KERNEL_MODE_TRAP;
pub const UNEXPECTED_KERNEL_MODE_TRAP_M = BUGCHECK_ERROR.UNEXPECTED_KERNEL_MODE_TRAP_M;
pub const NMI_HARDWARE_FAILURE = BUGCHECK_ERROR.NMI_HARDWARE_FAILURE;
pub const SPIN_LOCK_INIT_FAILURE = BUGCHECK_ERROR.SPIN_LOCK_INIT_FAILURE;
pub const DFS_FILE_SYSTEM = BUGCHECK_ERROR.DFS_FILE_SYSTEM;
pub const OFS_FILE_SYSTEM = BUGCHECK_ERROR.OFS_FILE_SYSTEM;
pub const RECOM_DRIVER = BUGCHECK_ERROR.RECOM_DRIVER;
pub const SETUP_FAILURE = BUGCHECK_ERROR.SETUP_FAILURE;
pub const AUDIT_FAILURE = BUGCHECK_ERROR.AUDIT_FAILURE;
pub const MBR_CHECKSUM_MISMATCH = BUGCHECK_ERROR.MBR_CHECKSUM_MISMATCH;
pub const KERNEL_MODE_EXCEPTION_NOT_HANDLED = BUGCHECK_ERROR.KERNEL_MODE_EXCEPTION_NOT_HANDLED;
pub const KERNEL_MODE_EXCEPTION_NOT_HANDLED_M = BUGCHECK_ERROR.KERNEL_MODE_EXCEPTION_NOT_HANDLED_M;
pub const PP0_INITIALIZATION_FAILED = BUGCHECK_ERROR.PP0_INITIALIZATION_FAILED;
pub const PP1_INITIALIZATION_FAILED = BUGCHECK_ERROR.PP1_INITIALIZATION_FAILED;
pub const WIN32K_INIT_OR_RIT_FAILURE = BUGCHECK_ERROR.WIN32K_INIT_OR_RIT_FAILURE;
pub const UP_DRIVER_ON_MP_SYSTEM = BUGCHECK_ERROR.UP_DRIVER_ON_MP_SYSTEM;
pub const INVALID_KERNEL_HANDLE = BUGCHECK_ERROR.INVALID_KERNEL_HANDLE;
pub const KERNEL_STACK_LOCKED_AT_EXIT = BUGCHECK_ERROR.KERNEL_STACK_LOCKED_AT_EXIT;
pub const PNP_INTERNAL_ERROR = BUGCHECK_ERROR.PNP_INTERNAL_ERROR;
pub const INVALID_WORK_QUEUE_ITEM = BUGCHECK_ERROR.INVALID_WORK_QUEUE_ITEM;
pub const BOUND_IMAGE_UNSUPPORTED = BUGCHECK_ERROR.BOUND_IMAGE_UNSUPPORTED;
pub const END_OF_NT_EVALUATION_PERIOD = BUGCHECK_ERROR.END_OF_NT_EVALUATION_PERIOD;
pub const INVALID_REGION_OR_SEGMENT = BUGCHECK_ERROR.INVALID_REGION_OR_SEGMENT;
pub const SYSTEM_LICENSE_VIOLATION = BUGCHECK_ERROR.SYSTEM_LICENSE_VIOLATION;
pub const UDFS_FILE_SYSTEM = BUGCHECK_ERROR.UDFS_FILE_SYSTEM;
pub const MACHINE_CHECK_EXCEPTION = BUGCHECK_ERROR.MACHINE_CHECK_EXCEPTION;
pub const USER_MODE_HEALTH_MONITOR = BUGCHECK_ERROR.USER_MODE_HEALTH_MONITOR;
pub const DRIVER_POWER_STATE_FAILURE = BUGCHECK_ERROR.DRIVER_POWER_STATE_FAILURE;
pub const INTERNAL_POWER_ERROR = BUGCHECK_ERROR.INTERNAL_POWER_ERROR;
pub const PCI_BUS_DRIVER_INTERNAL = BUGCHECK_ERROR.PCI_BUS_DRIVER_INTERNAL;
pub const MEMORY_IMAGE_CORRUPT = BUGCHECK_ERROR.MEMORY_IMAGE_CORRUPT;
pub const ACPI_DRIVER_INTERNAL = BUGCHECK_ERROR.ACPI_DRIVER_INTERNAL;
pub const CNSS_FILE_SYSTEM_FILTER = BUGCHECK_ERROR.CNSS_FILE_SYSTEM_FILTER;
pub const ACPI_BIOS_ERROR = BUGCHECK_ERROR.ACPI_BIOS_ERROR;
pub const FP_EMULATION_ERROR = BUGCHECK_ERROR.FP_EMULATION_ERROR;
pub const BAD_EXHANDLE = BUGCHECK_ERROR.BAD_EXHANDLE;
pub const BOOTING_IN_SAFEMODE_MINIMAL = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_MINIMAL;
pub const BOOTING_IN_SAFEMODE_NETWORK = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_NETWORK;
pub const BOOTING_IN_SAFEMODE_DSREPAIR = BUGCHECK_ERROR.BOOTING_IN_SAFEMODE_DSREPAIR;
pub const SESSION_HAS_VALID_POOL_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_POOL_ON_EXIT;
pub const HAL_MEMORY_ALLOCATION = BUGCHECK_ERROR.HAL_MEMORY_ALLOCATION;
pub const VIDEO_DRIVER_DEBUG_REPORT_REQUEST = BUGCHECK_ERROR.VIDEO_DRIVER_DEBUG_REPORT_REQUEST;
pub const BGI_DETECTED_VIOLATION = BUGCHECK_ERROR.BGI_DETECTED_VIOLATION;
pub const VIDEO_DRIVER_INIT_FAILURE = BUGCHECK_ERROR.VIDEO_DRIVER_INIT_FAILURE;
pub const BOOTLOG_LOADED = BUGCHECK_ERROR.BOOTLOG_LOADED;
pub const BOOTLOG_NOT_LOADED = BUGCHECK_ERROR.BOOTLOG_NOT_LOADED;
pub const BOOTLOG_ENABLED = BUGCHECK_ERROR.BOOTLOG_ENABLED;
pub const ATTEMPTED_SWITCH_FROM_DPC = BUGCHECK_ERROR.ATTEMPTED_SWITCH_FROM_DPC;
pub const CHIPSET_DETECTED_ERROR = BUGCHECK_ERROR.CHIPSET_DETECTED_ERROR;
pub const SESSION_HAS_VALID_VIEWS_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_VIEWS_ON_EXIT;
pub const NETWORK_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.NETWORK_BOOT_INITIALIZATION_FAILED;
pub const NETWORK_BOOT_DUPLICATE_ADDRESS = BUGCHECK_ERROR.NETWORK_BOOT_DUPLICATE_ADDRESS;
pub const INVALID_HIBERNATED_STATE = BUGCHECK_ERROR.INVALID_HIBERNATED_STATE;
pub const ATTEMPTED_WRITE_TO_READONLY_MEMORY = BUGCHECK_ERROR.ATTEMPTED_WRITE_TO_READONLY_MEMORY;
pub const MUTEX_ALREADY_OWNED = BUGCHECK_ERROR.MUTEX_ALREADY_OWNED;
pub const PCI_CONFIG_SPACE_ACCESS_FAILURE = BUGCHECK_ERROR.PCI_CONFIG_SPACE_ACCESS_FAILURE;
pub const SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION = BUGCHECK_ERROR.SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION;
pub const BAD_POOL_CALLER = BUGCHECK_ERROR.BAD_POOL_CALLER;
pub const SYSTEM_IMAGE_BAD_SIGNATURE = BUGCHECK_ERROR.SYSTEM_IMAGE_BAD_SIGNATURE;
pub const DRIVER_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_DETECTED_VIOLATION;
pub const DRIVER_CORRUPTED_EXPOOL = BUGCHECK_ERROR.DRIVER_CORRUPTED_EXPOOL;
pub const DRIVER_CAUGHT_MODIFYING_FREED_POOL = BUGCHECK_ERROR.DRIVER_CAUGHT_MODIFYING_FREED_POOL;
pub const TIMER_OR_DPC_INVALID = BUGCHECK_ERROR.TIMER_OR_DPC_INVALID;
pub const IRQL_UNEXPECTED_VALUE = BUGCHECK_ERROR.IRQL_UNEXPECTED_VALUE;
pub const DRIVER_VERIFIER_IOMANAGER_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_IOMANAGER_VIOLATION;
pub const PNP_DETECTED_FATAL_ERROR = BUGCHECK_ERROR.PNP_DETECTED_FATAL_ERROR;
pub const DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS = BUGCHECK_ERROR.DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS;
pub const PAGE_FAULT_IN_FREED_SPECIAL_POOL = BUGCHECK_ERROR.PAGE_FAULT_IN_FREED_SPECIAL_POOL;
pub const PAGE_FAULT_BEYOND_END_OF_ALLOCATION = BUGCHECK_ERROR.PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
pub const DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS = BUGCHECK_ERROR.DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS;
pub const TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE = BUGCHECK_ERROR.TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE;
pub const DRIVER_CORRUPTED_MMPOOL = BUGCHECK_ERROR.DRIVER_CORRUPTED_MMPOOL;
pub const DRIVER_IRQL_NOT_LESS_OR_EQUAL = BUGCHECK_ERROR.DRIVER_IRQL_NOT_LESS_OR_EQUAL;
pub const BUGCODE_ID_DRIVER = BUGCHECK_ERROR.BUGCODE_ID_DRIVER;
pub const DRIVER_PORTION_MUST_BE_NONPAGED = BUGCHECK_ERROR.DRIVER_PORTION_MUST_BE_NONPAGED;
pub const SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD = BUGCHECK_ERROR.SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD;
pub const DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL;
pub const DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
pub const DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M = BUGCHECK_ERROR.DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M;
pub const DRIVER_UNMAPPING_INVALID_VIEW = BUGCHECK_ERROR.DRIVER_UNMAPPING_INVALID_VIEW;
pub const DRIVER_USED_EXCESSIVE_PTES = BUGCHECK_ERROR.DRIVER_USED_EXCESSIVE_PTES;
pub const LOCKED_PAGES_TRACKER_CORRUPTION = BUGCHECK_ERROR.LOCKED_PAGES_TRACKER_CORRUPTION;
pub const SYSTEM_PTE_MISUSE = BUGCHECK_ERROR.SYSTEM_PTE_MISUSE;
pub const DRIVER_CORRUPTED_SYSPTES = BUGCHECK_ERROR.DRIVER_CORRUPTED_SYSPTES;
pub const DRIVER_INVALID_STACK_ACCESS = BUGCHECK_ERROR.DRIVER_INVALID_STACK_ACCESS;
pub const POOL_CORRUPTION_IN_FILE_AREA = BUGCHECK_ERROR.POOL_CORRUPTION_IN_FILE_AREA;
pub const IMPERSONATING_WORKER_THREAD = BUGCHECK_ERROR.IMPERSONATING_WORKER_THREAD;
pub const ACPI_BIOS_FATAL_ERROR = BUGCHECK_ERROR.ACPI_BIOS_FATAL_ERROR;
pub const WORKER_THREAD_RETURNED_AT_BAD_IRQL = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_AT_BAD_IRQL;
pub const MANUALLY_INITIATED_CRASH = BUGCHECK_ERROR.MANUALLY_INITIATED_CRASH;
pub const RESOURCE_NOT_OWNED = BUGCHECK_ERROR.RESOURCE_NOT_OWNED;
pub const WORKER_INVALID = BUGCHECK_ERROR.WORKER_INVALID;
pub const POWER_FAILURE_SIMULATE = BUGCHECK_ERROR.POWER_FAILURE_SIMULATE;
pub const DRIVER_VERIFIER_DMA_VIOLATION = BUGCHECK_ERROR.DRIVER_VERIFIER_DMA_VIOLATION;
pub const INVALID_FLOATING_POINT_STATE = BUGCHECK_ERROR.INVALID_FLOATING_POINT_STATE;
pub const INVALID_CANCEL_OF_FILE_OPEN = BUGCHECK_ERROR.INVALID_CANCEL_OF_FILE_OPEN;
pub const ACTIVE_EX_WORKER_THREAD_TERMINATION = BUGCHECK_ERROR.ACTIVE_EX_WORKER_THREAD_TERMINATION;
pub const SAVER_UNSPECIFIED = BUGCHECK_ERROR.SAVER_UNSPECIFIED;
pub const SAVER_BLANKSCREEN = BUGCHECK_ERROR.SAVER_BLANKSCREEN;
pub const SAVER_INPUT = BUGCHECK_ERROR.SAVER_INPUT;
pub const SAVER_WATCHDOG = BUGCHECK_ERROR.SAVER_WATCHDOG;
pub const SAVER_STARTNOTVISIBLE = BUGCHECK_ERROR.SAVER_STARTNOTVISIBLE;
pub const SAVER_NAVIGATIONMODEL = BUGCHECK_ERROR.SAVER_NAVIGATIONMODEL;
pub const SAVER_OUTOFMEMORY = BUGCHECK_ERROR.SAVER_OUTOFMEMORY;
pub const SAVER_GRAPHICS = BUGCHECK_ERROR.SAVER_GRAPHICS;
pub const SAVER_NAVSERVERTIMEOUT = BUGCHECK_ERROR.SAVER_NAVSERVERTIMEOUT;
pub const SAVER_CHROMEPROCESSCRASH = BUGCHECK_ERROR.SAVER_CHROMEPROCESSCRASH;
pub const SAVER_NOTIFICATIONDISMISSAL = BUGCHECK_ERROR.SAVER_NOTIFICATIONDISMISSAL;
pub const SAVER_SPEECHDISMISSAL = BUGCHECK_ERROR.SAVER_SPEECHDISMISSAL;
pub const SAVER_CALLDISMISSAL = BUGCHECK_ERROR.SAVER_CALLDISMISSAL;
pub const SAVER_APPBARDISMISSAL = BUGCHECK_ERROR.SAVER_APPBARDISMISSAL;
pub const SAVER_RILADAPTATIONCRASH = BUGCHECK_ERROR.SAVER_RILADAPTATIONCRASH;
pub const SAVER_APPLISTUNREACHABLE = BUGCHECK_ERROR.SAVER_APPLISTUNREACHABLE;
pub const SAVER_REPORTNOTIFICATIONFAILURE = BUGCHECK_ERROR.SAVER_REPORTNOTIFICATIONFAILURE;
pub const SAVER_UNEXPECTEDSHUTDOWN = BUGCHECK_ERROR.SAVER_UNEXPECTEDSHUTDOWN;
pub const SAVER_RPCFAILURE = BUGCHECK_ERROR.SAVER_RPCFAILURE;
pub const SAVER_AUXILIARYFULLDUMP = BUGCHECK_ERROR.SAVER_AUXILIARYFULLDUMP;
pub const SAVER_ACCOUNTPROVSVCINITFAILURE = BUGCHECK_ERROR.SAVER_ACCOUNTPROVSVCINITFAILURE;
pub const SAVER_MTBFCOMMANDTIMEOUT = BUGCHECK_ERROR.SAVER_MTBFCOMMANDTIMEOUT;
pub const SAVER_MTBFCOMMANDHANG = BUGCHECK_ERROR.SAVER_MTBFCOMMANDHANG;
pub const SAVER_MTBFPASSBUGCHECK = BUGCHECK_ERROR.SAVER_MTBFPASSBUGCHECK;
pub const SAVER_MTBFIOERROR = BUGCHECK_ERROR.SAVER_MTBFIOERROR;
pub const SAVER_RENDERTHREADHANG = BUGCHECK_ERROR.SAVER_RENDERTHREADHANG;
pub const SAVER_RENDERMOBILEUIOOM = BUGCHECK_ERROR.SAVER_RENDERMOBILEUIOOM;
pub const SAVER_DEVICEUPDATEUNSPECIFIED = BUGCHECK_ERROR.SAVER_DEVICEUPDATEUNSPECIFIED;
pub const SAVER_AUDIODRIVERHANG = BUGCHECK_ERROR.SAVER_AUDIODRIVERHANG;
pub const SAVER_BATTERYPULLOUT = BUGCHECK_ERROR.SAVER_BATTERYPULLOUT;
pub const SAVER_MEDIACORETESTHANG = BUGCHECK_ERROR.SAVER_MEDIACORETESTHANG;
pub const SAVER_RESOURCEMANAGEMENT = BUGCHECK_ERROR.SAVER_RESOURCEMANAGEMENT;
pub const SAVER_CAPTURESERVICE = BUGCHECK_ERROR.SAVER_CAPTURESERVICE;
pub const SAVER_WAITFORSHELLREADY = BUGCHECK_ERROR.SAVER_WAITFORSHELLREADY;
pub const SAVER_NONRESPONSIVEPROCESS = BUGCHECK_ERROR.SAVER_NONRESPONSIVEPROCESS;
pub const SAVER_SICKAPPLICATION = BUGCHECK_ERROR.SAVER_SICKAPPLICATION;
pub const THREAD_STUCK_IN_DEVICE_DRIVER = BUGCHECK_ERROR.THREAD_STUCK_IN_DEVICE_DRIVER;
pub const THREAD_STUCK_IN_DEVICE_DRIVER_M = BUGCHECK_ERROR.THREAD_STUCK_IN_DEVICE_DRIVER_M;
pub const DIRTY_MAPPED_PAGES_CONGESTION = BUGCHECK_ERROR.DIRTY_MAPPED_PAGES_CONGESTION;
pub const SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT = BUGCHECK_ERROR.SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT;
pub const UNMOUNTABLE_BOOT_VOLUME = BUGCHECK_ERROR.UNMOUNTABLE_BOOT_VOLUME;
pub const CRITICAL_PROCESS_DIED = BUGCHECK_ERROR.CRITICAL_PROCESS_DIED;
pub const STORAGE_MINIPORT_ERROR = BUGCHECK_ERROR.STORAGE_MINIPORT_ERROR;
pub const SCSI_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.SCSI_VERIFIER_DETECTED_VIOLATION;
pub const HARDWARE_INTERRUPT_STORM = BUGCHECK_ERROR.HARDWARE_INTERRUPT_STORM;
pub const DISORDERLY_SHUTDOWN = BUGCHECK_ERROR.DISORDERLY_SHUTDOWN;
pub const CRITICAL_OBJECT_TERMINATION = BUGCHECK_ERROR.CRITICAL_OBJECT_TERMINATION;
pub const FLTMGR_FILE_SYSTEM = BUGCHECK_ERROR.FLTMGR_FILE_SYSTEM;
pub const PCI_VERIFIER_DETECTED_VIOLATION = BUGCHECK_ERROR.PCI_VERIFIER_DETECTED_VIOLATION;
pub const DRIVER_OVERRAN_STACK_BUFFER = BUGCHECK_ERROR.DRIVER_OVERRAN_STACK_BUFFER;
pub const RAMDISK_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.RAMDISK_BOOT_INITIALIZATION_FAILED;
pub const DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN = BUGCHECK_ERROR.DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN;
pub const HTTP_DRIVER_CORRUPTED = BUGCHECK_ERROR.HTTP_DRIVER_CORRUPTED;
pub const RECURSIVE_MACHINE_CHECK = BUGCHECK_ERROR.RECURSIVE_MACHINE_CHECK;
pub const ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY = BUGCHECK_ERROR.ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY;
pub const DIRTY_NOWRITE_PAGES_CONGESTION = BUGCHECK_ERROR.DIRTY_NOWRITE_PAGES_CONGESTION;
pub const BUGCODE_USB_DRIVER = BUGCHECK_ERROR.BUGCODE_USB_DRIVER;
pub const BC_BLUETOOTH_VERIFIER_FAULT = BUGCHECK_ERROR.BC_BLUETOOTH_VERIFIER_FAULT;
pub const BC_BTHMINI_VERIFIER_FAULT = BUGCHECK_ERROR.BC_BTHMINI_VERIFIER_FAULT;
pub const RESERVE_QUEUE_OVERFLOW = BUGCHECK_ERROR.RESERVE_QUEUE_OVERFLOW;
pub const LOADER_BLOCK_MISMATCH = BUGCHECK_ERROR.LOADER_BLOCK_MISMATCH;
pub const CLOCK_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.CLOCK_WATCHDOG_TIMEOUT;
pub const DPC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.DPC_WATCHDOG_TIMEOUT;
pub const MUP_FILE_SYSTEM = BUGCHECK_ERROR.MUP_FILE_SYSTEM;
pub const AGP_INVALID_ACCESS = BUGCHECK_ERROR.AGP_INVALID_ACCESS;
pub const AGP_GART_CORRUPTION = BUGCHECK_ERROR.AGP_GART_CORRUPTION;
pub const AGP_ILLEGALLY_REPROGRAMMED = BUGCHECK_ERROR.AGP_ILLEGALLY_REPROGRAMMED;
pub const KERNEL_EXPAND_STACK_ACTIVE = BUGCHECK_ERROR.KERNEL_EXPAND_STACK_ACTIVE;
pub const THIRD_PARTY_FILE_SYSTEM_FAILURE = BUGCHECK_ERROR.THIRD_PARTY_FILE_SYSTEM_FAILURE;
pub const CRITICAL_STRUCTURE_CORRUPTION = BUGCHECK_ERROR.CRITICAL_STRUCTURE_CORRUPTION;
pub const APP_TAGGING_INITIALIZATION_FAILED = BUGCHECK_ERROR.APP_TAGGING_INITIALIZATION_FAILED;
pub const DFSC_FILE_SYSTEM = BUGCHECK_ERROR.DFSC_FILE_SYSTEM;
pub const FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION = BUGCHECK_ERROR.FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION;
pub const WDF_VIOLATION = BUGCHECK_ERROR.WDF_VIOLATION;
pub const VIDEO_MEMORY_MANAGEMENT_INTERNAL = BUGCHECK_ERROR.VIDEO_MEMORY_MANAGEMENT_INTERNAL;
pub const DRIVER_INVALID_CRUNTIME_PARAMETER = BUGCHECK_ERROR.DRIVER_INVALID_CRUNTIME_PARAMETER;
pub const RECURSIVE_NMI = BUGCHECK_ERROR.RECURSIVE_NMI;
pub const MSRPC_STATE_VIOLATION = BUGCHECK_ERROR.MSRPC_STATE_VIOLATION;
pub const VIDEO_DXGKRNL_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_DXGKRNL_FATAL_ERROR;
pub const VIDEO_SHADOW_DRIVER_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_SHADOW_DRIVER_FATAL_ERROR;
pub const AGP_INTERNAL = BUGCHECK_ERROR.AGP_INTERNAL;
pub const VIDEO_TDR_FAILURE = BUGCHECK_ERROR.VIDEO_TDR_FAILURE;
pub const VIDEO_TDR_TIMEOUT_DETECTED = BUGCHECK_ERROR.VIDEO_TDR_TIMEOUT_DETECTED;
pub const NTHV_GUEST_ERROR = BUGCHECK_ERROR.NTHV_GUEST_ERROR;
pub const VIDEO_SCHEDULER_INTERNAL_ERROR = BUGCHECK_ERROR.VIDEO_SCHEDULER_INTERNAL_ERROR;
pub const EM_INITIALIZATION_ERROR = BUGCHECK_ERROR.EM_INITIALIZATION_ERROR;
pub const DRIVER_RETURNED_HOLDING_CANCEL_LOCK = BUGCHECK_ERROR.DRIVER_RETURNED_HOLDING_CANCEL_LOCK;
pub const ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE = BUGCHECK_ERROR.ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE;
pub const EVENT_TRACING_FATAL_ERROR = BUGCHECK_ERROR.EVENT_TRACING_FATAL_ERROR;
pub const TOO_MANY_RECURSIVE_FAULTS = BUGCHECK_ERROR.TOO_MANY_RECURSIVE_FAULTS;
pub const INVALID_DRIVER_HANDLE = BUGCHECK_ERROR.INVALID_DRIVER_HANDLE;
pub const BITLOCKER_FATAL_ERROR = BUGCHECK_ERROR.BITLOCKER_FATAL_ERROR;
pub const DRIVER_VIOLATION = BUGCHECK_ERROR.DRIVER_VIOLATION;
pub const WHEA_INTERNAL_ERROR = BUGCHECK_ERROR.WHEA_INTERNAL_ERROR;
pub const CRYPTO_SELF_TEST_FAILURE = BUGCHECK_ERROR.CRYPTO_SELF_TEST_FAILURE;
pub const WHEA_UNCORRECTABLE_ERROR = BUGCHECK_ERROR.WHEA_UNCORRECTABLE_ERROR;
pub const NMR_INVALID_STATE = BUGCHECK_ERROR.NMR_INVALID_STATE;
pub const NETIO_INVALID_POOL_CALLER = BUGCHECK_ERROR.NETIO_INVALID_POOL_CALLER;
pub const PAGE_NOT_ZERO = BUGCHECK_ERROR.PAGE_NOT_ZERO;
pub const WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY;
pub const WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY;
pub const MUI_NO_VALID_SYSTEM_LANGUAGE = BUGCHECK_ERROR.MUI_NO_VALID_SYSTEM_LANGUAGE;
pub const FAULTY_HARDWARE_CORRUPTED_PAGE = BUGCHECK_ERROR.FAULTY_HARDWARE_CORRUPTED_PAGE;
pub const EXFAT_FILE_SYSTEM = BUGCHECK_ERROR.EXFAT_FILE_SYSTEM;
pub const VOLSNAP_OVERLAPPED_TABLE_ACCESS = BUGCHECK_ERROR.VOLSNAP_OVERLAPPED_TABLE_ACCESS;
pub const INVALID_MDL_RANGE = BUGCHECK_ERROR.INVALID_MDL_RANGE;
pub const VHD_BOOT_INITIALIZATION_FAILED = BUGCHECK_ERROR.VHD_BOOT_INITIALIZATION_FAILED;
pub const DYNAMIC_ADD_PROCESSOR_MISMATCH = BUGCHECK_ERROR.DYNAMIC_ADD_PROCESSOR_MISMATCH;
pub const INVALID_EXTENDED_PROCESSOR_STATE = BUGCHECK_ERROR.INVALID_EXTENDED_PROCESSOR_STATE;
pub const RESOURCE_OWNER_POINTER_INVALID = BUGCHECK_ERROR.RESOURCE_OWNER_POINTER_INVALID;
pub const DPC_WATCHDOG_VIOLATION = BUGCHECK_ERROR.DPC_WATCHDOG_VIOLATION;
pub const DRIVE_EXTENDER = BUGCHECK_ERROR.DRIVE_EXTENDER;
pub const REGISTRY_FILTER_DRIVER_EXCEPTION = BUGCHECK_ERROR.REGISTRY_FILTER_DRIVER_EXCEPTION;
pub const VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE = BUGCHECK_ERROR.VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE;
pub const WIN32K_HANDLE_MANAGER = BUGCHECK_ERROR.WIN32K_HANDLE_MANAGER;
pub const GPIO_CONTROLLER_DRIVER_ERROR = BUGCHECK_ERROR.GPIO_CONTROLLER_DRIVER_ERROR;
pub const KERNEL_SECURITY_CHECK_FAILURE = BUGCHECK_ERROR.KERNEL_SECURITY_CHECK_FAILURE;
pub const KERNEL_MODE_HEAP_CORRUPTION = BUGCHECK_ERROR.KERNEL_MODE_HEAP_CORRUPTION;
pub const PASSIVE_INTERRUPT_ERROR = BUGCHECK_ERROR.PASSIVE_INTERRUPT_ERROR;
pub const INVALID_IO_BOOST_STATE = BUGCHECK_ERROR.INVALID_IO_BOOST_STATE;
pub const CRITICAL_INITIALIZATION_FAILURE = BUGCHECK_ERROR.CRITICAL_INITIALIZATION_FAILURE;
pub const ERRATA_WORKAROUND_UNSUCCESSFUL = BUGCHECK_ERROR.ERRATA_WORKAROUND_UNSUCCESSFUL;
pub const REGISTRY_CALLBACK_DRIVER_EXCEPTION = BUGCHECK_ERROR.REGISTRY_CALLBACK_DRIVER_EXCEPTION;
pub const STORAGE_DEVICE_ABNORMALITY_DETECTED = BUGCHECK_ERROR.STORAGE_DEVICE_ABNORMALITY_DETECTED;
pub const VIDEO_ENGINE_TIMEOUT_DETECTED = BUGCHECK_ERROR.VIDEO_ENGINE_TIMEOUT_DETECTED;
pub const VIDEO_TDR_APPLICATION_BLOCKED = BUGCHECK_ERROR.VIDEO_TDR_APPLICATION_BLOCKED;
pub const PROCESSOR_DRIVER_INTERNAL = BUGCHECK_ERROR.PROCESSOR_DRIVER_INTERNAL;
pub const BUGCODE_USB3_DRIVER = BUGCHECK_ERROR.BUGCODE_USB3_DRIVER;
pub const SECURE_BOOT_VIOLATION = BUGCHECK_ERROR.SECURE_BOOT_VIOLATION;
pub const NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED = BUGCHECK_ERROR.NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED;
pub const ABNORMAL_RESET_DETECTED = BUGCHECK_ERROR.ABNORMAL_RESET_DETECTED;
pub const IO_OBJECT_INVALID = BUGCHECK_ERROR.IO_OBJECT_INVALID;
pub const REFS_FILE_SYSTEM = BUGCHECK_ERROR.REFS_FILE_SYSTEM;
pub const KERNEL_WMI_INTERNAL = BUGCHECK_ERROR.KERNEL_WMI_INTERNAL;
pub const SOC_SUBSYSTEM_FAILURE = BUGCHECK_ERROR.SOC_SUBSYSTEM_FAILURE;
pub const FATAL_ABNORMAL_RESET_ERROR = BUGCHECK_ERROR.FATAL_ABNORMAL_RESET_ERROR;
pub const EXCEPTION_SCOPE_INVALID = BUGCHECK_ERROR.EXCEPTION_SCOPE_INVALID;
pub const SOC_CRITICAL_DEVICE_REMOVED = BUGCHECK_ERROR.SOC_CRITICAL_DEVICE_REMOVED;
pub const PDC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.PDC_WATCHDOG_TIMEOUT;
pub const TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK = BUGCHECK_ERROR.TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK;
pub const UNSUPPORTED_INSTRUCTION_MODE = BUGCHECK_ERROR.UNSUPPORTED_INSTRUCTION_MODE;
pub const INVALID_PUSH_LOCK_FLAGS = BUGCHECK_ERROR.INVALID_PUSH_LOCK_FLAGS;
pub const KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION = BUGCHECK_ERROR.KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION;
pub const UNEXPECTED_STORE_EXCEPTION = BUGCHECK_ERROR.UNEXPECTED_STORE_EXCEPTION;
pub const OS_DATA_TAMPERING = BUGCHECK_ERROR.OS_DATA_TAMPERING;
pub const WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP = BUGCHECK_ERROR.WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP;
pub const KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION = BUGCHECK_ERROR.KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION;
pub const ILLEGAL_IOMMU_PAGE_FAULT = BUGCHECK_ERROR.ILLEGAL_IOMMU_PAGE_FAULT;
pub const HAL_ILLEGAL_IOMMU_PAGE_FAULT = BUGCHECK_ERROR.HAL_ILLEGAL_IOMMU_PAGE_FAULT;
pub const SDBUS_INTERNAL_ERROR = BUGCHECK_ERROR.SDBUS_INTERNAL_ERROR;
pub const WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE;
pub const PDC_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.PDC_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const SOC_SUBSYSTEM_FAILURE_LIVEDUMP = BUGCHECK_ERROR.SOC_SUBSYSTEM_FAILURE_LIVEDUMP;
pub const BUGCODE_NDIS_DRIVER_LIVE_DUMP = BUGCHECK_ERROR.BUGCODE_NDIS_DRIVER_LIVE_DUMP;
pub const CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const WIN32K_ATOMIC_CHECK_FAILURE = BUGCHECK_ERROR.WIN32K_ATOMIC_CHECK_FAILURE;
pub const LIVE_SYSTEM_DUMP = BUGCHECK_ERROR.LIVE_SYSTEM_DUMP;
pub const KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE = BUGCHECK_ERROR.KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE;
pub const WORKER_THREAD_TEST_CONDITION = BUGCHECK_ERROR.WORKER_THREAD_TEST_CONDITION;
pub const WIN32K_CRITICAL_FAILURE = BUGCHECK_ERROR.WIN32K_CRITICAL_FAILURE;
pub const CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP;
pub const CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP;
pub const CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP;
pub const CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP;
pub const INVALID_RUNDOWN_PROTECTION_FLAGS = BUGCHECK_ERROR.INVALID_RUNDOWN_PROTECTION_FLAGS;
pub const INVALID_SLOT_ALLOCATOR_FLAGS = BUGCHECK_ERROR.INVALID_SLOT_ALLOCATOR_FLAGS;
pub const ERESOURCE_INVALID_RELEASE = BUGCHECK_ERROR.ERESOURCE_INVALID_RELEASE;
pub const CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP;
pub const CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG = BUGCHECK_ERROR.CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG;
pub const CRYPTO_LIBRARY_INTERNAL_ERROR = BUGCHECK_ERROR.CRYPTO_LIBRARY_INTERNAL_ERROR;
pub const COREMSGCALL_INTERNAL_ERROR = BUGCHECK_ERROR.COREMSGCALL_INTERNAL_ERROR;
pub const COREMSG_INTERNAL_ERROR = BUGCHECK_ERROR.COREMSG_INTERNAL_ERROR;
pub const PREVIOUS_FATAL_ABNORMAL_RESET_ERROR = BUGCHECK_ERROR.PREVIOUS_FATAL_ABNORMAL_RESET_ERROR;
pub const ELAM_DRIVER_DETECTED_FATAL_ERROR = BUGCHECK_ERROR.ELAM_DRIVER_DETECTED_FATAL_ERROR;
pub const CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP;
pub const PROFILER_CONFIGURATION_ILLEGAL = BUGCHECK_ERROR.PROFILER_CONFIGURATION_ILLEGAL;
pub const PDC_LOCK_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.PDC_LOCK_WATCHDOG_LIVEDUMP;
pub const PDC_UNEXPECTED_REVOCATION_LIVEDUMP = BUGCHECK_ERROR.PDC_UNEXPECTED_REVOCATION_LIVEDUMP;
pub const MICROCODE_REVISION_MISMATCH = BUGCHECK_ERROR.MICROCODE_REVISION_MISMATCH;
pub const HYPERGUARD_INITIALIZATION_FAILURE = BUGCHECK_ERROR.HYPERGUARD_INITIALIZATION_FAILURE;
pub const WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT;
pub const WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT;
pub const WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT;
pub const WVR_LIVEDUMP_APP_IO_TIMEOUT = BUGCHECK_ERROR.WVR_LIVEDUMP_APP_IO_TIMEOUT;
pub const WVR_LIVEDUMP_MANUALLY_INITIATED = BUGCHECK_ERROR.WVR_LIVEDUMP_MANUALLY_INITIATED;
pub const WVR_LIVEDUMP_STATE_FAILURE = BUGCHECK_ERROR.WVR_LIVEDUMP_STATE_FAILURE;
pub const WVR_LIVEDUMP_CRITICAL_ERROR = BUGCHECK_ERROR.WVR_LIVEDUMP_CRITICAL_ERROR;
pub const VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD = BUGCHECK_ERROR.VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD;
pub const CLUSTER_CSVFS_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_CSVFS_LIVEDUMP;
pub const BAD_OBJECT_HEADER = BUGCHECK_ERROR.BAD_OBJECT_HEADER;
pub const SILO_CORRUPT = BUGCHECK_ERROR.SILO_CORRUPT;
pub const SECURE_KERNEL_ERROR = BUGCHECK_ERROR.SECURE_KERNEL_ERROR;
pub const HYPERGUARD_VIOLATION = BUGCHECK_ERROR.HYPERGUARD_VIOLATION;
pub const SECURE_FAULT_UNHANDLED = BUGCHECK_ERROR.SECURE_FAULT_UNHANDLED;
pub const KERNEL_PARTITION_REFERENCE_VIOLATION = BUGCHECK_ERROR.KERNEL_PARTITION_REFERENCE_VIOLATION;
pub const SYNTHETIC_EXCEPTION_UNHANDLED = BUGCHECK_ERROR.SYNTHETIC_EXCEPTION_UNHANDLED;
pub const WIN32K_CRITICAL_FAILURE_LIVEDUMP = BUGCHECK_ERROR.WIN32K_CRITICAL_FAILURE_LIVEDUMP;
pub const PF_DETECTED_CORRUPTION = BUGCHECK_ERROR.PF_DETECTED_CORRUPTION;
pub const KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL = BUGCHECK_ERROR.KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL;
pub const VIDEO_DXGKRNL_LIVEDUMP = BUGCHECK_ERROR.VIDEO_DXGKRNL_LIVEDUMP;
pub const KERNEL_STORAGE_SLOT_IN_USE = BUGCHECK_ERROR.KERNEL_STORAGE_SLOT_IN_USE;
pub const SMB_SERVER_LIVEDUMP = BUGCHECK_ERROR.SMB_SERVER_LIVEDUMP;
pub const LOADER_ROLLBACK_DETECTED = BUGCHECK_ERROR.LOADER_ROLLBACK_DETECTED;
pub const WIN32K_SECURITY_FAILURE = BUGCHECK_ERROR.WIN32K_SECURITY_FAILURE;
pub const UFX_LIVEDUMP = BUGCHECK_ERROR.UFX_LIVEDUMP;
pub const WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO;
pub const TTM_FATAL_ERROR = BUGCHECK_ERROR.TTM_FATAL_ERROR;
pub const WIN32K_POWER_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.WIN32K_POWER_WATCHDOG_TIMEOUT;
pub const CLUSTER_SVHDX_LIVEDUMP = BUGCHECK_ERROR.CLUSTER_SVHDX_LIVEDUMP;
pub const BUGCODE_NETADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_NETADAPTER_DRIVER;
pub const PDC_PRIVILEGE_CHECK_LIVEDUMP = BUGCHECK_ERROR.PDC_PRIVILEGE_CHECK_LIVEDUMP;
pub const TTM_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.TTM_WATCHDOG_TIMEOUT;
pub const WIN32K_CALLOUT_WATCHDOG_LIVEDUMP = BUGCHECK_ERROR.WIN32K_CALLOUT_WATCHDOG_LIVEDUMP;
pub const WIN32K_CALLOUT_WATCHDOG_BUGCHECK = BUGCHECK_ERROR.WIN32K_CALLOUT_WATCHDOG_BUGCHECK;
pub const CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP;
pub const DRIPS_SW_HW_DIVERGENCE_LIVEDUMP = BUGCHECK_ERROR.DRIPS_SW_HW_DIVERGENCE_LIVEDUMP;
pub const USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP = BUGCHECK_ERROR.USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP;
pub const BLUETOOTH_ERROR_RECOVERY_LIVEDUMP = BUGCHECK_ERROR.BLUETOOTH_ERROR_RECOVERY_LIVEDUMP;
pub const SMB_REDIRECTOR_LIVEDUMP = BUGCHECK_ERROR.SMB_REDIRECTOR_LIVEDUMP;
pub const VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP = BUGCHECK_ERROR.VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP;
pub const DIRECTED_FX_TRANSITION_LIVEDUMP = BUGCHECK_ERROR.DIRECTED_FX_TRANSITION_LIVEDUMP;
pub const EXCEPTION_ON_INVALID_STACK = BUGCHECK_ERROR.EXCEPTION_ON_INVALID_STACK;
pub const UNWIND_ON_INVALID_STACK = BUGCHECK_ERROR.UNWIND_ON_INVALID_STACK;
pub const VIDEO_MINIPORT_FAILED_LIVEDUMP = BUGCHECK_ERROR.VIDEO_MINIPORT_FAILED_LIVEDUMP;
pub const VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP = BUGCHECK_ERROR.VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP;
pub const DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP = BUGCHECK_ERROR.DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP;
pub const IO_THREADPOOL_DEADLOCK_LIVEDUMP = BUGCHECK_ERROR.IO_THREADPOOL_DEADLOCK_LIVEDUMP;
pub const FAST_ERESOURCE_PRECONDITION_VIOLATION = BUGCHECK_ERROR.FAST_ERESOURCE_PRECONDITION_VIOLATION;
pub const STORE_DATA_STRUCTURE_CORRUPTION = BUGCHECK_ERROR.STORE_DATA_STRUCTURE_CORRUPTION;
pub const MANUALLY_INITIATED_POWER_BUTTON_HOLD = BUGCHECK_ERROR.MANUALLY_INITIATED_POWER_BUTTON_HOLD;
pub const USER_MODE_HEALTH_MONITOR_LIVEDUMP = BUGCHECK_ERROR.USER_MODE_HEALTH_MONITOR_LIVEDUMP;
pub const SYNTHETIC_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.SYNTHETIC_WATCHDOG_TIMEOUT;
pub const INVALID_SILO_DETACH = BUGCHECK_ERROR.INVALID_SILO_DETACH;
pub const EXRESOURCE_TIMEOUT_LIVEDUMP = BUGCHECK_ERROR.EXRESOURCE_TIMEOUT_LIVEDUMP;
pub const INVALID_CALLBACK_STACK_ADDRESS = BUGCHECK_ERROR.INVALID_CALLBACK_STACK_ADDRESS;
pub const INVALID_KERNEL_STACK_ADDRESS = BUGCHECK_ERROR.INVALID_KERNEL_STACK_ADDRESS;
pub const HARDWARE_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.HARDWARE_WATCHDOG_TIMEOUT;
pub const ACPI_FIRMWARE_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.ACPI_FIRMWARE_WATCHDOG_TIMEOUT;
pub const TELEMETRY_ASSERTS_LIVEDUMP = BUGCHECK_ERROR.TELEMETRY_ASSERTS_LIVEDUMP;
pub const WORKER_THREAD_INVALID_STATE = BUGCHECK_ERROR.WORKER_THREAD_INVALID_STATE;
pub const WFP_INVALID_OPERATION = BUGCHECK_ERROR.WFP_INVALID_OPERATION;
pub const UCMUCSI_LIVEDUMP = BUGCHECK_ERROR.UCMUCSI_LIVEDUMP;
pub const DRIVER_PNP_WATCHDOG = BUGCHECK_ERROR.DRIVER_PNP_WATCHDOG;
pub const WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS = BUGCHECK_ERROR.WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS;
pub const EFS_FATAL_ERROR = BUGCHECK_ERROR.EFS_FATAL_ERROR;
pub const UCMUCSI_FAILURE = BUGCHECK_ERROR.UCMUCSI_FAILURE;
pub const HAL_IOMMU_INTERNAL_ERROR = BUGCHECK_ERROR.HAL_IOMMU_INTERNAL_ERROR;
pub const HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR = BUGCHECK_ERROR.HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR;
pub const IPI_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.IPI_WATCHDOG_TIMEOUT;
pub const DMA_COMMON_BUFFER_VECTOR_ERROR = BUGCHECK_ERROR.DMA_COMMON_BUFFER_VECTOR_ERROR;
pub const BUGCODE_MBBADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_MBBADAPTER_DRIVER;
pub const BUGCODE_WIFIADAPTER_DRIVER = BUGCHECK_ERROR.BUGCODE_WIFIADAPTER_DRIVER;
pub const PROCESSOR_START_TIMEOUT = BUGCHECK_ERROR.PROCESSOR_START_TIMEOUT;
pub const INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION = BUGCHECK_ERROR.INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION;
pub const DEVICE_DIAGNOSTIC_LOG_LIVEDUMP = BUGCHECK_ERROR.DEVICE_DIAGNOSTIC_LOG_LIVEDUMP;
pub const AZURE_DEVICE_FW_DUMP = BUGCHECK_ERROR.AZURE_DEVICE_FW_DUMP;
pub const BREAKAWAY_CABLE_TRANSITION = BUGCHECK_ERROR.BREAKAWAY_CABLE_TRANSITION;
pub const VIDEO_DXGKRNL_SYSMM_FATAL_ERROR = BUGCHECK_ERROR.VIDEO_DXGKRNL_SYSMM_FATAL_ERROR;
pub const DRIVER_VERIFIER_TRACKING_LIVE_DUMP = BUGCHECK_ERROR.DRIVER_VERIFIER_TRACKING_LIVE_DUMP;
pub const CRASHDUMP_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.CRASHDUMP_WATCHDOG_TIMEOUT;
pub const REGISTRY_LIVE_DUMP = BUGCHECK_ERROR.REGISTRY_LIVE_DUMP;
pub const INVALID_THREAD_AFFINITY_STATE = BUGCHECK_ERROR.INVALID_THREAD_AFFINITY_STATE;
pub const ILLEGAL_ATS_INITIALIZATION = BUGCHECK_ERROR.ILLEGAL_ATS_INITIALIZATION;
pub const SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION = BUGCHECK_ERROR.SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION;
pub const DAM_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.DAM_WATCHDOG_TIMEOUT;
pub const HANDLE_LIVE_DUMP = BUGCHECK_ERROR.HANDLE_LIVE_DUMP;
pub const HANDLE_ERROR_ON_CRITICAL_THREAD = BUGCHECK_ERROR.HANDLE_ERROR_ON_CRITICAL_THREAD;
pub const MPSDRV_QUERY_USER = BUGCHECK_ERROR.MPSDRV_QUERY_USER;
pub const VMBUS_LIVEDUMP = BUGCHECK_ERROR.VMBUS_LIVEDUMP;
pub const USB4_HARDWARE_VIOLATION = BUGCHECK_ERROR.USB4_HARDWARE_VIOLATION;
pub const KASAN_ENLIGHTENMENT_VIOLATION = BUGCHECK_ERROR.KASAN_ENLIGHTENMENT_VIOLATION;
pub const KASAN_ILLEGAL_ACCESS = BUGCHECK_ERROR.KASAN_ILLEGAL_ACCESS;
pub const IORING = BUGCHECK_ERROR.IORING;
pub const MDL_CACHE = BUGCHECK_ERROR.MDL_CACHE;
pub const MISALIGNED_POINTER_PARAMETER = BUGCHECK_ERROR.MISALIGNED_POINTER_PARAMETER;
pub const XBOX_VMCTRL_CS_TIMEOUT = BUGCHECK_ERROR.XBOX_VMCTRL_CS_TIMEOUT;
pub const XBOX_CORRUPTED_IMAGE = BUGCHECK_ERROR.XBOX_CORRUPTED_IMAGE;
pub const XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW = BUGCHECK_ERROR.XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW;
pub const XBOX_CORRUPTED_IMAGE_BASE = BUGCHECK_ERROR.XBOX_CORRUPTED_IMAGE_BASE;
pub const XBOX_XDS_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.XBOX_XDS_WATCHDOG_TIMEOUT;
pub const XBOX_SHUTDOWN_WATCHDOG_TIMEOUT = BUGCHECK_ERROR.XBOX_SHUTDOWN_WATCHDOG_TIMEOUT;
pub const XBOX_360_SYSTEM_CRASH = BUGCHECK_ERROR.XBOX_360_SYSTEM_CRASH;
pub const XBOX_360_SYSTEM_CRASH_RESERVED = BUGCHECK_ERROR.XBOX_360_SYSTEM_CRASH_RESERVED;
pub const XBOX_SECURITY_FAILUE = BUGCHECK_ERROR.XBOX_SECURITY_FAILUE;
pub const KERNEL_CFG_INIT_FAILURE = BUGCHECK_ERROR.KERNEL_CFG_INIT_FAILURE;
pub const MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP = BUGCHECK_ERROR.MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP;
pub const HYPERVISOR_ERROR = BUGCHECK_ERROR.HYPERVISOR_ERROR;
pub const XBOX_MANUALLY_INITIATED_CRASH = BUGCHECK_ERROR.XBOX_MANUALLY_INITIATED_CRASH;
pub const MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP = BUGCHECK_ERROR.MANUALLY_INITIATED_BLACKSCREEN_HOTKEY_LIVE_DUMP;
pub const WINLOGON_FATAL_ERROR = BUGCHECK_ERROR.WINLOGON_FATAL_ERROR;
pub const MANUALLY_INITIATED_CRASH1 = BUGCHECK_ERROR.MANUALLY_INITIATED_CRASH1;
pub const BUGCHECK_CONTEXT_MODIFIER = BUGCHECK_ERROR.BUGCHECK_CONTEXT_MODIFIER;

pub const FACILITY_CODE = enum(u32) {
    NULL = 0,
    RPC = 1,
    DISPATCH = 2,
    STORAGE = 3,
    ITF = 4,
    WIN32 = 7,
    WINDOWS = 8,
    SSPI = 9,
    // SECURITY = 9, this enum value conflicts with SSPI
    CONTROL = 10,
    CERT = 11,
    INTERNET = 12,
    MEDIASERVER = 13,
    MSMQ = 14,
    SETUPAPI = 15,
    SCARD = 16,
    COMPLUS = 17,
    AAF = 18,
    URT = 19,
    ACS = 20,
    DPLAY = 21,
    UMI = 22,
    SXS = 23,
    WINDOWS_CE = 24,
    HTTP = 25,
    USERMODE_COMMONLOG = 26,
    WER = 27,
    USERMODE_FILTER_MANAGER = 31,
    BACKGROUNDCOPY = 32,
    CONFIGURATION = 33,
    // WIA = 33, this enum value conflicts with CONFIGURATION
    STATE_MANAGEMENT = 34,
    METADIRECTORY = 35,
    WINDOWSUPDATE = 36,
    DIRECTORYSERVICE = 37,
    GRAPHICS = 38,
    SHELL = 39,
    // NAP = 39, this enum value conflicts with SHELL
    TPM_SERVICES = 40,
    TPM_SOFTWARE = 41,
    UI = 42,
    XAML = 43,
    ACTION_QUEUE = 44,
    PLA = 48,
    // WINDOWS_SETUP = 48, this enum value conflicts with PLA
    FVE = 49,
    FWP = 50,
    WINRM = 51,
    NDIS = 52,
    USERMODE_HYPERVISOR = 53,
    CMI = 54,
    USERMODE_VIRTUALIZATION = 55,
    USERMODE_VOLMGR = 56,
    BCD = 57,
    USERMODE_VHD = 58,
    USERMODE_HNS = 59,
    SDIAG = 60,
    WEBSERVICES = 61,
    // WINPE = 61, this enum value conflicts with WEBSERVICES
    WPN = 62,
    WINDOWS_STORE = 63,
    INPUT = 64,
    QUIC = 65,
    EAP = 66,
    IORING = 70,
    WINDOWS_DEFENDER = 80,
    OPC = 81,
    XPS = 82,
    MBN = 84,
    // POWERSHELL = 84, this enum value conflicts with MBN
    RAS = 83,
    P2P_INT = 98,
    P2P = 99,
    DAF = 100,
    BLUETOOTH_ATT = 101,
    AUDIO = 102,
    STATEREPOSITORY = 103,
    VISUALCPP = 109,
    SCRIPT = 112,
    PARSE = 113,
    BLB = 120,
    BLB_CLI = 121,
    WSBAPP = 122,
    BLBUI = 128,
    USN = 129,
    USERMODE_VOLSNAP = 130,
    TIERING = 131,
    WSB_ONLINE = 133,
    ONLINE_ID = 134,
    DEVICE_UPDATE_AGENT = 135,
    DRVSERVICING = 136,
    DLS = 153,
    DELIVERY_OPTIMIZATION = 208,
    USERMODE_SPACES = 231,
    USER_MODE_SECURITY_CORE = 232,
    USERMODE_LICENSING = 234,
    SOS = 160,
    OCP_UPDATE_AGENT = 173,
    DEBUGGERS = 176,
    SPP = 256,
    // RESTORE = 256, this enum value conflicts with SPP
    // DMSERVER = 256, this enum value conflicts with SPP
    DEPLOYMENT_SERVICES_SERVER = 257,
    DEPLOYMENT_SERVICES_IMAGING = 258,
    DEPLOYMENT_SERVICES_MANAGEMENT = 259,
    DEPLOYMENT_SERVICES_UTIL = 260,
    DEPLOYMENT_SERVICES_BINLSVC = 261,
    DEPLOYMENT_SERVICES_PXE = 263,
    DEPLOYMENT_SERVICES_TFTP = 264,
    DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 272,
    DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 278,
    DEPLOYMENT_SERVICES_MULTICAST_SERVER = 289,
    DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 290,
    DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 293,
    HSP_SERVICES = 296,
    HSP_SOFTWARE = 297,
    LINGUISTIC_SERVICES = 305,
    AUDIOSTREAMING = 1094,
    TTD = 1490,
    ACCELERATOR = 1536,
    WMAAECMA = 1996,
    DIRECTMUSIC = 2168,
    DIRECT3D10 = 2169,
    DXGI = 2170,
    DXGI_DDI = 2171,
    DIRECT3D11 = 2172,
    DIRECT3D11_DEBUG = 2173,
    DIRECT3D12 = 2174,
    DIRECT3D12_DEBUG = 2175,
    DXCORE = 2176,
    PRESENTATION = 2177,
    LEAP = 2184,
    AUDCLNT = 2185,
    WINCODEC_DWRITE_DWM = 2200,
    WINML = 2192,
    DIRECT2D = 2201,
    DEFRAG = 2304,
    USERMODE_SDBUS = 2305,
    JSCRIPT = 2306,
    PIDGENX = 2561,
    EAS = 85,
    WEB = 885,
    WEB_SOCKET = 886,
    MOBILE = 1793,
    SQLITE = 1967,
    SERVICE_FABRIC = 1968,
    UTC = 1989,
    WEP = 2049,
    SYNCENGINE = 2050,
    XBOX = 2339,
    GAME = 2340,
    PIX = 2748,
    NT_BIT = 268435456,
};
pub const FACILITY_NULL = FACILITY_CODE.NULL;
pub const FACILITY_RPC = FACILITY_CODE.RPC;
pub const FACILITY_DISPATCH = FACILITY_CODE.DISPATCH;
pub const FACILITY_STORAGE = FACILITY_CODE.STORAGE;
pub const FACILITY_ITF = FACILITY_CODE.ITF;
pub const FACILITY_WIN32 = FACILITY_CODE.WIN32;
pub const FACILITY_WINDOWS = FACILITY_CODE.WINDOWS;
pub const FACILITY_SSPI = FACILITY_CODE.SSPI;
pub const FACILITY_SECURITY = FACILITY_CODE.SSPI;
pub const FACILITY_CONTROL = FACILITY_CODE.CONTROL;
pub const FACILITY_CERT = FACILITY_CODE.CERT;
pub const FACILITY_INTERNET = FACILITY_CODE.INTERNET;
pub const FACILITY_MEDIASERVER = FACILITY_CODE.MEDIASERVER;
pub const FACILITY_MSMQ = FACILITY_CODE.MSMQ;
pub const FACILITY_SETUPAPI = FACILITY_CODE.SETUPAPI;
pub const FACILITY_SCARD = FACILITY_CODE.SCARD;
pub const FACILITY_COMPLUS = FACILITY_CODE.COMPLUS;
pub const FACILITY_AAF = FACILITY_CODE.AAF;
pub const FACILITY_URT = FACILITY_CODE.URT;
pub const FACILITY_ACS = FACILITY_CODE.ACS;
pub const FACILITY_DPLAY = FACILITY_CODE.DPLAY;
pub const FACILITY_UMI = FACILITY_CODE.UMI;
pub const FACILITY_SXS = FACILITY_CODE.SXS;
pub const FACILITY_WINDOWS_CE = FACILITY_CODE.WINDOWS_CE;
pub const FACILITY_HTTP = FACILITY_CODE.HTTP;
pub const FACILITY_USERMODE_COMMONLOG = FACILITY_CODE.USERMODE_COMMONLOG;
pub const FACILITY_WER = FACILITY_CODE.WER;
pub const FACILITY_USERMODE_FILTER_MANAGER = FACILITY_CODE.USERMODE_FILTER_MANAGER;
pub const FACILITY_BACKGROUNDCOPY = FACILITY_CODE.BACKGROUNDCOPY;
pub const FACILITY_CONFIGURATION = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_WIA = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_STATE_MANAGEMENT = FACILITY_CODE.STATE_MANAGEMENT;
pub const FACILITY_METADIRECTORY = FACILITY_CODE.METADIRECTORY;
pub const FACILITY_WINDOWSUPDATE = FACILITY_CODE.WINDOWSUPDATE;
pub const FACILITY_DIRECTORYSERVICE = FACILITY_CODE.DIRECTORYSERVICE;
pub const FACILITY_GRAPHICS = FACILITY_CODE.GRAPHICS;
pub const FACILITY_SHELL = FACILITY_CODE.SHELL;
pub const FACILITY_NAP = FACILITY_CODE.SHELL;
pub const FACILITY_TPM_SERVICES = FACILITY_CODE.TPM_SERVICES;
pub const FACILITY_TPM_SOFTWARE = FACILITY_CODE.TPM_SOFTWARE;
pub const FACILITY_UI = FACILITY_CODE.UI;
pub const FACILITY_XAML = FACILITY_CODE.XAML;
pub const FACILITY_ACTION_QUEUE = FACILITY_CODE.ACTION_QUEUE;
pub const FACILITY_PLA = FACILITY_CODE.PLA;
pub const FACILITY_WINDOWS_SETUP = FACILITY_CODE.PLA;
pub const FACILITY_FVE = FACILITY_CODE.FVE;
pub const FACILITY_FWP = FACILITY_CODE.FWP;
pub const FACILITY_WINRM = FACILITY_CODE.WINRM;
pub const FACILITY_NDIS = FACILITY_CODE.NDIS;
pub const FACILITY_USERMODE_HYPERVISOR = FACILITY_CODE.USERMODE_HYPERVISOR;
pub const FACILITY_CMI = FACILITY_CODE.CMI;
pub const FACILITY_USERMODE_VIRTUALIZATION = FACILITY_CODE.USERMODE_VIRTUALIZATION;
pub const FACILITY_USERMODE_VOLMGR = FACILITY_CODE.USERMODE_VOLMGR;
pub const FACILITY_BCD = FACILITY_CODE.BCD;
pub const FACILITY_USERMODE_VHD = FACILITY_CODE.USERMODE_VHD;
pub const FACILITY_USERMODE_HNS = FACILITY_CODE.USERMODE_HNS;
pub const FACILITY_SDIAG = FACILITY_CODE.SDIAG;
pub const FACILITY_WEBSERVICES = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WINPE = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WPN = FACILITY_CODE.WPN;
pub const FACILITY_WINDOWS_STORE = FACILITY_CODE.WINDOWS_STORE;
pub const FACILITY_INPUT = FACILITY_CODE.INPUT;
pub const FACILITY_QUIC = FACILITY_CODE.QUIC;
pub const FACILITY_EAP = FACILITY_CODE.EAP;
pub const FACILITY_IORING = FACILITY_CODE.IORING;
pub const FACILITY_WINDOWS_DEFENDER = FACILITY_CODE.WINDOWS_DEFENDER;
pub const FACILITY_OPC = FACILITY_CODE.OPC;
pub const FACILITY_XPS = FACILITY_CODE.XPS;
pub const FACILITY_MBN = FACILITY_CODE.MBN;
pub const FACILITY_POWERSHELL = FACILITY_CODE.MBN;
pub const FACILITY_RAS = FACILITY_CODE.RAS;
pub const FACILITY_P2P_INT = FACILITY_CODE.P2P_INT;
pub const FACILITY_P2P = FACILITY_CODE.P2P;
pub const FACILITY_DAF = FACILITY_CODE.DAF;
pub const FACILITY_BLUETOOTH_ATT = FACILITY_CODE.BLUETOOTH_ATT;
pub const FACILITY_AUDIO = FACILITY_CODE.AUDIO;
pub const FACILITY_STATEREPOSITORY = FACILITY_CODE.STATEREPOSITORY;
pub const FACILITY_VISUALCPP = FACILITY_CODE.VISUALCPP;
pub const FACILITY_SCRIPT = FACILITY_CODE.SCRIPT;
pub const FACILITY_PARSE = FACILITY_CODE.PARSE;
pub const FACILITY_BLB = FACILITY_CODE.BLB;
pub const FACILITY_BLB_CLI = FACILITY_CODE.BLB_CLI;
pub const FACILITY_WSBAPP = FACILITY_CODE.WSBAPP;
pub const FACILITY_BLBUI = FACILITY_CODE.BLBUI;
pub const FACILITY_USN = FACILITY_CODE.USN;
pub const FACILITY_USERMODE_VOLSNAP = FACILITY_CODE.USERMODE_VOLSNAP;
pub const FACILITY_TIERING = FACILITY_CODE.TIERING;
pub const FACILITY_WSB_ONLINE = FACILITY_CODE.WSB_ONLINE;
pub const FACILITY_ONLINE_ID = FACILITY_CODE.ONLINE_ID;
pub const FACILITY_DEVICE_UPDATE_AGENT = FACILITY_CODE.DEVICE_UPDATE_AGENT;
pub const FACILITY_DRVSERVICING = FACILITY_CODE.DRVSERVICING;
pub const FACILITY_DLS = FACILITY_CODE.DLS;
pub const FACILITY_DELIVERY_OPTIMIZATION = FACILITY_CODE.DELIVERY_OPTIMIZATION;
pub const FACILITY_USERMODE_SPACES = FACILITY_CODE.USERMODE_SPACES;
pub const FACILITY_USER_MODE_SECURITY_CORE = FACILITY_CODE.USER_MODE_SECURITY_CORE;
pub const FACILITY_USERMODE_LICENSING = FACILITY_CODE.USERMODE_LICENSING;
pub const FACILITY_SOS = FACILITY_CODE.SOS;
pub const FACILITY_OCP_UPDATE_AGENT = FACILITY_CODE.OCP_UPDATE_AGENT;
pub const FACILITY_DEBUGGERS = FACILITY_CODE.DEBUGGERS;
pub const FACILITY_SPP = FACILITY_CODE.SPP;
pub const FACILITY_RESTORE = FACILITY_CODE.SPP;
pub const FACILITY_DMSERVER = FACILITY_CODE.SPP;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING = FACILITY_CODE.DEPLOYMENT_SERVICES_IMAGING;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL = FACILITY_CODE.DEPLOYMENT_SERVICES_UTIL;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC = FACILITY_CODE.DEPLOYMENT_SERVICES_BINLSVC;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE = FACILITY_CODE.DEPLOYMENT_SERVICES_PXE;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP = FACILITY_CODE.DEPLOYMENT_SERVICES_TFTP;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = FACILITY_CODE.DEPLOYMENT_SERVICES_DRIVER_PROVISIONING;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_CLIENT;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER = FACILITY_CODE.DEPLOYMENT_SERVICES_CONTENT_PROVIDER;
pub const FACILITY_HSP_SERVICES = FACILITY_CODE.HSP_SERVICES;
pub const FACILITY_HSP_SOFTWARE = FACILITY_CODE.HSP_SOFTWARE;
pub const FACILITY_LINGUISTIC_SERVICES = FACILITY_CODE.LINGUISTIC_SERVICES;
pub const FACILITY_AUDIOSTREAMING = FACILITY_CODE.AUDIOSTREAMING;
pub const FACILITY_TTD = FACILITY_CODE.TTD;
pub const FACILITY_ACCELERATOR = FACILITY_CODE.ACCELERATOR;
pub const FACILITY_WMAAECMA = FACILITY_CODE.WMAAECMA;
pub const FACILITY_DIRECTMUSIC = FACILITY_CODE.DIRECTMUSIC;
pub const FACILITY_DIRECT3D10 = FACILITY_CODE.DIRECT3D10;
pub const FACILITY_DXGI = FACILITY_CODE.DXGI;
pub const FACILITY_DXGI_DDI = FACILITY_CODE.DXGI_DDI;
pub const FACILITY_DIRECT3D11 = FACILITY_CODE.DIRECT3D11;
pub const FACILITY_DIRECT3D11_DEBUG = FACILITY_CODE.DIRECT3D11_DEBUG;
pub const FACILITY_DIRECT3D12 = FACILITY_CODE.DIRECT3D12;
pub const FACILITY_DIRECT3D12_DEBUG = FACILITY_CODE.DIRECT3D12_DEBUG;
pub const FACILITY_DXCORE = FACILITY_CODE.DXCORE;
pub const FACILITY_PRESENTATION = FACILITY_CODE.PRESENTATION;
pub const FACILITY_LEAP = FACILITY_CODE.LEAP;
pub const FACILITY_AUDCLNT = FACILITY_CODE.AUDCLNT;
pub const FACILITY_WINCODEC_DWRITE_DWM = FACILITY_CODE.WINCODEC_DWRITE_DWM;
pub const FACILITY_WINML = FACILITY_CODE.WINML;
pub const FACILITY_DIRECT2D = FACILITY_CODE.DIRECT2D;
pub const FACILITY_DEFRAG = FACILITY_CODE.DEFRAG;
pub const FACILITY_USERMODE_SDBUS = FACILITY_CODE.USERMODE_SDBUS;
pub const FACILITY_JSCRIPT = FACILITY_CODE.JSCRIPT;
pub const FACILITY_PIDGENX = FACILITY_CODE.PIDGENX;
pub const FACILITY_EAS = FACILITY_CODE.EAS;
pub const FACILITY_WEB = FACILITY_CODE.WEB;
pub const FACILITY_WEB_SOCKET = FACILITY_CODE.WEB_SOCKET;
pub const FACILITY_MOBILE = FACILITY_CODE.MOBILE;
pub const FACILITY_SQLITE = FACILITY_CODE.SQLITE;
pub const FACILITY_SERVICE_FABRIC = FACILITY_CODE.SERVICE_FABRIC;
pub const FACILITY_UTC = FACILITY_CODE.UTC;
pub const FACILITY_WEP = FACILITY_CODE.WEP;
pub const FACILITY_SYNCENGINE = FACILITY_CODE.SYNCENGINE;
pub const FACILITY_XBOX = FACILITY_CODE.XBOX;
pub const FACILITY_GAME = FACILITY_CODE.GAME;
pub const FACILITY_PIX = FACILITY_CODE.PIX;
pub const FACILITY_NT_BIT = FACILITY_CODE.NT_BIT;

pub const THREAD_ERROR_MODE = enum(u32) {
    ALL_ERRORS = 0,
    FAILCRITICALERRORS = 1,
    NOGPFAULTERRORBOX = 2,
    NOOPENFILEERRORBOX = 32768,
    NOALIGNMENTFAULTEXCEPT = 4,
    _,
    pub fn initFlags(o: struct {
        ALL_ERRORS: u1 = 0,
        FAILCRITICALERRORS: u1 = 0,
        NOGPFAULTERRORBOX: u1 = 0,
        NOOPENFILEERRORBOX: u1 = 0,
        NOALIGNMENTFAULTEXCEPT: u1 = 0,
    }) THREAD_ERROR_MODE {
        return @as(THREAD_ERROR_MODE, @enumFromInt(
              (if (o.ALL_ERRORS == 1) @intFromEnum(THREAD_ERROR_MODE.ALL_ERRORS) else 0)
            | (if (o.FAILCRITICALERRORS == 1) @intFromEnum(THREAD_ERROR_MODE.FAILCRITICALERRORS) else 0)
            | (if (o.NOGPFAULTERRORBOX == 1) @intFromEnum(THREAD_ERROR_MODE.NOGPFAULTERRORBOX) else 0)
            | (if (o.NOOPENFILEERRORBOX == 1) @intFromEnum(THREAD_ERROR_MODE.NOOPENFILEERRORBOX) else 0)
            | (if (o.NOALIGNMENTFAULTEXCEPT == 1) @intFromEnum(THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT) else 0)
        ));
    }
};
pub const SEM_ALL_ERRORS = THREAD_ERROR_MODE.ALL_ERRORS;
pub const SEM_FAILCRITICALERRORS = THREAD_ERROR_MODE.FAILCRITICALERRORS;
pub const SEM_NOGPFAULTERRORBOX = THREAD_ERROR_MODE.NOGPFAULTERRORBOX;
pub const SEM_NOOPENFILEERRORBOX = THREAD_ERROR_MODE.NOOPENFILEERRORBOX;
pub const SEM_NOALIGNMENTFAULTEXCEPT = THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT;

pub const FORMAT_MESSAGE_OPTIONS = enum(u32) {
    ALLOCATE_BUFFER = 256,
    ARGUMENT_ARRAY = 8192,
    FROM_HMODULE = 2048,
    FROM_STRING = 1024,
    FROM_SYSTEM = 4096,
    IGNORE_INSERTS = 512,
    _,
    pub fn initFlags(o: struct {
        ALLOCATE_BUFFER: u1 = 0,
        ARGUMENT_ARRAY: u1 = 0,
        FROM_HMODULE: u1 = 0,
        FROM_STRING: u1 = 0,
        FROM_SYSTEM: u1 = 0,
        IGNORE_INSERTS: u1 = 0,
    }) FORMAT_MESSAGE_OPTIONS {
        return @as(FORMAT_MESSAGE_OPTIONS, @enumFromInt(
              (if (o.ALLOCATE_BUFFER == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER) else 0)
            | (if (o.ARGUMENT_ARRAY == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY) else 0)
            | (if (o.FROM_HMODULE == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_HMODULE) else 0)
            | (if (o.FROM_STRING == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_STRING) else 0)
            | (if (o.FROM_SYSTEM == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM) else 0)
            | (if (o.IGNORE_INSERTS == 1) @intFromEnum(FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS) else 0)
        ));
    }
};
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY = FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY;
pub const FORMAT_MESSAGE_FROM_HMODULE = FORMAT_MESSAGE_OPTIONS.FROM_HMODULE;
pub const FORMAT_MESSAGE_FROM_STRING = FORMAT_MESSAGE_OPTIONS.FROM_STRING;
pub const FORMAT_MESSAGE_FROM_SYSTEM = FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM;
pub const FORMAT_MESSAGE_IGNORE_INSERTS = FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS;

pub const RTL_VIRTUAL_UNWIND_HANDLER_TYPE = enum(u32) {
    NHANDLER = 0,
    EHANDLER = 1,
    UHANDLER = 2,
    CHAININFO = 4,
};
pub const UNW_FLAG_NHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.NHANDLER;
pub const UNW_FLAG_EHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.EHANDLER;
pub const UNW_FLAG_UHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.UHANDLER;
pub const UNW_FLAG_CHAININFO = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.CHAININFO;

pub const OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS = enum(u32) {
    G = 1,
};
pub const WCT_ASYNC_OPEN_FLAG = OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS.G;

pub const SYM_SRV_STORE_FILE_FLAGS = enum(u32) {
    COMPRESS = 1,
    OVERWRITE = 2,
    PASS_IF_EXISTS = 64,
    POINTER = 8,
    RETURNINDEX = 4,
};
pub const SYMSTOREOPT_COMPRESS = SYM_SRV_STORE_FILE_FLAGS.COMPRESS;
pub const SYMSTOREOPT_OVERWRITE = SYM_SRV_STORE_FILE_FLAGS.OVERWRITE;
pub const SYMSTOREOPT_PASS_IF_EXISTS = SYM_SRV_STORE_FILE_FLAGS.PASS_IF_EXISTS;
pub const SYMSTOREOPT_POINTER = SYM_SRV_STORE_FILE_FLAGS.POINTER;
pub const SYMSTOREOPT_RETURNINDEX = SYM_SRV_STORE_FILE_FLAGS.RETURNINDEX;

pub const IMAGE_DIRECTORY_ENTRY = enum(u16) {
    ARCHITECTURE = 7,
    BASERELOC = 5,
    BOUND_IMPORT = 11,
    COM_DESCRIPTOR = 14,
    DEBUG = 6,
    DELAY_IMPORT = 13,
    EXCEPTION = 3,
    EXPORT = 0,
    GLOBALPTR = 8,
    IAT = 12,
    IMPORT = 1,
    LOAD_CONFIG = 10,
    RESOURCE = 2,
    SECURITY = 4,
    TLS = 9,
};
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = IMAGE_DIRECTORY_ENTRY.ARCHITECTURE;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC = IMAGE_DIRECTORY_ENTRY.BASERELOC;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = IMAGE_DIRECTORY_ENTRY.BOUND_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = IMAGE_DIRECTORY_ENTRY.COM_DESCRIPTOR;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG = IMAGE_DIRECTORY_ENTRY.DEBUG;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = IMAGE_DIRECTORY_ENTRY.DELAY_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION = IMAGE_DIRECTORY_ENTRY.EXCEPTION;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT = IMAGE_DIRECTORY_ENTRY.EXPORT;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR = IMAGE_DIRECTORY_ENTRY.GLOBALPTR;
pub const IMAGE_DIRECTORY_ENTRY_IAT = IMAGE_DIRECTORY_ENTRY.IAT;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT = IMAGE_DIRECTORY_ENTRY.IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = IMAGE_DIRECTORY_ENTRY.LOAD_CONFIG;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE = IMAGE_DIRECTORY_ENTRY.RESOURCE;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY = IMAGE_DIRECTORY_ENTRY.SECURITY;
pub const IMAGE_DIRECTORY_ENTRY_TLS = IMAGE_DIRECTORY_ENTRY.TLS;

pub const WAIT_CHAIN_THREAD_OPTIONS = enum(u32) {
    COM_FLAG = 2,
    CS_FLAG = 4,
    FLAG = 1,
};
pub const WCT_OUT_OF_PROC_COM_FLAG = WAIT_CHAIN_THREAD_OPTIONS.COM_FLAG;
pub const WCT_OUT_OF_PROC_CS_FLAG = WAIT_CHAIN_THREAD_OPTIONS.CS_FLAG;
pub const WCT_OUT_OF_PROC_FLAG = WAIT_CHAIN_THREAD_OPTIONS.FLAG;

pub const SYM_FIND_ID_OPTION = enum(u32) {
    DWORD = 2,
    DWORDPTR = 4,
    GUIDPTR = 8,
};
pub const SSRVOPT_DWORD = SYM_FIND_ID_OPTION.DWORD;
pub const SSRVOPT_DWORDPTR = SYM_FIND_ID_OPTION.DWORDPTR;
pub const SSRVOPT_GUIDPTR = SYM_FIND_ID_OPTION.GUIDPTR;

pub const IMAGE_FILE_CHARACTERISTICS = enum(u16) {
    RELOCS_STRIPPED = 1,
    EXECUTABLE_IMAGE = 2,
    LINE_NUMS_STRIPPED = 4,
    LOCAL_SYMS_STRIPPED = 8,
    AGGRESIVE_WS_TRIM = 16,
    LARGE_ADDRESS_AWARE = 32,
    BYTES_REVERSED_LO = 128,
    @"32BIT_MACHINE" = 256,
    DEBUG_STRIPPED = 512,
    REMOVABLE_RUN_FROM_SWAP = 1024,
    NET_RUN_FROM_SWAP = 2048,
    SYSTEM = 4096,
    DLL = 8192,
    UP_SYSTEM_ONLY = 16384,
    BYTES_REVERSED_HI = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED: u1 = 0,
        EXECUTABLE_IMAGE: u1 = 0,
        LINE_NUMS_STRIPPED: u1 = 0,
        LOCAL_SYMS_STRIPPED: u1 = 0,
        AGGRESIVE_WS_TRIM: u1 = 0,
        LARGE_ADDRESS_AWARE: u1 = 0,
        BYTES_REVERSED_LO: u1 = 0,
        @"32BIT_MACHINE": u1 = 0,
        DEBUG_STRIPPED: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP: u1 = 0,
        NET_RUN_FROM_SWAP: u1 = 0,
        SYSTEM: u1 = 0,
        DLL: u1 = 0,
        UP_SYSTEM_ONLY: u1 = 0,
        BYTES_REVERSED_HI: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS {
        return @as(IMAGE_FILE_CHARACTERISTICS, @enumFromInt(
              (if (o.RELOCS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED) else 0)
            | (if (o.EXECUTABLE_IMAGE == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE) else 0)
            | (if (o.LINE_NUMS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED) else 0)
            | (if (o.LOCAL_SYMS_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED) else 0)
            | (if (o.AGGRESIVE_WS_TRIM == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM) else 0)
            | (if (o.LARGE_ADDRESS_AWARE == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE) else 0)
            | (if (o.BYTES_REVERSED_LO == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO) else 0)
            | (if (o.@"32BIT_MACHINE" == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE") else 0)
            | (if (o.DEBUG_STRIPPED == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED) else 0)
            | (if (o.REMOVABLE_RUN_FROM_SWAP == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP) else 0)
            | (if (o.NET_RUN_FROM_SWAP == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP) else 0)
            | (if (o.SYSTEM == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.SYSTEM) else 0)
            | (if (o.DLL == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.DLL) else 0)
            | (if (o.UP_SYSTEM_ONLY == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY) else 0)
            | (if (o.BYTES_REVERSED_HI == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI) else 0)
        ));
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED;
pub const IMAGE_FILE_EXECUTABLE_IMAGE = IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM = IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE = IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE;
pub const IMAGE_FILE_BYTES_REVERSED_LO = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO;
pub const IMAGE_FILE_32BIT_MACHINE = IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE";
pub const IMAGE_FILE_DEBUG_STRIPPED = IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP;
pub const IMAGE_FILE_SYSTEM = IMAGE_FILE_CHARACTERISTICS.SYSTEM;
pub const IMAGE_FILE_DLL = IMAGE_FILE_CHARACTERISTICS.DLL;
pub const IMAGE_FILE_UP_SYSTEM_ONLY = IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY;
pub const IMAGE_FILE_BYTES_REVERSED_HI = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI;

pub const IMAGE_FILE_CHARACTERISTICS2 = enum(u32) {
    RELOCS_STRIPPED2 = 1,
    EXECUTABLE_IMAGE2 = 2,
    LINE_NUMS_STRIPPED2 = 4,
    LOCAL_SYMS_STRIPPED2 = 8,
    AGGRESIVE_WS_TRIM2 = 16,
    LARGE_ADDRESS_AWARE2 = 32,
    BYTES_REVERSED_LO2 = 128,
    @"32BIT_MACHINE2" = 256,
    DEBUG_STRIPPED2 = 512,
    REMOVABLE_RUN_FROM_SWAP2 = 1024,
    NET_RUN_FROM_SWAP2 = 2048,
    SYSTEM_2 = 4096,
    DLL_2 = 8192,
    UP_SYSTEM_ONLY_2 = 16384,
    BYTES_REVERSED_HI_2 = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED2: u1 = 0,
        EXECUTABLE_IMAGE2: u1 = 0,
        LINE_NUMS_STRIPPED2: u1 = 0,
        LOCAL_SYMS_STRIPPED2: u1 = 0,
        AGGRESIVE_WS_TRIM2: u1 = 0,
        LARGE_ADDRESS_AWARE2: u1 = 0,
        BYTES_REVERSED_LO2: u1 = 0,
        @"32BIT_MACHINE2": u1 = 0,
        DEBUG_STRIPPED2: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP2: u1 = 0,
        NET_RUN_FROM_SWAP2: u1 = 0,
        SYSTEM_2: u1 = 0,
        DLL_2: u1 = 0,
        UP_SYSTEM_ONLY_2: u1 = 0,
        BYTES_REVERSED_HI_2: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS2 {
        return @as(IMAGE_FILE_CHARACTERISTICS2, @enumFromInt(
              (if (o.RELOCS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2) else 0)
            | (if (o.EXECUTABLE_IMAGE2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2) else 0)
            | (if (o.LINE_NUMS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2) else 0)
            | (if (o.LOCAL_SYMS_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2) else 0)
            | (if (o.AGGRESIVE_WS_TRIM2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2) else 0)
            | (if (o.LARGE_ADDRESS_AWARE2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2) else 0)
            | (if (o.BYTES_REVERSED_LO2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2) else 0)
            | (if (o.@"32BIT_MACHINE2" == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2") else 0)
            | (if (o.DEBUG_STRIPPED2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2) else 0)
            | (if (o.REMOVABLE_RUN_FROM_SWAP2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2) else 0)
            | (if (o.NET_RUN_FROM_SWAP2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2) else 0)
            | (if (o.SYSTEM_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2) else 0)
            | (if (o.DLL_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.DLL_2) else 0)
            | (if (o.UP_SYSTEM_ONLY_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2) else 0)
            | (if (o.BYTES_REVERSED_HI_2 == 1) @intFromEnum(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2) else 0)
        ));
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2;
pub const IMAGE_FILE_EXECUTABLE_IMAGE2 = IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM2 = IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE2 = IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2;
pub const IMAGE_FILE_BYTES_REVERSED_LO2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2;
pub const IMAGE_FILE_32BIT_MACHINE2 = IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2";
pub const IMAGE_FILE_DEBUG_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2;
pub const IMAGE_FILE_SYSTEM_2 = IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2;
pub const IMAGE_FILE_DLL_2 = IMAGE_FILE_CHARACTERISTICS2.DLL_2;
pub const IMAGE_FILE_UP_SYSTEM_ONLY_2 = IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2;
pub const IMAGE_FILE_BYTES_REVERSED_HI_2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2;

pub const SYMBOL_INFO_FLAGS = enum(u32) {
    CLR_TOKEN = 262144,
    CONSTANT = 256,
    EXPORT = 512,
    FORWARDER = 1024,
    FRAMEREL = 32,
    FUNCTION = 2048,
    ILREL = 65536,
    LOCAL = 128,
    METADATA = 131072,
    PARAMETER = 64,
    REGISTER = 8,
    REGREL = 16,
    SLOT = 32768,
    THUNK = 8192,
    TLSREL = 16384,
    VALUEPRESENT = 1,
    VIRTUAL = 4096,
    _,
    pub fn initFlags(o: struct {
        CLR_TOKEN: u1 = 0,
        CONSTANT: u1 = 0,
        EXPORT: u1 = 0,
        FORWARDER: u1 = 0,
        FRAMEREL: u1 = 0,
        FUNCTION: u1 = 0,
        ILREL: u1 = 0,
        LOCAL: u1 = 0,
        METADATA: u1 = 0,
        PARAMETER: u1 = 0,
        REGISTER: u1 = 0,
        REGREL: u1 = 0,
        SLOT: u1 = 0,
        THUNK: u1 = 0,
        TLSREL: u1 = 0,
        VALUEPRESENT: u1 = 0,
        VIRTUAL: u1 = 0,
    }) SYMBOL_INFO_FLAGS {
        return @as(SYMBOL_INFO_FLAGS, @enumFromInt(
              (if (o.CLR_TOKEN == 1) @intFromEnum(SYMBOL_INFO_FLAGS.CLR_TOKEN) else 0)
            | (if (o.CONSTANT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.CONSTANT) else 0)
            | (if (o.EXPORT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.EXPORT) else 0)
            | (if (o.FORWARDER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FORWARDER) else 0)
            | (if (o.FRAMEREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FRAMEREL) else 0)
            | (if (o.FUNCTION == 1) @intFromEnum(SYMBOL_INFO_FLAGS.FUNCTION) else 0)
            | (if (o.ILREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.ILREL) else 0)
            | (if (o.LOCAL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.LOCAL) else 0)
            | (if (o.METADATA == 1) @intFromEnum(SYMBOL_INFO_FLAGS.METADATA) else 0)
            | (if (o.PARAMETER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.PARAMETER) else 0)
            | (if (o.REGISTER == 1) @intFromEnum(SYMBOL_INFO_FLAGS.REGISTER) else 0)
            | (if (o.REGREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.REGREL) else 0)
            | (if (o.SLOT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.SLOT) else 0)
            | (if (o.THUNK == 1) @intFromEnum(SYMBOL_INFO_FLAGS.THUNK) else 0)
            | (if (o.TLSREL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.TLSREL) else 0)
            | (if (o.VALUEPRESENT == 1) @intFromEnum(SYMBOL_INFO_FLAGS.VALUEPRESENT) else 0)
            | (if (o.VIRTUAL == 1) @intFromEnum(SYMBOL_INFO_FLAGS.VIRTUAL) else 0)
        ));
    }
};
pub const SYMFLAG_CLR_TOKEN = SYMBOL_INFO_FLAGS.CLR_TOKEN;
pub const SYMFLAG_CONSTANT = SYMBOL_INFO_FLAGS.CONSTANT;
pub const SYMFLAG_EXPORT = SYMBOL_INFO_FLAGS.EXPORT;
pub const SYMFLAG_FORWARDER = SYMBOL_INFO_FLAGS.FORWARDER;
pub const SYMFLAG_FRAMEREL = SYMBOL_INFO_FLAGS.FRAMEREL;
pub const SYMFLAG_FUNCTION = SYMBOL_INFO_FLAGS.FUNCTION;
pub const SYMFLAG_ILREL = SYMBOL_INFO_FLAGS.ILREL;
pub const SYMFLAG_LOCAL = SYMBOL_INFO_FLAGS.LOCAL;
pub const SYMFLAG_METADATA = SYMBOL_INFO_FLAGS.METADATA;
pub const SYMFLAG_PARAMETER = SYMBOL_INFO_FLAGS.PARAMETER;
pub const SYMFLAG_REGISTER = SYMBOL_INFO_FLAGS.REGISTER;
pub const SYMFLAG_REGREL = SYMBOL_INFO_FLAGS.REGREL;
pub const SYMFLAG_SLOT = SYMBOL_INFO_FLAGS.SLOT;
pub const SYMFLAG_THUNK = SYMBOL_INFO_FLAGS.THUNK;
pub const SYMFLAG_TLSREL = SYMBOL_INFO_FLAGS.TLSREL;
pub const SYMFLAG_VALUEPRESENT = SYMBOL_INFO_FLAGS.VALUEPRESENT;
pub const SYMFLAG_VIRTUAL = SYMBOL_INFO_FLAGS.VIRTUAL;

pub const IMAGEHLP_CBA_EVENT_SEVERITY = enum(u32) {
    Info = 0,
    Problem = 1,
    Attn = 2,
    Fatal = 3,
};
// TODO: enum 'IMAGEHLP_CBA_EVENT_SEVERITY' has known issues with its value aliases

pub const IMAGEHLP_GET_TYPE_INFO_FLAGS = enum(u32) {
    CHILDREN = 2,
    UNCACHED = 1,
};
pub const IMAGEHLP_GET_TYPE_INFO_CHILDREN = IMAGEHLP_GET_TYPE_INFO_FLAGS.CHILDREN;
pub const IMAGEHLP_GET_TYPE_INFO_UNCACHED = IMAGEHLP_GET_TYPE_INFO_FLAGS.UNCACHED;

pub const RIP_INFO_TYPE = enum(u32) {
    ERROR = 1,
    MINORERROR = 2,
    WARNING = 3,
};
pub const SLE_ERROR = RIP_INFO_TYPE.ERROR;
pub const SLE_MINORERROR = RIP_INFO_TYPE.MINORERROR;
pub const SLE_WARNING = RIP_INFO_TYPE.WARNING;

pub const VER_PLATFORM = enum(u32) {
    s = 0,
    _WINDOWS = 1,
    _NT = 2,
};
pub const VER_PLATFORM_WIN32s = VER_PLATFORM.s;
pub const VER_PLATFORM_WIN32_WINDOWS = VER_PLATFORM._WINDOWS;
pub const VER_PLATFORM_WIN32_NT = VER_PLATFORM._NT;

pub const IMAGE_DEBUG_TYPE = enum(u32) {
    UNKNOWN = 0,
    COFF = 1,
    CODEVIEW = 2,
    FPO = 3,
    MISC = 4,
    EXCEPTION = 5,
    FIXUP = 6,
    BORLAND = 9,
};
pub const IMAGE_DEBUG_TYPE_UNKNOWN = IMAGE_DEBUG_TYPE.UNKNOWN;
pub const IMAGE_DEBUG_TYPE_COFF = IMAGE_DEBUG_TYPE.COFF;
pub const IMAGE_DEBUG_TYPE_CODEVIEW = IMAGE_DEBUG_TYPE.CODEVIEW;
pub const IMAGE_DEBUG_TYPE_FPO = IMAGE_DEBUG_TYPE.FPO;
pub const IMAGE_DEBUG_TYPE_MISC = IMAGE_DEBUG_TYPE.MISC;
pub const IMAGE_DEBUG_TYPE_EXCEPTION = IMAGE_DEBUG_TYPE.EXCEPTION;
pub const IMAGE_DEBUG_TYPE_FIXUP = IMAGE_DEBUG_TYPE.FIXUP;
pub const IMAGE_DEBUG_TYPE_BORLAND = IMAGE_DEBUG_TYPE.BORLAND;

pub const MINIDUMP_THREAD_INFO_DUMP_FLAGS = enum(u32) {
    ERROR_THREAD = 1,
    EXITED_THREAD = 4,
    INVALID_CONTEXT = 16,
    INVALID_INFO = 8,
    INVALID_TEB = 32,
    WRITING_THREAD = 2,
};
pub const MINIDUMP_THREAD_INFO_ERROR_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.ERROR_THREAD;
pub const MINIDUMP_THREAD_INFO_EXITED_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.EXITED_THREAD;
pub const MINIDUMP_THREAD_INFO_INVALID_CONTEXT = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_CONTEXT;
pub const MINIDUMP_THREAD_INFO_INVALID_INFO = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_INFO;
pub const MINIDUMP_THREAD_INFO_INVALID_TEB = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_TEB;
pub const MINIDUMP_THREAD_INFO_WRITING_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.WRITING_THREAD;

pub const DEBUG_EVENT_CODE = enum(u32) {
    CREATE_PROCESS_DEBUG_EVENT = 3,
    CREATE_THREAD_DEBUG_EVENT = 2,
    EXCEPTION_DEBUG_EVENT = 1,
    EXIT_PROCESS_DEBUG_EVENT = 5,
    EXIT_THREAD_DEBUG_EVENT = 4,
    LOAD_DLL_DEBUG_EVENT = 6,
    OUTPUT_DEBUG_STRING_EVENT = 8,
    RIP_EVENT = 9,
    UNLOAD_DLL_DEBUG_EVENT = 7,
};
pub const CREATE_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_PROCESS_DEBUG_EVENT;
pub const CREATE_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_THREAD_DEBUG_EVENT;
pub const EXCEPTION_DEBUG_EVENT = DEBUG_EVENT_CODE.EXCEPTION_DEBUG_EVENT;
pub const EXIT_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_PROCESS_DEBUG_EVENT;
pub const EXIT_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_THREAD_DEBUG_EVENT;
pub const LOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.LOAD_DLL_DEBUG_EVENT;
pub const OUTPUT_DEBUG_STRING_EVENT = DEBUG_EVENT_CODE.OUTPUT_DEBUG_STRING_EVENT;
pub const RIP_EVENT = DEBUG_EVENT_CODE.RIP_EVENT;
pub const UNLOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.UNLOAD_DLL_DEBUG_EVENT;

pub const MINIDUMP_MISC_INFO_FLAGS = enum(u32) {
    ID = 1,
    TIMES = 2,
    _,
    pub fn initFlags(o: struct {
        ID: u1 = 0,
        TIMES: u1 = 0,
    }) MINIDUMP_MISC_INFO_FLAGS {
        return @as(MINIDUMP_MISC_INFO_FLAGS, @enumFromInt(
              (if (o.ID == 1) @intFromEnum(MINIDUMP_MISC_INFO_FLAGS.ID) else 0)
            | (if (o.TIMES == 1) @intFromEnum(MINIDUMP_MISC_INFO_FLAGS.TIMES) else 0)
        ));
    }
};
pub const MINIDUMP_MISC1_PROCESS_ID = MINIDUMP_MISC_INFO_FLAGS.ID;
pub const MINIDUMP_MISC1_PROCESS_TIMES = MINIDUMP_MISC_INFO_FLAGS.TIMES;

pub const MODLOAD_DATA_TYPE = enum(u32) {
    DEBUGDIRS = 1,
    CVMISC = 2,
};
pub const DBHHEADER_DEBUGDIRS = MODLOAD_DATA_TYPE.DEBUGDIRS;
pub const DBHHEADER_CVMISC = MODLOAD_DATA_TYPE.CVMISC;

pub const CONTEXT_FLAGS = enum(u32) {
    AMD64 = 1048576,
    CONTROL_AMD64 = 1048577,
    INTEGER_AMD64 = 1048578,
    SEGMENTS_AMD64 = 1048580,
    FLOATING_POINT_AMD64 = 1048584,
    DEBUG_REGISTERS_AMD64 = 1048592,
    FULL_AMD64 = 1048587,
    ALL_AMD64 = 1048607,
    XSTATE_AMD64 = 1048640,
    KERNEL_CET_AMD64 = 1048704,
    KERNEL_DEBUGGER_AMD64 = 67108864,
    EXCEPTION_ACTIVE_AMD64 = 134217728,
    SERVICE_ACTIVE_AMD64 = 268435456,
    EXCEPTION_REQUEST_AMD64 = 1073741824,
    EXCEPTION_REPORTING_AMD64 = 2147483648,
    UNWOUND_TO_CALL_AMD64 = 536870912,
    X86 = 65536,
    CONTROL_X86 = 65537,
    INTEGER_X86 = 65538,
    SEGMENTS_X86 = 65540,
    FLOATING_POINT_X86 = 65544,
    DEBUG_REGISTERS_X86 = 65552,
    EXTENDED_REGISTERS_X86 = 65568,
    FULL_X86 = 65543,
    ALL_X86 = 65599,
    XSTATE_X86 = 65600,
    // EXCEPTION_ACTIVE_X86 = 134217728, this enum value conflicts with EXCEPTION_ACTIVE_AMD64
    // SERVICE_ACTIVE_X86 = 268435456, this enum value conflicts with SERVICE_ACTIVE_AMD64
    // EXCEPTION_REQUEST_X86 = 1073741824, this enum value conflicts with EXCEPTION_REQUEST_AMD64
    // EXCEPTION_REPORTING_X86 = 2147483648, this enum value conflicts with EXCEPTION_REPORTING_AMD64
    ARM64 = 4194304,
    CONTROL_ARM64 = 4194305,
    INTEGER_ARM64 = 4194306,
    FLOATING_POINT_ARM64 = 4194308,
    DEBUG_REGISTERS_ARM64 = 4194312,
    X18_ARM64 = 4194320,
    FULL_ARM64 = 4194311,
    ALL_ARM64 = 4194335,
    // EXCEPTION_ACTIVE_ARM64 = 134217728, this enum value conflicts with EXCEPTION_ACTIVE_AMD64
    // SERVICE_ACTIVE_ARM64 = 268435456, this enum value conflicts with SERVICE_ACTIVE_AMD64
    // EXCEPTION_REQUEST_ARM64 = 1073741824, this enum value conflicts with EXCEPTION_REQUEST_AMD64
    // EXCEPTION_REPORTING_ARM64 = 2147483648, this enum value conflicts with EXCEPTION_REPORTING_AMD64
    // UNWOUND_TO_CALL_ARM64 = 536870912, this enum value conflicts with UNWOUND_TO_CALL_AMD64
    // RET_TO_GUEST_ARM64 = 1073741824, this enum value conflicts with EXCEPTION_REQUEST_AMD64
    ARM = 2097152,
    CONTROL_ARM = 2097153,
    INTEGER_ARM = 2097154,
    FLOATING_POINT_ARM = 2097156,
    DEBUG_REGISTERS_ARM = 2097160,
    FULL_ARM = 2097159,
    ALL_ARM = 2097167,
    // EXCEPTION_ACTIVE_ARM = 134217728, this enum value conflicts with EXCEPTION_ACTIVE_AMD64
    // SERVICE_ACTIVE_ARM = 268435456, this enum value conflicts with SERVICE_ACTIVE_AMD64
    // EXCEPTION_REQUEST_ARM = 1073741824, this enum value conflicts with EXCEPTION_REQUEST_AMD64
    // EXCEPTION_REPORTING_ARM = 2147483648, this enum value conflicts with EXCEPTION_REPORTING_AMD64
    // UNWOUND_TO_CALL_ARM = 536870912, this enum value conflicts with UNWOUND_TO_CALL_AMD64
    _,
    pub fn initFlags(o: struct {
        AMD64: u1 = 0,
        CONTROL_AMD64: u1 = 0,
        INTEGER_AMD64: u1 = 0,
        SEGMENTS_AMD64: u1 = 0,
        FLOATING_POINT_AMD64: u1 = 0,
        DEBUG_REGISTERS_AMD64: u1 = 0,
        FULL_AMD64: u1 = 0,
        ALL_AMD64: u1 = 0,
        XSTATE_AMD64: u1 = 0,
        KERNEL_CET_AMD64: u1 = 0,
        KERNEL_DEBUGGER_AMD64: u1 = 0,
        EXCEPTION_ACTIVE_AMD64: u1 = 0,
        SERVICE_ACTIVE_AMD64: u1 = 0,
        EXCEPTION_REQUEST_AMD64: u1 = 0,
        EXCEPTION_REPORTING_AMD64: u1 = 0,
        UNWOUND_TO_CALL_AMD64: u1 = 0,
        X86: u1 = 0,
        CONTROL_X86: u1 = 0,
        INTEGER_X86: u1 = 0,
        SEGMENTS_X86: u1 = 0,
        FLOATING_POINT_X86: u1 = 0,
        DEBUG_REGISTERS_X86: u1 = 0,
        EXTENDED_REGISTERS_X86: u1 = 0,
        FULL_X86: u1 = 0,
        ALL_X86: u1 = 0,
        XSTATE_X86: u1 = 0,
        ARM64: u1 = 0,
        CONTROL_ARM64: u1 = 0,
        INTEGER_ARM64: u1 = 0,
        FLOATING_POINT_ARM64: u1 = 0,
        DEBUG_REGISTERS_ARM64: u1 = 0,
        X18_ARM64: u1 = 0,
        FULL_ARM64: u1 = 0,
        ALL_ARM64: u1 = 0,
        ARM: u1 = 0,
        CONTROL_ARM: u1 = 0,
        INTEGER_ARM: u1 = 0,
        FLOATING_POINT_ARM: u1 = 0,
        DEBUG_REGISTERS_ARM: u1 = 0,
        FULL_ARM: u1 = 0,
        ALL_ARM: u1 = 0,
    }) CONTEXT_FLAGS {
        return @as(CONTEXT_FLAGS, @enumFromInt(
              (if (o.AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.AMD64) else 0)
            | (if (o.CONTROL_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.CONTROL_AMD64) else 0)
            | (if (o.INTEGER_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.INTEGER_AMD64) else 0)
            | (if (o.SEGMENTS_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.SEGMENTS_AMD64) else 0)
            | (if (o.FLOATING_POINT_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.FLOATING_POINT_AMD64) else 0)
            | (if (o.DEBUG_REGISTERS_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.DEBUG_REGISTERS_AMD64) else 0)
            | (if (o.FULL_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.FULL_AMD64) else 0)
            | (if (o.ALL_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.ALL_AMD64) else 0)
            | (if (o.XSTATE_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.XSTATE_AMD64) else 0)
            | (if (o.KERNEL_CET_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.KERNEL_CET_AMD64) else 0)
            | (if (o.KERNEL_DEBUGGER_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.KERNEL_DEBUGGER_AMD64) else 0)
            | (if (o.EXCEPTION_ACTIVE_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.EXCEPTION_ACTIVE_AMD64) else 0)
            | (if (o.SERVICE_ACTIVE_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.SERVICE_ACTIVE_AMD64) else 0)
            | (if (o.EXCEPTION_REQUEST_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64) else 0)
            | (if (o.EXCEPTION_REPORTING_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.EXCEPTION_REPORTING_AMD64) else 0)
            | (if (o.UNWOUND_TO_CALL_AMD64 == 1) @intFromEnum(CONTEXT_FLAGS.UNWOUND_TO_CALL_AMD64) else 0)
            | (if (o.X86 == 1) @intFromEnum(CONTEXT_FLAGS.X86) else 0)
            | (if (o.CONTROL_X86 == 1) @intFromEnum(CONTEXT_FLAGS.CONTROL_X86) else 0)
            | (if (o.INTEGER_X86 == 1) @intFromEnum(CONTEXT_FLAGS.INTEGER_X86) else 0)
            | (if (o.SEGMENTS_X86 == 1) @intFromEnum(CONTEXT_FLAGS.SEGMENTS_X86) else 0)
            | (if (o.FLOATING_POINT_X86 == 1) @intFromEnum(CONTEXT_FLAGS.FLOATING_POINT_X86) else 0)
            | (if (o.DEBUG_REGISTERS_X86 == 1) @intFromEnum(CONTEXT_FLAGS.DEBUG_REGISTERS_X86) else 0)
            | (if (o.EXTENDED_REGISTERS_X86 == 1) @intFromEnum(CONTEXT_FLAGS.EXTENDED_REGISTERS_X86) else 0)
            | (if (o.FULL_X86 == 1) @intFromEnum(CONTEXT_FLAGS.FULL_X86) else 0)
            | (if (o.ALL_X86 == 1) @intFromEnum(CONTEXT_FLAGS.ALL_X86) else 0)
            | (if (o.XSTATE_X86 == 1) @intFromEnum(CONTEXT_FLAGS.XSTATE_X86) else 0)
            | (if (o.ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.ARM64) else 0)
            | (if (o.CONTROL_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.CONTROL_ARM64) else 0)
            | (if (o.INTEGER_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.INTEGER_ARM64) else 0)
            | (if (o.FLOATING_POINT_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.FLOATING_POINT_ARM64) else 0)
            | (if (o.DEBUG_REGISTERS_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.DEBUG_REGISTERS_ARM64) else 0)
            | (if (o.X18_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.X18_ARM64) else 0)
            | (if (o.FULL_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.FULL_ARM64) else 0)
            | (if (o.ALL_ARM64 == 1) @intFromEnum(CONTEXT_FLAGS.ALL_ARM64) else 0)
            | (if (o.ARM == 1) @intFromEnum(CONTEXT_FLAGS.ARM) else 0)
            | (if (o.CONTROL_ARM == 1) @intFromEnum(CONTEXT_FLAGS.CONTROL_ARM) else 0)
            | (if (o.INTEGER_ARM == 1) @intFromEnum(CONTEXT_FLAGS.INTEGER_ARM) else 0)
            | (if (o.FLOATING_POINT_ARM == 1) @intFromEnum(CONTEXT_FLAGS.FLOATING_POINT_ARM) else 0)
            | (if (o.DEBUG_REGISTERS_ARM == 1) @intFromEnum(CONTEXT_FLAGS.DEBUG_REGISTERS_ARM) else 0)
            | (if (o.FULL_ARM == 1) @intFromEnum(CONTEXT_FLAGS.FULL_ARM) else 0)
            | (if (o.ALL_ARM == 1) @intFromEnum(CONTEXT_FLAGS.ALL_ARM) else 0)
        ));
    }
};
pub const CONTEXT_AMD64 = CONTEXT_FLAGS.AMD64;
pub const CONTEXT_CONTROL_AMD64 = CONTEXT_FLAGS.CONTROL_AMD64;
pub const CONTEXT_INTEGER_AMD64 = CONTEXT_FLAGS.INTEGER_AMD64;
pub const CONTEXT_SEGMENTS_AMD64 = CONTEXT_FLAGS.SEGMENTS_AMD64;
pub const CONTEXT_FLOATING_POINT_AMD64 = CONTEXT_FLAGS.FLOATING_POINT_AMD64;
pub const CONTEXT_DEBUG_REGISTERS_AMD64 = CONTEXT_FLAGS.DEBUG_REGISTERS_AMD64;
pub const CONTEXT_FULL_AMD64 = CONTEXT_FLAGS.FULL_AMD64;
pub const CONTEXT_ALL_AMD64 = CONTEXT_FLAGS.ALL_AMD64;
pub const CONTEXT_XSTATE_AMD64 = CONTEXT_FLAGS.XSTATE_AMD64;
pub const CONTEXT_KERNEL_CET_AMD64 = CONTEXT_FLAGS.KERNEL_CET_AMD64;
pub const CONTEXT_KERNEL_DEBUGGER_AMD64 = CONTEXT_FLAGS.KERNEL_DEBUGGER_AMD64;
pub const CONTEXT_EXCEPTION_ACTIVE_AMD64 = CONTEXT_FLAGS.EXCEPTION_ACTIVE_AMD64;
pub const CONTEXT_SERVICE_ACTIVE_AMD64 = CONTEXT_FLAGS.SERVICE_ACTIVE_AMD64;
pub const CONTEXT_EXCEPTION_REQUEST_AMD64 = CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64;
pub const CONTEXT_EXCEPTION_REPORTING_AMD64 = CONTEXT_FLAGS.EXCEPTION_REPORTING_AMD64;
pub const CONTEXT_UNWOUND_TO_CALL_AMD64 = CONTEXT_FLAGS.UNWOUND_TO_CALL_AMD64;
pub const CONTEXT_X86 = CONTEXT_FLAGS.X86;
pub const CONTEXT_CONTROL_X86 = CONTEXT_FLAGS.CONTROL_X86;
pub const CONTEXT_INTEGER_X86 = CONTEXT_FLAGS.INTEGER_X86;
pub const CONTEXT_SEGMENTS_X86 = CONTEXT_FLAGS.SEGMENTS_X86;
pub const CONTEXT_FLOATING_POINT_X86 = CONTEXT_FLAGS.FLOATING_POINT_X86;
pub const CONTEXT_DEBUG_REGISTERS_X86 = CONTEXT_FLAGS.DEBUG_REGISTERS_X86;
pub const CONTEXT_EXTENDED_REGISTERS_X86 = CONTEXT_FLAGS.EXTENDED_REGISTERS_X86;
pub const CONTEXT_FULL_X86 = CONTEXT_FLAGS.FULL_X86;
pub const CONTEXT_ALL_X86 = CONTEXT_FLAGS.ALL_X86;
pub const CONTEXT_XSTATE_X86 = CONTEXT_FLAGS.XSTATE_X86;
pub const CONTEXT_EXCEPTION_ACTIVE_X86 = CONTEXT_FLAGS.EXCEPTION_ACTIVE_AMD64;
pub const CONTEXT_SERVICE_ACTIVE_X86 = CONTEXT_FLAGS.SERVICE_ACTIVE_AMD64;
pub const CONTEXT_EXCEPTION_REQUEST_X86 = CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64;
pub const CONTEXT_EXCEPTION_REPORTING_X86 = CONTEXT_FLAGS.EXCEPTION_REPORTING_AMD64;
pub const CONTEXT_ARM64 = CONTEXT_FLAGS.ARM64;
pub const CONTEXT_CONTROL_ARM64 = CONTEXT_FLAGS.CONTROL_ARM64;
pub const CONTEXT_INTEGER_ARM64 = CONTEXT_FLAGS.INTEGER_ARM64;
pub const CONTEXT_FLOATING_POINT_ARM64 = CONTEXT_FLAGS.FLOATING_POINT_ARM64;
pub const CONTEXT_DEBUG_REGISTERS_ARM64 = CONTEXT_FLAGS.DEBUG_REGISTERS_ARM64;
pub const CONTEXT_X18_ARM64 = CONTEXT_FLAGS.X18_ARM64;
pub const CONTEXT_FULL_ARM64 = CONTEXT_FLAGS.FULL_ARM64;
pub const CONTEXT_ALL_ARM64 = CONTEXT_FLAGS.ALL_ARM64;
pub const CONTEXT_EXCEPTION_ACTIVE_ARM64 = CONTEXT_FLAGS.EXCEPTION_ACTIVE_AMD64;
pub const CONTEXT_SERVICE_ACTIVE_ARM64 = CONTEXT_FLAGS.SERVICE_ACTIVE_AMD64;
pub const CONTEXT_EXCEPTION_REQUEST_ARM64 = CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64;
pub const CONTEXT_EXCEPTION_REPORTING_ARM64 = CONTEXT_FLAGS.EXCEPTION_REPORTING_AMD64;
pub const CONTEXT_UNWOUND_TO_CALL_ARM64 = CONTEXT_FLAGS.UNWOUND_TO_CALL_AMD64;
pub const CONTEXT_RET_TO_GUEST_ARM64 = CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64;
pub const CONTEXT_ARM = CONTEXT_FLAGS.ARM;
pub const CONTEXT_CONTROL_ARM = CONTEXT_FLAGS.CONTROL_ARM;
pub const CONTEXT_INTEGER_ARM = CONTEXT_FLAGS.INTEGER_ARM;
pub const CONTEXT_FLOATING_POINT_ARM = CONTEXT_FLAGS.FLOATING_POINT_ARM;
pub const CONTEXT_DEBUG_REGISTERS_ARM = CONTEXT_FLAGS.DEBUG_REGISTERS_ARM;
pub const CONTEXT_FULL_ARM = CONTEXT_FLAGS.FULL_ARM;
pub const CONTEXT_ALL_ARM = CONTEXT_FLAGS.ALL_ARM;
pub const CONTEXT_EXCEPTION_ACTIVE_ARM = CONTEXT_FLAGS.EXCEPTION_ACTIVE_AMD64;
pub const CONTEXT_SERVICE_ACTIVE_ARM = CONTEXT_FLAGS.SERVICE_ACTIVE_AMD64;
pub const CONTEXT_EXCEPTION_REQUEST_ARM = CONTEXT_FLAGS.EXCEPTION_REQUEST_AMD64;
pub const CONTEXT_EXCEPTION_REPORTING_ARM = CONTEXT_FLAGS.EXCEPTION_REPORTING_AMD64;
pub const CONTEXT_UNWOUND_TO_CALL_ARM = CONTEXT_FLAGS.UNWOUND_TO_CALL_AMD64;

pub const WOW64_CONTEXT_FLAGS = enum(u32) {
    X86 = 65536,
    CONTROL = 65537,
    INTEGER = 65538,
    SEGMENTS = 65540,
    FLOATING_POINT = 65544,
    DEBUG_REGISTERS = 65552,
    EXTENDED_REGISTERS = 65568,
    FULL = 65543,
    ALL = 65599,
    XSTATE = 65600,
    EXCEPTION_ACTIVE = 134217728,
    SERVICE_ACTIVE = 268435456,
    EXCEPTION_REQUEST = 1073741824,
    EXCEPTION_REPORTING = 2147483648,
    _,
    pub fn initFlags(o: struct {
        X86: u1 = 0,
        CONTROL: u1 = 0,
        INTEGER: u1 = 0,
        SEGMENTS: u1 = 0,
        FLOATING_POINT: u1 = 0,
        DEBUG_REGISTERS: u1 = 0,
        EXTENDED_REGISTERS: u1 = 0,
        FULL: u1 = 0,
        ALL: u1 = 0,
        XSTATE: u1 = 0,
        EXCEPTION_ACTIVE: u1 = 0,
        SERVICE_ACTIVE: u1 = 0,
        EXCEPTION_REQUEST: u1 = 0,
        EXCEPTION_REPORTING: u1 = 0,
    }) WOW64_CONTEXT_FLAGS {
        return @as(WOW64_CONTEXT_FLAGS, @enumFromInt(
              (if (o.X86 == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.X86) else 0)
            | (if (o.CONTROL == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.CONTROL) else 0)
            | (if (o.INTEGER == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.INTEGER) else 0)
            | (if (o.SEGMENTS == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.SEGMENTS) else 0)
            | (if (o.FLOATING_POINT == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.FLOATING_POINT) else 0)
            | (if (o.DEBUG_REGISTERS == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.DEBUG_REGISTERS) else 0)
            | (if (o.EXTENDED_REGISTERS == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.EXTENDED_REGISTERS) else 0)
            | (if (o.FULL == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.FULL) else 0)
            | (if (o.ALL == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.ALL) else 0)
            | (if (o.XSTATE == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.XSTATE) else 0)
            | (if (o.EXCEPTION_ACTIVE == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.EXCEPTION_ACTIVE) else 0)
            | (if (o.SERVICE_ACTIVE == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.SERVICE_ACTIVE) else 0)
            | (if (o.EXCEPTION_REQUEST == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.EXCEPTION_REQUEST) else 0)
            | (if (o.EXCEPTION_REPORTING == 1) @intFromEnum(WOW64_CONTEXT_FLAGS.EXCEPTION_REPORTING) else 0)
        ));
    }
};
pub const WOW64_CONTEXT_X86 = WOW64_CONTEXT_FLAGS.X86;
pub const WOW64_CONTEXT_CONTROL = WOW64_CONTEXT_FLAGS.CONTROL;
pub const WOW64_CONTEXT_INTEGER = WOW64_CONTEXT_FLAGS.INTEGER;
pub const WOW64_CONTEXT_SEGMENTS = WOW64_CONTEXT_FLAGS.SEGMENTS;
pub const WOW64_CONTEXT_FLOATING_POINT = WOW64_CONTEXT_FLAGS.FLOATING_POINT;
pub const WOW64_CONTEXT_DEBUG_REGISTERS = WOW64_CONTEXT_FLAGS.DEBUG_REGISTERS;
pub const WOW64_CONTEXT_EXTENDED_REGISTERS = WOW64_CONTEXT_FLAGS.EXTENDED_REGISTERS;
pub const WOW64_CONTEXT_FULL = WOW64_CONTEXT_FLAGS.FULL;
pub const WOW64_CONTEXT_ALL = WOW64_CONTEXT_FLAGS.ALL;
pub const WOW64_CONTEXT_XSTATE = WOW64_CONTEXT_FLAGS.XSTATE;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE = WOW64_CONTEXT_FLAGS.EXCEPTION_ACTIVE;
pub const WOW64_CONTEXT_SERVICE_ACTIVE = WOW64_CONTEXT_FLAGS.SERVICE_ACTIVE;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST = WOW64_CONTEXT_FLAGS.EXCEPTION_REQUEST;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING = WOW64_CONTEXT_FLAGS.EXCEPTION_REPORTING;








pub const EXCEPTION_DEBUG_INFO = extern struct {
    ExceptionRecord: EXCEPTION_RECORD,
    dwFirstChance: u32,
};

pub const CREATE_THREAD_DEBUG_INFO = extern struct {
    hThread: ?HANDLE,
    lpThreadLocalBase: ?*anyopaque,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
};

pub const CREATE_PROCESS_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    lpBaseOfImage: ?*anyopaque,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpThreadLocalBase: ?*anyopaque,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
    lpImageName: ?*anyopaque,
    fUnicode: u16,
};

pub const EXIT_THREAD_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const EXIT_PROCESS_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const LOAD_DLL_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    lpBaseOfDll: ?*anyopaque,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpImageName: ?*anyopaque,
    fUnicode: u16,
};

pub const UNLOAD_DLL_DEBUG_INFO = extern struct {
    lpBaseOfDll: ?*anyopaque,
};

pub const OUTPUT_DEBUG_STRING_INFO = extern struct {
    lpDebugStringData: ?PSTR,
    fUnicode: u16,
    nDebugStringLength: u16,
};

pub const RIP_INFO = extern struct {
    dwError: u32,
    dwType: RIP_INFO_TYPE,
};

pub const DEBUG_EVENT = extern struct {
    dwDebugEventCode: DEBUG_EVENT_CODE,
    dwProcessId: u32,
    dwThreadId: u32,
    u: extern union {
        Exception: EXCEPTION_DEBUG_INFO,
        CreateThread: CREATE_THREAD_DEBUG_INFO,
        CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
        ExitThread: EXIT_THREAD_DEBUG_INFO,
        ExitProcess: EXIT_PROCESS_DEBUG_INFO,
        LoadDll: LOAD_DLL_DEBUG_INFO,
        UnloadDll: UNLOAD_DLL_DEBUG_INFO,
        DebugString: OUTPUT_DEBUG_STRING_INFO,
        RipInfo: RIP_INFO,
    },
};

pub const APC_CALLBACK_DATA = extern struct {
    Parameter: usize,
    ContextRecord: ?*CONTEXT,
    Reserved0: usize,
    Reserved1: usize,
};














pub const M128A = extern struct {
    Low: u64,
    High: i64,
};


pub const XSAVE_AREA_HEADER = extern struct {
    Mask: u64,
    CompactionMask: u64,
    Reserved2: [6]u64,
};

pub const XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};


pub const ARM64_NT_NEON128 = extern union {
    Anonymous: extern struct {
        Low: u64,
        High: i64,
    },
    D: [2]f64,
    S: [4]f32,
    H: [8]u16,
    B: [16]u8,
};



pub const LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};


pub const WOW64_FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Cr0NpxState: u32,
};

pub const WOW64_CONTEXT = extern struct {
    ContextFlags: WOW64_CONTEXT_FLAGS,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: WOW64_FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

pub const WOW64_LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};

pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};

pub const EXCEPTION_RECORD = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ExceptionAddress: ?*anyopaque,
    NumberParameters: u32,
    ExceptionInformation: [15]usize,
};

pub const EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: u32,
    ExceptionAddress: u32,
    NumberParameters: u32,
    ExceptionInformation: [15]u32,
};

pub const EXCEPTION_RECORD64 = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const EXCEPTION_POINTERS = extern struct {
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ContextRecord: ?*CONTEXT,
};

pub const XSTATE_FEATURE = extern struct {
    Offset: u32,
    Size: u32,
};

pub const XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: u64,
    EnabledVolatileFeatures: u64,
    Size: u32,
    Anonymous: extern union {
        ControlFlags: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
    Features: [64]XSTATE_FEATURE,
    EnabledSupervisorFeatures: u64,
    AlignedFeatures: u64,
    AllFeatureSize: u32,
    AllFeatures: [64]u32,
    EnabledUserVisibleSupervisorFeatures: u64,
    ExtendedFeatureDisableFeatures: u64,
    AllNonLargeFeatureSize: u32,
    Spare: u32,
};

pub const IMAGE_FILE_HEADER = extern struct {
    Machine: IMAGE_FILE_MACHINE,
    NumberOfSections: u16,
    TimeDateStamp: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
    SizeOfOptionalHeader: u16,
    Characteristics: IMAGE_FILE_CHARACTERISTICS,
};

pub const IMAGE_DATA_DIRECTORY = extern struct {
    VirtualAddress: u32,
    Size: u32,
};

pub const IMAGE_OPTIONAL_HEADER32 = extern struct {
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    ImageBase: u32,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: IMAGE_SUBSYSTEM,
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS,
    SizeOfStackReserve: u32,
    SizeOfStackCommit: u32,
    SizeOfHeapReserve: u32,
    SizeOfHeapCommit: u32,
    /// Deprecated
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    BaseOfBss: u32,
    GprMask: u32,
    CprMask: [4]u32,
    GpValue: u32,
};

pub const IMAGE_OPTIONAL_HEADER64 = extern struct {
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC align(4),
    MajorLinkerVersion: u8 align(4),
    MinorLinkerVersion: u8 align(4),
    SizeOfCode: u32 align(4),
    SizeOfInitializedData: u32 align(4),
    SizeOfUninitializedData: u32 align(4),
    AddressOfEntryPoint: u32 align(4),
    BaseOfCode: u32 align(4),
    ImageBase: u64 align(4),
    SectionAlignment: u32 align(4),
    FileAlignment: u32 align(4),
    MajorOperatingSystemVersion: u16 align(4),
    MinorOperatingSystemVersion: u16 align(4),
    MajorImageVersion: u16 align(4),
    MinorImageVersion: u16 align(4),
    MajorSubsystemVersion: u16 align(4),
    MinorSubsystemVersion: u16 align(4),
    Win32VersionValue: u32 align(4),
    SizeOfImage: u32 align(4),
    SizeOfHeaders: u32 align(4),
    CheckSum: u32 align(4),
    Subsystem: IMAGE_SUBSYSTEM align(4),
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS align(4),
    SizeOfStackReserve: u64 align(4),
    SizeOfStackCommit: u64 align(4),
    SizeOfHeapReserve: u64 align(4),
    SizeOfHeapCommit: u64 align(4),
    /// Deprecated
    LoaderFlags: u32 align(4),
    NumberOfRvaAndSizes: u32 align(4),
    DataDirectory: [16]IMAGE_DATA_DIRECTORY align(4),
};

pub const IMAGE_NT_HEADERS64 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER64,
};

pub const IMAGE_NT_HEADERS32 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER32,
};

pub const IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};

pub const IMAGE_SECTION_HEADER = extern struct {
    Name: [8]u8,
    Misc: extern union {
        PhysicalAddress: u32,
        VirtualSize: u32,
    },
    VirtualAddress: u32,
    SizeOfRawData: u32,
    PointerToRawData: u32,
    PointerToRelocations: u32,
    PointerToLinenumbers: u32,
    NumberOfRelocations: u16,
    NumberOfLinenumbers: u16,
    Characteristics: IMAGE_SECTION_CHARACTERISTICS,
};

pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: u16,
    Catalog: u16,
    CatalogOffset: u32,
    Reserved: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY32 = extern struct {
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u32,
    DeCommitTotalFreeThreshold: u32,
    LockPrefixTable: u32,
    MaximumAllocationSize: u32,
    VirtualMemoryThreshold: u32,
    ProcessHeapFlags: u32,
    ProcessAffinityMask: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u32,
    SecurityCookie: u32,
    SEHandlerTable: u32,
    SEHandlerCount: u32,
    GuardCFCheckFunctionPointer: u32,
    GuardCFDispatchFunctionPointer: u32,
    GuardCFFunctionTable: u32,
    GuardCFFunctionCount: u32,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u32,
    GuardAddressTakenIatEntryCount: u32,
    GuardLongJumpTargetTable: u32,
    GuardLongJumpTargetCount: u32,
    DynamicValueRelocTable: u32,
    CHPEMetadataPointer: u32,
    GuardRFFailureRoutine: u32,
    GuardRFFailureRoutineFunctionPointer: u32,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u32,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u32,
    VolatileMetadataPointer: u32,
    GuardEHContinuationTable: u32,
    GuardEHContinuationCount: u32,
    GuardXFGCheckFunctionPointer: u32,
    GuardXFGDispatchFunctionPointer: u32,
    GuardXFGTableDispatchFunctionPointer: u32,
    CastGuardOsDeterminedFailureMode: u32,
    GuardMemcpyFunctionPointer: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY64 = extern struct {
    Size: u32 align(4),
    TimeDateStamp: u32 align(4),
    MajorVersion: u16 align(4),
    MinorVersion: u16 align(4),
    GlobalFlagsClear: u32 align(4),
    GlobalFlagsSet: u32 align(4),
    CriticalSectionDefaultTimeout: u32 align(4),
    DeCommitFreeBlockThreshold: u64 align(4),
    DeCommitTotalFreeThreshold: u64 align(4),
    LockPrefixTable: u64 align(4),
    MaximumAllocationSize: u64 align(4),
    VirtualMemoryThreshold: u64 align(4),
    ProcessAffinityMask: u64 align(4),
    ProcessHeapFlags: u32 align(4),
    CSDVersion: u16 align(4),
    DependentLoadFlags: u16 align(4),
    EditList: u64 align(4),
    SecurityCookie: u64 align(4),
    SEHandlerTable: u64 align(4),
    SEHandlerCount: u64 align(4),
    GuardCFCheckFunctionPointer: u64 align(4),
    GuardCFDispatchFunctionPointer: u64 align(4),
    GuardCFFunctionTable: u64 align(4),
    GuardCFFunctionCount: u64 align(4),
    GuardFlags: u32 align(4),
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY align(4),
    GuardAddressTakenIatEntryTable: u64 align(4),
    GuardAddressTakenIatEntryCount: u64 align(4),
    GuardLongJumpTargetTable: u64 align(4),
    GuardLongJumpTargetCount: u64 align(4),
    DynamicValueRelocTable: u64 align(4),
    CHPEMetadataPointer: u64 align(4),
    GuardRFFailureRoutine: u64 align(4),
    GuardRFFailureRoutineFunctionPointer: u64 align(4),
    DynamicValueRelocTableOffset: u32 align(4),
    DynamicValueRelocTableSection: u16 align(4),
    Reserved2: u16 align(4),
    GuardRFVerifyStackPointerFunctionPointer: u64 align(4),
    HotPatchTableOffset: u32 align(4),
    Reserved3: u32 align(4),
    EnclaveConfigurationPointer: u64 align(4),
    VolatileMetadataPointer: u64 align(4),
    GuardEHContinuationTable: u64 align(4),
    GuardEHContinuationCount: u64 align(4),
    GuardXFGCheckFunctionPointer: u64 align(4),
    GuardXFGDispatchFunctionPointer: u64 align(4),
    GuardXFGTableDispatchFunctionPointer: u64 align(4),
    CastGuardOsDeterminedFailureMode: u64 align(4),
    GuardMemcpyFunctionPointer: u64 align(4),
};

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: extern union {
        UnwindData: u32,
        Anonymous: extern struct {
            _bitfield: u32,
        },
    },
};

pub const IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    Anonymous: extern union {
        UnwindInfoAddress: u32,
        UnwindData: u32,
    },
};

pub const IMAGE_DEBUG_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Type: IMAGE_DEBUG_TYPE,
    SizeOfData: u32,
    AddressOfRawData: u32,
    PointerToRawData: u32,
};

pub const IMAGE_COFF_SYMBOLS_HEADER = extern struct {
    NumberOfSymbols: u32,
    LvaToFirstSymbol: u32,
    NumberOfLinenumbers: u32,
    LvaToFirstLinenumber: u32,
    RvaToFirstByteOfCode: u32,
    RvaToLastByteOfCode: u32,
    RvaToFirstByteOfData: u32,
    RvaToLastByteOfData: u32,
};

pub const FPO_DATA = extern struct {
    ulOffStart: u32,
    cbProcSize: u32,
    cdwLocals: u32,
    cdwParams: u16,
    _bitfield: u16,
};

pub const IMAGE_FUNCTION_ENTRY = extern struct {
    StartingAddress: u32,
    EndingAddress: u32,
    EndOfPrologue: u32,
};

pub const IMAGE_FUNCTION_ENTRY64 = extern struct {
    StartingAddress: u64 align(4),
    EndingAddress: u64 align(4),
    Anonymous: extern union {
        EndOfPrologue: u64 align(4),
        UnwindInfoAddress: u64 align(4),
    } align(4),
};

pub const IMAGE_COR20_HEADER = extern struct {
    cb: u32,
    MajorRuntimeVersion: u16,
    MinorRuntimeVersion: u16,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: u32,
    Anonymous: extern union {
        EntryPointToken: u32,
        EntryPointRVA: u32,
    },
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
};

pub const PVECTORED_EXCEPTION_HANDLER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const LPTOP_LEVEL_EXCEPTION_FILTER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
    else => *const fn(
        ExceptionInfo: ?*EXCEPTION_POINTERS,
    ) callconv(@import("std").os.windows.WINAPI) i32,
} ;

pub const WCT_OBJECT_TYPE = enum(i32) {
    CriticalSectionType = 1,
    SendMessageType = 2,
    MutexType = 3,
    AlpcType = 4,
    ComType = 5,
    ThreadWaitType = 6,
    ProcessWaitType = 7,
    ThreadType = 8,
    ComActivationType = 9,
    UnknownType = 10,
    SocketIoType = 11,
    SmbIoType = 12,
    MaxType = 13,
};
pub const WctCriticalSectionType = WCT_OBJECT_TYPE.CriticalSectionType;
pub const WctSendMessageType = WCT_OBJECT_TYPE.SendMessageType;
pub const WctMutexType = WCT_OBJECT_TYPE.MutexType;
pub const WctAlpcType = WCT_OBJECT_TYPE.AlpcType;
pub const WctComType = WCT_OBJECT_TYPE.ComType;
pub const WctThreadWaitType = WCT_OBJECT_TYPE.ThreadWaitType;
pub const WctProcessWaitType = WCT_OBJECT_TYPE.ProcessWaitType;
pub const WctThreadType = WCT_OBJECT_TYPE.ThreadType;
pub const WctComActivationType = WCT_OBJECT_TYPE.ComActivationType;
pub const WctUnknownType = WCT_OBJECT_TYPE.UnknownType;
pub const WctSocketIoType = WCT_OBJECT_TYPE.SocketIoType;
pub const WctSmbIoType = WCT_OBJECT_TYPE.SmbIoType;
pub const WctMaxType = WCT_OBJECT_TYPE.MaxType;

pub const WCT_OBJECT_STATUS = enum(i32) {
    NoAccess = 1,
    Running = 2,
    Blocked = 3,
    PidOnly = 4,
    PidOnlyRpcss = 5,
    Owned = 6,
    NotOwned = 7,
    Abandoned = 8,
    Unknown = 9,
    Error = 10,
    Max = 11,
};
pub const WctStatusNoAccess = WCT_OBJECT_STATUS.NoAccess;
pub const WctStatusRunning = WCT_OBJECT_STATUS.Running;
pub const WctStatusBlocked = WCT_OBJECT_STATUS.Blocked;
pub const WctStatusPidOnly = WCT_OBJECT_STATUS.PidOnly;
pub const WctStatusPidOnlyRpcss = WCT_OBJECT_STATUS.PidOnlyRpcss;
pub const WctStatusOwned = WCT_OBJECT_STATUS.Owned;
pub const WctStatusNotOwned = WCT_OBJECT_STATUS.NotOwned;
pub const WctStatusAbandoned = WCT_OBJECT_STATUS.Abandoned;
pub const WctStatusUnknown = WCT_OBJECT_STATUS.Unknown;
pub const WctStatusError = WCT_OBJECT_STATUS.Error;
pub const WctStatusMax = WCT_OBJECT_STATUS.Max;

pub const WAITCHAIN_NODE_INFO = extern struct {
    ObjectType: WCT_OBJECT_TYPE,
    ObjectStatus: WCT_OBJECT_STATUS,
    Anonymous: extern union {
        LockObject: extern struct {
            ObjectName: [128]u16,
            Timeout: i64,
            Alertable: BOOL,
        },
        ThreadObject: extern struct {
            ProcessId: u32,
            ThreadId: u32,
            WaitTime: u32,
            ContextSwitches: u32,
        },
    },
};

pub const PWAITCHAINCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        WctHandle: ?*anyopaque,
        Context: usize,
        CallbackStatus: u32,
        NodeCount: ?*u32,
        NodeInfoArray: ?*WAITCHAIN_NODE_INFO,
        IsCycle: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        WctHandle: ?*anyopaque,
        Context: usize,
        CallbackStatus: u32,
        NodeCount: ?*u32,
        NodeInfoArray: ?*WAITCHAIN_NODE_INFO,
        IsCycle: ?*BOOL,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const PCOGETCALLSTATE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: i32,
        param1: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        param0: i32,
        param1: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PCOGETACTIVATIONSTATE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: Guid,
        param1: u32,
        param2: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        param0: Guid,
        param1: u32,
        param2: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const MINIDUMP_LOCATION_DESCRIPTOR = extern struct {
    DataSize: u32 align(4),
    Rva: u32 align(4),
};

pub const MINIDUMP_LOCATION_DESCRIPTOR64 = extern struct {
    DataSize: u64 align(4),
    Rva: u64 align(4),
};

pub const MINIDUMP_MEMORY_DESCRIPTOR = extern struct {
    StartOfMemoryRange: u64 align(4),
    Memory: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_MEMORY_DESCRIPTOR64 = extern struct {
    StartOfMemoryRange: u64 align(4),
    DataSize: u64 align(4),
};

pub const MINIDUMP_HEADER = extern struct {
    Signature: u32 align(4),
    Version: u32 align(4),
    NumberOfStreams: u32 align(4),
    StreamDirectoryRva: u32 align(4),
    CheckSum: u32 align(4),
    Anonymous: extern union {
        Reserved: u32,
        TimeDateStamp: u32,
    } align(4),
    Flags: u64 align(4),
};

pub const MINIDUMP_DIRECTORY = extern struct {
    StreamType: u32 align(4),
    Location: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_STRING = extern struct {
    Length: u32 align(4),
    Buffer: [1]u16 align(4),
};

pub const MINIDUMP_STREAM_TYPE = enum(i32) {
    UnusedStream = 0,
    ReservedStream0 = 1,
    ReservedStream1 = 2,
    ThreadListStream = 3,
    ModuleListStream = 4,
    MemoryListStream = 5,
    ExceptionStream = 6,
    SystemInfoStream = 7,
    ThreadExListStream = 8,
    Memory64ListStream = 9,
    CommentStreamA = 10,
    CommentStreamW = 11,
    HandleDataStream = 12,
    FunctionTableStream = 13,
    UnloadedModuleListStream = 14,
    MiscInfoStream = 15,
    MemoryInfoListStream = 16,
    ThreadInfoListStream = 17,
    HandleOperationListStream = 18,
    TokenStream = 19,
    JavaScriptDataStream = 20,
    SystemMemoryInfoStream = 21,
    ProcessVmCountersStream = 22,
    IptTraceStream = 23,
    ThreadNamesStream = 24,
    ceStreamNull = 32768,
    ceStreamSystemInfo = 32769,
    ceStreamException = 32770,
    ceStreamModuleList = 32771,
    ceStreamProcessList = 32772,
    ceStreamThreadList = 32773,
    ceStreamThreadContextList = 32774,
    ceStreamThreadCallStackList = 32775,
    ceStreamMemoryVirtualList = 32776,
    ceStreamMemoryPhysicalList = 32777,
    ceStreamBucketParameters = 32778,
    ceStreamProcessModuleMap = 32779,
    ceStreamDiagnosisList = 32780,
    LastReservedStream = 65535,
};
pub const UnusedStream = MINIDUMP_STREAM_TYPE.UnusedStream;
pub const ReservedStream0 = MINIDUMP_STREAM_TYPE.ReservedStream0;
pub const ReservedStream1 = MINIDUMP_STREAM_TYPE.ReservedStream1;
pub const ThreadListStream = MINIDUMP_STREAM_TYPE.ThreadListStream;
pub const ModuleListStream = MINIDUMP_STREAM_TYPE.ModuleListStream;
pub const MemoryListStream = MINIDUMP_STREAM_TYPE.MemoryListStream;
pub const ExceptionStream = MINIDUMP_STREAM_TYPE.ExceptionStream;
pub const SystemInfoStream = MINIDUMP_STREAM_TYPE.SystemInfoStream;
pub const ThreadExListStream = MINIDUMP_STREAM_TYPE.ThreadExListStream;
pub const Memory64ListStream = MINIDUMP_STREAM_TYPE.Memory64ListStream;
pub const CommentStreamA = MINIDUMP_STREAM_TYPE.CommentStreamA;
pub const CommentStreamW = MINIDUMP_STREAM_TYPE.CommentStreamW;
pub const HandleDataStream = MINIDUMP_STREAM_TYPE.HandleDataStream;
pub const FunctionTableStream = MINIDUMP_STREAM_TYPE.FunctionTableStream;
pub const UnloadedModuleListStream = MINIDUMP_STREAM_TYPE.UnloadedModuleListStream;
pub const MiscInfoStream = MINIDUMP_STREAM_TYPE.MiscInfoStream;
pub const MemoryInfoListStream = MINIDUMP_STREAM_TYPE.MemoryInfoListStream;
pub const ThreadInfoListStream = MINIDUMP_STREAM_TYPE.ThreadInfoListStream;
pub const HandleOperationListStream = MINIDUMP_STREAM_TYPE.HandleOperationListStream;
pub const TokenStream = MINIDUMP_STREAM_TYPE.TokenStream;
pub const JavaScriptDataStream = MINIDUMP_STREAM_TYPE.JavaScriptDataStream;
pub const SystemMemoryInfoStream = MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream;
pub const ProcessVmCountersStream = MINIDUMP_STREAM_TYPE.ProcessVmCountersStream;
pub const IptTraceStream = MINIDUMP_STREAM_TYPE.IptTraceStream;
pub const ThreadNamesStream = MINIDUMP_STREAM_TYPE.ThreadNamesStream;
pub const ceStreamNull = MINIDUMP_STREAM_TYPE.ceStreamNull;
pub const ceStreamSystemInfo = MINIDUMP_STREAM_TYPE.ceStreamSystemInfo;
pub const ceStreamException = MINIDUMP_STREAM_TYPE.ceStreamException;
pub const ceStreamModuleList = MINIDUMP_STREAM_TYPE.ceStreamModuleList;
pub const ceStreamProcessList = MINIDUMP_STREAM_TYPE.ceStreamProcessList;
pub const ceStreamThreadList = MINIDUMP_STREAM_TYPE.ceStreamThreadList;
pub const ceStreamThreadContextList = MINIDUMP_STREAM_TYPE.ceStreamThreadContextList;
pub const ceStreamThreadCallStackList = MINIDUMP_STREAM_TYPE.ceStreamThreadCallStackList;
pub const ceStreamMemoryVirtualList = MINIDUMP_STREAM_TYPE.ceStreamMemoryVirtualList;
pub const ceStreamMemoryPhysicalList = MINIDUMP_STREAM_TYPE.ceStreamMemoryPhysicalList;
pub const ceStreamBucketParameters = MINIDUMP_STREAM_TYPE.ceStreamBucketParameters;
pub const ceStreamProcessModuleMap = MINIDUMP_STREAM_TYPE.ceStreamProcessModuleMap;
pub const ceStreamDiagnosisList = MINIDUMP_STREAM_TYPE.ceStreamDiagnosisList;
pub const LastReservedStream = MINIDUMP_STREAM_TYPE.LastReservedStream;

pub const CPU_INFORMATION = extern union {
    X86CpuInfo: extern struct {
        VendorId: [3]u32,
        VersionInformation: u32,
        FeatureInformation: u32,
        AMDExtendedCpuFeatures: u32,
    },
    OtherCpuInfo: extern struct {
        ProcessorFeatures: [2]u64 align(4),
    },
};

pub const MINIDUMP_SYSTEM_INFO = extern struct {
    ProcessorArchitecture: PROCESSOR_ARCHITECTURE align(4),
    ProcessorLevel: u16 align(4),
    ProcessorRevision: u16 align(4),
    Anonymous1: extern union {
        Reserved0: u16,
        Anonymous: extern struct {
            NumberOfProcessors: u8,
            ProductType: u8,
        },
    } align(4),
    MajorVersion: u32 align(4),
    MinorVersion: u32 align(4),
    BuildNumber: u32 align(4),
    PlatformId: VER_PLATFORM align(4),
    CSDVersionRva: u32 align(4),
    Anonymous2: extern union {
        Reserved1: u32,
        Anonymous: extern struct {
            SuiteMask: u16,
            Reserved2: u16,
        },
    } align(4),
    Cpu: CPU_INFORMATION align(4),
};

pub const MINIDUMP_THREAD = extern struct {
    ThreadId: u32 align(4),
    SuspendCount: u32 align(4),
    PriorityClass: u32 align(4),
    Priority: u32 align(4),
    Teb: u64 align(4),
    Stack: MINIDUMP_MEMORY_DESCRIPTOR align(4),
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_THREAD_LIST = extern struct {
    NumberOfThreads: u32 align(4),
    Threads: [1]MINIDUMP_THREAD align(4),
};

pub const MINIDUMP_THREAD_EX = extern struct {
    ThreadId: u32 align(4),
    SuspendCount: u32 align(4),
    PriorityClass: u32 align(4),
    Priority: u32 align(4),
    Teb: u64 align(4),
    Stack: MINIDUMP_MEMORY_DESCRIPTOR align(4),
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    BackingStore: MINIDUMP_MEMORY_DESCRIPTOR align(4),
};

pub const MINIDUMP_THREAD_EX_LIST = extern struct {
    NumberOfThreads: u32 align(4),
    Threads: [1]MINIDUMP_THREAD_EX align(4),
};

pub const MINIDUMP_EXCEPTION = extern struct {
    ExceptionCode: u32 align(4),
    ExceptionFlags: u32 align(4),
    ExceptionRecord: u64 align(4),
    ExceptionAddress: u64 align(4),
    NumberParameters: u32 align(4),
    __unusedAlignment: u32 align(4),
    ExceptionInformation: [15]u64 align(4),
};

pub const MINIDUMP_EXCEPTION_STREAM = extern struct {
    ThreadId: u32 align(4),
    __alignment: u32 align(4),
    ExceptionRecord: MINIDUMP_EXCEPTION align(4),
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};

pub const MINIDUMP_MODULE = extern struct {
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    ModuleNameRva: u32 align(4),
    VersionInfo: VS_FIXEDFILEINFO align(4),
    CvRecord: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    MiscRecord: MINIDUMP_LOCATION_DESCRIPTOR align(4),
    Reserved0: u64 align(4),
    Reserved1: u64 align(4),
};

pub const MINIDUMP_MODULE_LIST = extern struct {
    NumberOfModules: u32 align(4),
    Modules: [1]MINIDUMP_MODULE align(4),
};

pub const MINIDUMP_MEMORY_LIST = extern struct {
    NumberOfMemoryRanges: u32 align(4),
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR align(4),
};

pub const MINIDUMP_MEMORY64_LIST = extern struct {
    NumberOfMemoryRanges: u64 align(4),
    BaseRva: u64 align(4),
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR64 align(4),
};


pub const MINIDUMP_EXCEPTION_INFORMATION64 = extern struct {
    ThreadId: u32 align(4),
    ExceptionRecord: u64 align(4),
    ContextRecord: u64 align(4),
    ClientPointers: BOOL align(4),
};

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE = enum(i32) {
    HandleObjectInformationNone = 0,
    ThreadInformation1 = 1,
    MutantInformation1 = 2,
    MutantInformation2 = 3,
    ProcessInformation1 = 4,
    ProcessInformation2 = 5,
    EventInformation1 = 6,
    SectionInformation1 = 7,
    SemaphoreInformation1 = 8,
    HandleObjectInformationTypeMax = 9,
};
pub const MiniHandleObjectInformationNone = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationNone;
pub const MiniThreadInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ThreadInformation1;
pub const MiniMutantInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation1;
pub const MiniMutantInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation2;
pub const MiniProcessInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation1;
pub const MiniProcessInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation2;
pub const MiniEventInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.EventInformation1;
pub const MiniSectionInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SectionInformation1;
pub const MiniSemaphoreInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SemaphoreInformation1;
pub const MiniHandleObjectInformationTypeMax = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationTypeMax;

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION = extern struct {
    NextInfoRva: u32 align(4),
    InfoType: u32 align(4),
    SizeOfInfo: u32 align(4),
};

pub const MINIDUMP_HANDLE_DESCRIPTOR = extern struct {
    Handle: u64 align(4),
    TypeNameRva: u32 align(4),
    ObjectNameRva: u32 align(4),
    Attributes: u32 align(4),
    GrantedAccess: u32 align(4),
    HandleCount: u32 align(4),
    PointerCount: u32 align(4),
};

pub const MINIDUMP_HANDLE_DESCRIPTOR_2 = extern struct {
    Handle: u64 align(4),
    TypeNameRva: u32 align(4),
    ObjectNameRva: u32 align(4),
    Attributes: u32 align(4),
    GrantedAccess: u32 align(4),
    HandleCount: u32 align(4),
    PointerCount: u32 align(4),
    ObjectInfoRva: u32 align(4),
    Reserved0: u32 align(4),
};

pub const MINIDUMP_HANDLE_DATA_STREAM = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfDescriptor: u32 align(4),
    NumberOfDescriptors: u32 align(4),
    Reserved: u32 align(4),
};

pub const MINIDUMP_HANDLE_OPERATION_LIST = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfEntry: u32 align(4),
    NumberOfEntries: u32 align(4),
    Reserved: u32 align(4),
};

pub const MINIDUMP_FUNCTION_TABLE_DESCRIPTOR = extern struct {
    MinimumAddress: u64 align(4),
    MaximumAddress: u64 align(4),
    BaseAddress: u64 align(4),
    EntryCount: u32 align(4),
    SizeOfAlignPad: u32 align(4),
};

pub const MINIDUMP_FUNCTION_TABLE_STREAM = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfDescriptor: u32 align(4),
    SizeOfNativeDescriptor: u32 align(4),
    SizeOfFunctionEntry: u32 align(4),
    NumberOfDescriptors: u32 align(4),
    SizeOfAlignPad: u32 align(4),
};

pub const MINIDUMP_UNLOADED_MODULE = extern struct {
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    ModuleNameRva: u32 align(4),
};

pub const MINIDUMP_UNLOADED_MODULE_LIST = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfEntry: u32 align(4),
    NumberOfEntries: u32 align(4),
};

pub const XSTATE_CONFIG_FEATURE_MSC_INFO = extern struct {
    SizeOfInfo: u32 align(4),
    ContextSize: u32 align(4),
    EnabledFeatures: u64 align(4),
    Features: [64]XSTATE_FEATURE align(4),
};

pub const MINIDUMP_MISC_INFO = extern struct {
    SizeOfInfo: u32 align(4),
    Flags1: MINIDUMP_MISC_INFO_FLAGS align(4),
    ProcessId: u32 align(4),
    ProcessCreateTime: u32 align(4),
    ProcessUserTime: u32 align(4),
    ProcessKernelTime: u32 align(4),
};

pub const MINIDUMP_MISC_INFO_2 = extern struct {
    SizeOfInfo: u32 align(4),
    Flags1: u32 align(4),
    ProcessId: u32 align(4),
    ProcessCreateTime: u32 align(4),
    ProcessUserTime: u32 align(4),
    ProcessKernelTime: u32 align(4),
    ProcessorMaxMhz: u32 align(4),
    ProcessorCurrentMhz: u32 align(4),
    ProcessorMhzLimit: u32 align(4),
    ProcessorMaxIdleState: u32 align(4),
    ProcessorCurrentIdleState: u32 align(4),
};

pub const MINIDUMP_MISC_INFO_3 = extern struct {
    SizeOfInfo: u32 align(4),
    Flags1: u32 align(4),
    ProcessId: u32 align(4),
    ProcessCreateTime: u32 align(4),
    ProcessUserTime: u32 align(4),
    ProcessKernelTime: u32 align(4),
    ProcessorMaxMhz: u32 align(4),
    ProcessorCurrentMhz: u32 align(4),
    ProcessorMhzLimit: u32 align(4),
    ProcessorMaxIdleState: u32 align(4),
    ProcessorCurrentIdleState: u32 align(4),
    ProcessIntegrityLevel: u32 align(4),
    ProcessExecuteFlags: u32 align(4),
    ProtectedProcess: u32 align(4),
    TimeZoneId: u32 align(4),
    TimeZone: TIME_ZONE_INFORMATION align(4),
};

pub const MINIDUMP_MISC_INFO_4 = extern struct {
    SizeOfInfo: u32 align(4),
    Flags1: u32 align(4),
    ProcessId: u32 align(4),
    ProcessCreateTime: u32 align(4),
    ProcessUserTime: u32 align(4),
    ProcessKernelTime: u32 align(4),
    ProcessorMaxMhz: u32 align(4),
    ProcessorCurrentMhz: u32 align(4),
    ProcessorMhzLimit: u32 align(4),
    ProcessorMaxIdleState: u32 align(4),
    ProcessorCurrentIdleState: u32 align(4),
    ProcessIntegrityLevel: u32 align(4),
    ProcessExecuteFlags: u32 align(4),
    ProtectedProcess: u32 align(4),
    TimeZoneId: u32 align(4),
    TimeZone: TIME_ZONE_INFORMATION align(4),
    BuildString: [260]u16 align(4),
    DbgBldStr: [40]u16 align(4),
};

pub const MINIDUMP_MISC_INFO_5 = extern struct {
    SizeOfInfo: u32 align(4),
    Flags1: u32 align(4),
    ProcessId: u32 align(4),
    ProcessCreateTime: u32 align(4),
    ProcessUserTime: u32 align(4),
    ProcessKernelTime: u32 align(4),
    ProcessorMaxMhz: u32 align(4),
    ProcessorCurrentMhz: u32 align(4),
    ProcessorMhzLimit: u32 align(4),
    ProcessorMaxIdleState: u32 align(4),
    ProcessorCurrentIdleState: u32 align(4),
    ProcessIntegrityLevel: u32 align(4),
    ProcessExecuteFlags: u32 align(4),
    ProtectedProcess: u32 align(4),
    TimeZoneId: u32 align(4),
    TimeZone: TIME_ZONE_INFORMATION align(4),
    BuildString: [260]u16 align(4),
    DbgBldStr: [40]u16 align(4),
    XStateData: XSTATE_CONFIG_FEATURE_MSC_INFO align(4),
    ProcessCookie: u32 align(4),
};

pub const MINIDUMP_MEMORY_INFO = extern struct {
    BaseAddress: u64 align(4),
    AllocationBase: u64 align(4),
    AllocationProtect: u32 align(4),
    __alignment1: u32 align(4),
    RegionSize: u64 align(4),
    State: VIRTUAL_ALLOCATION_TYPE align(4),
    Protect: u32 align(4),
    Type: u32 align(4),
    __alignment2: u32 align(4),
};

pub const MINIDUMP_MEMORY_INFO_LIST = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfEntry: u32 align(4),
    NumberOfEntries: u64 align(4),
};

pub const MINIDUMP_THREAD_NAME = extern struct {
    ThreadId: u32 align(4),
    RvaOfThreadName: u64 align(4),
};

pub const MINIDUMP_THREAD_NAME_LIST = extern struct {
    NumberOfThreadNames: u32 align(4),
    ThreadNames: [1]MINIDUMP_THREAD_NAME align(4),
};

pub const MINIDUMP_THREAD_INFO = extern struct {
    ThreadId: u32 align(4),
    DumpFlags: MINIDUMP_THREAD_INFO_DUMP_FLAGS align(4),
    DumpError: u32 align(4),
    ExitStatus: u32 align(4),
    CreateTime: u64 align(4),
    ExitTime: u64 align(4),
    KernelTime: u64 align(4),
    UserTime: u64 align(4),
    StartAddress: u64 align(4),
    Affinity: u64 align(4),
};

pub const MINIDUMP_THREAD_INFO_LIST = extern struct {
    SizeOfHeader: u32 align(4),
    SizeOfEntry: u32 align(4),
    NumberOfEntries: u32 align(4),
};

pub const MINIDUMP_TOKEN_INFO_HEADER = extern struct {
    TokenSize: u32 align(4),
    TokenId: u32 align(4),
    TokenHandle: u64 align(4),
};

pub const MINIDUMP_TOKEN_INFO_LIST = extern struct {
    TokenListSize: u32 align(4),
    TokenListEntries: u32 align(4),
    ListHeaderSize: u32 align(4),
    ElementHeaderSize: u32 align(4),
};

pub const MINIDUMP_SYSTEM_BASIC_INFORMATION = extern struct {
    TimerResolution: u32 align(4),
    PageSize: u32 align(4),
    NumberOfPhysicalPages: u32 align(4),
    LowestPhysicalPageNumber: u32 align(4),
    HighestPhysicalPageNumber: u32 align(4),
    AllocationGranularity: u32 align(4),
    MinimumUserModeAddress: u64 align(4),
    MaximumUserModeAddress: u64 align(4),
    ActiveProcessorsAffinityMask: u64 align(4),
    NumberOfProcessors: u32 align(4),
};

pub const MINIDUMP_SYSTEM_FILECACHE_INFORMATION = extern struct {
    CurrentSize: u64 align(4),
    PeakSize: u64 align(4),
    PageFaultCount: u32 align(4),
    MinimumWorkingSet: u64 align(4),
    MaximumWorkingSet: u64 align(4),
    CurrentSizeIncludingTransitionInPages: u64 align(4),
    PeakSizeIncludingTransitionInPages: u64 align(4),
    TransitionRePurposeCount: u32 align(4),
    Flags: u32 align(4),
};

pub const MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION = extern struct {
    AvailablePages: u64 align(4),
    CommittedPages: u64 align(4),
    CommitLimit: u64 align(4),
    PeakCommitment: u64 align(4),
};

pub const MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    IdleProcessTime: u64 align(4),
    IoReadTransferCount: u64 align(4),
    IoWriteTransferCount: u64 align(4),
    IoOtherTransferCount: u64 align(4),
    IoReadOperationCount: u32 align(4),
    IoWriteOperationCount: u32 align(4),
    IoOtherOperationCount: u32 align(4),
    AvailablePages: u32 align(4),
    CommittedPages: u32 align(4),
    CommitLimit: u32 align(4),
    PeakCommitment: u32 align(4),
    PageFaultCount: u32 align(4),
    CopyOnWriteCount: u32 align(4),
    TransitionCount: u32 align(4),
    CacheTransitionCount: u32 align(4),
    DemandZeroCount: u32 align(4),
    PageReadCount: u32 align(4),
    PageReadIoCount: u32 align(4),
    CacheReadCount: u32 align(4),
    CacheIoCount: u32 align(4),
    DirtyPagesWriteCount: u32 align(4),
    DirtyWriteIoCount: u32 align(4),
    MappedPagesWriteCount: u32 align(4),
    MappedWriteIoCount: u32 align(4),
    PagedPoolPages: u32 align(4),
    NonPagedPoolPages: u32 align(4),
    PagedPoolAllocs: u32 align(4),
    PagedPoolFrees: u32 align(4),
    NonPagedPoolAllocs: u32 align(4),
    NonPagedPoolFrees: u32 align(4),
    FreeSystemPtes: u32 align(4),
    ResidentSystemCodePage: u32 align(4),
    TotalSystemDriverPages: u32 align(4),
    TotalSystemCodePages: u32 align(4),
    NonPagedPoolLookasideHits: u32 align(4),
    PagedPoolLookasideHits: u32 align(4),
    AvailablePagedPoolPages: u32 align(4),
    ResidentSystemCachePage: u32 align(4),
    ResidentPagedPoolPage: u32 align(4),
    ResidentSystemDriverPage: u32 align(4),
    CcFastReadNoWait: u32 align(4),
    CcFastReadWait: u32 align(4),
    CcFastReadResourceMiss: u32 align(4),
    CcFastReadNotPossible: u32 align(4),
    CcFastMdlReadNoWait: u32 align(4),
    CcFastMdlReadWait: u32 align(4),
    CcFastMdlReadResourceMiss: u32 align(4),
    CcFastMdlReadNotPossible: u32 align(4),
    CcMapDataNoWait: u32 align(4),
    CcMapDataWait: u32 align(4),
    CcMapDataNoWaitMiss: u32 align(4),
    CcMapDataWaitMiss: u32 align(4),
    CcPinMappedDataCount: u32 align(4),
    CcPinReadNoWait: u32 align(4),
    CcPinReadWait: u32 align(4),
    CcPinReadNoWaitMiss: u32 align(4),
    CcPinReadWaitMiss: u32 align(4),
    CcCopyReadNoWait: u32 align(4),
    CcCopyReadWait: u32 align(4),
    CcCopyReadNoWaitMiss: u32 align(4),
    CcCopyReadWaitMiss: u32 align(4),
    CcMdlReadNoWait: u32 align(4),
    CcMdlReadWait: u32 align(4),
    CcMdlReadNoWaitMiss: u32 align(4),
    CcMdlReadWaitMiss: u32 align(4),
    CcReadAheadIos: u32 align(4),
    CcLazyWriteIos: u32 align(4),
    CcLazyWritePages: u32 align(4),
    CcDataFlushes: u32 align(4),
    CcDataPages: u32 align(4),
    ContextSwitches: u32 align(4),
    FirstLevelTbFills: u32 align(4),
    SecondLevelTbFills: u32 align(4),
    SystemCalls: u32 align(4),
    CcTotalDirtyPages: u64 align(4),
    CcDirtyPageThreshold: u64 align(4),
    ResidentAvailablePages: i64 align(4),
    SharedCommittedPages: u64 align(4),
};

pub const MINIDUMP_SYSTEM_MEMORY_INFO_1 = extern struct {
    Revision: u16 align(4),
    Flags: u16 align(4),
    BasicInfo: MINIDUMP_SYSTEM_BASIC_INFORMATION align(4),
    FileCacheInfo: MINIDUMP_SYSTEM_FILECACHE_INFORMATION align(4),
    BasicPerfInfo: MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION align(4),
    PerfInfo: MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION align(4),
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_1 = extern struct {
    Revision: u16 align(4),
    PageFaultCount: u32 align(4),
    PeakWorkingSetSize: u64 align(4),
    WorkingSetSize: u64 align(4),
    QuotaPeakPagedPoolUsage: u64 align(4),
    QuotaPagedPoolUsage: u64 align(4),
    QuotaPeakNonPagedPoolUsage: u64 align(4),
    QuotaNonPagedPoolUsage: u64 align(4),
    PagefileUsage: u64 align(4),
    PeakPagefileUsage: u64 align(4),
    PrivateUsage: u64 align(4),
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_2 = extern struct {
    Revision: u16 align(4),
    Flags: u16 align(4),
    PageFaultCount: u32 align(4),
    PeakWorkingSetSize: u64 align(4),
    WorkingSetSize: u64 align(4),
    QuotaPeakPagedPoolUsage: u64 align(4),
    QuotaPagedPoolUsage: u64 align(4),
    QuotaPeakNonPagedPoolUsage: u64 align(4),
    QuotaNonPagedPoolUsage: u64 align(4),
    PagefileUsage: u64 align(4),
    PeakPagefileUsage: u64 align(4),
    PeakVirtualSize: u64 align(4),
    VirtualSize: u64 align(4),
    PrivateUsage: u64 align(4),
    PrivateWorkingSetSize: u64 align(4),
    SharedCommitUsage: u64 align(4),
    JobSharedCommitUsage: u64 align(4),
    JobPrivateCommitUsage: u64 align(4),
    JobPeakPrivateCommitUsage: u64 align(4),
    JobPrivateCommitLimit: u64 align(4),
    JobTotalCommitLimit: u64 align(4),
};

pub const MINIDUMP_USER_RECORD = extern struct {
    Type: u32 align(4),
    Memory: MINIDUMP_LOCATION_DESCRIPTOR align(4),
};



pub const MINIDUMP_CALLBACK_TYPE = enum(i32) {
    ModuleCallback = 0,
    ThreadCallback = 1,
    ThreadExCallback = 2,
    IncludeThreadCallback = 3,
    IncludeModuleCallback = 4,
    MemoryCallback = 5,
    CancelCallback = 6,
    WriteKernelMinidumpCallback = 7,
    KernelMinidumpStatusCallback = 8,
    RemoveMemoryCallback = 9,
    IncludeVmRegionCallback = 10,
    IoStartCallback = 11,
    IoWriteAllCallback = 12,
    IoFinishCallback = 13,
    ReadMemoryFailureCallback = 14,
    SecondaryFlagsCallback = 15,
    IsProcessSnapshotCallback = 16,
    VmStartCallback = 17,
    VmQueryCallback = 18,
    VmPreReadCallback = 19,
    VmPostReadCallback = 20,
};
pub const ModuleCallback = MINIDUMP_CALLBACK_TYPE.ModuleCallback;
pub const ThreadCallback = MINIDUMP_CALLBACK_TYPE.ThreadCallback;
pub const ThreadExCallback = MINIDUMP_CALLBACK_TYPE.ThreadExCallback;
pub const IncludeThreadCallback = MINIDUMP_CALLBACK_TYPE.IncludeThreadCallback;
pub const IncludeModuleCallback = MINIDUMP_CALLBACK_TYPE.IncludeModuleCallback;
pub const MemoryCallback = MINIDUMP_CALLBACK_TYPE.MemoryCallback;
pub const CancelCallback = MINIDUMP_CALLBACK_TYPE.CancelCallback;
pub const WriteKernelMinidumpCallback = MINIDUMP_CALLBACK_TYPE.WriteKernelMinidumpCallback;
pub const KernelMinidumpStatusCallback = MINIDUMP_CALLBACK_TYPE.KernelMinidumpStatusCallback;
pub const RemoveMemoryCallback = MINIDUMP_CALLBACK_TYPE.RemoveMemoryCallback;
pub const IncludeVmRegionCallback = MINIDUMP_CALLBACK_TYPE.IncludeVmRegionCallback;
pub const IoStartCallback = MINIDUMP_CALLBACK_TYPE.IoStartCallback;
pub const IoWriteAllCallback = MINIDUMP_CALLBACK_TYPE.IoWriteAllCallback;
pub const IoFinishCallback = MINIDUMP_CALLBACK_TYPE.IoFinishCallback;
pub const ReadMemoryFailureCallback = MINIDUMP_CALLBACK_TYPE.ReadMemoryFailureCallback;
pub const SecondaryFlagsCallback = MINIDUMP_CALLBACK_TYPE.SecondaryFlagsCallback;
pub const IsProcessSnapshotCallback = MINIDUMP_CALLBACK_TYPE.IsProcessSnapshotCallback;
pub const VmStartCallback = MINIDUMP_CALLBACK_TYPE.VmStartCallback;
pub const VmQueryCallback = MINIDUMP_CALLBACK_TYPE.VmQueryCallback;
pub const VmPreReadCallback = MINIDUMP_CALLBACK_TYPE.VmPreReadCallback;
pub const VmPostReadCallback = MINIDUMP_CALLBACK_TYPE.VmPostReadCallback;



pub const MINIDUMP_INCLUDE_THREAD_CALLBACK = extern struct {
    ThreadId: u32 align(4),
};

pub const THREAD_WRITE_FLAGS = enum(i32) {
    Thread = 1,
    Stack = 2,
    Context = 4,
    BackingStore = 8,
    InstructionWindow = 16,
    ThreadData = 32,
    ThreadInfo = 64,
};
pub const ThreadWriteThread = THREAD_WRITE_FLAGS.Thread;
pub const ThreadWriteStack = THREAD_WRITE_FLAGS.Stack;
pub const ThreadWriteContext = THREAD_WRITE_FLAGS.Context;
pub const ThreadWriteBackingStore = THREAD_WRITE_FLAGS.BackingStore;
pub const ThreadWriteInstructionWindow = THREAD_WRITE_FLAGS.InstructionWindow;
pub const ThreadWriteThreadData = THREAD_WRITE_FLAGS.ThreadData;
pub const ThreadWriteThreadInfo = THREAD_WRITE_FLAGS.ThreadInfo;

pub const MINIDUMP_MODULE_CALLBACK = extern struct {
    FullPath: ?[*]align(1) u16 align(4),
    BaseOfImage: u64 align(4),
    SizeOfImage: u32 align(4),
    CheckSum: u32 align(4),
    TimeDateStamp: u32 align(4),
    VersionInfo: VS_FIXEDFILEINFO align(4),
    CvRecord: ?*anyopaque align(4),
    SizeOfCvRecord: u32 align(4),
    MiscRecord: ?*anyopaque align(4),
    SizeOfMiscRecord: u32 align(4),
};

pub const MINIDUMP_INCLUDE_MODULE_CALLBACK = extern struct {
    BaseOfImage: u64 align(4),
};

pub const MODULE_WRITE_FLAGS = enum(i32) {
    WriteModule = 1,
    WriteDataSeg = 2,
    WriteMiscRecord = 4,
    WriteCvRecord = 8,
    ReferencedByMemory = 16,
    WriteTlsData = 32,
    WriteCodeSegs = 64,
};
pub const ModuleWriteModule = MODULE_WRITE_FLAGS.WriteModule;
pub const ModuleWriteDataSeg = MODULE_WRITE_FLAGS.WriteDataSeg;
pub const ModuleWriteMiscRecord = MODULE_WRITE_FLAGS.WriteMiscRecord;
pub const ModuleWriteCvRecord = MODULE_WRITE_FLAGS.WriteCvRecord;
pub const ModuleReferencedByMemory = MODULE_WRITE_FLAGS.ReferencedByMemory;
pub const ModuleWriteTlsData = MODULE_WRITE_FLAGS.WriteTlsData;
pub const ModuleWriteCodeSegs = MODULE_WRITE_FLAGS.WriteCodeSegs;

pub const MINIDUMP_IO_CALLBACK = extern struct {
    Handle: ?HANDLE align(4),
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    BufferBytes: u32 align(4),
};

pub const MINIDUMP_READ_MEMORY_FAILURE_CALLBACK = extern struct {
    Offset: u64 align(4),
    Bytes: u32 align(4),
    FailureStatus: HRESULT align(4),
};

pub const MINIDUMP_VM_QUERY_CALLBACK = extern struct {
    Offset: u64 align(4),
};

pub const MINIDUMP_VM_PRE_READ_CALLBACK = extern struct {
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    Size: u32 align(4),
};

pub const MINIDUMP_VM_POST_READ_CALLBACK = extern struct {
    Offset: u64 align(4),
    Buffer: ?*anyopaque align(4),
    Size: u32 align(4),
    Completed: u32 align(4),
    Status: HRESULT align(4),
};

pub const MINIDUMP_CALLBACK_INPUT = extern struct {
    ProcessId: u32 align(4),
    ProcessHandle: ?HANDLE align(4),
    CallbackType: u32 align(4),
    Anonymous: extern union {
        Status: HRESULT,
        Thread: MINIDUMP_THREAD_CALLBACK,
        ThreadEx: MINIDUMP_THREAD_EX_CALLBACK,
        Module: MINIDUMP_MODULE_CALLBACK,
        IncludeThread: MINIDUMP_INCLUDE_THREAD_CALLBACK,
        IncludeModule: MINIDUMP_INCLUDE_MODULE_CALLBACK,
        Io: MINIDUMP_IO_CALLBACK,
        ReadMemoryFailure: MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
        SecondaryFlags: u32,
        VmQuery: MINIDUMP_VM_QUERY_CALLBACK,
        VmPreRead: MINIDUMP_VM_PRE_READ_CALLBACK,
        VmPostRead: MINIDUMP_VM_POST_READ_CALLBACK,
    } align(4),
};

pub const MINIDUMP_CALLBACK_OUTPUT = extern struct {
    Anonymous: extern union {
        ModuleWriteFlags: u32,
        ThreadWriteFlags: u32,
        SecondaryFlags: u32,
        Anonymous1: extern struct {
            MemoryBase: u64 align(4),
            MemorySize: u32 align(4),
        },
        Anonymous2: extern struct {
            CheckCancel: BOOL,
            Cancel: BOOL,
        },
        Handle: ?HANDLE,
        Anonymous3: extern struct {
            VmRegion: MINIDUMP_MEMORY_INFO,
            Continue: BOOL,
        },
        Anonymous4: extern struct {
            VmQueryStatus: HRESULT,
            VmQueryResult: MINIDUMP_MEMORY_INFO,
        },
        Anonymous5: extern struct {
            VmReadStatus: HRESULT,
            VmReadBytesCompleted: u32,
        },
        Status: HRESULT,
    } align(4),
};

pub const MINIDUMP_TYPE = enum(i32) {
    Normal = 0,
    WithDataSegs = 1,
    WithFullMemory = 2,
    WithHandleData = 4,
    FilterMemory = 8,
    ScanMemory = 16,
    WithUnloadedModules = 32,
    WithIndirectlyReferencedMemory = 64,
    FilterModulePaths = 128,
    WithProcessThreadData = 256,
    WithPrivateReadWriteMemory = 512,
    WithoutOptionalData = 1024,
    WithFullMemoryInfo = 2048,
    WithThreadInfo = 4096,
    WithCodeSegs = 8192,
    WithoutAuxiliaryState = 16384,
    WithFullAuxiliaryState = 32768,
    WithPrivateWriteCopyMemory = 65536,
    IgnoreInaccessibleMemory = 131072,
    WithTokenInformation = 262144,
    WithModuleHeaders = 524288,
    FilterTriage = 1048576,
    WithAvxXStateContext = 2097152,
    WithIptTrace = 4194304,
    ScanInaccessiblePartialPages = 8388608,
    FilterWriteCombinedMemory = 16777216,
    ValidTypeFlags = 33554431,
    _,
    pub fn initFlags(o: struct {
        Normal: u1 = 0,
        WithDataSegs: u1 = 0,
        WithFullMemory: u1 = 0,
        WithHandleData: u1 = 0,
        FilterMemory: u1 = 0,
        ScanMemory: u1 = 0,
        WithUnloadedModules: u1 = 0,
        WithIndirectlyReferencedMemory: u1 = 0,
        FilterModulePaths: u1 = 0,
        WithProcessThreadData: u1 = 0,
        WithPrivateReadWriteMemory: u1 = 0,
        WithoutOptionalData: u1 = 0,
        WithFullMemoryInfo: u1 = 0,
        WithThreadInfo: u1 = 0,
        WithCodeSegs: u1 = 0,
        WithoutAuxiliaryState: u1 = 0,
        WithFullAuxiliaryState: u1 = 0,
        WithPrivateWriteCopyMemory: u1 = 0,
        IgnoreInaccessibleMemory: u1 = 0,
        WithTokenInformation: u1 = 0,
        WithModuleHeaders: u1 = 0,
        FilterTriage: u1 = 0,
        WithAvxXStateContext: u1 = 0,
        WithIptTrace: u1 = 0,
        ScanInaccessiblePartialPages: u1 = 0,
        FilterWriteCombinedMemory: u1 = 0,
        ValidTypeFlags: u1 = 0,
    }) MINIDUMP_TYPE {
        return @as(MINIDUMP_TYPE, @enumFromInt(
              (if (o.Normal == 1) @intFromEnum(MINIDUMP_TYPE.Normal) else 0)
            | (if (o.WithDataSegs == 1) @intFromEnum(MINIDUMP_TYPE.WithDataSegs) else 0)
            | (if (o.WithFullMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithFullMemory) else 0)
            | (if (o.WithHandleData == 1) @intFromEnum(MINIDUMP_TYPE.WithHandleData) else 0)
            | (if (o.FilterMemory == 1) @intFromEnum(MINIDUMP_TYPE.FilterMemory) else 0)
            | (if (o.ScanMemory == 1) @intFromEnum(MINIDUMP_TYPE.ScanMemory) else 0)
            | (if (o.WithUnloadedModules == 1) @intFromEnum(MINIDUMP_TYPE.WithUnloadedModules) else 0)
            | (if (o.WithIndirectlyReferencedMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithIndirectlyReferencedMemory) else 0)
            | (if (o.FilterModulePaths == 1) @intFromEnum(MINIDUMP_TYPE.FilterModulePaths) else 0)
            | (if (o.WithProcessThreadData == 1) @intFromEnum(MINIDUMP_TYPE.WithProcessThreadData) else 0)
            | (if (o.WithPrivateReadWriteMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithPrivateReadWriteMemory) else 0)
            | (if (o.WithoutOptionalData == 1) @intFromEnum(MINIDUMP_TYPE.WithoutOptionalData) else 0)
            | (if (o.WithFullMemoryInfo == 1) @intFromEnum(MINIDUMP_TYPE.WithFullMemoryInfo) else 0)
            | (if (o.WithThreadInfo == 1) @intFromEnum(MINIDUMP_TYPE.WithThreadInfo) else 0)
            | (if (o.WithCodeSegs == 1) @intFromEnum(MINIDUMP_TYPE.WithCodeSegs) else 0)
            | (if (o.WithoutAuxiliaryState == 1) @intFromEnum(MINIDUMP_TYPE.WithoutAuxiliaryState) else 0)
            | (if (o.WithFullAuxiliaryState == 1) @intFromEnum(MINIDUMP_TYPE.WithFullAuxiliaryState) else 0)
            | (if (o.WithPrivateWriteCopyMemory == 1) @intFromEnum(MINIDUMP_TYPE.WithPrivateWriteCopyMemory) else 0)
            | (if (o.IgnoreInaccessibleMemory == 1) @intFromEnum(MINIDUMP_TYPE.IgnoreInaccessibleMemory) else 0)
            | (if (o.WithTokenInformation == 1) @intFromEnum(MINIDUMP_TYPE.WithTokenInformation) else 0)
            | (if (o.WithModuleHeaders == 1) @intFromEnum(MINIDUMP_TYPE.WithModuleHeaders) else 0)
            | (if (o.FilterTriage == 1) @intFromEnum(MINIDUMP_TYPE.FilterTriage) else 0)
            | (if (o.WithAvxXStateContext == 1) @intFromEnum(MINIDUMP_TYPE.WithAvxXStateContext) else 0)
            | (if (o.WithIptTrace == 1) @intFromEnum(MINIDUMP_TYPE.WithIptTrace) else 0)
            | (if (o.ScanInaccessiblePartialPages == 1) @intFromEnum(MINIDUMP_TYPE.ScanInaccessiblePartialPages) else 0)
            | (if (o.FilterWriteCombinedMemory == 1) @intFromEnum(MINIDUMP_TYPE.FilterWriteCombinedMemory) else 0)
            | (if (o.ValidTypeFlags == 1) @intFromEnum(MINIDUMP_TYPE.ValidTypeFlags) else 0)
        ));
    }
};
pub const MiniDumpNormal = MINIDUMP_TYPE.Normal;
pub const MiniDumpWithDataSegs = MINIDUMP_TYPE.WithDataSegs;
pub const MiniDumpWithFullMemory = MINIDUMP_TYPE.WithFullMemory;
pub const MiniDumpWithHandleData = MINIDUMP_TYPE.WithHandleData;
pub const MiniDumpFilterMemory = MINIDUMP_TYPE.FilterMemory;
pub const MiniDumpScanMemory = MINIDUMP_TYPE.ScanMemory;
pub const MiniDumpWithUnloadedModules = MINIDUMP_TYPE.WithUnloadedModules;
pub const MiniDumpWithIndirectlyReferencedMemory = MINIDUMP_TYPE.WithIndirectlyReferencedMemory;
pub const MiniDumpFilterModulePaths = MINIDUMP_TYPE.FilterModulePaths;
pub const MiniDumpWithProcessThreadData = MINIDUMP_TYPE.WithProcessThreadData;
pub const MiniDumpWithPrivateReadWriteMemory = MINIDUMP_TYPE.WithPrivateReadWriteMemory;
pub const MiniDumpWithoutOptionalData = MINIDUMP_TYPE.WithoutOptionalData;
pub const MiniDumpWithFullMemoryInfo = MINIDUMP_TYPE.WithFullMemoryInfo;
pub const MiniDumpWithThreadInfo = MINIDUMP_TYPE.WithThreadInfo;
pub const MiniDumpWithCodeSegs = MINIDUMP_TYPE.WithCodeSegs;
pub const MiniDumpWithoutAuxiliaryState = MINIDUMP_TYPE.WithoutAuxiliaryState;
pub const MiniDumpWithFullAuxiliaryState = MINIDUMP_TYPE.WithFullAuxiliaryState;
pub const MiniDumpWithPrivateWriteCopyMemory = MINIDUMP_TYPE.WithPrivateWriteCopyMemory;
pub const MiniDumpIgnoreInaccessibleMemory = MINIDUMP_TYPE.IgnoreInaccessibleMemory;
pub const MiniDumpWithTokenInformation = MINIDUMP_TYPE.WithTokenInformation;
pub const MiniDumpWithModuleHeaders = MINIDUMP_TYPE.WithModuleHeaders;
pub const MiniDumpFilterTriage = MINIDUMP_TYPE.FilterTriage;
pub const MiniDumpWithAvxXStateContext = MINIDUMP_TYPE.WithAvxXStateContext;
pub const MiniDumpWithIptTrace = MINIDUMP_TYPE.WithIptTrace;
pub const MiniDumpScanInaccessiblePartialPages = MINIDUMP_TYPE.ScanInaccessiblePartialPages;
pub const MiniDumpFilterWriteCombinedMemory = MINIDUMP_TYPE.FilterWriteCombinedMemory;
pub const MiniDumpValidTypeFlags = MINIDUMP_TYPE.ValidTypeFlags;

pub const MINIDUMP_SECONDARY_FLAGS = enum(i32) {
    WithoutPowerInfo = 1,
    // ValidFlags = 1, this enum value conflicts with WithoutPowerInfo
};
pub const MiniSecondaryWithoutPowerInfo = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;
pub const MiniSecondaryValidFlags = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;

pub const MINIDUMP_CALLBACK_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        CallbackParam: ?*anyopaque,
        CallbackInput: ?*MINIDUMP_CALLBACK_INPUT,
        CallbackOutput: ?*MINIDUMP_CALLBACK_OUTPUT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        CallbackParam: ?*anyopaque,
        CallbackInput: ?*MINIDUMP_CALLBACK_INPUT,
        CallbackOutput: ?*MINIDUMP_CALLBACK_OUTPUT,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;



pub const IMAGEHLP_STATUS_REASON = enum(i32) {
    OutOfMemory = 0,
    RvaToVaFailed = 1,
    NoRoomInImage = 2,
    ImportModuleFailed = 3,
    ImportProcedureFailed = 4,
    ImportModule = 5,
    ImportProcedure = 6,
    Forwarder = 7,
    ForwarderNOT = 8,
    ImageModified = 9,
    ExpandFileHeaders = 10,
    ImageComplete = 11,
    MismatchedSymbols = 12,
    SymbolsNotUpdated = 13,
    ImportProcedure32 = 14,
    ImportProcedure64 = 15,
    Forwarder32 = 16,
    Forwarder64 = 17,
    ForwarderNOT32 = 18,
    ForwarderNOT64 = 19,
};
pub const BindOutOfMemory = IMAGEHLP_STATUS_REASON.OutOfMemory;
pub const BindRvaToVaFailed = IMAGEHLP_STATUS_REASON.RvaToVaFailed;
pub const BindNoRoomInImage = IMAGEHLP_STATUS_REASON.NoRoomInImage;
pub const BindImportModuleFailed = IMAGEHLP_STATUS_REASON.ImportModuleFailed;
pub const BindImportProcedureFailed = IMAGEHLP_STATUS_REASON.ImportProcedureFailed;
pub const BindImportModule = IMAGEHLP_STATUS_REASON.ImportModule;
pub const BindImportProcedure = IMAGEHLP_STATUS_REASON.ImportProcedure;
pub const BindForwarder = IMAGEHLP_STATUS_REASON.Forwarder;
pub const BindForwarderNOT = IMAGEHLP_STATUS_REASON.ForwarderNOT;
pub const BindImageModified = IMAGEHLP_STATUS_REASON.ImageModified;
pub const BindExpandFileHeaders = IMAGEHLP_STATUS_REASON.ExpandFileHeaders;
pub const BindImageComplete = IMAGEHLP_STATUS_REASON.ImageComplete;
pub const BindMismatchedSymbols = IMAGEHLP_STATUS_REASON.MismatchedSymbols;
pub const BindSymbolsNotUpdated = IMAGEHLP_STATUS_REASON.SymbolsNotUpdated;
pub const BindImportProcedure32 = IMAGEHLP_STATUS_REASON.ImportProcedure32;
pub const BindImportProcedure64 = IMAGEHLP_STATUS_REASON.ImportProcedure64;
pub const BindForwarder32 = IMAGEHLP_STATUS_REASON.Forwarder32;
pub const BindForwarder64 = IMAGEHLP_STATUS_REASON.Forwarder64;
pub const BindForwarderNOT32 = IMAGEHLP_STATUS_REASON.ForwarderNOT32;
pub const BindForwarderNOT64 = IMAGEHLP_STATUS_REASON.ForwarderNOT64;

pub const PIMAGEHLP_STATUS_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: usize,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: usize,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PIMAGEHLP_STATUS_ROUTINE32 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: u32,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: u32,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PIMAGEHLP_STATUS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: u64,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        Reason: IMAGEHLP_STATUS_REASON,
        ImageName: ?[*:0]align(1) const u8,
        DllName: ?[*:0]align(1) const u8,
        Va: u64,
        Parameter: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const DIGEST_FUNCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        refdata: ?*anyopaque,
        pData: ?*u8,
        dwLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        refdata: ?*anyopaque,
        pData: ?*u8,
        dwLength: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFIND_DEBUG_FILE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFIND_DEBUG_FILE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFINDFILEINPATHCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        filename: ?[*:0]align(1) const u8,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        filename: ?[*:0]align(1) const u8,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFINDFILEINPATHCALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        filename: ?[*:0]align(1) const u16,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        filename: ?[*:0]align(1) const u16,
        context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFIND_EXE_FILE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFIND_EXE_FILE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FileHandle: ?HANDLE,
        FileName: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;


pub const PENUMDIRTREE_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FilePath: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FilePath: ?[*:0]align(1) const u8,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PENUMDIRTREE_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        FilePath: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        FilePath: ?[*:0]align(1) const u16,
        CallerData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const MODLOAD_DATA = extern struct {
    ssize: u32,
    ssig: MODLOAD_DATA_TYPE,
    data: ?*anyopaque,
    size: u32,
    flags: u32,
};

pub const MODLOAD_CVMISC = extern struct {
    oCV: u32,
    cCV: usize,
    oMisc: u32,
    cMisc: usize,
    dtImage: u32,
    cImage: u32,
};

pub const MODLOAD_PDBGUID_PDBAGE = extern struct {
    PdbGuid: Guid,
    PdbAge: u32,
};

pub const ADDRESS_MODE = enum(i32) {
    @"1616" = 0,
    @"1632" = 1,
    Real = 2,
    Flat = 3,
};
pub const AddrMode1616 = ADDRESS_MODE.@"1616";
pub const AddrMode1632 = ADDRESS_MODE.@"1632";
pub const AddrModeReal = ADDRESS_MODE.Real;
pub const AddrModeFlat = ADDRESS_MODE.Flat;

pub const ADDRESS64 = extern struct {
    Offset: u64,
    Segment: u16,
    Mode: ADDRESS_MODE,
};


pub const KDHELP64 = extern struct {
    Thread: u64,
    ThCallbackStack: u32,
    ThCallbackBStore: u32,
    NextCallback: u32,
    FramePointer: u32,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    SystemRangeStart: u64,
    KiUserExceptionDispatcher: u64,
    StackBase: u64,
    StackLimit: u64,
    BuildVersion: u32,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubFunctionTable: u64,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
    Reserved0: [2]u64,
};


pub const STACKFRAME64 = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*anyopaque,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
};

pub const STACKFRAME_EX = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*anyopaque,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
    StackFrameSize: u32,
    InlineFrameContext: u32,
};


pub const PREAD_PROCESS_MEMORY_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        qwBaseAddress: u64,
        // TODO: what to do with BytesParamIndex 3?
        lpBuffer: ?*anyopaque,
        nSize: u32,
        lpNumberOfBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hProcess: ?HANDLE,
        qwBaseAddress: u64,
        // TODO: what to do with BytesParamIndex 3?
        lpBuffer: ?*anyopaque,
        nSize: u32,
        lpNumberOfBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PFUNCTION_TABLE_ACCESS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ahProcess: ?HANDLE,
        AddrBase: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn(
        ahProcess: ?HANDLE,
        AddrBase: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
} ;

pub const PGET_MODULE_BASE_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        Address: u64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn(
        hProcess: ?HANDLE,
        Address: u64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
} ;

pub const PTRANSLATE_ADDRESS_ROUTINE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        hThread: ?HANDLE,
        lpaddr: ?*ADDRESS64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
    else => *const fn(
        hProcess: ?HANDLE,
        hThread: ?HANDLE,
        lpaddr: ?*ADDRESS64,
    ) callconv(@import("std").os.windows.WINAPI) u64,
} ;

pub const PGET_TARGET_ATTRIBUTE_VALUE64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        Attribute: u32,
        AttributeData: u64,
        AttributeValue: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hProcess: ?HANDLE,
        Attribute: u32,
        AttributeData: u64,
        AttributeValue: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;





pub const API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PSYM_ENUMMODULES_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ModuleName: ?[*:0]align(1) const u8,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        ModuleName: ?[*:0]align(1) const u8,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMMODULES_CALLBACKW64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ModuleName: ?[*:0]align(1) const u16,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        ModuleName: ?[*:0]align(1) const u16,
        BaseOfDll: u64,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PENUMLOADED_MODULES_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ModuleName: ?[*:0]align(1) const u8,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        ModuleName: ?[*:0]align(1) const u8,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PENUMLOADED_MODULES_CALLBACKW64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ModuleName: ?[*:0]align(1) const u16,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        ModuleName: ?[*:0]align(1) const u16,
        ModuleBase: u64,
        ModuleSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMSYMBOLS_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SymbolName: ?[*:0]align(1) const u8,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        SymbolName: ?[*:0]align(1) const u8,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMSYMBOLS_CALLBACK64W = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        SymbolName: ?[*:0]align(1) const u16,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        SymbolName: ?[*:0]align(1) const u16,
        SymbolAddress: u64,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOL_REGISTERED_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        ActionCode: u32,
        CallbackData: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hProcess: ?HANDLE,
        ActionCode: u32,
        CallbackData: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOL_FUNCENTRY_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        AddrBase: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn(
        hProcess: ?HANDLE,
        AddrBase: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
} ;

pub const PSYMBOL_FUNCENTRY_CALLBACK64 = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        AddrBase: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    else => *const fn(
        hProcess: ?HANDLE,
        AddrBase: u64,
        UserContext: u64,
    ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
} ;






pub const SYM_TYPE = enum(i32) {
    SymNone = 0,
    SymCoff = 1,
    SymCv = 2,
    SymPdb = 3,
    SymExport = 4,
    SymDeferred = 5,
    SymSym = 6,
    SymDia = 7,
    SymVirtual = 8,
    NumSymTypes = 9,
};
pub const SymNone = SYM_TYPE.SymNone;
pub const SymCoff = SYM_TYPE.SymCoff;
pub const SymCv = SYM_TYPE.SymCv;
pub const SymPdb = SYM_TYPE.SymPdb;
pub const SymExport = SYM_TYPE.SymExport;
pub const SymDeferred = SYM_TYPE.SymDeferred;
pub const SymSym = SYM_TYPE.SymSym;
pub const SymDia = SYM_TYPE.SymDia;
pub const SymVirtual = SYM_TYPE.SymVirtual;
pub const NumSymTypes = SYM_TYPE.NumSymTypes;

pub const IMAGEHLP_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]CHAR,
};

pub const IMAGEHLP_SYMBOL64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOL64,
    name: [2001]CHAR,
};

pub const IMAGEHLP_SYMBOLW64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]u16,
};

pub const IMAGEHLP_SYMBOLW64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOLW64,
    name: [2001]u16,
};





pub const IMAGEHLP_MODULE64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]CHAR,
    ImageName: [256]CHAR,
    LoadedImageName: [256]CHAR,
    LoadedPdbName: [256]CHAR,
    CVSig: u32,
    CVData: [780]CHAR,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_MODULE64_EX = extern struct {
    Module: IMAGEHLP_MODULE64,
    RegionFlags: u32,
};

pub const IMAGEHLP_MODULEW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]u16,
    ImageName: [256]u16,
    LoadedImageName: [256]u16,
    LoadedPdbName: [256]u16,
    CVSig: u32,
    CVData: [780]u16,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_MODULEW64_EX = extern struct {
    Module: IMAGEHLP_MODULEW64,
    RegionFlags: u32,
};



pub const IMAGEHLP_LINE64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    LineNumber: u32,
    FileName: ?[*]align(1) u8,
    Address: u64,
};

pub const IMAGEHLP_LINEW64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    LineNumber: u32,
    FileName: ?PWSTR,
    Address: u64,
};



pub const SOURCEFILE = extern struct {
    ModBase: u64,
    FileName: ?[*]align(1) u8,
};

pub const SOURCEFILEW = extern struct {
    ModBase: u64,
    FileName: ?PWSTR,
};

pub const IMAGEHLP_CBA_READ_MEMORY = extern struct {
    addr: u64,
    buf: ?*anyopaque,
    bytes: u32,
    bytesread: ?*u32,
};

pub const IMAGEHLP_CBA_EVENT = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*]align(1) u8,
    object: ?*anyopaque,
};

pub const IMAGEHLP_CBA_EVENTW = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*:0]align(1) const u16,
    object: ?*anyopaque,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [260]CHAR,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOADW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [261]u16,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};


pub const IMAGEHLP_DUPLICATE_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    NumberOfDups: u32,
    Symbol: ?*IMAGEHLP_SYMBOL64,
    SelectedSymbol: u32,
};


pub const IMAGEHLP_JIT_SYMBOLMAP = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    BaseOfImage: u64,
};

pub const IMAGEHLP_HD_TYPE = enum(i32) {
    Base = 0,
    Sym = 1,
    Src = 2,
    Max = 3,
};
pub const hdBase = IMAGEHLP_HD_TYPE.Base;
pub const hdSym = IMAGEHLP_HD_TYPE.Sym;
pub const hdSrc = IMAGEHLP_HD_TYPE.Src;
pub const hdMax = IMAGEHLP_HD_TYPE.Max;

pub const OMAP = extern struct {
    rva: u32,
    rvaTo: u32,
};

pub const IMAGEHLP_EXTENDED_OPTIONS = enum(i32) {
    DISABLEACCESSTIMEUPDATE = 0,
    LASTVALIDDEBUGDIRECTORY = 1,
    NOIMPLICITPATTERNSEARCH = 2,
    NEVERLOADSYMBOLS = 3,
    MAX = 4,
};
pub const SYMOPT_EX_DISABLEACCESSTIMEUPDATE = IMAGEHLP_EXTENDED_OPTIONS.DISABLEACCESSTIMEUPDATE;
pub const SYMOPT_EX_LASTVALIDDEBUGDIRECTORY = IMAGEHLP_EXTENDED_OPTIONS.LASTVALIDDEBUGDIRECTORY;
pub const SYMOPT_EX_NOIMPLICITPATTERNSEARCH = IMAGEHLP_EXTENDED_OPTIONS.NOIMPLICITPATTERNSEARCH;
pub const SYMOPT_EX_NEVERLOADSYMBOLS = IMAGEHLP_EXTENDED_OPTIONS.NEVERLOADSYMBOLS;
pub const SYMOPT_EX_MAX = IMAGEHLP_EXTENDED_OPTIONS.MAX;

pub const PSYM_ENUMSOURCEFILES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSourceFile: ?*SOURCEFILE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pSourceFile: ?*SOURCEFILE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMSOURCEFILES_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSourceFile: ?*SOURCEFILEW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pSourceFile: ?*SOURCEFILEW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const SRCCODEINFO = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    ModBase: u64,
    Obj: [261]CHAR,
    FileName: [261]CHAR,
    LineNumber: u32,
    Address: u64,
};

pub const SRCCODEINFOW = extern struct {
    SizeOfStruct: u32,
    Key: ?*anyopaque,
    ModBase: u64,
    Obj: [261]u16,
    FileName: [261]u16,
    LineNumber: u32,
    Address: u64,
};

pub const PSYM_ENUMLINES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        LineInfo: ?*SRCCODEINFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        LineInfo: ?*SRCCODEINFO,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMLINES_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        LineInfo: ?*SRCCODEINFOW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        LineInfo: ?*SRCCODEINFOW,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PENUMSOURCEFILETOKENSCALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        token: ?*anyopaque,
        size: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        token: ?*anyopaque,
        size: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const IMAGEHLP_SYMBOL_SRC = extern struct {
    sizeofstruct: u32,
    type: u32,
    file: [260]CHAR,
};

pub const MODULE_TYPE_INFO = extern struct {
    dataLength: u16,
    leaf: u16,
    data: [1]u8,
};

pub const SYMBOL_INFO = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]CHAR,
};

pub const SYMBOL_INFO_PACKAGE = extern struct {
    si: SYMBOL_INFO,
    name: [2001]CHAR,
};

pub const SYMBOL_INFOW = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]u16,
};

pub const SYMBOL_INFO_PACKAGEW = extern struct {
    si: SYMBOL_INFOW,
    name: [2001]u16,
};

pub const IMAGEHLP_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    BackingStoreOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [5]u64,
    Virtual: BOOL,
    Reserved2: u32,
};

pub const PSYM_ENUMPROCESSES_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hProcess: ?HANDLE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        hProcess: ?HANDLE,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMERATESYMBOLS_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSymInfo: ?*SYMBOL_INFO,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pSymInfo: ?*SYMBOL_INFO,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYM_ENUMERATESYMBOLS_CALLBACKW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pSymInfo: ?*SYMBOL_INFOW,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pSymInfo: ?*SYMBOL_INFOW,
        SymbolSize: u32,
        UserContext: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const IMAGEHLP_SYMBOL_TYPE_INFO = enum(i32) {
    TI_GET_SYMTAG = 0,
    TI_GET_SYMNAME = 1,
    TI_GET_LENGTH = 2,
    TI_GET_TYPE = 3,
    TI_GET_TYPEID = 4,
    TI_GET_BASETYPE = 5,
    TI_GET_ARRAYINDEXTYPEID = 6,
    TI_FINDCHILDREN = 7,
    TI_GET_DATAKIND = 8,
    TI_GET_ADDRESSOFFSET = 9,
    TI_GET_OFFSET = 10,
    TI_GET_VALUE = 11,
    TI_GET_COUNT = 12,
    TI_GET_CHILDRENCOUNT = 13,
    TI_GET_BITPOSITION = 14,
    TI_GET_VIRTUALBASECLASS = 15,
    TI_GET_VIRTUALTABLESHAPEID = 16,
    TI_GET_VIRTUALBASEPOINTEROFFSET = 17,
    TI_GET_CLASSPARENTID = 18,
    TI_GET_NESTED = 19,
    TI_GET_SYMINDEX = 20,
    TI_GET_LEXICALPARENT = 21,
    TI_GET_ADDRESS = 22,
    TI_GET_THISADJUST = 23,
    TI_GET_UDTKIND = 24,
    TI_IS_EQUIV_TO = 25,
    TI_GET_CALLING_CONVENTION = 26,
    TI_IS_CLOSE_EQUIV_TO = 27,
    TI_GTIEX_REQS_VALID = 28,
    TI_GET_VIRTUALBASEOFFSET = 29,
    TI_GET_VIRTUALBASEDISPINDEX = 30,
    TI_GET_IS_REFERENCE = 31,
    TI_GET_INDIRECTVIRTUALBASECLASS = 32,
    TI_GET_VIRTUALBASETABLETYPE = 33,
    TI_GET_OBJECTPOINTERTYPE = 34,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX = 35,
};
pub const TI_GET_SYMTAG = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMTAG;
pub const TI_GET_SYMNAME = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMNAME;
pub const TI_GET_LENGTH = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LENGTH;
pub const TI_GET_TYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPE;
pub const TI_GET_TYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPEID;
pub const TI_GET_BASETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BASETYPE;
pub const TI_GET_ARRAYINDEXTYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ARRAYINDEXTYPEID;
pub const TI_FINDCHILDREN = IMAGEHLP_SYMBOL_TYPE_INFO.TI_FINDCHILDREN;
pub const TI_GET_DATAKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_DATAKIND;
pub const TI_GET_ADDRESSOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESSOFFSET;
pub const TI_GET_OFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_OFFSET;
pub const TI_GET_VALUE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VALUE;
pub const TI_GET_COUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_COUNT;
pub const TI_GET_CHILDRENCOUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CHILDRENCOUNT;
pub const TI_GET_BITPOSITION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BITPOSITION;
pub const TI_GET_VIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASECLASS;
pub const TI_GET_VIRTUALTABLESHAPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALTABLESHAPEID;
pub const TI_GET_VIRTUALBASEPOINTEROFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEPOINTEROFFSET;
pub const TI_GET_CLASSPARENTID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CLASSPARENTID;
pub const TI_GET_NESTED = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_NESTED;
pub const TI_GET_SYMINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMINDEX;
pub const TI_GET_LEXICALPARENT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LEXICALPARENT;
pub const TI_GET_ADDRESS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESS;
pub const TI_GET_THISADJUST = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_THISADJUST;
pub const TI_GET_UDTKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_UDTKIND;
pub const TI_IS_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_EQUIV_TO;
pub const TI_GET_CALLING_CONVENTION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CALLING_CONVENTION;
pub const TI_IS_CLOSE_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_CLOSE_EQUIV_TO;
pub const TI_GTIEX_REQS_VALID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GTIEX_REQS_VALID;
pub const TI_GET_VIRTUALBASEOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEOFFSET;
pub const TI_GET_VIRTUALBASEDISPINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEDISPINDEX;
pub const TI_GET_IS_REFERENCE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_IS_REFERENCE;
pub const TI_GET_INDIRECTVIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_INDIRECTVIRTUALBASECLASS;
pub const TI_GET_VIRTUALBASETABLETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASETABLETYPE;
pub const TI_GET_OBJECTPOINTERTYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_OBJECTPOINTERTYPE;
pub const IMAGEHLP_SYMBOL_TYPE_INFO_MAX = IMAGEHLP_SYMBOL_TYPE_INFO.IMAGEHLP_SYMBOL_TYPE_INFO_MAX;

pub const TI_FINDCHILDREN_PARAMS = extern struct {
    Count: u32,
    Start: u32,
    ChildId: [1]u32,
};

pub const IMAGEHLP_GET_TYPE_INFO_PARAMS = extern struct {
    SizeOfStruct: u32,
    Flags: IMAGEHLP_GET_TYPE_INFO_FLAGS,
    NumIds: u32,
    TypeIds: ?*u32,
    TagFilter: u64,
    NumReqs: u32,
    ReqKinds: ?*IMAGEHLP_SYMBOL_TYPE_INFO,
    ReqOffsets: ?*usize,
    ReqSizes: ?*u32,
    ReqStride: usize,
    BufferSize: usize,
    Buffer: ?*anyopaque,
    EntriesMatched: u32,
    EntriesFilled: u32,
    TagsFound: u64,
    AllReqsValid: u64,
    NumReqsValid: u32,
    ReqsValid: ?*u64,
};

pub const SYMADDSOURCESTREAM = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]align(1) const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]align(1) const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const SYMADDSOURCESTREAMA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]align(1) const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?HANDLE,
        param1: u64,
        param2: ?[*:0]align(1) const u8,
        param3: ?*u8,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const SYMSRV_INDEX_INFO = extern struct {
    sizeofstruct: u32,
    file: [261]CHAR,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]CHAR,
    pdbfile: [261]CHAR,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const SYMSRV_INDEX_INFOW = extern struct {
    sizeofstruct: u32,
    file: [261]u16,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]u16,
    pdbfile: [261]u16,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const IMAGEHLP_SF_TYPE = enum(i32) {
    Image = 0,
    Dbg = 1,
    Pdb = 2,
    Mpd = 3,
    Max = 4,
};
pub const sfImage = IMAGEHLP_SF_TYPE.Image;
pub const sfDbg = IMAGEHLP_SF_TYPE.Dbg;
pub const sfPdb = IMAGEHLP_SF_TYPE.Pdb;
pub const sfMpd = IMAGEHLP_SF_TYPE.Mpd;
pub const sfMax = IMAGEHLP_SF_TYPE.Max;

pub const PDBGHELP_CREATE_USER_DUMP_CALLBACK = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        DataType: u32,
        Data: ?*?*anyopaque,
        DataLength: ?*u32,
        UserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        DataType: u32,
        Data: ?*?*anyopaque,
        DataLength: ?*u32,
        UserData: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const SYMSRV_EXTENDED_OUTPUT_DATA = extern struct {
    sizeOfStruct: u32,
    version: u32,
    filePtrMsg: [261]u16,
};

pub const PSYMBOLSERVERPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERBYINDEXPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERBYINDEXPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERBYINDEXPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVEROPENPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERCLOSEPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSETOPTIONSPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSETOPTIONSWPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: usize,
        param1: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERCALLBACKPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETOPTIONSPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) usize,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) usize,
} ;

pub const PSYMBOLSERVERPINGPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERPINGPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERPINGPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETVERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*API_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?*API_VERSION,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERDELTANAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERDELTANAMEW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PWSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?*anyopaque,
        param2: u32,
        param3: u32,
        param4: ?*anyopaque,
        param5: u32,
        param6: u32,
        param7: ?PWSTR,
        param8: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETSUPPLEMENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETSUPPLEMENTW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSTORESUPPLEMENT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?[*:0]align(1) const u8,
        param3: ?PSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSTORESUPPLEMENTW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?[*:0]align(1) const u16,
        param3: ?PWSTR,
        param4: usize,
        param5: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETINDEXSTRING = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETINDEXSTRINGW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?*anyopaque,
        param1: u32,
        param2: u32,
        param3: ?PWSTR,
        param4: usize,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSTOREFILE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
        param1: ?[*:0]align(1) const u8,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSTOREFILEW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: usize,
        param7: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERISSTORE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u8,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERISSTOREW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERVERSION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const PSYMBOLSERVERMESSAGEPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        action: usize,
        data: u64,
        context: u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERWEXPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: ?*SYMSRV_EXTENDED_OUTPUT_DATA,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
        param1: ?[*:0]align(1) const u16,
        param2: ?*anyopaque,
        param3: u32,
        param4: u32,
        param5: ?PWSTR,
        param6: ?*SYMSRV_EXTENDED_OUTPUT_DATA,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERPINGPROCWEX = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERGETOPTIONDATAPROC = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: usize,
        param1: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: usize,
        param1: ?*u64,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const PSYMBOLSERVERSETHTTPAUTHHEADER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pszAuthHeader: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        pszAuthHeader: ?[*:0]align(1) const u16,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const LPCALL_BACK_USER_INTERRUPT_ROUTINE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) u32,
} ;

pub const DBGHELP_DATA_REPORT_STRUCT = extern struct {
    pBinPathNonExist: ?[*:0]align(1) const u16,
    pSymbolPathNonExist: ?[*:0]align(1) const u16,
};

pub const DUMP_TYPE = enum(i32) {
    INVALID = -1,
    UNKNOWN = 0,
    FULL = 1,
    SUMMARY = 2,
    HEADER = 3,
    TRIAGE = 4,
    BITMAP_FULL = 5,
    BITMAP_KERNEL = 6,
    AUTOMATIC = 7,
};
pub const DUMP_TYPE_INVALID = DUMP_TYPE.INVALID;
pub const DUMP_TYPE_UNKNOWN = DUMP_TYPE.UNKNOWN;
pub const DUMP_TYPE_FULL = DUMP_TYPE.FULL;
pub const DUMP_TYPE_SUMMARY = DUMP_TYPE.SUMMARY;
pub const DUMP_TYPE_HEADER = DUMP_TYPE.HEADER;
pub const DUMP_TYPE_TRIAGE = DUMP_TYPE.TRIAGE;
pub const DUMP_TYPE_BITMAP_FULL = DUMP_TYPE.BITMAP_FULL;
pub const DUMP_TYPE_BITMAP_KERNEL = DUMP_TYPE.BITMAP_KERNEL;
pub const DUMP_TYPE_AUTOMATIC = DUMP_TYPE.AUTOMATIC;

pub const PHYSICAL_MEMORY_RUN32 = extern struct {
    BasePage: u32,
    PageCount: u32,
};

pub const PHYSICAL_MEMORY_DESCRIPTOR32 = extern struct {
    NumberOfRuns: u32,
    NumberOfPages: u32,
    Run: [1]PHYSICAL_MEMORY_RUN32,
};

pub const PHYSICAL_MEMORY_RUN64 = extern struct {
    BasePage: u64,
    PageCount: u64,
};

pub const PHYSICAL_MEMORY_DESCRIPTOR64 = extern struct {
    NumberOfRuns: u32,
    NumberOfPages: u64,
    Run: [1]PHYSICAL_MEMORY_RUN64,
};

pub const DUMP_FILE_ATTRIBUTES = extern union {
    Anonymous: extern struct {
        _bitfield: u32,
    },
    Attributes: u32,
};

pub const DUMP_HEADER32 = extern struct {
    Signature: u32,
    ValidDump: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    DirectoryTableBase: u32,
    PfnDataBase: u32,
    PsLoadedModuleList: u32,
    PsActiveProcessHead: u32,
    MachineImageType: u32,
    NumberProcessors: u32,
    BugCheckCode: u32,
    BugCheckParameter1: u32,
    BugCheckParameter2: u32,
    BugCheckParameter3: u32,
    BugCheckParameter4: u32,
    VersionUser: [32]CHAR,
    PaeEnabled: u8,
    KdSecondaryVersion: u8,
    Spare3: [2]u8,
    KdDebuggerDataBlock: u32,
    Anonymous: extern union {
        PhysicalMemoryBlock: PHYSICAL_MEMORY_DESCRIPTOR32,
        PhysicalMemoryBlockBuffer: [700]u8,
    },
    ContextRecord: [1200]u8,
    Exception: EXCEPTION_RECORD32,
    Comment: [128]CHAR,
    Attributes: DUMP_FILE_ATTRIBUTES,
    BootId: u32,
    _reserved0: [1760]u8,
    DumpType: u32,
    MiniDumpFields: u32,
    SecondaryDataState: u32,
    ProductType: u32,
    SuiteMask: u32,
    WriterStatus: u32,
    RequiredDumpSpace: i64,
    _reserved2: [16]u8,
    SystemUpTime: i64,
    SystemTime: i64,
    _reserved3: [56]u8,
};

pub const DUMP_HEADER64 = extern struct {
    Signature: u32,
    ValidDump: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    DirectoryTableBase: u64,
    PfnDataBase: u64,
    PsLoadedModuleList: u64,
    PsActiveProcessHead: u64,
    MachineImageType: u32,
    NumberProcessors: u32,
    BugCheckCode: u32,
    BugCheckParameter1: u64,
    BugCheckParameter2: u64,
    BugCheckParameter3: u64,
    BugCheckParameter4: u64,
    VersionUser: [32]CHAR,
    KdDebuggerDataBlock: u64,
    Anonymous: extern union {
        PhysicalMemoryBlock: PHYSICAL_MEMORY_DESCRIPTOR64,
        PhysicalMemoryBlockBuffer: [700]u8,
    },
    ContextRecord: [3000]u8,
    Exception: EXCEPTION_RECORD64,
    DumpType: u32,
    RequiredDumpSpace: i64,
    SystemTime: i64,
    Comment: [128]CHAR,
    SystemUpTime: i64,
    MiniDumpFields: u32,
    SecondaryDataState: u32,
    ProductType: u32,
    SuiteMask: u32,
    WriterStatus: u32,
    Unused1: u8,
    KdSecondaryVersion: u8,
    Unused: [2]u8,
    Attributes: DUMP_FILE_ATTRIBUTES,
    BootId: u32,
    _reserved0: [4008]u8,
};

const IID_IObjectSafety_Value = Guid.initString("cb5bdc81-93c1-11cf-8f20-00805f2cd064");
pub const IID_IObjectSafety = &IID_IObjectSafety_Value;
pub const IObjectSafety = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterfaceSafetyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IObjectSafety,
                riid: ?*const Guid,
                pdwSupportedOptions: ?*u32,
                pdwEnabledOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IObjectSafety,
                riid: ?*const Guid,
                pdwSupportedOptions: ?*u32,
                pdwEnabledOptions: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInterfaceSafetyOptions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IObjectSafety,
                riid: ?*const Guid,
                dwOptionSetMask: u32,
                dwEnabledOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IObjectSafety,
                riid: ?*const Guid,
                dwOptionSetMask: u32,
                dwEnabledOptions: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectSafety_GetInterfaceSafetyOptions(self: *const T, riid: ?*const Guid, pdwSupportedOptions: ?*u32, pdwEnabledOptions: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IObjectSafety.VTable, @ptrCast(self.vtable)).GetInterfaceSafetyOptions(@as(*const IObjectSafety, @ptrCast(self)), riid, pdwSupportedOptions, pdwEnabledOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectSafety_SetInterfaceSafetyOptions(self: *const T, riid: ?*const Guid, dwOptionSetMask: u32, dwEnabledOptions: u32) callconv(.Inline) HRESULT {
            return @as(*const IObjectSafety.VTable, @ptrCast(self.vtable)).SetInterfaceSafetyOptions(@as(*const IObjectSafety, @ptrCast(self)), riid, dwOptionSetMask, dwEnabledOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WHEA_ERROR_SOURCE_TYPE = enum(i32) {
    MCE = 0,
    CMC = 1,
    CPE = 2,
    NMI = 3,
    PCIe = 4,
    Generic = 5,
    INIT = 6,
    BOOT = 7,
    SCIGeneric = 8,
    IPFMCA = 9,
    IPFCMC = 10,
    IPFCPE = 11,
    GenericV2 = 12,
    SCIGenericV2 = 13,
    BMC = 14,
    PMEM = 15,
    DeviceDriver = 16,
    Sea = 17,
    Sei = 18,
    Max = 19,
};
pub const WheaErrSrcTypeMCE = WHEA_ERROR_SOURCE_TYPE.MCE;
pub const WheaErrSrcTypeCMC = WHEA_ERROR_SOURCE_TYPE.CMC;
pub const WheaErrSrcTypeCPE = WHEA_ERROR_SOURCE_TYPE.CPE;
pub const WheaErrSrcTypeNMI = WHEA_ERROR_SOURCE_TYPE.NMI;
pub const WheaErrSrcTypePCIe = WHEA_ERROR_SOURCE_TYPE.PCIe;
pub const WheaErrSrcTypeGeneric = WHEA_ERROR_SOURCE_TYPE.Generic;
pub const WheaErrSrcTypeINIT = WHEA_ERROR_SOURCE_TYPE.INIT;
pub const WheaErrSrcTypeBOOT = WHEA_ERROR_SOURCE_TYPE.BOOT;
pub const WheaErrSrcTypeSCIGeneric = WHEA_ERROR_SOURCE_TYPE.SCIGeneric;
pub const WheaErrSrcTypeIPFMCA = WHEA_ERROR_SOURCE_TYPE.IPFMCA;
pub const WheaErrSrcTypeIPFCMC = WHEA_ERROR_SOURCE_TYPE.IPFCMC;
pub const WheaErrSrcTypeIPFCPE = WHEA_ERROR_SOURCE_TYPE.IPFCPE;
pub const WheaErrSrcTypeGenericV2 = WHEA_ERROR_SOURCE_TYPE.GenericV2;
pub const WheaErrSrcTypeSCIGenericV2 = WHEA_ERROR_SOURCE_TYPE.SCIGenericV2;
pub const WheaErrSrcTypeBMC = WHEA_ERROR_SOURCE_TYPE.BMC;
pub const WheaErrSrcTypePMEM = WHEA_ERROR_SOURCE_TYPE.PMEM;
pub const WheaErrSrcTypeDeviceDriver = WHEA_ERROR_SOURCE_TYPE.DeviceDriver;
pub const WheaErrSrcTypeSea = WHEA_ERROR_SOURCE_TYPE.Sea;
pub const WheaErrSrcTypeSei = WHEA_ERROR_SOURCE_TYPE.Sei;
pub const WheaErrSrcTypeMax = WHEA_ERROR_SOURCE_TYPE.Max;

pub const WHEA_ERROR_SOURCE_STATE = enum(i32) {
    Stopped = 1,
    Started = 2,
    Removed = 3,
    RemovePending = 4,
};
pub const WheaErrSrcStateStopped = WHEA_ERROR_SOURCE_STATE.Stopped;
pub const WheaErrSrcStateStarted = WHEA_ERROR_SOURCE_STATE.Started;
pub const WheaErrSrcStateRemoved = WHEA_ERROR_SOURCE_STATE.Removed;
pub const WheaErrSrcStateRemovePending = WHEA_ERROR_SOURCE_STATE.RemovePending;

pub const WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Context: ?*anyopaque,
        ErrorSourceId: u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
    else => *const fn(
        Context: ?*anyopaque,
        ErrorSourceId: u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
} ;

pub const WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        Context: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

pub const WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        ErrorSourceDesc: ?*anyopaque,
        MaximumSectionLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
    else => *const fn(
        ErrorSourceDesc: ?*anyopaque,
        MaximumSectionLength: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) NTSTATUS,
} ;

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DD = extern struct {
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
    Correct: ?WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER align(1),
};

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1 = extern struct {
    Version: u32 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved: [6]u8 align(1),
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
};

pub const WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER = extern struct {
    Version: u32 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved: [6]u8 align(1),
    Initialize: ?WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER align(1),
    Uninitialize: ?WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER align(1),
    MaxSectionDataLength: u32 align(1),
    MaxSectionsPerReport: u32 align(1),
    CreatorId: Guid align(1),
    PartitionId: Guid align(1),
};

pub const WHEA_DRIVER_BUFFER_SET = extern struct {
    Version: u32 align(1),
    Data: ?*u8 align(1),
    DataSize: u32 align(1),
    SectionTypeGuid: ?*Guid align(1),
    SectionFriendlyName: ?*u8 align(1),
    Flags: ?*u8 align(1),
};

pub const WHEA_NOTIFICATION_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const XPF_MC_BANK_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u8,
    },
    AsUCHAR: u8,
};

pub const XPF_MCE_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u32 align(1),
    } align(1),
    AsULONG: u32 align(1),
};

pub const AER_ROOTPORT_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const AER_ENDPOINT_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const AER_BRIDGE_DESCRIPTOR_FLAGS = extern union {
    Anonymous: extern struct {
        _bitfield: u16 align(1),
    } align(1),
    AsUSHORT: u16 align(1),
};

pub const WHEA_NOTIFICATION_DESCRIPTOR = extern struct {
    Type: u8,
    Length: u8,
    Flags: WHEA_NOTIFICATION_FLAGS,
    u: extern union {
        Polled: extern struct {
            PollInterval: u32 align(1),
        },
        Interrupt: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        LocalInterrupt: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sci: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Nmi: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sea: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Sei: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
        Gsiv: extern struct {
            PollInterval: u32 align(1),
            Vector: u32 align(1),
            SwitchToPollingThreshold: u32 align(1),
            SwitchToPollingWindow: u32 align(1),
            ErrorThreshold: u32 align(1),
            ErrorThresholdWindow: u32 align(1),
        },
    },
};

pub const WHEA_XPF_MC_BANK_DESCRIPTOR = extern struct {
    BankNumber: u8 align(1),
    ClearOnInitialization: BOOLEAN align(1),
    StatusDataFormat: u8 align(1),
    Flags: XPF_MC_BANK_FLAGS align(1),
    ControlMsr: u32 align(1),
    StatusMsr: u32 align(1),
    AddressMsr: u32 align(1),
    MiscMsr: u32 align(1),
    ControlData: u64 align(1),
};

pub const WHEA_XPF_MCE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    NumberOfBanks: u8 align(1),
    Flags: XPF_MCE_FLAGS align(1),
    MCG_Capability: u64 align(1),
    MCG_GlobalControl: u64 align(1),
    Banks: [32]WHEA_XPF_MC_BANK_DESCRIPTOR align(1),
};

pub const WHEA_XPF_CMC_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    NumberOfBanks: u8 align(1),
    Reserved: u32 align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
    Banks: [32]WHEA_XPF_MC_BANK_DESCRIPTOR align(1),
};

pub const WHEA_PCI_SLOT_NUMBER = extern struct {
    u: extern union {
        bits: extern struct {
            _bitfield: u32 align(1),
        } align(1),
        AsULONG: u32 align(1),
    },
};

pub const WHEA_XPF_NMI_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
};

pub const WHEA_AER_ROOTPORT_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_ROOTPORT_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
    RootErrorCommand: u32 align(1),
};

pub const WHEA_AER_ENDPOINT_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_ENDPOINT_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
};

pub const WHEA_AER_BRIDGE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    BusNumber: u32 align(1),
    Slot: WHEA_PCI_SLOT_NUMBER align(1),
    DeviceControl: u16 align(1),
    Flags: AER_BRIDGE_DESCRIPTOR_FLAGS align(1),
    UncorrectableErrorMask: u32 align(1),
    UncorrectableErrorSeverity: u32 align(1),
    CorrectableErrorMask: u32 align(1),
    AdvancedCapsAndControl: u32 align(1),
    SecondaryUncorrectableErrorMask: u32 align(1),
    SecondaryUncorrectableErrorSev: u32 align(1),
    SecondaryCapsAndControl: u32 align(1),
};

pub const WHEA_GENERIC_ERROR_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Reserved: u8 align(1),
    Enabled: u8 align(1),
    ErrStatusBlockLength: u32 align(1),
    RelatedErrorSourceId: u32 align(1),
    ErrStatusAddressSpaceID: u8 align(1),
    ErrStatusAddressBitWidth: u8 align(1),
    ErrStatusAddressBitOffset: u8 align(1),
    ErrStatusAddressAccessSize: u8 align(1),
    ErrStatusAddress: i64 align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
};

pub const WHEA_GENERIC_ERROR_DESCRIPTOR_V2 = extern struct {
    Type: u16 align(1),
    Reserved: u8 align(1),
    Enabled: u8 align(1),
    ErrStatusBlockLength: u32 align(1),
    RelatedErrorSourceId: u32 align(1),
    ErrStatusAddressSpaceID: u8 align(1),
    ErrStatusAddressBitWidth: u8 align(1),
    ErrStatusAddressBitOffset: u8 align(1),
    ErrStatusAddressAccessSize: u8 align(1),
    ErrStatusAddress: i64 align(1),
    Notify: WHEA_NOTIFICATION_DESCRIPTOR align(1),
    ReadAckAddressSpaceID: u8 align(1),
    ReadAckAddressBitWidth: u8 align(1),
    ReadAckAddressBitOffset: u8 align(1),
    ReadAckAddressAccessSize: u8 align(1),
    ReadAckAddress: i64 align(1),
    ReadAckPreserveMask: u64 align(1),
    ReadAckWriteMask: u64 align(1),
};

pub const WHEA_DEVICE_DRIVER_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: BOOLEAN align(1),
    Reserved: u8 align(1),
    SourceGuid: Guid align(1),
    LogTag: u16 align(1),
    Reserved2: u16 align(1),
    PacketLength: u32 align(1),
    PacketCount: u32 align(1),
    PacketBuffer: ?*u8 align(1),
    Config: WHEA_ERROR_SOURCE_CONFIGURATION_DD align(1),
    CreatorId: Guid align(1),
    PartitionId: Guid align(1),
    MaxSectionDataLength: u32 align(1),
    MaxSectionsPerRecord: u32 align(1),
    PacketStateBuffer: ?*u8 align(1),
    OpenHandles: i32 align(1),
};

pub const WHEA_IPF_MCA_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_IPF_CMC_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_IPF_CPE_DESCRIPTOR = extern struct {
    Type: u16 align(1),
    Enabled: u8 align(1),
    Reserved: u8 align(1),
};

pub const WHEA_ERROR_SOURCE_DESCRIPTOR = extern struct {
    Length: u32 align(1),
    Version: u32 align(1),
    Type: WHEA_ERROR_SOURCE_TYPE align(1),
    State: WHEA_ERROR_SOURCE_STATE align(1),
    MaxRawDataLength: u32 align(1),
    NumRecordsToPreallocate: u32 align(1),
    MaxSectionsPerRecord: u32 align(1),
    ErrorSourceId: u32 align(1),
    PlatformErrorSourceId: u32 align(1),
    Flags: u32 align(1),
    Info: extern union {
        XpfMceDescriptor: WHEA_XPF_MCE_DESCRIPTOR,
        XpfCmcDescriptor: WHEA_XPF_CMC_DESCRIPTOR,
        XpfNmiDescriptor: WHEA_XPF_NMI_DESCRIPTOR,
        IpfMcaDescriptor: WHEA_IPF_MCA_DESCRIPTOR,
        IpfCmcDescriptor: WHEA_IPF_CMC_DESCRIPTOR,
        IpfCpeDescriptor: WHEA_IPF_CPE_DESCRIPTOR,
        AerRootportDescriptor: WHEA_AER_ROOTPORT_DESCRIPTOR,
        AerEndpointDescriptor: WHEA_AER_ENDPOINT_DESCRIPTOR,
        AerBridgeDescriptor: WHEA_AER_BRIDGE_DESCRIPTOR,
        GenErrDescriptor: WHEA_GENERIC_ERROR_DESCRIPTOR,
        GenErrDescriptorV2: WHEA_GENERIC_ERROR_DESCRIPTOR_V2,
        DeviceDriverDescriptor: WHEA_DEVICE_DRIVER_DESCRIPTOR,
    } align(1),
};

pub const IPMI_OS_SEL_RECORD_TYPE = enum(i32) {
    Whea = 0,
    Other = 1,
    WheaErrorXpfMca = 2,
    WheaErrorPci = 3,
    WheaErrorNmi = 4,
    WheaErrorOther = 5,
    Raw = 6,
    Driver = 7,
    BugcheckRecovery = 8,
    BugcheckData = 9,
    Max = 10,
};
pub const IpmiOsSelRecordTypeWhea = IPMI_OS_SEL_RECORD_TYPE.Whea;
pub const IpmiOsSelRecordTypeOther = IPMI_OS_SEL_RECORD_TYPE.Other;
pub const IpmiOsSelRecordTypeWheaErrorXpfMca = IPMI_OS_SEL_RECORD_TYPE.WheaErrorXpfMca;
pub const IpmiOsSelRecordTypeWheaErrorPci = IPMI_OS_SEL_RECORD_TYPE.WheaErrorPci;
pub const IpmiOsSelRecordTypeWheaErrorNmi = IPMI_OS_SEL_RECORD_TYPE.WheaErrorNmi;
pub const IpmiOsSelRecordTypeWheaErrorOther = IPMI_OS_SEL_RECORD_TYPE.WheaErrorOther;
pub const IpmiOsSelRecordTypeRaw = IPMI_OS_SEL_RECORD_TYPE.Raw;
pub const IpmiOsSelRecordTypeDriver = IPMI_OS_SEL_RECORD_TYPE.Driver;
pub const IpmiOsSelRecordTypeBugcheckRecovery = IPMI_OS_SEL_RECORD_TYPE.BugcheckRecovery;
pub const IpmiOsSelRecordTypeBugcheckData = IPMI_OS_SEL_RECORD_TYPE.BugcheckData;
pub const IpmiOsSelRecordTypeMax = IPMI_OS_SEL_RECORD_TYPE.Max;

pub const IPMI_OS_SEL_RECORD = extern struct {
    Signature: u32 align(1),
    Version: u32 align(1),
    Length: u32 align(1),
    RecordType: IPMI_OS_SEL_RECORD_TYPE align(1),
    DataLength: u32 align(1),
    Data: [1]u8 align(1),
};

pub const DBGPROP_ATTRIB_FLAGS = enum(i32) {
    NO_ATTRIB = 0,
    VALUE_IS_INVALID = 8,
    VALUE_IS_EXPANDABLE = 16,
    VALUE_IS_FAKE = 32,
    VALUE_IS_METHOD = 256,
    VALUE_IS_EVENT = 512,
    VALUE_IS_RAW_STRING = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    FRAME_INTRYBLOCK = 16777216,
    FRAME_INCATCHBLOCK = 33554432,
    FRAME_INFINALLYBLOCK = 67108864,
    VALUE_IS_RETURN_VALUE = 134217728,
    VALUE_PENDING_MUTATION = 268435456,
    _,
    pub fn initFlags(o: struct {
        NO_ATTRIB: u1 = 0,
        VALUE_IS_INVALID: u1 = 0,
        VALUE_IS_EXPANDABLE: u1 = 0,
        VALUE_IS_FAKE: u1 = 0,
        VALUE_IS_METHOD: u1 = 0,
        VALUE_IS_EVENT: u1 = 0,
        VALUE_IS_RAW_STRING: u1 = 0,
        VALUE_READONLY: u1 = 0,
        ACCESS_PUBLIC: u1 = 0,
        ACCESS_PRIVATE: u1 = 0,
        ACCESS_PROTECTED: u1 = 0,
        ACCESS_FINAL: u1 = 0,
        STORAGE_GLOBAL: u1 = 0,
        STORAGE_STATIC: u1 = 0,
        STORAGE_FIELD: u1 = 0,
        STORAGE_VIRTUAL: u1 = 0,
        TYPE_IS_CONSTANT: u1 = 0,
        TYPE_IS_SYNCHRONIZED: u1 = 0,
        TYPE_IS_VOLATILE: u1 = 0,
        HAS_EXTENDED_ATTRIBS: u1 = 0,
        FRAME_INTRYBLOCK: u1 = 0,
        FRAME_INCATCHBLOCK: u1 = 0,
        FRAME_INFINALLYBLOCK: u1 = 0,
        VALUE_IS_RETURN_VALUE: u1 = 0,
        VALUE_PENDING_MUTATION: u1 = 0,
    }) DBGPROP_ATTRIB_FLAGS {
        return @as(DBGPROP_ATTRIB_FLAGS, @enumFromInt(
              (if (o.NO_ATTRIB == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.NO_ATTRIB) else 0)
            | (if (o.VALUE_IS_INVALID == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID) else 0)
            | (if (o.VALUE_IS_EXPANDABLE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE) else 0)
            | (if (o.VALUE_IS_FAKE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE) else 0)
            | (if (o.VALUE_IS_METHOD == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD) else 0)
            | (if (o.VALUE_IS_EVENT == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT) else 0)
            | (if (o.VALUE_IS_RAW_STRING == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING) else 0)
            | (if (o.VALUE_READONLY == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_READONLY) else 0)
            | (if (o.ACCESS_PUBLIC == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC) else 0)
            | (if (o.ACCESS_PRIVATE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE) else 0)
            | (if (o.ACCESS_PROTECTED == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED) else 0)
            | (if (o.ACCESS_FINAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL) else 0)
            | (if (o.STORAGE_GLOBAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL) else 0)
            | (if (o.STORAGE_STATIC == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC) else 0)
            | (if (o.STORAGE_FIELD == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD) else 0)
            | (if (o.STORAGE_VIRTUAL == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL) else 0)
            | (if (o.TYPE_IS_CONSTANT == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT) else 0)
            | (if (o.TYPE_IS_SYNCHRONIZED == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED) else 0)
            | (if (o.TYPE_IS_VOLATILE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE) else 0)
            | (if (o.HAS_EXTENDED_ATTRIBS == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS) else 0)
            | (if (o.FRAME_INTRYBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK) else 0)
            | (if (o.FRAME_INCATCHBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK) else 0)
            | (if (o.FRAME_INFINALLYBLOCK == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK) else 0)
            | (if (o.VALUE_IS_RETURN_VALUE == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE) else 0)
            | (if (o.VALUE_PENDING_MUTATION == 1) @intFromEnum(DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION) else 0)
        ));
    }
};
pub const DBGPROP_ATTRIB_NO_ATTRIB = DBGPROP_ATTRIB_FLAGS.NO_ATTRIB;
pub const DBGPROP_ATTRIB_VALUE_IS_INVALID = DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID;
pub const DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE;
pub const DBGPROP_ATTRIB_VALUE_IS_FAKE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE;
pub const DBGPROP_ATTRIB_VALUE_IS_METHOD = DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD;
pub const DBGPROP_ATTRIB_VALUE_IS_EVENT = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT;
pub const DBGPROP_ATTRIB_VALUE_IS_RAW_STRING = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING;
pub const DBGPROP_ATTRIB_VALUE_READONLY = DBGPROP_ATTRIB_FLAGS.VALUE_READONLY;
pub const DBGPROP_ATTRIB_ACCESS_PUBLIC = DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC;
pub const DBGPROP_ATTRIB_ACCESS_PRIVATE = DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE;
pub const DBGPROP_ATTRIB_ACCESS_PROTECTED = DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED;
pub const DBGPROP_ATTRIB_ACCESS_FINAL = DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL;
pub const DBGPROP_ATTRIB_STORAGE_GLOBAL = DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL;
pub const DBGPROP_ATTRIB_STORAGE_STATIC = DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC;
pub const DBGPROP_ATTRIB_STORAGE_FIELD = DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD;
pub const DBGPROP_ATTRIB_STORAGE_VIRTUAL = DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL;
pub const DBGPROP_ATTRIB_TYPE_IS_CONSTANT = DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT;
pub const DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED = DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED;
pub const DBGPROP_ATTRIB_TYPE_IS_VOLATILE = DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE;
pub const DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS = DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS;
pub const DBGPROP_ATTRIB_FRAME_INTRYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INCATCHBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK;
pub const DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE;
pub const DBGPROP_ATTRIB_VALUE_PENDING_MUTATION = DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION;

pub const DBGPROP_INFO = enum(i32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    BEAUTIFY = 33554432,
    CALLTOSTRING = 67108864,
    AUTOEXPAND = 134217728,
    _,
    pub fn initFlags(o: struct {
        NAME: u1 = 0,
        TYPE: u1 = 0,
        VALUE: u1 = 0,
        FULLNAME: u1 = 0,
        ATTRIBUTES: u1 = 0,
        DEBUGPROP: u1 = 0,
        BEAUTIFY: u1 = 0,
        CALLTOSTRING: u1 = 0,
        AUTOEXPAND: u1 = 0,
    }) DBGPROP_INFO {
        return @as(DBGPROP_INFO, @enumFromInt(
              (if (o.NAME == 1) @intFromEnum(DBGPROP_INFO.NAME) else 0)
            | (if (o.TYPE == 1) @intFromEnum(DBGPROP_INFO.TYPE) else 0)
            | (if (o.VALUE == 1) @intFromEnum(DBGPROP_INFO.VALUE) else 0)
            | (if (o.FULLNAME == 1) @intFromEnum(DBGPROP_INFO.FULLNAME) else 0)
            | (if (o.ATTRIBUTES == 1) @intFromEnum(DBGPROP_INFO.ATTRIBUTES) else 0)
            | (if (o.DEBUGPROP == 1) @intFromEnum(DBGPROP_INFO.DEBUGPROP) else 0)
            | (if (o.BEAUTIFY == 1) @intFromEnum(DBGPROP_INFO.BEAUTIFY) else 0)
            | (if (o.CALLTOSTRING == 1) @intFromEnum(DBGPROP_INFO.CALLTOSTRING) else 0)
            | (if (o.AUTOEXPAND == 1) @intFromEnum(DBGPROP_INFO.AUTOEXPAND) else 0)
        ));
    }
};
pub const DBGPROP_INFO_NAME = DBGPROP_INFO.NAME;
pub const DBGPROP_INFO_TYPE = DBGPROP_INFO.TYPE;
pub const DBGPROP_INFO_VALUE = DBGPROP_INFO.VALUE;
pub const DBGPROP_INFO_FULLNAME = DBGPROP_INFO.FULLNAME;
pub const DBGPROP_INFO_ATTRIBUTES = DBGPROP_INFO.ATTRIBUTES;
pub const DBGPROP_INFO_DEBUGPROP = DBGPROP_INFO.DEBUGPROP;
pub const DBGPROP_INFO_BEAUTIFY = DBGPROP_INFO.BEAUTIFY;
pub const DBGPROP_INFO_CALLTOSTRING = DBGPROP_INFO.CALLTOSTRING;
pub const DBGPROP_INFO_AUTOEXPAND = DBGPROP_INFO.AUTOEXPAND;

pub const OBJECT_ATTRIB_FLAGS = enum(i32) {
    NO_ATTRIB = 0,
    NO_NAME = 1,
    NO_TYPE = 2,
    NO_VALUE = 4,
    VALUE_IS_INVALID = 8,
    VALUE_IS_OBJECT = 16,
    VALUE_IS_ENUM = 32,
    VALUE_IS_CUSTOM = 64,
    OBJECT_IS_EXPANDABLE = 112,
    VALUE_HAS_CODE = 128,
    TYPE_IS_OBJECT = 256,
    TYPE_HAS_CODE = 512,
    // TYPE_IS_EXPANDABLE = 256, this enum value conflicts with TYPE_IS_OBJECT
    SLOT_IS_CATEGORY = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    IS_CLASS = 16777216,
    IS_FUNCTION = 33554432,
    IS_VARIABLE = 67108864,
    IS_PROPERTY = 134217728,
    IS_MACRO = 268435456,
    IS_TYPE = 536870912,
    IS_INHERITED = 1073741824,
    IS_INTERFACE = -2147483648,
};
pub const OBJECT_ATTRIB_NO_ATTRIB = OBJECT_ATTRIB_FLAGS.NO_ATTRIB;
pub const OBJECT_ATTRIB_NO_NAME = OBJECT_ATTRIB_FLAGS.NO_NAME;
pub const OBJECT_ATTRIB_NO_TYPE = OBJECT_ATTRIB_FLAGS.NO_TYPE;
pub const OBJECT_ATTRIB_NO_VALUE = OBJECT_ATTRIB_FLAGS.NO_VALUE;
pub const OBJECT_ATTRIB_VALUE_IS_INVALID = OBJECT_ATTRIB_FLAGS.VALUE_IS_INVALID;
pub const OBJECT_ATTRIB_VALUE_IS_OBJECT = OBJECT_ATTRIB_FLAGS.VALUE_IS_OBJECT;
pub const OBJECT_ATTRIB_VALUE_IS_ENUM = OBJECT_ATTRIB_FLAGS.VALUE_IS_ENUM;
pub const OBJECT_ATTRIB_VALUE_IS_CUSTOM = OBJECT_ATTRIB_FLAGS.VALUE_IS_CUSTOM;
pub const OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE = OBJECT_ATTRIB_FLAGS.OBJECT_IS_EXPANDABLE;
pub const OBJECT_ATTRIB_VALUE_HAS_CODE = OBJECT_ATTRIB_FLAGS.VALUE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_OBJECT = OBJECT_ATTRIB_FLAGS.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_TYPE_HAS_CODE = OBJECT_ATTRIB_FLAGS.TYPE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_EXPANDABLE = OBJECT_ATTRIB_FLAGS.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_SLOT_IS_CATEGORY = OBJECT_ATTRIB_FLAGS.SLOT_IS_CATEGORY;
pub const OBJECT_ATTRIB_VALUE_READONLY = OBJECT_ATTRIB_FLAGS.VALUE_READONLY;
pub const OBJECT_ATTRIB_ACCESS_PUBLIC = OBJECT_ATTRIB_FLAGS.ACCESS_PUBLIC;
pub const OBJECT_ATTRIB_ACCESS_PRIVATE = OBJECT_ATTRIB_FLAGS.ACCESS_PRIVATE;
pub const OBJECT_ATTRIB_ACCESS_PROTECTED = OBJECT_ATTRIB_FLAGS.ACCESS_PROTECTED;
pub const OBJECT_ATTRIB_ACCESS_FINAL = OBJECT_ATTRIB_FLAGS.ACCESS_FINAL;
pub const OBJECT_ATTRIB_STORAGE_GLOBAL = OBJECT_ATTRIB_FLAGS.STORAGE_GLOBAL;
pub const OBJECT_ATTRIB_STORAGE_STATIC = OBJECT_ATTRIB_FLAGS.STORAGE_STATIC;
pub const OBJECT_ATTRIB_STORAGE_FIELD = OBJECT_ATTRIB_FLAGS.STORAGE_FIELD;
pub const OBJECT_ATTRIB_STORAGE_VIRTUAL = OBJECT_ATTRIB_FLAGS.STORAGE_VIRTUAL;
pub const OBJECT_ATTRIB_TYPE_IS_CONSTANT = OBJECT_ATTRIB_FLAGS.TYPE_IS_CONSTANT;
pub const OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED = OBJECT_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED;
pub const OBJECT_ATTRIB_TYPE_IS_VOLATILE = OBJECT_ATTRIB_FLAGS.TYPE_IS_VOLATILE;
pub const OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS = OBJECT_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS;
pub const OBJECT_ATTRIB_IS_CLASS = OBJECT_ATTRIB_FLAGS.IS_CLASS;
pub const OBJECT_ATTRIB_IS_FUNCTION = OBJECT_ATTRIB_FLAGS.IS_FUNCTION;
pub const OBJECT_ATTRIB_IS_VARIABLE = OBJECT_ATTRIB_FLAGS.IS_VARIABLE;
pub const OBJECT_ATTRIB_IS_PROPERTY = OBJECT_ATTRIB_FLAGS.IS_PROPERTY;
pub const OBJECT_ATTRIB_IS_MACRO = OBJECT_ATTRIB_FLAGS.IS_MACRO;
pub const OBJECT_ATTRIB_IS_TYPE = OBJECT_ATTRIB_FLAGS.IS_TYPE;
pub const OBJECT_ATTRIB_IS_INHERITED = OBJECT_ATTRIB_FLAGS.IS_INHERITED;
pub const OBJECT_ATTRIB_IS_INTERFACE = OBJECT_ATTRIB_FLAGS.IS_INTERFACE;

pub const PROP_INFO_FLAGS = enum(i32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    AUTOEXPAND = 134217728,
};
pub const PROP_INFO_NAME = PROP_INFO_FLAGS.NAME;
pub const PROP_INFO_TYPE = PROP_INFO_FLAGS.TYPE;
pub const PROP_INFO_VALUE = PROP_INFO_FLAGS.VALUE;
pub const PROP_INFO_FULLNAME = PROP_INFO_FLAGS.FULLNAME;
pub const PROP_INFO_ATTRIBUTES = PROP_INFO_FLAGS.ATTRIBUTES;
pub const PROP_INFO_DEBUGPROP = PROP_INFO_FLAGS.DEBUGPROP;
pub const PROP_INFO_AUTOEXPAND = PROP_INFO_FLAGS.AUTOEXPAND;

pub const DebugPropertyInfo = extern struct {
    m_dwValidFields: u32,
    m_bstrName: ?BSTR,
    m_bstrType: ?BSTR,
    m_bstrValue: ?BSTR,
    m_bstrFullName: ?BSTR,
    m_dwAttrib: u32,
    m_pDebugProp: ?*IDebugProperty,
};

pub const EX_PROP_INFO_FLAGS = enum(i32) {
    ID = 256,
    NTYPE = 512,
    NVALUE = 1024,
    LOCKBYTES = 2048,
    DEBUGEXTPROP = 4096,
};
pub const EX_PROP_INFO_ID = EX_PROP_INFO_FLAGS.ID;
pub const EX_PROP_INFO_NTYPE = EX_PROP_INFO_FLAGS.NTYPE;
pub const EX_PROP_INFO_NVALUE = EX_PROP_INFO_FLAGS.NVALUE;
pub const EX_PROP_INFO_LOCKBYTES = EX_PROP_INFO_FLAGS.LOCKBYTES;
pub const EX_PROP_INFO_DEBUGEXTPROP = EX_PROP_INFO_FLAGS.DEBUGEXTPROP;

pub const ExtendedDebugPropertyInfo = extern struct {
    dwValidFields: u32,
    pszName: ?PWSTR,
    pszType: ?PWSTR,
    pszValue: ?PWSTR,
    pszFullName: ?PWSTR,
    dwAttrib: u32,
    pDebugProp: ?*IDebugProperty,
    nDISPID: u32,
    nType: u32,
    varValue: VARIANT,
    plbValue: ?*ILockBytes,
    pDebugExtProp: ?*IDebugExtendedProperty,
};

const IID_IDebugProperty_Value = Guid.initString("51973c50-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugProperty = &IID_IDebugProperty_Value;
pub const IDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pPropertyInfo: ?*DebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pPropertyInfo: ?*DebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetExtendedInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugProperty,
                cInfos: u32,
                rgguidExtendedInfo: [*]Guid,
                rgvar: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugProperty,
                cInfos: u32,
                rgguidExtendedInfo: [*]Guid,
                rgvar: [*]VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValueAsString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugProperty,
                pszValue: ?[*:0]align(1) const u16,
                nRadix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugProperty,
                pszValue: ?[*:0]align(1) const u16,
                nRadix: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                refiid: ?*const Guid,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                refiid: ?*const Guid,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugProperty,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugProperty,
                ppDebugProp: ?*?*IDebugProperty,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pPropertyInfo: ?*DebugPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetPropertyInfo(@as(*const IDebugProperty, @ptrCast(self)), dwFieldSpec, nRadix, pPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetExtendedInfo(self: *const T, cInfos: u32, rgguidExtendedInfo: [*]Guid, rgvar: [*]VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetExtendedInfo(@as(*const IDebugProperty, @ptrCast(self)), cInfos, rgguidExtendedInfo, rgvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_SetValueAsString(self: *const T, pszValue: ?[*:0]align(1) const u16, nRadix: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).SetValueAsString(@as(*const IDebugProperty, @ptrCast(self)), pszValue, nRadix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_EnumMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, refiid: ?*const Guid, ppepi: ?*?*IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).EnumMembers(@as(*const IDebugProperty, @ptrCast(self)), dwFieldSpec, nRadix, refiid, ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetParent(self: *const T, ppDebugProp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @as(*const IDebugProperty.VTable, @ptrCast(self.vtable)).GetParent(@as(*const IDebugProperty, @ptrCast(self)), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugPropertyInfo_Value = Guid.initString("51973c51-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugPropertyInfo = &IID_IEnumDebugPropertyInfo_Value;
pub const IEnumDebugPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
                pi: [*]DebugPropertyInfo,
                pcEltsfetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
                pi: [*]DebugPropertyInfo,
                pcEltsfetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugPropertyInfo,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugPropertyInfo,
                ppepi: ?*?*IEnumDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Next(self: *const T, celt: u32, pi: [*]DebugPropertyInfo, pcEltsfetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), celt, pi, pcEltsfetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Clone(self: *const T, ppepi: ?*?*IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugPropertyInfo.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumDebugPropertyInfo, @ptrCast(self)), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExtendedProperty_Value = Guid.initString("51973c52-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExtendedProperty = &IID_IDebugExtendedProperty_Value;
pub const IDebugExtendedProperty = extern struct {
    pub const VTable = extern struct {
        base: IDebugProperty.VTable,
        GetExtendedPropertyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumExtendedMembers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                ppeepi: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugExtendedProperty,
                dwFieldSpec: u32,
                nRadix: u32,
                ppeepi: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_GetExtendedPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IDebugExtendedProperty.VTable, @ptrCast(self.vtable)).GetExtendedPropertyInfo(@as(*const IDebugExtendedProperty, @ptrCast(self)), dwFieldSpec, nRadix, pExtendedPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_EnumExtendedMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, ppeepi: ?*?*IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IDebugExtendedProperty.VTable, @ptrCast(self.vtable)).EnumExtendedMembers(@as(*const IDebugExtendedProperty, @ptrCast(self)), dwFieldSpec, nRadix, ppeepi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExtendedPropertyInfo_Value = Guid.initString("51973c53-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExtendedPropertyInfo = &IID_IEnumDebugExtendedPropertyInfo_Value;
pub const IEnumDebugExtendedPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
                rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
                rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
                pceltFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                celt: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                pedpe: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                pedpe: ?*?*IEnumDebugExtendedPropertyInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumDebugExtendedPropertyInfo,
                pcelt: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Next(self: *const T, celt: u32, rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), celt, rgExtendedPropertyInfo, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Clone(self: *const T, pedpe: ?*?*IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), pedpe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumDebugExtendedPropertyInfo.VTable, @ptrCast(self.vtable)).GetCount(@as(*const IEnumDebugExtendedPropertyInfo, @ptrCast(self)), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPerPropertyBrowsing2_Value = Guid.initString("51973c54-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IPerPropertyBrowsing2 = &IID_IPerPropertyBrowsing2_Value;
pub const IPerPropertyBrowsing2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pBstr: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapPropertyToPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pClsidPropPage: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pClsidPropPage: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPredefinedStrings: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pCaStrings: ?*CALPOLESTR,
                pCaCookies: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                pCaStrings: ?*CALPOLESTR,
                pCaCookies: ?*CADWORD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPredefinedValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPerPropertyBrowsing2,
                dispid: i32,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetDisplayString(self: *const T, dispid: i32, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).GetDisplayString(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_MapPropertyToPage(self: *const T, dispid: i32, pClsidPropPage: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).MapPropertyToPage(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pClsidPropPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetPredefinedStrings(self: *const T, dispid: i32, pCaStrings: ?*CALPOLESTR, pCaCookies: ?*CADWORD) callconv(.Inline) HRESULT {
            return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).GetPredefinedStrings(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, pCaStrings, pCaCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_SetPredefinedValue(self: *const T, dispid: i32, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IPerPropertyBrowsing2.VTable, @ptrCast(self.vtable)).SetPredefinedValue(@as(*const IPerPropertyBrowsing2, @ptrCast(self)), dispid, dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_All_Value = Guid.initString("51973c55-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_All = &IID_IDebugPropertyEnumType_All_Value;
pub const IDebugPropertyEnumType_All = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebugPropertyEnumType_All,
                __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebugPropertyEnumType_All,
                __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPropertyEnumType_All_GetName(self: *const T, __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDebugPropertyEnumType_All.VTable, @ptrCast(self.vtable)).GetName(@as(*const IDebugPropertyEnumType_All, @ptrCast(self)), __MIDL__IDebugPropertyEnumType_All0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Locals_Value = Guid.initString("51973c56-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Locals = &IID_IDebugPropertyEnumType_Locals_Value;
pub const IDebugPropertyEnumType_Locals = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Arguments_Value = Guid.initString("51973c57-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Arguments = &IID_IDebugPropertyEnumType_Arguments_Value;
pub const IDebugPropertyEnumType_Arguments = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_LocalsPlusArgs_Value = Guid.initString("51973c58-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_LocalsPlusArgs = &IID_IDebugPropertyEnumType_LocalsPlusArgs_Value;
pub const IDebugPropertyEnumType_LocalsPlusArgs = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Registers_Value = Guid.initString("51973c59-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Registers = &IID_IDebugPropertyEnumType_Registers_Value;
pub const IDebugPropertyEnumType_Registers = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONTEXT = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        ContextFlags: CONTEXT_FLAGS,
        Cpsr: u32,
        Anonymous: extern union {
            Anonymous: extern struct {
                X0: u64,
                X1: u64,
                X2: u64,
                X3: u64,
                X4: u64,
                X5: u64,
                X6: u64,
                X7: u64,
                X8: u64,
                X9: u64,
                X10: u64,
                X11: u64,
                X12: u64,
                X13: u64,
                X14: u64,
                X15: u64,
                X16: u64,
                X17: u64,
                X18: u64,
                X19: u64,
                X20: u64,
                X21: u64,
                X22: u64,
                X23: u64,
                X24: u64,
                X25: u64,
                X26: u64,
                X27: u64,
                X28: u64,
                Fp: u64,
                Lr: u64,
            },
            X: [31]u64,
        },
        Sp: u64,
        Pc: u64,
        V: [32]ARM64_NT_NEON128,
        Fpcr: u32,
        Fpsr: u32,
        Bcr: [8]u32,
        Bvr: [8]u64,
        Wcr: [2]u32,
        Wvr: [2]u64,
    },
    .X64 => extern struct {
        P1Home: u64,
        P2Home: u64,
        P3Home: u64,
        P4Home: u64,
        P5Home: u64,
        P6Home: u64,
        ContextFlags: CONTEXT_FLAGS,
        MxCsr: u32,
        SegCs: u16,
        SegDs: u16,
        SegEs: u16,
        SegFs: u16,
        SegGs: u16,
        SegSs: u16,
        EFlags: u32,
        Dr0: u64,
        Dr1: u64,
        Dr2: u64,
        Dr3: u64,
        Dr6: u64,
        Dr7: u64,
        Rax: u64,
        Rcx: u64,
        Rdx: u64,
        Rbx: u64,
        Rsp: u64,
        Rbp: u64,
        Rsi: u64,
        Rdi: u64,
        R8: u64,
        R9: u64,
        R10: u64,
        R11: u64,
        R12: u64,
        R13: u64,
        R14: u64,
        R15: u64,
        Rip: u64,
        Anonymous: extern union {
            FltSave: XSAVE_FORMAT,
            Anonymous: extern struct {
                Header: [2]M128A,
                Legacy: [8]M128A,
                Xmm0: M128A,
                Xmm1: M128A,
                Xmm2: M128A,
                Xmm3: M128A,
                Xmm4: M128A,
                Xmm5: M128A,
                Xmm6: M128A,
                Xmm7: M128A,
                Xmm8: M128A,
                Xmm9: M128A,
                Xmm10: M128A,
                Xmm11: M128A,
                Xmm12: M128A,
                Xmm13: M128A,
                Xmm14: M128A,
                Xmm15: M128A,
            },
        },
        VectorRegister: [26]M128A,
        VectorControl: u64,
        DebugControl: u64,
        LastBranchToRip: u64,
        LastBranchFromRip: u64,
        LastExceptionToRip: u64,
        LastExceptionFromRip: u64,
    },
    .X86 => extern struct {
        ContextFlags: CONTEXT_FLAGS,
        Dr0: u32,
        Dr1: u32,
        Dr2: u32,
        Dr3: u32,
        Dr6: u32,
        Dr7: u32,
        FloatSave: FLOATING_SAVE_AREA,
        SegGs: u32,
        SegFs: u32,
        SegEs: u32,
        SegDs: u32,
        Edi: u32,
        Esi: u32,
        Ebx: u32,
        Edx: u32,
        Ecx: u32,
        Eax: u32,
        Ebp: u32,
        Eip: u32,
        SegCs: u32,
        EFlags: u32,
        Esp: u32,
        SegSs: u32,
        ExtendedRegisters: [512]u8,
    },
};
pub const DISPATCHER_CONTEXT = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        ControlPc: usize,
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        EstablisherFrame: usize,
        TargetPc: usize,
        ContextRecord: ?*CONTEXT,
        LanguageHandler: ?EXCEPTION_ROUTINE,
        HandlerData: ?*anyopaque,
        HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ScopeIndex: u32,
        ControlPcIsUnwound: BOOLEAN,
        NonVolatileRegisters: ?*u8,
    },
    .X64 => extern struct {
        ControlPc: u64,
        ImageBase: u64,
        FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
        EstablisherFrame: u64,
        TargetIp: u64,
        ContextRecord: ?*CONTEXT,
        LanguageHandler: ?EXCEPTION_ROUTINE,
        HandlerData: ?*anyopaque,
        HistoryTable: ?*UNWIND_HISTORY_TABLE,
        ScopeIndex: u32,
        Fill0: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PGET_RUNTIME_FUNCTION_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
        else => *const fn(
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    } ,
    .X64 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
        else => *const fn(
            ControlPc: u64,
            Context: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        X19: ?*u64,
        X20: ?*u64,
        X21: ?*u64,
        X22: ?*u64,
        X23: ?*u64,
        X24: ?*u64,
        X25: ?*u64,
        X26: ?*u64,
        X27: ?*u64,
        X28: ?*u64,
        Fp: ?*u64,
        Lr: ?*u64,
        D8: ?*u64,
        D9: ?*u64,
        D10: ?*u64,
        D11: ?*u64,
        D12: ?*u64,
        D13: ?*u64,
        D14: ?*u64,
        D15: ?*u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const UNWIND_HISTORY_TABLE_ENTRY = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    },
    .X64 => extern struct {
        ImageBase: usize,
        FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const MINIDUMP_THREAD_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Pad: u32 align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
    },
    .X86, .X64 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
    },
};
pub const MINIDUMP_THREAD_EX_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Pad: u32 align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
        BackingStoreBase: u64 align(4),
        BackingStoreEnd: u64 align(4),
    },
    .X86, .X64 => extern struct {
        ThreadId: u32 align(4),
        ThreadHandle: ?HANDLE align(4),
        Context: CONTEXT align(4),
        SizeOfContext: u32 align(4),
        StackBase: u64 align(4),
        StackEnd: u64 align(4),
        BackingStoreBase: u64 align(4),
        BackingStoreEnd: u64 align(4),
    },
};
pub const XSAVE_FORMAT = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ControlWord: u16,
        StatusWord: u16,
        TagWord: u8,
        Reserved1: u8,
        ErrorOpcode: u16,
        ErrorOffset: u32,
        ErrorSelector: u16,
        Reserved2: u16,
        DataOffset: u32,
        DataSelector: u16,
        Reserved3: u16,
        MxCsr: u32,
        MxCsr_Mask: u32,
        FloatRegisters: [8]M128A,
        XmmRegisters: [16]M128A,
        Reserved4: [96]u8,
    },
    .X86 => extern struct {
        ControlWord: u16,
        StatusWord: u16,
        TagWord: u8,
        Reserved1: u8,
        ErrorOpcode: u16,
        ErrorOffset: u32,
        ErrorSelector: u16,
        Reserved2: u16,
        DataOffset: u32,
        DataSelector: u16,
        Reserved3: u16,
        MxCsr: u32,
        MxCsr_Mask: u32,
        FloatRegisters: [8]M128A,
        XmmRegisters: [8]M128A,
        Reserved4: [224]u8,
    },
};
pub const XSTATE_CONTEXT = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Mask: u64,
        Length: u32,
        Reserved1: u32,
        Area: ?*XSAVE_AREA,
        Buffer: ?*anyopaque,
    },
    .X86 => extern struct {
        Mask: u64,
        Length: u32,
        Reserved1: u32,
        Area: ?*XSAVE_AREA,
        Reserved2: u32,
        Buffer: ?*anyopaque,
        Reserved3: u32,
    },
};
pub const KNONVOLATILE_CONTEXT_POINTERS = switch(@import("../../../../zig.zig").arch) {
    .X64 => extern struct {
        Anonymous1: extern union {
            FloatingContext: [16]?*M128A,
            Anonymous: extern struct {
                Xmm0: ?*M128A,
                Xmm1: ?*M128A,
                Xmm2: ?*M128A,
                Xmm3: ?*M128A,
                Xmm4: ?*M128A,
                Xmm5: ?*M128A,
                Xmm6: ?*M128A,
                Xmm7: ?*M128A,
                Xmm8: ?*M128A,
                Xmm9: ?*M128A,
                Xmm10: ?*M128A,
                Xmm11: ?*M128A,
                Xmm12: ?*M128A,
                Xmm13: ?*M128A,
                Xmm14: ?*M128A,
                Xmm15: ?*M128A,
            },
        },
        Anonymous2: extern union {
            IntegerContext: [16]?*u64,
            Anonymous: extern struct {
                Rax: ?*u64,
                Rcx: ?*u64,
                Rdx: ?*u64,
                Rbx: ?*u64,
                Rsp: ?*u64,
                Rbp: ?*u64,
                Rsi: ?*u64,
                Rdi: ?*u64,
                R8: ?*u64,
                R9: ?*u64,
                R10: ?*u64,
                R11: ?*u64,
                R12: ?*u64,
                R13: ?*u64,
                R14: ?*u64,
                R15: ?*u64,
            },
        },
    },
    .X86 => extern struct {
        Dummy: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const UNWIND_HISTORY_TABLE = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Count: u32,
        LocalHint: u8,
        GlobalHint: u8,
        Search: u8,
        Once: u8,
        LowAddress: usize,
        HighAddress: usize,
        Entry: [12]UNWIND_HISTORY_TABLE_ENTRY,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const MINIDUMP_EXCEPTION_INFORMATION = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ThreadId: u32 align(4),
        ExceptionPointers: ?*EXCEPTION_POINTERS align(4),
        ClientPointers: BOOL align(4),
    },
    .X86 => extern struct {
        ThreadId: u32,
        ExceptionPointers: ?*EXCEPTION_POINTERS,
        ClientPointers: BOOL,
    },
};
pub const MINIDUMP_USER_STREAM = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        Type: u32 align(4),
        BufferSize: u32 align(4),
        Buffer: ?*anyopaque align(4),
    },
    .X86 => extern struct {
        Type: u32,
        BufferSize: u32,
        Buffer: ?*anyopaque,
    },
};
pub const MINIDUMP_USER_STREAM_INFORMATION = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        UserStreamCount: u32 align(4),
        UserStreamArray: ?*MINIDUMP_USER_STREAM align(4),
    },
    .X86 => extern struct {
        UserStreamCount: u32,
        UserStreamArray: ?*MINIDUMP_USER_STREAM,
    },
};
pub const MINIDUMP_CALLBACK_INFORMATION = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        CallbackRoutine: ?MINIDUMP_CALLBACK_ROUTINE align(4),
        CallbackParam: ?*anyopaque align(4),
    },
    .X86 => extern struct {
        CallbackRoutine: ?MINIDUMP_CALLBACK_ROUTINE,
        CallbackParam: ?*anyopaque,
    },
};
pub const LOADED_IMAGE = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS64,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
    .X86 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS32,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
};
pub const ARM64_NT_CONTEXT = switch(@import("../../../../zig.zig").arch) {
    .X86, .X64 => extern struct {
        ContextFlags: u32,
        Cpsr: u32,
        Anonymous: extern union {
            Anonymous: extern struct {
                X0: u64,
                X1: u64,
                X2: u64,
                X3: u64,
                X4: u64,
                X5: u64,
                X6: u64,
                X7: u64,
                X8: u64,
                X9: u64,
                X10: u64,
                X11: u64,
                X12: u64,
                X13: u64,
                X14: u64,
                X15: u64,
                X16: u64,
                X17: u64,
                X18: u64,
                X19: u64,
                X20: u64,
                X21: u64,
                X22: u64,
                X23: u64,
                X24: u64,
                X25: u64,
                X26: u64,
                X27: u64,
                X28: u64,
                Fp: u64,
                Lr: u64,
            },
            X: [31]u64,
        },
        Sp: u64,
        Pc: u64,
        V: [32]ARM64_NT_NEON128,
        Fpcr: u32,
        Fpsr: u32,
        Bcr: [8]u32,
        Bvr: [8]u64,
        Wcr: [2]u32,
        Wvr: [2]u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGE_DEBUG_INFORMATION = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        List: LIST_ENTRY,
        ReservedSize: u32,
        ReservedMappedBase: ?*anyopaque,
        ReservedMachine: u16,
        ReservedCharacteristics: u16,
        ReservedCheckSum: u32,
        ImageBase: u32,
        SizeOfImage: u32,
        ReservedNumberOfSections: u32,
        ReservedSections: ?*IMAGE_SECTION_HEADER,
        ReservedExportedNamesSize: u32,
        ReservedExportedNames: ?PSTR,
        ReservedNumberOfFunctionTableEntries: u32,
        ReservedFunctionTableEntries: ?*IMAGE_FUNCTION_ENTRY,
        ReservedLowestFunctionStartingAddress: u32,
        ReservedHighestFunctionEndingAddress: u32,
        ReservedNumberOfFpoTableEntries: u32,
        ReservedFpoTableEntries: ?*FPO_DATA,
        SizeOfCoffSymbols: u32,
        CoffSymbols: ?*IMAGE_COFF_SYMBOLS_HEADER,
        ReservedSizeOfCodeViewSymbols: u32,
        ReservedCodeViewSymbols: ?*anyopaque,
        ImageFilePath: ?PSTR,
        ImageFileName: ?PSTR,
        ReservedDebugFilePath: ?PSTR,
        ReservedTimeDateStamp: u32,
        ReservedRomImage: BOOL,
        ReservedDebugDirectory: ?*IMAGE_DEBUG_DIRECTORY,
        ReservedNumberOfDebugDirectories: u32,
        ReservedOriginalFunctionTableBaseAddress: u32,
        Reserved: [2]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const ADDRESS = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        Offset: u32,
        Segment: u16,
        Mode: ADDRESS_MODE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const KDHELP = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        Thread: u32,
        ThCallbackStack: u32,
        NextCallback: u32,
        FramePointer: u32,
        KiCallUserMode: u32,
        KeUserCallbackDispatcher: u32,
        SystemRangeStart: u32,
        ThCallbackBStore: u32,
        KiUserExceptionDispatcher: u32,
        StackBase: u32,
        StackLimit: u32,
        Reserved: [5]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const STACKFRAME = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        AddrPC: ADDRESS,
        AddrReturn: ADDRESS,
        AddrFrame: ADDRESS,
        AddrStack: ADDRESS,
        FuncTableEntry: ?*anyopaque,
        Params: [4]u32,
        Far: BOOL,
        Virtual: BOOL,
        Reserved: [3]u32,
        KdHelp: KDHELP,
        AddrBStore: ADDRESS,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PREAD_PROCESS_MEMORY_ROUTINE = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            hProcess: ?HANDLE,
            lpBaseAddress: u32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: ?*anyopaque,
            nSize: u32,
            lpNumberOfBytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            hProcess: ?HANDLE,
            lpBaseAddress: u32,
            // TODO: what to do with BytesParamIndex 3?
            lpBuffer: ?*anyopaque,
            nSize: u32,
            lpNumberOfBytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PFUNCTION_TABLE_ACCESS_ROUTINE = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            hProcess: ?HANDLE,
            AddrBase: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
        else => *const fn(
            hProcess: ?HANDLE,
            AddrBase: u32,
        ) callconv(@import("std").os.windows.WINAPI) ?*anyopaque,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PGET_MODULE_BASE_ROUTINE = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            hProcess: ?HANDLE,
            Address: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        else => *const fn(
            hProcess: ?HANDLE,
            Address: u32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PTRANSLATE_ADDRESS_ROUTINE = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            hProcess: ?HANDLE,
            hThread: ?HANDLE,
            lpaddr: ?*ADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        else => *const fn(
            hProcess: ?HANDLE,
            hThread: ?HANDLE,
            lpaddr: ?*ADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMMODULES_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            ModuleName: ?[*:0]align(1) const u8,
            BaseOfDll: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            ModuleName: ?[*:0]align(1) const u8,
            BaseOfDll: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            SymbolName: ?[*:0]align(1) const u8,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            SymbolName: ?[*:0]align(1) const u8,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACKW = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            SymbolName: ?[*:0]align(1) const u16,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            SymbolName: ?[*:0]align(1) const u16,
            SymbolAddress: u32,
            SymbolSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PENUMLOADED_MODULES_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            ModuleName: ?[*:0]align(1) const u8,
            ModuleBase: u32,
            ModuleSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            ModuleName: ?[*:0]align(1) const u8,
            ModuleBase: u32,
            ModuleSize: u32,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYMBOL_REGISTERED_CALLBACK = switch(@import("../../../../zig.zig").arch) {
    .X86 => switch (@import("builtin").zig_backend) {
        .stage1 => fn(
            hProcess: ?HANDLE,
            ActionCode: u32,
            CallbackData: ?*anyopaque,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        else => *const fn(
            hProcess: ?HANDLE,
            ActionCode: u32,
            CallbackData: ?*anyopaque,
            UserContext: ?*anyopaque,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    } ,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL_PACKAGE = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOL,
        name: [2001]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW_PACKAGE = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOLW,
        name: [2001]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULE = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]CHAR,
        ImageName: [256]CHAR,
        LoadedImageName: [256]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULEW = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]u16,
        ImageName: [256]u16,
        LoadedImageName: [256]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINE = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*anyopaque,
        LineNumber: u32,
        FileName: ?[*]align(1) u8,
        Address: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINEW = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*anyopaque,
        LineNumber: u32,
        FileName: ?[*]align(1) u8,
        Address: u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        CheckSum: u32,
        TimeDateStamp: u32,
        FileName: [260]CHAR,
        Reparse: BOOLEAN,
        hFile: ?HANDLE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DUPLICATE_SYMBOL = switch(@import("../../../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        NumberOfDups: u32,
        Symbol: ?*IMAGEHLP_SYMBOL,
        SelectedSymbol: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

//--------------------------------------------------------------------------------
// Section: Functions (325)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

pub extern "kernel32" fn RtlAddFunctionTable(
    FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    BaseAddress: usize,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

pub extern "kernel32" fn RtlDeleteFunctionTable(
    FunctionTable: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

pub extern "kernel32" fn RtlInstallFunctionTableCallback(
    TableIdentifier: u64,
    BaseAddress: u64,
    Length: u32,
    Callback: ?PGET_RUNTIME_FUNCTION_CALLBACK,
    Context: ?*anyopaque,
    OutOfProcessCallbackDll: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlAddGrowableFunctionTable(
    DynamicTable: ?*?*anyopaque,
    FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    MaximumEntryCount: u32,
    RangeBase: usize,
    RangeEnd: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

pub extern "kernel32" fn RtlLookupFunctionEntry(
    ControlPc: usize,
    ImageBase: ?*usize,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.Arm64 => struct {

pub extern "kernel32" fn RtlVirtualUnwind(
    HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
    ImageBase: usize,
    ControlPc: usize,
    FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    ContextRecord: ?*CONTEXT,
    HandlerData: ?*?*anyopaque,
    EstablisherFrame: ?*usize,
    ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS_ARM64,
) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ReadProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*const anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*anyopaque,
    nSize: usize,
    lpNumberOfBytesRead: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WriteProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*anyopaque,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*const anyopaque,
    nSize: usize,
    lpNumberOfBytesWritten: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FlushInstructionCache(
    hProcess: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBaseAddress: ?*const anyopaque,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn Wow64SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlCaptureContext2(
    ContextRecord: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlAddFunctionTable(
    FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    BaseAddress: u64,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlDeleteFunctionTable(
    FunctionTable: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlInstallFunctionTableCallback(
    TableIdentifier: u64,
    BaseAddress: u64,
    Length: u32,
    Callback: ?PGET_RUNTIME_FUNCTION_CALLBACK,
    Context: ?*anyopaque,
    OutOfProcessCallbackDll: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlAddGrowableFunctionTable(
    DynamicTable: ?*?*anyopaque,
    FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    MaximumEntryCount: u32,
    RangeBase: usize,
    RangeEnd: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlGrowFunctionTable(
    DynamicTable: ?*anyopaque,
    NewEntryCount: u32,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlDeleteGrowableFunctionTable(
    DynamicTable: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlLookupFunctionEntry(
    ControlPc: u64,
    ImageBase: ?*u64,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "kernel32" fn RtlUnwindEx(
    TargetFrame: ?*anyopaque,
    TargetIp: ?*anyopaque,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: ?*anyopaque,
    ContextRecord: ?*CONTEXT,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64 => struct {

pub extern "kernel32" fn RtlVirtualUnwind(
    HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
    ImageBase: u64,
    ControlPc: u64,
    FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    ContextRecord: ?*CONTEXT,
    HandlerData: ?*?*anyopaque,
    EstablisherFrame: ?*u64,
    ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS,
) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn CheckSumMappedFile(
    BaseAddress: ?*anyopaque,
    FileLength: u32,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS64;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn GetImageConfigInformation(
    LoadedImage: ?*LOADED_IMAGE,
    ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn SetImageConfigInformation(
    LoadedImage: ?*LOADED_IMAGE,
    ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageNtHeader(
    Base: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS64;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageRvaToSection(
    NtHeaders: ?*IMAGE_NT_HEADERS64,
    Base: ?*anyopaque,
    Rva: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageRvaToVa(
    NtHeaders: ?*IMAGE_NT_HEADERS64,
    Base: ?*anyopaque,
    Rva: u32,
    LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlCaptureStackBackTrace(
    FramesToSkip: u32,
    FramesToCapture: u32,
    BackTrace: [*]?*anyopaque,
    BackTraceHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlCaptureContext(
    ContextRecord: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RtlUnwind(
    TargetFrame: ?*anyopaque,
    TargetIp: ?*anyopaque,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn RtlRestoreContext(
    ContextRecord: ?*CONTEXT,
    ExceptionRecord: ?*EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn RtlRaiseException(
    ExceptionRecord: ?*EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "kernel32" fn RtlPcToFileHeader(
    PcValue: ?*anyopaque,
    BaseOfImage: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn IsDebuggerPresent(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugBreak(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn OutputDebugStringA(
    lpOutputString: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn OutputDebugStringW(
    lpOutputString: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn ContinueDebugEvent(
    dwProcessId: u32,
    dwThreadId: u32,
    dwContinueStatus: NTSTATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn WaitForDebugEvent(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugActiveProcess(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugActiveProcessStop(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn CheckRemoteDebuggerPresent(
    hProcess: ?HANDLE,
    pbDebuggerPresent: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "kernel32" fn WaitForDebugEventEx(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn EncodePointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn DecodePointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn EncodeSystemPointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "kernel32" fn DecodeSystemPointer(
    Ptr: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "api-ms-win-core-util-l1-1-1" fn EncodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*anyopaque,
    EncodedPtr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-util-l1-1-1" fn DecodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*anyopaque,
    DecodedPtr: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn Beep(
    dwFreq: u32,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RaiseException(
    dwExceptionCode: u32,
    dwExceptionFlags: u32,
    nNumberOfArguments: u32,
    lpArguments: ?[*]const usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn UnhandledExceptionFilter(
    ExceptionInfo: ?*EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter: ?LPTOP_LEVEL_EXCEPTION_FILTER,
) callconv(@import("std").os.windows.WINAPI) ?LPTOP_LEVEL_EXCEPTION_FILTER;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn GetErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn SetErrorMode(
    uMode: THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn AddVectoredExceptionHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn RemoveVectoredExceptionHandler(
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn AddVectoredContinueHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "kernel32" fn RemoveVectoredContinueHandler(
    Handle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn RaiseFailFastException(
    pExceptionRecord: ?*EXCEPTION_RECORD,
    pContextRecord: ?*CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalAppExitA(
    uAction: u32,
    lpMessageText: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalAppExitW(
    uAction: u32,
    lpMessageText: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn GetThreadErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn SetThreadErrorMode(
    dwNewMode: THREAD_ERROR_MODE,
    lpOldMode: ?*THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-errorhandling-l1-1-3" fn TerminateProcessOnMemoryExhaustion(
    FailedAllocationSize: usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn OpenThreadWaitChainSession(
    Flags: OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS,
    callback: ?PWAITCHAINCALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn CloseThreadWaitChainSession(
    WctHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn GetThreadWaitChain(
    WctHandle: ?*anyopaque,
    Context: usize,
    Flags: WAIT_CHAIN_THREAD_OPTIONS,
    ThreadId: u32,
    NodeCount: ?*u32,
    NodeInfoArray: [*]WAITCHAIN_NODE_INFO,
    IsCycle: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "advapi32" fn RegisterWaitChainCOMCallback(
    CallStateCallback: ?PCOGETCALLSTATE,
    ActivationStateCallback: ?PCOGETACTIVATIONSTATE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn MiniDumpWriteDump(
    hProcess: ?HANDLE,
    ProcessId: u32,
    hFile: ?HANDLE,
    DumpType: MINIDUMP_TYPE,
    ExceptionParam: ?*MINIDUMP_EXCEPTION_INFORMATION,
    UserStreamParam: ?*MINIDUMP_USER_STREAM_INFORMATION,
    CallbackParam: ?*MINIDUMP_CALLBACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MiniDumpReadDumpStream(
    BaseOfDump: ?*anyopaque,
    StreamNumber: u32,
    Dir: ?*?*MINIDUMP_DIRECTORY,
    StreamPointer: ?*?*anyopaque,
    StreamSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn BindImage(
    ImageName: ?[*:0]align(1) const u8,
    DllPath: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn BindImageEx(
    Flags: u32,
    ImageName: ?[*:0]align(1) const u8,
    DllPath: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    StatusRoutine: ?PIMAGEHLP_STATUS_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ReBaseImage(
    CurrentImageName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    fReBase: BOOL,
    fRebaseSysfileOk: BOOL,
    fGoingDown: BOOL,
    CheckImageSize: u32,
    OldImageSize: ?*u32,
    OldImageBase: ?*usize,
    NewImageSize: ?*u32,
    NewImageBase: ?*usize,
    TimeStamp: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ReBaseImage64(
    CurrentImageName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    fReBase: BOOL,
    fRebaseSysfileOk: BOOL,
    fGoingDown: BOOL,
    CheckImageSize: u32,
    OldImageSize: ?*u32,
    OldImageBase: ?*u64,
    NewImageSize: ?*u32,
    NewImageBase: ?*u64,
    TimeStamp: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn CheckSumMappedFile(
    BaseAddress: ?*anyopaque,
    FileLength: u32,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS32;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapFileAndCheckSumA(
    Filename: ?[*:0]align(1) const u8,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapFileAndCheckSumW(
    Filename: ?[*:0]align(1) const u16,
    HeaderSum: ?*u32,
    CheckSum: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn GetImageConfigInformation(
    LoadedImage: ?*LOADED_IMAGE,
    ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn GetImageUnusedHeaderBytes(
    LoadedImage: ?*LOADED_IMAGE,
    SizeUnusedHeaderBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn SetImageConfigInformation(
    LoadedImage: ?*LOADED_IMAGE,
    ImageConfigInformation: ?*IMAGE_LOAD_CONFIG_DIRECTORY32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetDigestStream(
    FileHandle: ?HANDLE,
    DigestLevel: u32,
    DigestFunction: ?DIGEST_FUNCTION,
    DigestHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageAddCertificate(
    FileHandle: ?HANDLE,
    Certificate: ?*WIN_CERTIFICATE,
    Index: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageRemoveCertificate(
    FileHandle: ?HANDLE,
    Index: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageEnumerateCertificates(
    FileHandle: ?HANDLE,
    TypeFilter: u16,
    CertificateCount: ?*u32,
    Indices: ?[*]u32,
    IndexCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetCertificateData(
    FileHandle: ?HANDLE,
    CertificateIndex: u32,
    Certificate: ?*WIN_CERTIFICATE,
    RequiredLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageGetCertificateHeader(
    FileHandle: ?HANDLE,
    CertificateIndex: u32,
    Certificateheader: ?*WIN_CERTIFICATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageLoad(
    DllName: ?[*:0]align(1) const u8,
    DllPath: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) ?*LOADED_IMAGE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn ImageUnload(
    LoadedImage: ?*LOADED_IMAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn MapAndLoad(
    ImageName: ?[*:0]align(1) const u8,
    DllPath: ?[*:0]align(1) const u8,
    LoadedImage: ?*LOADED_IMAGE,
    DotDll: BOOL,
    ReadOnly: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UnMapAndLoad(
    LoadedImage: ?*LOADED_IMAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn TouchFileTimes(
    FileHandle: ?HANDLE,
    pSystemTime: ?*SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UpdateDebugInfoFile(
    ImageFileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    DebugFilePath: ?PSTR,
    NtHeaders: ?*IMAGE_NT_HEADERS32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "imagehlp" fn UpdateDebugInfoFileEx(
    ImageFileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    DebugFilePath: ?PSTR,
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    OldCheckSum: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindDebugInfoFile(
    hProcess: ?HANDLE,
    FileName: ?[*:0]align(1) const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindDebugInfoFileW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]align(1) const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFile(
    FileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    DebugFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileEx(
    FileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileExW(
    FileName: ?[*:0]align(1) const u16,
    SymbolPath: ?[*:0]align(1) const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PSTR,
    callback: ?PFINDFILEINPATHCALLBACK,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindFileInPathW(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u16,
    FileName: ?[*:0]align(1) const u16,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PWSTR,
    callback: ?PFINDFILEINPATHCALLBACKW,
    context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindExecutableImage(
    hProcess: ?HANDLE,
    FileName: ?[*:0]align(1) const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindExecutableImageW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]align(1) const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImage(
    FileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    ImageFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageEx(
    FileName: ?[*:0]align(1) const u8,
    SymbolPath: ?[*:0]align(1) const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageExW(
    FileName: ?[*:0]align(1) const u16,
    SymbolPath: ?[*:0]align(1) const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageNtHeader(
    Base: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS32;

}, else => struct { } };

pub extern "dbghelp" fn ImageDirectoryEntryToDataEx(
    Base: ?*anyopaque,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
    FoundHeader: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn ImageDirectoryEntryToData(
    Base: ?*anyopaque,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageRvaToSection(
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    Base: ?*anyopaque,
    Rva: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageRvaToVa(
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    Base: ?*anyopaque,
    Rva: u32,
    LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

}, else => struct { } };

pub extern "dbghelp" fn SearchTreeForFile(
    RootPath: ?[*:0]align(1) const u8,
    InputPathName: ?[*:0]align(1) const u8,
    OutputPathBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SearchTreeForFileW(
    RootPath: ?[*:0]align(1) const u16,
    InputPathName: ?[*:0]align(1) const u16,
    OutputPathBuffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTree(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]align(1) const u8,
    InputPathName: ?[*:0]align(1) const u8,
    OutputPathBuffer: ?PSTR,
    cb: ?PENUMDIRTREE_CALLBACK,
    data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTreeW(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]align(1) const u16,
    InputPathName: ?[*:0]align(1) const u16,
    OutputPathBuffer: ?PWSTR,
    cb: ?PENUMDIRTREE_CALLBACKW,
    data: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MakeSureDirectoryPathExists(
    DirPath: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn UnDecorateSymbolName(
    name: ?[*:0]align(1) const u8,
    outputString: [*:0]u8,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn UnDecorateSymbolNameW(
    name: ?[*:0]align(1) const u16,
    outputString: [*:0]u16,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn StackWalk64(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME64,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn StackWalkEx(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME_EX,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn StackWalk2(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME_EX,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
    GetTargetAttributeValue: ?PGET_TARGET_ATTRIBUTE_VALUE64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn StackWalk(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME,
    ContextRecord: ?*anyopaque,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn ImagehlpApiVersion(
) callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn ImagehlpApiVersionEx(
    AppVersion: ?*API_VERSION,
) callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn GetTimestampForLoadedLibrary(
    Module: HMODULE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymSetParentWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetHomeDirectory(
    hProcess: ?HANDLE,
    dir: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSetHomeDirectoryW(
    hProcess: ?HANDLE,
    dir: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetHomeDirectory(
    type: u32,
    dir: [*:0]u8,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymGetHomeDirectoryW(
    type: u32,
    dir: [*:0]u16,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetOmaps(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    OmapTo: ?*?*OMAP,
    cOmapTo: ?*u64,
    OmapFrom: ?*?*OMAP,
    cOmapFrom: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetOptions(
    SymOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymGetOptions(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCleanup(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchString(
    string: ?[*:0]align(1) const u8,
    expression: ?[*:0]align(1) const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringA(
    string: ?[*:0]align(1) const u8,
    expression: ?[*:0]align(1) const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringW(
    string: ?[*:0]align(1) const u16,
    expression: ?[*:0]align(1) const u16,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFiles(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]align(1) const u8,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFilesW(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]align(1) const u16,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModules64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModulesW64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymEnumerateModules(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn EnumerateLoadedModulesEx(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesExW(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModules64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesW64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn EnumerateLoadedModules(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymFunctionTableAccess64(
    hProcess: ?HANDLE,
    AddrBase: u64,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn SymFunctionTableAccess64AccessRoutines(
    hProcess: ?HANDLE,
    AddrBase: u64,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymFunctionTableAccess(
    hProcess: ?HANDLE,
    AddrBase: u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

}, else => struct { } };

pub extern "dbghelp" fn SymGetUnwindInfo(
    hProcess: ?HANDLE,
    Address: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfo64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfoW64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleInfo(
    hProcess: ?HANDLE,
    dwAddr: u32,
    ModuleInfo: ?*IMAGEHLP_MODULE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleInfoW(
    hProcess: ?HANDLE,
    dwAddr: u32,
    ModuleInfo: ?*IMAGEHLP_MODULEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetModuleBase64(
    hProcess: ?HANDLE,
    qwAddr: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleBase(
    hProcess: ?HANDLE,
    dwAddr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub extern "dbghelp" fn SymEnumLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddrW64(
    hProcess: ?HANDLE,
    dwAddr: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContext(
    hProcess: ?HANDLE,
    qwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContextW(
    hProcess: ?HANDLE,
    dwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddrIncludeInlineTrace(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCompareInlineTrace(
    hProcess: ?HANDLE,
    Address1: u64,
    InlineContext1: u32,
    RetAddress1: u64,
    Address2: u64,
    RetAddress2: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymQueryInlineTrace(
    hProcess: ?HANDLE,
    StartAddress: u64,
    StartContext: u32,
    StartRetAddress: u64,
    CurAddress: u64,
    CurContext: ?*u32,
    CurFrameIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineFromAddr(
    hProcess: ?HANDLE,
    dwAddr: u32,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetLineFromName64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromNameW64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]align(1) const u16,
    FileName: ?[*:0]align(1) const u16,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineFromName(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetLineNext64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineNextW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineNext(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetLinePrev64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLinePrevW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLinePrev(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetFileLineOffsets64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    Buffer: [*]u64,
    BufferLines: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymMatchFileName(
    FileName: ?[*:0]align(1) const u8,
    Match: ?[*:0]align(1) const u8,
    FileNameStop: ?*?PSTR,
    MatchStop: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchFileNameW(
    FileName: ?[*:0]align(1) const u16,
    Match: ?[*:0]align(1) const u16,
    FileNameStop: ?*?PWSTR,
    MatchStop: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFile(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]align(1) const u8,
    FileSpec: ?[*:0]align(1) const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileW(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]align(1) const u16,
    FileSpec: ?[*:0]align(1) const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileToken(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u8,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenByTokenName(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u8,
    TokenName: ?[*:0]align(1) const u8,
    TokenParameters: ?[*:0]align(1) const u8,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksumW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u16,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksum(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u8,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u16,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenByTokenNameW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u16,
    TokenName: ?[*:0]align(1) const u16,
    TokenParameters: ?[*:0]align(1) const u16,
    Token: ?*?*anyopaque,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromToken(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]align(1) const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenByTokenName(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    TokenName: ?[*:0]align(1) const u8,
    Params: ?[*:0]align(1) const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]align(1) const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenByTokenNameW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    TokenName: ?[*:0]align(1) const u16,
    Params: ?[*:0]align(1) const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromToken(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]align(1) const u8,
    VarName: ?[*:0]align(1) const u8,
    Value: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*anyopaque,
    Params: ?[*:0]align(1) const u16,
    VarName: ?[*:0]align(1) const u16,
    Value: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFileTokens(
    hProcess: ?HANDLE,
    Base: u64,
    Callback: ?PENUMSOURCEFILETOKENSCALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitialize(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]align(1) const u8,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitializeW(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]align(1) const u16,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u8,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u16,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// This function from dll 'dbghelp.dll' is being skipped because it has some sort of issue
pub fn SymLoadModuleEx() void { @panic("this function is not working"); }

// This function from dll 'dbghelp.dll' is being skipped because it has some sort of issue
pub fn SymLoadModuleExW() void { @panic("this function is not working"); }

pub extern "dbghelp" fn SymUnloadModule64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymUnloadModule(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymUnDName64(
    sym: ?*IMAGEHLP_SYMBOL64,
    UnDecName: [*:0]u8,
    UnDecNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymUnDName(
    sym: ?*IMAGEHLP_SYMBOL,
    UnDecName: [*:0]u8,
    UnDecNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymRegisterCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterCallbackW64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterFunctionEntryCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymRegisterCallback(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymRegisterFunctionEntryCallback(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymSetContext(
    hProcess: ?HANDLE,
    StackFrame: ?*IMAGEHLP_STACK_FRAME,
    Context: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumProcesses(
    EnumProcessesCallback: ?PSYM_ENUMPROCESSES_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContextW(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromToken(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNext(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNextW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrev(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrevW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromName(
    hProcess: ?HANDLE,
    Name: ?[*:0]align(1) const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromNameW(
    hProcess: ?HANDLE,
    Name: ?[*:0]align(1) const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbols(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]align(1) const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsEx(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]align(1) const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]align(1) const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsExW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]align(1) const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddr(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearch(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]align(1) const u8,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearchW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]align(1) const u16,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScope(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScopeW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndexW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfo(
    hProcess: ?HANDLE,
    ModBase: u64,
    TypeId: u32,
    GetType: IMAGEHLP_SYMBOL_TYPE_INFO,
    pInfo: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfoEx(
    hProcess: ?HANDLE,
    ModBase: u64,
    Params: ?*IMAGEHLP_GET_TYPE_INFO_PARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypes(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]align(1) const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]align(1) const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u8,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u16,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u8,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]align(1) const u16,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRefreshModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStream(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]align(1) const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamA(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]align(1) const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]align(1) const u16,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStoreW(
    hProcess: ?HANDLE,
    path: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStore(
    hProcess: ?HANDLE,
    path: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvDeltaName(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u8,
    Type: ?[*:0]align(1) const u8,
    File1: ?[*:0]align(1) const u8,
    File2: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvDeltaNameW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u16,
    Type: ?[*:0]align(1) const u16,
    File1: ?[*:0]align(1) const u16,
    File2: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetSupplement(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u8,
    Node: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvGetSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u16,
    Node: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetFileIndexes(
    File: ?[*:0]align(1) const u8,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexesW(
    File: ?[*:0]align(1) const u16,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexStringW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
    Index: [*:0]u16,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexString(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
    Index: [*:0]u8,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfo(
    File: ?[*:0]align(1) const u8,
    Info: ?*SYMSRV_INDEX_INFO,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfoW(
    File: ?[*:0]align(1) const u16,
    Info: ?*SYMSRV_INDEX_INFOW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvStoreSupplement(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]align(1) const u8,
    Node: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u16,
    Node: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvStoreFile(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]align(1) const u8,
    File: ?[*:0]align(1) const u8,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreFileW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]align(1) const u16,
    File: ?[*:0]align(1) const u16,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetSymbolFile(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u8,
    ImageFile: ?[*:0]align(1) const u8,
    Type: u32,
    SymbolFile: [*:0]u8,
    cSymbolFile: usize,
    DbgFile: [*:0]u8,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymbolFileW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]align(1) const u16,
    ImageFile: ?[*:0]align(1) const u16,
    Type: u32,
    SymbolFile: [*:0]u16,
    cSymbolFile: usize,
    DbgFile: [*:0]u16,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDump(
    FileName: ?[*:0]align(1) const u8,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDumpW(
    FileName: ?[*:0]align(1) const u16,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u64,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymFromAddr(
    hProcess: ?HANDLE,
    dwAddr: u32,
    pdwDisplacement: ?*u32,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetSymFromName64(
    hProcess: ?HANDLE,
    Name: ?[*:0]align(1) const u8,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymFromName(
    hProcess: ?HANDLE,
    Name: ?[*:0]align(1) const u8,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

// this function is obselete
pub extern "dbghelp" fn FindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    id: ?*anyopaque,
    two: u32,
    three: u32,
    flags: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// this function is obselete
pub extern "dbghelp" fn FindFileInSearchPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]align(1) const u8,
    FileName: ?[*:0]align(1) const u8,
    one: u32,
    two: u32,
    three: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// this function is obselete
pub extern "dbghelp" fn SymEnumSym(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// this function is obselete
pub extern "dbghelp" fn SymEnumerateSymbols64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// this function is obselete
pub extern "dbghelp" fn SymEnumerateSymbolsW64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64W,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

// this function is obselete
pub extern "dbghelp" fn SymEnumerateSymbols(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

// this function is obselete
pub extern "dbghelp" fn SymEnumerateSymbolsW(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACKW,
    UserContext: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymLoadModule64(
    hProcess: ?HANDLE,
    hFile: ?HANDLE,
    ImageName: ?[*:0]align(1) const u8,
    ModuleName: ?[*:0]align(1) const u8,
    BaseOfDll: u64,
    SizeOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) u64;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymLoadModule(
    hProcess: ?HANDLE,
    hFile: ?HANDLE,
    ImageName: ?[*:0]align(1) const u8,
    ModuleName: ?[*:0]align(1) const u8,
    BaseOfDll: u32,
    SizeOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub extern "dbghelp" fn SymGetSymNext64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymNext(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SymGetSymPrev64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymPrev(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub extern "dbghelp" fn SetCheckUserInterruptShared(
    lpStartAddress: ?LPCALL_BACK_USER_INTERRUPT_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn GetSymLoadError(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SetSymLoadError(
    @"error": u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn ReportSymbolLoadSummary(
    hProcess: ?HANDLE,
    pLoadModule: ?[*:0]align(1) const u16,
    pSymbolData: ?*DBGHELP_DATA_REPORT_STRUCT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RemoveInvalidModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapCreate(
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

pub extern "dbghelp" fn RangeMapFree(
    RmapHandle: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapAddPeImageSections(
    RmapHandle: ?*anyopaque,
    ImageName: ?[*:0]align(1) const u16,
    // TODO: what to do with BytesParamIndex 3?
    MappedImage: ?*anyopaque,
    MappingBytes: u32,
    ImageBase: u64,
    UserTag: u64,
    MappingFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRemove(
    RmapHandle: ?*anyopaque,
    UserTag: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRead(
    RmapHandle: ?*anyopaque,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapWrite(
    RmapHandle: ?*anyopaque,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "user32" fn MessageBeep(
    uType: MESSAGEBOX_STYLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FatalExit(
    ExitCode: i32,
) callconv(@import("std").os.windows.WINAPI) noreturn;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn Wow64GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*WOW64_LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugSetProcessKillOnExit(
    KillOnExit: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn DebugBreakProcess(
    Process: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FormatMessageA(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const anyopaque,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "kernel32" fn FormatMessageW(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const anyopaque,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PWSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn CopyContext(
    Destination: ?*CONTEXT,
    ContextFlags: CONTEXT_FLAGS,
    Source: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn InitializeContext(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    ContextFlags: CONTEXT_FLAGS,
    Context: ?*?*CONTEXT,
    ContextLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "kernel32" fn InitializeContext2(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*anyopaque,
    ContextFlags: CONTEXT_FLAGS,
    Context: ?*?*CONTEXT,
    ContextLength: ?*u32,
    XStateCompactionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn GetEnabledXStateFeatures(
) callconv(@import("std").os.windows.WINAPI) u64;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn GetXStateFeaturesMask(
    Context: ?*CONTEXT,
    FeatureMask: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn LocateXStateFeature(
    Context: ?*CONTEXT,
    FeatureId: u32,
    Length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*anyopaque;

}, else => struct { } };

pub usingnamespace switch (@import("../../../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "kernel32" fn SetXStateFeaturesMask(
    Context: ?*CONTEXT,
    FeatureMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (4)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringA;
        pub const FatalAppExit = thismodule.FatalAppExitA;
        pub const MapFileAndCheckSum = thismodule.MapFileAndCheckSumA;
        pub const FormatMessage = thismodule.FormatMessageA;
    },
    .wide => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringW;
        pub const FatalAppExit = thismodule.FatalAppExitW;
        pub const MapFileAndCheckSum = thismodule.MapFileAndCheckSumW;
        pub const FormatMessage = thismodule.FormatMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OutputDebugString = *opaque{};
        pub const FatalAppExit = *opaque{};
        pub const MapFileAndCheckSum = *opaque{};
        pub const FormatMessage = *opaque{};
    } else struct {
        pub const OutputDebugString = @compileError("'OutputDebugString' requires that UNICODE be set to true or false in the root module");
        pub const FatalAppExit = @compileError("'FatalAppExit' requires that UNICODE be set to true or false in the root module");
        pub const MapFileAndCheckSum = @compileError("'MapFileAndCheckSum' requires that UNICODE be set to true or false in the root module");
        pub const FormatMessage = @compileError("'FormatMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (29)
//--------------------------------------------------------------------------------
const Guid = @import("../../../../zig.zig").Guid;
const BOOL = @import("../../../../windows/win32/foundation.zig").BOOL;
const BOOLEAN = @import("../../../../windows/win32/foundation.zig").BOOLEAN;
const BSTR = @import("../../../../windows/win32/foundation.zig").BSTR;
const CADWORD = @import("../../../../windows/win32/system/ole.zig").CADWORD;
const CALPOLESTR = @import("../../../../windows/win32/system/ole.zig").CALPOLESTR;
const CHAR = @import("../../../../windows/win32/foundation.zig").CHAR;
const HANDLE = @import("../../../../windows/win32/foundation.zig").HANDLE;
const HMODULE = @import("../../../../windows/win32/foundation.zig").HMODULE;
const HRESULT = @import("../../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../../windows/win32/foundation.zig").HWND;
const ILockBytes = @import("../../../../windows/win32/system/com/structured_storage.zig").ILockBytes;
const IMAGE_FILE_MACHINE = @import("../../../../windows/win32/system/system_information.zig").IMAGE_FILE_MACHINE;
const IUnknown = @import("../../../../windows/win32/system/com.zig").IUnknown;
const LIST_ENTRY = @import("../../../../windows/win32/system/kernel.zig").LIST_ENTRY;
const LPTHREAD_START_ROUTINE = @import("../../../../windows/win32/system/threading.zig").LPTHREAD_START_ROUTINE;
const MESSAGEBOX_STYLE = @import("../../../../windows/win32/ui/windows_and_messaging.zig").MESSAGEBOX_STYLE;
const NTSTATUS = @import("../../../../windows/win32/foundation.zig").NTSTATUS;
const PROCESSOR_ARCHITECTURE = @import("../../../../windows/win32/system/system_information.zig").PROCESSOR_ARCHITECTURE;
const PSTR = @import("../../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../../windows/win32/foundation.zig").PWSTR;
const SYSTEMTIME = @import("../../../../windows/win32/foundation.zig").SYSTEMTIME;
const TIME_ZONE_INFORMATION = @import("../../../../windows/win32/system/time.zig").TIME_ZONE_INFORMATION;
const VARIANT = @import("../../../../windows/win32/system/variant.zig").VARIANT;
const VIRTUAL_ALLOCATION_TYPE = @import("../../../../windows/win32/system/memory.zig").VIRTUAL_ALLOCATION_TYPE;
const VS_FIXEDFILEINFO = @import("../../../../windows/win32/storage/file_system.zig").VS_FIXEDFILEINFO;
const WIN_CERTIFICATE = @import("../../../../windows/win32/security/win_trust.zig").WIN_CERTIFICATE;
// 2 arch-specific imports
const EXCEPTION_ROUTINE = switch(@import("../../../../zig.zig").arch) {
    .X64, .Arm64 => @import("../../../../windows/win32/system/kernel.zig").EXCEPTION_ROUTINE,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const FLOATING_SAVE_AREA = switch(@import("../../../../zig.zig").arch) {
    .X86 => @import("../../../../windows/win32/system/kernel.zig").FLOATING_SAVE_AREA,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PVECTORED_EXCEPTION_HANDLER")) { _ = PVECTORED_EXCEPTION_HANDLER; }
    if (@hasDecl(@This(), "LPTOP_LEVEL_EXCEPTION_FILTER")) { _ = LPTOP_LEVEL_EXCEPTION_FILTER; }
    if (@hasDecl(@This(), "PWAITCHAINCALLBACK")) { _ = PWAITCHAINCALLBACK; }
    if (@hasDecl(@This(), "PCOGETCALLSTATE")) { _ = PCOGETCALLSTATE; }
    if (@hasDecl(@This(), "PCOGETACTIVATIONSTATE")) { _ = PCOGETACTIVATIONSTATE; }
    if (@hasDecl(@This(), "MINIDUMP_CALLBACK_ROUTINE")) { _ = MINIDUMP_CALLBACK_ROUTINE; }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE")) { _ = PIMAGEHLP_STATUS_ROUTINE; }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE32")) { _ = PIMAGEHLP_STATUS_ROUTINE32; }
    if (@hasDecl(@This(), "PIMAGEHLP_STATUS_ROUTINE64")) { _ = PIMAGEHLP_STATUS_ROUTINE64; }
    if (@hasDecl(@This(), "DIGEST_FUNCTION")) { _ = DIGEST_FUNCTION; }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACK")) { _ = PFIND_DEBUG_FILE_CALLBACK; }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACKW")) { _ = PFIND_DEBUG_FILE_CALLBACKW; }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACK")) { _ = PFINDFILEINPATHCALLBACK; }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACKW")) { _ = PFINDFILEINPATHCALLBACKW; }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACK")) { _ = PFIND_EXE_FILE_CALLBACK; }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACKW")) { _ = PFIND_EXE_FILE_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACK")) { _ = PENUMDIRTREE_CALLBACK; }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACKW")) { _ = PENUMDIRTREE_CALLBACKW; }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE64")) { _ = PREAD_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE64")) { _ = PFUNCTION_TABLE_ACCESS_ROUTINE64; }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE64")) { _ = PGET_MODULE_BASE_ROUTINE64; }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE64")) { _ = PTRANSLATE_ADDRESS_ROUTINE64; }
    if (@hasDecl(@This(), "PGET_TARGET_ATTRIBUTE_VALUE64")) { _ = PGET_TARGET_ATTRIBUTE_VALUE64; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK64")) { _ = PSYM_ENUMMODULES_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACKW64")) { _ = PSYM_ENUMMODULES_CALLBACKW64; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK64")) { _ = PENUMLOADED_MODULES_CALLBACK64; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACKW64")) { _ = PENUMLOADED_MODULES_CALLBACKW64; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64")) { _ = PSYM_ENUMSYMBOLS_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64W")) { _ = PSYM_ENUMSYMBOLS_CALLBACK64W; }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK64")) { _ = PSYMBOL_REGISTERED_CALLBACK64; }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK")) { _ = PSYMBOL_FUNCENTRY_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK64")) { _ = PSYMBOL_FUNCENTRY_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACK")) { _ = PSYM_ENUMSOURCEFILES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACKW")) { _ = PSYM_ENUMSOURCEFILES_CALLBACKW; }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACK")) { _ = PSYM_ENUMLINES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACKW")) { _ = PSYM_ENUMLINES_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMSOURCEFILETOKENSCALLBACK")) { _ = PENUMSOURCEFILETOKENSCALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMPROCESSES_CALLBACK")) { _ = PSYM_ENUMPROCESSES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACK")) { _ = PSYM_ENUMERATESYMBOLS_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACKW")) { _ = PSYM_ENUMERATESYMBOLS_CALLBACKW; }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAM")) { _ = SYMADDSOURCESTREAM; }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAMA")) { _ = SYMADDSOURCESTREAMA; }
    if (@hasDecl(@This(), "PDBGHELP_CREATE_USER_DUMP_CALLBACK")) { _ = PDBGHELP_CREATE_USER_DUMP_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROC")) { _ = PSYMBOLSERVERPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCA")) { _ = PSYMBOLSERVERPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCW")) { _ = PSYMBOLSERVERPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROC")) { _ = PSYMBOLSERVERBYINDEXPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCA")) { _ = PSYMBOLSERVERBYINDEXPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCW")) { _ = PSYMBOLSERVERBYINDEXPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVEROPENPROC")) { _ = PSYMBOLSERVEROPENPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERCLOSEPROC")) { _ = PSYMBOLSERVERCLOSEPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSPROC")) { _ = PSYMBOLSERVERSETOPTIONSPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSWPROC")) { _ = PSYMBOLSERVERSETOPTIONSWPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERCALLBACKPROC")) { _ = PSYMBOLSERVERCALLBACKPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONSPROC")) { _ = PSYMBOLSERVERGETOPTIONSPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROC")) { _ = PSYMBOLSERVERPINGPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCA")) { _ = PSYMBOLSERVERPINGPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCW")) { _ = PSYMBOLSERVERPINGPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETVERSION")) { _ = PSYMBOLSERVERGETVERSION; }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAME")) { _ = PSYMBOLSERVERDELTANAME; }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAMEW")) { _ = PSYMBOLSERVERDELTANAMEW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENT")) { _ = PSYMBOLSERVERGETSUPPLEMENT; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENTW")) { _ = PSYMBOLSERVERGETSUPPLEMENTW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENT")) { _ = PSYMBOLSERVERSTORESUPPLEMENT; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENTW")) { _ = PSYMBOLSERVERSTORESUPPLEMENTW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRING")) { _ = PSYMBOLSERVERGETINDEXSTRING; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRINGW")) { _ = PSYMBOLSERVERGETINDEXSTRINGW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILE")) { _ = PSYMBOLSERVERSTOREFILE; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILEW")) { _ = PSYMBOLSERVERSTOREFILEW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTORE")) { _ = PSYMBOLSERVERISSTORE; }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTOREW")) { _ = PSYMBOLSERVERISSTOREW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERVERSION")) { _ = PSYMBOLSERVERVERSION; }
    if (@hasDecl(@This(), "PSYMBOLSERVERMESSAGEPROC")) { _ = PSYMBOLSERVERMESSAGEPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERWEXPROC")) { _ = PSYMBOLSERVERWEXPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCWEX")) { _ = PSYMBOLSERVERPINGPROCWEX; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONDATAPROC")) { _ = PSYMBOLSERVERGETOPTIONDATAPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETHTTPAUTHHEADER")) { _ = PSYMBOLSERVERSETHTTPAUTHHEADER; }
    if (@hasDecl(@This(), "LPCALL_BACK_USER_INTERRUPT_ROUTINE")) { _ = LPCALL_BACK_USER_INTERRUPT_ROUTINE; }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER")) { _ = WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER; }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER")) { _ = WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER; }
    if (@hasDecl(@This(), "WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER")) { _ = WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER; }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) { _ = PGET_RUNTIME_FUNCTION_CALLBACK; }
    if (@hasDecl(@This(), "PGET_RUNTIME_FUNCTION_CALLBACK")) { _ = PGET_RUNTIME_FUNCTION_CALLBACK; }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE")) { _ = PREAD_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE")) { _ = PFUNCTION_TABLE_ACCESS_ROUTINE; }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE")) { _ = PGET_MODULE_BASE_ROUTINE; }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE")) { _ = PTRANSLATE_ADDRESS_ROUTINE; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK")) { _ = PSYM_ENUMMODULES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK")) { _ = PSYM_ENUMSYMBOLS_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACKW")) { _ = PSYM_ENUMSYMBOLS_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK")) { _ = PENUMLOADED_MODULES_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK")) { _ = PSYMBOL_REGISTERED_CALLBACK; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (3)
//--------------------------------------------------------------------------------
pub const active_script = @import("debug/active_script.zig");
pub const extensions = @import("debug/extensions.zig");
pub const web_app = @import("debug/web_app.zig");
