//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (846)
//--------------------------------------------------------------------------------
pub const EC_SND_DEVICE_ERROR_BASE = @as(u32, 512);
pub const EC_SNDDEV_IN_ERROR = @as(u32, 512);
pub const EC_SNDDEV_OUT_ERROR = @as(u32, 513);
pub const EC_SYSTEMBASE = @as(u32, 0);
pub const EC_USER = @as(u32, 32768);
pub const EC_COMPLETE = @as(u32, 1);
pub const EC_USERABORT = @as(u32, 2);
pub const EC_ERRORABORT = @as(u32, 3);
pub const EC_TIME = @as(u32, 4);
pub const EC_REPAINT = @as(u32, 5);
pub const EC_STREAM_ERROR_STOPPED = @as(u32, 6);
pub const EC_STREAM_ERROR_STILLPLAYING = @as(u32, 7);
pub const EC_ERROR_STILLPLAYING = @as(u32, 8);
pub const EC_PALETTE_CHANGED = @as(u32, 9);
pub const EC_VIDEO_SIZE_CHANGED = @as(u32, 10);
pub const EC_QUALITY_CHANGE = @as(u32, 11);
pub const EC_SHUTTING_DOWN = @as(u32, 12);
pub const EC_CLOCK_CHANGED = @as(u32, 13);
pub const EC_PAUSED = @as(u32, 14);
pub const EC_OPENING_FILE = @as(u32, 16);
pub const EC_BUFFERING_DATA = @as(u32, 17);
pub const EC_FULLSCREEN_LOST = @as(u32, 18);
pub const EC_ACTIVATE = @as(u32, 19);
pub const EC_NEED_RESTART = @as(u32, 20);
pub const EC_WINDOW_DESTROYED = @as(u32, 21);
pub const EC_DISPLAY_CHANGED = @as(u32, 22);
pub const EC_STARVATION = @as(u32, 23);
pub const EC_OLE_EVENT = @as(u32, 24);
pub const EC_NOTIFY_WINDOW = @as(u32, 25);
pub const EC_STREAM_CONTROL_STOPPED = @as(u32, 26);
pub const EC_STREAM_CONTROL_STARTED = @as(u32, 27);
pub const EC_END_OF_SEGMENT = @as(u32, 28);
pub const EC_SEGMENT_STARTED = @as(u32, 29);
pub const EC_LENGTH_CHANGED = @as(u32, 30);
pub const EC_DEVICE_LOST = @as(u32, 31);
pub const EC_SAMPLE_NEEDED = @as(u32, 32);
pub const EC_PROCESSING_LATENCY = @as(u32, 33);
pub const EC_SAMPLE_LATENCY = @as(u32, 34);
pub const EC_SCRUB_TIME = @as(u32, 35);
pub const EC_STEP_COMPLETE = @as(u32, 36);
pub const EC_TIMECODE_AVAILABLE = @as(u32, 48);
pub const EC_EXTDEVICE_MODE_CHANGE = @as(u32, 49);
pub const EC_STATE_CHANGE = @as(u32, 50);
pub const EC_GRAPH_CHANGED = @as(u32, 80);
pub const EC_CLOCK_UNSET = @as(u32, 81);
pub const EC_VMR_RENDERDEVICE_SET = @as(u32, 83);
pub const VMR_RENDER_DEVICE_OVERLAY = @as(u32, 1);
pub const VMR_RENDER_DEVICE_VIDMEM = @as(u32, 2);
pub const VMR_RENDER_DEVICE_SYSMEM = @as(u32, 4);
pub const EC_VMR_SURFACE_FLIPPED = @as(u32, 84);
pub const EC_VMR_RECONNECTION_FAILED = @as(u32, 85);
pub const EC_PREPROCESS_COMPLETE = @as(u32, 86);
pub const EC_CODECAPI_EVENT = @as(u32, 87);
pub const EC_WMT_EVENT_BASE = @as(u32, 593);
pub const EC_WMT_INDEX_EVENT = @as(u32, 593);
pub const EC_WMT_EVENT = @as(u32, 594);
pub const EC_BUILT = @as(u32, 768);
pub const EC_UNBUILT = @as(u32, 769);
pub const EC_SKIP_FRAMES = @as(u32, 37);
pub const EC_PLEASE_REOPEN = @as(u32, 64);
pub const EC_STATUS = @as(u32, 65);
pub const EC_MARKER_HIT = @as(u32, 66);
pub const EC_LOADSTATUS = @as(u32, 67);
pub const EC_FILE_CLOSED = @as(u32, 68);
pub const EC_ERRORABORTEX = @as(u32, 69);
pub const AM_LOADSTATUS_CLOSED = @as(u32, 0);
pub const AM_LOADSTATUS_LOADINGDESCR = @as(u32, 1);
pub const AM_LOADSTATUS_LOADINGMCAST = @as(u32, 2);
pub const AM_LOADSTATUS_LOCATING = @as(u32, 3);
pub const AM_LOADSTATUS_CONNECTING = @as(u32, 4);
pub const AM_LOADSTATUS_OPENING = @as(u32, 5);
pub const AM_LOADSTATUS_OPEN = @as(u32, 6);
pub const EC_NEW_PIN = @as(u32, 32);
pub const EC_RENDER_FINISHED = @as(u32, 33);
pub const EC_EOS_SOON = @as(u32, 70);
pub const EC_CONTENTPROPERTY_CHANGED = @as(u32, 71);
pub const AM_CONTENTPROPERTY_TITLE = @as(u32, 1);
pub const AM_CONTENTPROPERTY_AUTHOR = @as(u32, 2);
pub const AM_CONTENTPROPERTY_COPYRIGHT = @as(u32, 4);
pub const AM_CONTENTPROPERTY_DESCRIPTION = @as(u32, 8);
pub const EC_BANDWIDTHCHANGE = @as(u32, 72);
pub const EC_VIDEOFRAMEREADY = @as(u32, 73);
pub const EC_DVDBASE = @as(u32, 256);
pub const EC_DVD_DOMAIN_CHANGE = @as(u32, 257);
pub const EC_DVD_TITLE_CHANGE = @as(u32, 258);
pub const EC_DVD_CHAPTER_START = @as(u32, 259);
pub const EC_DVD_AUDIO_STREAM_CHANGE = @as(u32, 260);
pub const EC_DVD_SUBPICTURE_STREAM_CHANGE = @as(u32, 261);
pub const EC_DVD_ANGLE_CHANGE = @as(u32, 262);
pub const EC_DVD_BUTTON_CHANGE = @as(u32, 263);
pub const EC_DVD_VALID_UOPS_CHANGE = @as(u32, 264);
pub const EC_DVD_STILL_ON = @as(u32, 265);
pub const EC_DVD_STILL_OFF = @as(u32, 266);
pub const EC_DVD_CURRENT_TIME = @as(u32, 267);
pub const EC_DVD_ERROR = @as(u32, 268);
pub const EC_DVD_WARNING = @as(u32, 269);
pub const EC_DVD_CHAPTER_AUTOSTOP = @as(u32, 270);
pub const EC_DVD_NO_FP_PGC = @as(u32, 271);
pub const EC_DVD_PLAYBACK_RATE_CHANGE = @as(u32, 272);
pub const EC_DVD_PARENTAL_LEVEL_CHANGE = @as(u32, 273);
pub const EC_DVD_PLAYBACK_STOPPED = @as(u32, 274);
pub const EC_DVD_ANGLES_AVAILABLE = @as(u32, 275);
pub const EC_DVD_PLAYPERIOD_AUTOSTOP = @as(u32, 276);
pub const EC_DVD_BUTTON_AUTO_ACTIVATED = @as(u32, 277);
pub const EC_DVD_CMD_START = @as(u32, 278);
pub const EC_DVD_CMD_END = @as(u32, 279);
pub const EC_DVD_DISC_EJECTED = @as(u32, 280);
pub const EC_DVD_DISC_INSERTED = @as(u32, 281);
pub const EC_DVD_CURRENT_HMSF_TIME = @as(u32, 282);
pub const EC_DVD_KARAOKE_MODE = @as(u32, 283);
pub const EC_DVD_PROGRAM_CELL_CHANGE = @as(u32, 284);
pub const EC_DVD_TITLE_SET_CHANGE = @as(u32, 285);
pub const EC_DVD_PROGRAM_CHAIN_CHANGE = @as(u32, 286);
pub const EC_DVD_VOBU_Offset = @as(u32, 287);
pub const EC_DVD_VOBU_Timestamp = @as(u32, 288);
pub const EC_DVD_GPRM_Change = @as(u32, 289);
pub const EC_DVD_SPRM_Change = @as(u32, 290);
pub const EC_DVD_BeginNavigationCommands = @as(u32, 291);
pub const EC_DVD_NavigationCommand = @as(u32, 292);
pub const AM_AC3_ALTERNATE_AUDIO_1 = @as(u32, 1);
pub const AM_AC3_ALTERNATE_AUDIO_2 = @as(u32, 2);
pub const AM_AC3_ALTERNATE_AUDIO_BOTH = @as(u32, 3);
pub const AM_AC3_SERVICE_MAIN_AUDIO = @as(u32, 0);
pub const AM_AC3_SERVICE_NO_DIALOG = @as(u32, 1);
pub const AM_AC3_SERVICE_VISUALLY_IMPAIRED = @as(u32, 2);
pub const AM_AC3_SERVICE_HEARING_IMPAIRED = @as(u32, 3);
pub const AM_AC3_SERVICE_DIALOG_ONLY = @as(u32, 4);
pub const AM_AC3_SERVICE_COMMENTARY = @as(u32, 5);
pub const AM_AC3_SERVICE_EMERGENCY_FLASH = @as(u32, 6);
pub const AM_AC3_SERVICE_VOICE_OVER = @as(u32, 7);
pub const AM_UseNewCSSKey = @as(u32, 1);
pub const AM_ReverseBlockStart = @as(u32, 2);
pub const AM_ReverseBlockEnd = @as(u32, 4);
pub const AM_DVD_CGMS_RESERVED_MASK = @as(u32, 120);
pub const AM_DVD_CGMS_COPY_PROTECT_MASK = @as(u32, 24);
pub const AM_DVD_CGMS_COPY_PERMITTED = @as(u32, 0);
pub const AM_DVD_CGMS_COPY_ONCE = @as(u32, 16);
pub const AM_DVD_CGMS_NO_COPY = @as(u32, 24);
pub const AM_DVD_COPYRIGHT_MASK = @as(u32, 64);
pub const AM_DVD_NOT_COPYRIGHTED = @as(u32, 0);
pub const AM_DVD_COPYRIGHTED = @as(u32, 64);
pub const AM_DVD_SECTOR_PROTECT_MASK = @as(u32, 32);
pub const AM_DVD_SECTOR_NOT_PROTECTED = @as(u32, 0);
pub const AM_DVD_SECTOR_PROTECTED = @as(u32, 32);
pub const AMINTERLACE_IsInterlaced = @as(u32, 1);
pub const AMINTERLACE_1FieldPerSample = @as(u32, 2);
pub const AMINTERLACE_Field1First = @as(u32, 4);
pub const AMINTERLACE_UNUSED = @as(u32, 8);
pub const AMINTERLACE_FieldPatternMask = @as(u32, 48);
pub const AMINTERLACE_FieldPatField1Only = @as(u32, 0);
pub const AMINTERLACE_FieldPatField2Only = @as(u32, 16);
pub const AMINTERLACE_FieldPatBothRegular = @as(u32, 32);
pub const AMINTERLACE_FieldPatBothIrregular = @as(u32, 48);
pub const AMINTERLACE_DisplayModeMask = @as(u32, 192);
pub const AMINTERLACE_DisplayModeBobOnly = @as(u32, 0);
pub const AMINTERLACE_DisplayModeWeaveOnly = @as(u32, 64);
pub const AMINTERLACE_DisplayModeBobOrWeave = @as(u32, 128);
pub const AMCOPYPROTECT_RestrictDuplication = @as(u32, 1);
pub const AMCONTROL_USED = @as(u32, 1);
pub const AMCONTROL_PAD_TO_4x3 = @as(u32, 2);
pub const AMCONTROL_PAD_TO_16x9 = @as(u32, 4);
pub const AMCONTROL_COLORINFO_PRESENT = @as(u32, 128);
pub const AM_VIDEO_FLAG_FIELD_MASK = @as(i32, 3);
pub const AM_VIDEO_FLAG_INTERLEAVED_FRAME = @as(i32, 0);
pub const AM_VIDEO_FLAG_FIELD1 = @as(i32, 1);
pub const AM_VIDEO_FLAG_FIELD2 = @as(i32, 2);
pub const AM_VIDEO_FLAG_FIELD1FIRST = @as(i32, 4);
pub const AM_VIDEO_FLAG_WEAVE = @as(i32, 8);
pub const AM_VIDEO_FLAG_IPB_MASK = @as(i32, 48);
pub const AM_VIDEO_FLAG_I_SAMPLE = @as(i32, 0);
pub const AM_VIDEO_FLAG_P_SAMPLE = @as(i32, 16);
pub const AM_VIDEO_FLAG_B_SAMPLE = @as(i32, 32);
pub const AM_VIDEO_FLAG_REPEAT_FIELD = @as(i32, 64);
pub const AVIF_HASINDEX = @as(u32, 16);
pub const AVIF_MUSTUSEINDEX = @as(u32, 32);
pub const AVIF_ISINTERLEAVED = @as(u32, 256);
pub const AVIF_TRUSTCKTYPE = @as(u32, 2048);
pub const AVIF_WASCAPTUREFILE = @as(u32, 65536);
pub const AVIF_COPYRIGHTED = @as(u32, 131072);
pub const AVI_HEADERSIZE = @as(u32, 2048);
pub const AVISF_DISABLED = @as(u32, 1);
pub const AVISF_VIDEO_PALCHANGES = @as(u32, 65536);
pub const AVIIF_LIST = @as(i32, 1);
pub const AVIIF_KEYFRAME = @as(i32, 16);
pub const AVIIF_FIRSTPART = @as(i32, 32);
pub const AVIIF_LASTPART = @as(i32, 64);
pub const AVIIF_NOTIME = @as(i32, 256);
pub const AVIIF_COMPUSE = @as(i32, 268369920);
pub const AVIIF_NO_TIME = @as(u32, 256);
pub const AVIIF_COMPRESSOR = @as(u32, 268369920);
pub const TIMECODE_RATE_30DROP = @as(u32, 0);
pub const TIMECODE_SMPTE_BINARY_GROUP = @as(u32, 7);
pub const TIMECODE_SMPTE_COLOR_FRAME = @as(u32, 8);
pub const AVI_INDEX_OF_INDEXES = @as(u32, 0);
pub const AVI_INDEX_OF_CHUNKS = @as(u32, 1);
pub const AVI_INDEX_OF_TIMED_CHUNKS = @as(u32, 2);
pub const AVI_INDEX_OF_SUB_2FIELD = @as(u32, 3);
pub const AVI_INDEX_IS_DATA = @as(u32, 128);
pub const AVI_INDEX_SUB_DEFAULT = @as(u32, 0);
pub const AVI_INDEX_SUB_2FIELD = @as(u32, 1);
pub const STDINDEXSIZE = @as(u32, 16384);
pub const AVISTDINDEX_DELTAFRAME = @as(u32, 2147483648);
pub const AMVA_TYPEINDEX_OUTPUTFRAME = @as(u32, 4294967295);
pub const AMVA_QUERYRENDERSTATUSF_READ = @as(u32, 1);
pub const MIN_DIMENSION = @as(u32, 1);
pub const BDA_PLP_ID_NOT_SET = @as(i32, -1);
pub const CDEF_CLASS_DEFAULT = @as(u32, 1);
pub const CDEF_BYPASS_CLASS_MANAGER = @as(u32, 2);
pub const CDEF_MERIT_ABOVE_DO_NOT_USE = @as(u32, 8);
pub const CDEF_DEVMON_CMGR_DEVICE = @as(u32, 16);
pub const CDEF_DEVMON_DMO = @as(u32, 32);
pub const CDEF_DEVMON_PNP_DEVICE = @as(u32, 64);
pub const CDEF_DEVMON_FILTER = @as(u32, 128);
pub const CDEF_DEVMON_SELECTIVE_MASK = @as(u32, 240);
pub const CHARS_IN_GUID = @as(u32, 39);
pub const MAX_PIN_NAME = @as(u32, 128);
pub const MAX_FILTER_NAME = @as(u32, 128);
pub const AM_GBF_PREVFRAMESKIPPED = @as(u32, 1);
pub const AM_GBF_NOTASYNCPOINT = @as(u32, 2);
pub const AM_GBF_NOWAIT = @as(u32, 4);
pub const AM_GBF_NODDSURFACELOCK = @as(u32, 8);
pub const AMF_AUTOMATICGAIN = @as(f64, -1);
pub const AnalogVideo_NTSC_Mask = @as(u32, 7);
pub const AnalogVideo_PAL_Mask = @as(u32, 1052656);
pub const AnalogVideo_SECAM_Mask = @as(u32, 1044480);
pub const MPEG2_PROGRAM_STREAM_MAP = @as(u32, 0);
pub const MPEG2_PROGRAM_ELEMENTARY_STREAM = @as(u32, 1);
pub const MPEG2_PROGRAM_DIRECTORY_PES_PACKET = @as(u32, 2);
pub const MPEG2_PROGRAM_PACK_HEADER = @as(u32, 3);
pub const MPEG2_PROGRAM_PES_STREAM = @as(u32, 4);
pub const MPEG2_PROGRAM_SYSTEM_HEADER = @as(u32, 5);
pub const SUBSTREAM_FILTER_VAL_NONE = @as(u32, 268435456);
pub const AM_GETDECODERCAP_QUERY_VMR_SUPPORT = @as(u32, 1);
pub const VMR_NOTSUPPORTED = @as(u32, 0);
pub const VMR_SUPPORTED = @as(u32, 1);
pub const AM_QUERY_DECODER_VMR_SUPPORT = @as(u32, 1);
pub const AM_QUERY_DECODER_DXVA_1_SUPPORT = @as(u32, 2);
pub const AM_QUERY_DECODER_DVD_SUPPORT = @as(u32, 3);
pub const AM_QUERY_DECODER_ATSC_SD_SUPPORT = @as(u32, 4);
pub const AM_QUERY_DECODER_ATSC_HD_SUPPORT = @as(u32, 5);
pub const AM_GETDECODERCAP_QUERY_VMR9_SUPPORT = @as(u32, 6);
pub const AM_GETDECODERCAP_QUERY_EVR_SUPPORT = @as(u32, 7);
pub const DECODER_CAP_NOTSUPPORTED = @as(u32, 0);
pub const DECODER_CAP_SUPPORTED = @as(u32, 1);
pub const VMRBITMAP_DISABLE = @as(u32, 1);
pub const VMRBITMAP_HDC = @as(u32, 2);
pub const VMRBITMAP_ENTIREDDS = @as(u32, 4);
pub const VMRBITMAP_SRCCOLORKEY = @as(u32, 8);
pub const VMRBITMAP_SRCRECT = @as(u32, 16);
pub const DVD_TITLE_MENU = @as(u32, 0);
pub const DVD_STREAM_DATA_CURRENT = @as(u32, 2048);
pub const DVD_STREAM_DATA_VMGM = @as(u32, 1024);
pub const DVD_STREAM_DATA_VTSM = @as(u32, 1025);
pub const DVD_DEFAULT_AUDIO_STREAM = @as(u32, 15);
pub const DVD_AUDIO_CAPS_AC3 = @as(u32, 1);
pub const DVD_AUDIO_CAPS_MPEG2 = @as(u32, 2);
pub const DVD_AUDIO_CAPS_LPCM = @as(u32, 4);
pub const DVD_AUDIO_CAPS_DTS = @as(u32, 8);
pub const DVD_AUDIO_CAPS_SDDS = @as(u32, 16);
pub const MEDIATYPE_MPEG2_PACK = Guid.initString("36523b13-8ee5-11d1-8ca3-0060b057664a");
pub const MEDIATYPE_MPEG2_PES = Guid.initString("e06d8020-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIATYPE_CONTROL = Guid.initString("e06d8021-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIATYPE_MPEG2_SECTIONS = Guid.initString("455f176c-4b06-47ce-9aef-8caef73df7b5");
pub const MEDIASUBTYPE_MPEG2_VERSIONED_TABLES = Guid.initString("1ed988b0-3ffc-4523-8725-347beec1a8a0");
pub const MEDIASUBTYPE_ATSC_SI = Guid.initString("b3c7397c-d303-414d-b33c-4ed2c9d29733");
pub const MEDIASUBTYPE_DVB_SI = Guid.initString("e9dd31a3-221d-4adb-8532-9af309c1a408");
pub const MEDIASUBTYPE_ISDB_SI = Guid.initString("e89ad298-3601-4b06-aaec-9ddeedcc5bd0");
pub const MEDIASUBTYPE_TIF_SI = Guid.initString("ec232eb2-cb96-4191-b226-0ea129f38250");
pub const MEDIASUBTYPE_MPEG2DATA = Guid.initString("c892e55b-252d-42b5-a316-d997e7a5d995");
pub const MEDIASUBTYPE_MPEG2_WMDRM_TRANSPORT = Guid.initString("18bec4ea-4676-450e-b478-0cd84c54b327");
pub const MEDIASUBTYPE_MPEG2_VIDEO = Guid.initString("e06d8026-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_MPEG2_VIDEO = Guid.initString("e06d80e3-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_MPEG2_PROGRAM = Guid.initString("e06d8022-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_MPEG2_TRANSPORT = Guid.initString("e06d8023-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE = Guid.initString("138aa9a4-1ee2-4c5b-988e-19abfdbc8a11");
pub const MEDIASUBTYPE_MPEG2_UDCR_TRANSPORT = Guid.initString("18bec4ea-4676-450e-b478-0cd84c54b327");
pub const MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_RAW = Guid.initString("0d7aed42-cb9a-11db-9705-005056c00008");
pub const MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_PROCESSED = Guid.initString("af748dd4-0d80-11db-9705-005056c00008");
pub const MEDIASUBTYPE_MPEG2_AUDIO = Guid.initString("e06d802b-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DOLBY_AC3 = Guid.initString("e06d802c-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DVD_SUBPICTURE = Guid.initString("e06d802d-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DVD_LPCM_AUDIO = Guid.initString("e06d8032-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DTS = Guid.initString("e06d8033-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_SDDS = Guid.initString("e06d8034-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIATYPE_DVD_ENCRYPTED_PACK = Guid.initString("ed0b916a-044d-11d1-aa78-00c04fc31d60");
pub const MEDIATYPE_DVD_NAVIGATION = Guid.initString("e06d802e-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DVD_NAVIGATION_PCI = Guid.initString("e06d802f-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DVD_NAVIGATION_DSI = Guid.initString("e06d8030-db46-11cf-b4d1-00805f6cbbea");
pub const MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER = Guid.initString("e06d8031-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_MPEG2Video = Guid.initString("e06d80e3-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_DolbyAC3 = Guid.initString("e06d80e4-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_MPEG2Audio = Guid.initString("e06d80e5-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_DVD_LPCMAudio = Guid.initString("e06d80e6-db46-11cf-b4d1-00805f6cbbea");
pub const FORMAT_UVCH264Video = Guid.initString("2017be05-6629-4248-aaed-7e1a47bc9b9c");
pub const FORMAT_JPEGImage = Guid.initString("692fa379-d3e8-4651-b5b4-0b94b013eeaf");
pub const FORMAT_Image = Guid.initString("692fa379-d3e8-4651-b5b4-0b94b013eeaf");
pub const AM_KSPROPSETID_AC3 = Guid.initString("bfabe720-6e1f-11d0-bcf2-444553540000");
pub const AM_KSPROPSETID_DvdSubPic = Guid.initString("ac390460-43af-11d0-bd6a-003505c103a9");
pub const AM_KSPROPSETID_CopyProt = Guid.initString("0e8a0a40-6aef-11d0-9ed0-00a024ca19b3");
pub const AM_KSPROPSETID_TSRateChange = Guid.initString("a503c5c0-1d1d-11d1-ad80-444553540000");
pub const AM_KSPROPSETID_DVD_RateChange = Guid.initString("3577eb09-9582-477f-b29c-b0c452a4ff9a");
pub const AM_KSPROPSETID_DvdKaraoke = Guid.initString("ae4720ae-aa71-42d8-b82a-fffdf58b76fd");
pub const AM_KSPROPSETID_FrameStep = Guid.initString("c830acbd-ab07-492f-8852-45b6987c2979");
pub const AM_KSPROPSETID_MPEG4_MediaType_Attributes = Guid.initString("ff6c4bfa-07a9-4c7b-a237-672f9d68065f");
pub const AM_KSCATEGORY_CAPTURE = Guid.initString("65e8773d-8f56-11d0-a3b9-00a0c9223196");
pub const AM_KSCATEGORY_RENDER = Guid.initString("65e8773e-8f56-11d0-a3b9-00a0c9223196");
pub const AM_KSCATEGORY_DATACOMPRESSOR = Guid.initString("1e84c900-7e70-11d0-a5d6-28db04c10000");
pub const AM_KSCATEGORY_AUDIO = Guid.initString("6994ad04-93ef-11d0-a3cc-00a0c9223196");
pub const AM_KSCATEGORY_VIDEO = Guid.initString("6994ad05-93ef-11d0-a3cc-00a0c9223196");
pub const AM_KSCATEGORY_TVTUNER = Guid.initString("a799a800-a46d-11d0-a18c-00a02401dcd4");
pub const AM_KSCATEGORY_CROSSBAR = Guid.initString("a799a801-a46d-11d0-a18c-00a02401dcd4");
pub const AM_KSCATEGORY_TVAUDIO = Guid.initString("a799a802-a46d-11d0-a18c-00a02401dcd4");
pub const AM_KSCATEGORY_VBICODEC = Guid.initString("07dad660-22f1-11d1-a9f4-00c04fbbde8f");
pub const AM_KSCATEGORY_VBICODEC_MI = Guid.initString("9c24a977-0951-451a-8006-0e49bd28cd5f");
pub const AM_KSCATEGORY_SPLITTER = Guid.initString("0a4252a0-7e70-11d0-a5d6-28db04c10000");
pub const AM_INTERFACESETID_Standard = Guid.initString("1a8766a0-62ce-11cf-a5d6-28db04c10000");
pub const PBDA_AUX_CONNECTOR_TYPE_SVideo = Guid.initString("a0e905f4-24c9-4a54-b761-213355efc13a");
pub const PBDA_AUX_CONNECTOR_TYPE_Composite = Guid.initString("f6298b4c-c725-4d42-849b-410bbb14ea62");
pub const CLSID_PBDA_AUX_DATA_TYPE = Guid.initString("fd456373-3323-4090-adca-8ed45f55cf10");
pub const CLSID_PBDA_Encoder_DATA_TYPE = Guid.initString("728fd6bc-5546-4716-b103-f899f5a1fa68");
pub const PBDA_Encoder_Audio_AlgorithmType_MPEG1LayerII = @as(u32, 0);
pub const PBDA_Encoder_Audio_AlgorithmType_AC3 = @as(u32, 1);
pub const PBDA_Encoder_Video_MPEG2PartII = @as(u32, 0);
pub const PBDA_Encoder_Video_MPEG4Part10 = @as(u32, 1);
pub const PBDA_Encoder_Video_AVC = @as(u32, 1);
pub const PBDA_Encoder_Video_H264 = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Constant = @as(u32, 1);
pub const PBDA_Encoder_BitrateMode_Variable = @as(u32, 2);
pub const PBDA_Encoder_BitrateMode_Average = @as(u32, 3);
pub const CLSID_PBDA_FDC_DATA_TYPE = Guid.initString("e7dbf9a0-22ab-4047-8e67-ef9ad504e729");
pub const CLSID_PBDA_GDDS_DATA_TYPE = Guid.initString("c80c0df3-6052-4c16-9f56-c44c21f73c45");
pub const LIBID_QuartzNetTypeLib = Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const LIBID_QuartzTypeLib = Guid.initString("56a868b0-0ad4-11ce-b03a-0020af0ba770");
pub const CLSID_AMMultiMediaStream = Guid.initString("49c47ce5-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMDirectDrawStream = Guid.initString("49c47ce4-9ba4-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioStream = Guid.initString("8496e040-af4c-11d0-8212-00c04fc32c45");
pub const CLSID_AMAudioData = Guid.initString("f2468580-af8a-11d0-8212-00c04fc32c45");
pub const CLSID_AMMediaTypeStream = Guid.initString("cf0f2f7c-f7bf-11d0-900d-00c04fd9189d");
pub const AMDDS_NONE = @as(u32, 0);
pub const AMDDS_DCIPS = @as(u32, 1);
pub const AMDDS_PS = @as(u32, 2);
pub const AMDDS_RGBOVR = @as(u32, 4);
pub const AMDDS_YUVOVR = @as(u32, 8);
pub const AMDDS_RGBOFF = @as(u32, 16);
pub const AMDDS_YUVOFF = @as(u32, 32);
pub const AMDDS_RGBFLP = @as(u32, 64);
pub const AMDDS_YUVFLP = @as(u32, 128);
pub const AMDDS_ALL = @as(u32, 255);
pub const AMDDS_DEFAULT = @as(u32, 255);
pub const iPALETTE_COLORS = @as(u32, 256);
pub const iEGA_COLORS = @as(u32, 16);
pub const iMASK_COLORS = @as(u32, 3);
pub const iTRUECOLOR = @as(u32, 16);
pub const iRED = @as(u32, 0);
pub const iGREEN = @as(u32, 1);
pub const iBLUE = @as(u32, 2);
pub const iPALETTE = @as(u32, 8);
pub const iMAXBITS = @as(u32, 8);
pub const MAX_SIZE_MPEG1_SEQUENCE_INFO = @as(u32, 140);
pub const CLSID_DMOWrapperFilter = Guid.initString("94297043-bd82-4dfd-b0de-8177739c6d20");
pub const CLSID_DMOFilterCategory = Guid.initString("bcd5796c-bd52-4d30-ab76-70f975b89199");
pub const AM_MPEG_AUDIO_DUAL_MERGE = @as(u32, 0);
pub const AM_MPEG_AUDIO_DUAL_LEFT = @as(u32, 1);
pub const AM_MPEG_AUDIO_DUAL_RIGHT = @as(u32, 2);
pub const VFW_FIRST_CODE = @as(u32, 512);
pub const MAX_ERROR_TEXT_LEN = @as(u32, 160);
pub const MPBOOL_TRUE = @as(u32, 1);
pub const MPBOOL_FALSE = @as(u32, 0);
pub const DWORD_ALLPARAMS = @as(i32, -1);
pub const GUID_TIME_REFERENCE = Guid.initString("93ad712b-daa0-4ffe-bc81-b0ce500fcdd9");
pub const GUID_TIME_MUSIC = Guid.initString("0574c49d-5b04-4b15-a542-ae282030117b");
pub const GUID_TIME_SAMPLES = Guid.initString("a8593d05-0c43-4984-9a63-97af9e02c4c0");
pub const MPF_ENVLP_STANDARD = @as(u32, 0);
pub const MPF_ENVLP_BEGIN_CURRENTVAL = @as(u32, 1);
pub const MPF_ENVLP_BEGIN_NEUTRALVAL = @as(u32, 2);
pub const MPF_PUNCHIN_REFTIME = @as(u32, 0);
pub const MPF_PUNCHIN_NOW = @as(u32, 1);
pub const MPF_PUNCHIN_STOPPED = @as(u32, 2);
pub const MSPID_PrimaryVideo = Guid.initString("a35ff56a-9fda-11d0-8fdf-00c04fd9189d");
pub const MSPID_PrimaryAudio = Guid.initString("a35ff56b-9fda-11d0-8fdf-00c04fd9189d");
pub const VFW_E_INVALIDMEDIATYPE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const VFW_E_INVALIDSUBTYPE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const VFW_E_NEED_OWNER = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const VFW_E_ENUM_OUT_OF_SYNC = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const VFW_E_ALREADY_CONNECTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const VFW_E_FILTER_ACTIVE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const VFW_E_NO_TYPES = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const VFW_E_NO_ACCEPTABLE_TYPES = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const VFW_E_INVALID_DIRECTION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const VFW_E_NOT_CONNECTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const VFW_E_NO_ALLOCATOR = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const VFW_E_RUNTIME_ERROR = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const VFW_E_BUFFER_NOTSET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const VFW_E_BUFFER_OVERFLOW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const VFW_E_BADALIGN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const VFW_E_ALREADY_COMMITTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const VFW_E_BUFFERS_OUTSTANDING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const VFW_E_NOT_COMMITTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const VFW_E_SIZENOTSET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const VFW_E_NO_CLOCK = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const VFW_E_NO_SINK = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const VFW_E_NO_INTERFACE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const VFW_E_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const VFW_E_CANNOT_CONNECT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const VFW_E_CANNOT_RENDER = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const VFW_E_CHANGING_FORMAT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const VFW_E_NO_COLOR_KEY_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const VFW_E_NOT_OVERLAY_CONNECTION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const VFW_E_NOT_SAMPLE_CONNECTION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const VFW_E_PALETTE_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const VFW_E_COLOR_KEY_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220962));
pub const VFW_E_NO_COLOR_KEY_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220961));
pub const VFW_E_NO_PALETTE_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220960));
pub const VFW_E_NO_DISPLAY_PALETTE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220959));
pub const VFW_E_TOO_MANY_COLORS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220958));
pub const VFW_E_STATE_CHANGED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220957));
pub const VFW_E_NOT_STOPPED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220956));
pub const VFW_E_NOT_PAUSED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220955));
pub const VFW_E_NOT_RUNNING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220954));
pub const VFW_E_WRONG_STATE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220953));
pub const VFW_E_START_TIME_AFTER_END = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220952));
pub const VFW_E_INVALID_RECT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220951));
pub const VFW_E_TYPE_NOT_ACCEPTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220950));
pub const VFW_E_SAMPLE_REJECTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220949));
pub const VFW_E_SAMPLE_REJECTED_EOS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220948));
pub const VFW_E_DUPLICATE_NAME = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220947));
pub const VFW_S_DUPLICATE_NAME = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262701));
pub const VFW_E_TIMEOUT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220946));
pub const VFW_E_INVALID_FILE_FORMAT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220945));
pub const VFW_E_ENUM_OUT_OF_RANGE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220944));
pub const VFW_E_CIRCULAR_GRAPH = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220943));
pub const VFW_E_NOT_ALLOWED_TO_SAVE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220942));
pub const VFW_E_TIME_ALREADY_PASSED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220941));
pub const VFW_E_ALREADY_CANCELLED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220940));
pub const VFW_E_CORRUPT_GRAPH_FILE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220939));
pub const VFW_E_ADVISE_ALREADY_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220938));
pub const VFW_S_STATE_INTERMEDIATE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262711));
pub const VFW_E_NO_MODEX_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220936));
pub const VFW_E_NO_ADVISE_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220935));
pub const VFW_E_NO_FULLSCREEN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220934));
pub const VFW_E_IN_FULLSCREEN_MODE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220933));
pub const VFW_E_UNKNOWN_FILE_TYPE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220928));
pub const VFW_E_CANNOT_LOAD_SOURCE_FILTER = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220927));
pub const VFW_S_PARTIAL_RENDER = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262722));
pub const VFW_E_FILE_TOO_SHORT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220925));
pub const VFW_E_INVALID_FILE_VERSION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220924));
pub const VFW_S_SOME_DATA_IGNORED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262725));
pub const VFW_S_CONNECTIONS_DEFERRED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262726));
pub const VFW_E_INVALID_CLSID = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220921));
pub const VFW_E_INVALID_MEDIA_TYPE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220920));
pub const VFW_E_BAD_KEY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220494));
pub const VFW_S_NO_MORE_ITEMS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262403));
pub const VFW_E_SAMPLE_TIME_NOT_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220919));
pub const VFW_S_RESOURCE_NOT_NEEDED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262736));
pub const VFW_E_MEDIA_TIME_NOT_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220911));
pub const VFW_E_NO_TIME_FORMAT_SET = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220910));
pub const VFW_E_MONO_AUDIO_HW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220909));
pub const VFW_S_MEDIA_TYPE_IGNORED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262740));
pub const VFW_E_NO_DECOMPRESSOR = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220907));
pub const VFW_E_NO_AUDIO_HARDWARE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220906));
pub const VFW_S_VIDEO_NOT_RENDERED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262743));
pub const VFW_S_AUDIO_NOT_RENDERED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262744));
pub const VFW_E_RPZA = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220903));
pub const VFW_S_RPZA = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262746));
pub const VFW_E_PROCESSOR_NOT_SUITABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220901));
pub const VFW_E_UNSUPPORTED_AUDIO = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220900));
pub const VFW_E_UNSUPPORTED_VIDEO = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220899));
pub const VFW_E_MPEG_NOT_CONSTRAINED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220898));
pub const VFW_E_NOT_IN_GRAPH = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220897));
pub const VFW_S_ESTIMATED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262752));
pub const VFW_E_NO_TIME_FORMAT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220895));
pub const VFW_E_READ_ONLY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220894));
pub const VFW_S_RESERVED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262755));
pub const VFW_E_BUFFER_UNDERFLOW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220892));
pub const VFW_E_UNSUPPORTED_STREAM = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220891));
pub const VFW_E_NO_TRANSPORT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220890));
pub const VFW_S_STREAM_OFF = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262759));
pub const VFW_S_CANT_CUE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262760));
pub const VFW_E_BAD_VIDEOCD = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220887));
pub const VFW_S_NO_STOP_TIME = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262768));
pub const VFW_E_OUT_OF_VIDEO_MEMORY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220879));
pub const VFW_E_VP_NEGOTIATION_FAILED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220878));
pub const VFW_E_DDRAW_CAPS_NOT_SUITABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220877));
pub const VFW_E_NO_VP_HARDWARE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220876));
pub const VFW_E_NO_CAPTURE_HARDWARE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220875));
pub const VFW_E_DVD_OPERATION_INHIBITED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220874));
pub const VFW_E_DVD_INVALIDDOMAIN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220873));
pub const VFW_E_DVD_NO_BUTTON = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220872));
pub const VFW_E_DVD_GRAPHNOTREADY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220871));
pub const VFW_E_DVD_RENDERFAIL = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220870));
pub const VFW_E_DVD_DECNOTENOUGH = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220869));
pub const VFW_E_DDRAW_VERSION_NOT_SUITABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220868));
pub const VFW_E_COPYPROT_FAILED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220867));
pub const VFW_S_NOPREVIEWPIN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262782));
pub const VFW_E_TIME_EXPIRED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220865));
pub const VFW_S_DVD_NON_ONE_SEQUENTIAL = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262784));
pub const VFW_E_DVD_WRONG_SPEED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220863));
pub const VFW_E_DVD_MENU_DOES_NOT_EXIST = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220862));
pub const VFW_E_DVD_CMD_CANCELLED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220861));
pub const VFW_E_DVD_STATE_WRONG_VERSION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220860));
pub const VFW_E_DVD_STATE_CORRUPT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220859));
pub const VFW_E_DVD_STATE_WRONG_DISC = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220858));
pub const VFW_E_DVD_INCOMPATIBLE_REGION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220857));
pub const VFW_E_DVD_NO_ATTRIBUTES = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220856));
pub const VFW_E_DVD_NO_GOUP_PGC = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220855));
pub const VFW_E_DVD_LOW_PARENTAL_LEVEL = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220854));
pub const VFW_E_DVD_NOT_IN_KARAOKE_MODE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220853));
pub const VFW_S_DVD_CHANNEL_CONTENTS_NOT_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262796));
pub const VFW_S_DVD_NOT_ACCURATE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262797));
pub const VFW_E_FRAME_STEP_UNSUPPORTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220850));
pub const VFW_E_DVD_STREAM_DISABLED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220849));
pub const VFW_E_DVD_TITLE_UNKNOWN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220848));
pub const VFW_E_DVD_INVALID_DISC = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220847));
pub const VFW_E_DVD_NO_RESUME_INFORMATION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220846));
pub const VFW_E_PIN_ALREADY_BLOCKED_ON_THIS_THREAD = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220845));
pub const VFW_E_PIN_ALREADY_BLOCKED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220844));
pub const VFW_E_CERTIFICATION_FAILURE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220843));
pub const VFW_E_VMR_NOT_IN_MIXER_MODE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220842));
pub const VFW_E_VMR_NO_AP_SUPPLIED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220841));
pub const VFW_E_VMR_NO_DEINTERLACE_HW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220840));
pub const VFW_E_VMR_NO_PROCAMP_HW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220839));
pub const VFW_E_DVD_VMR9_INCOMPATIBLEDEC = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220838));
pub const VFW_E_NO_COPP_HW = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220837));
pub const VFW_E_DVD_NONBLOCKING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220836));
pub const VFW_E_DVD_TOO_MANY_RENDERERS_IN_FILTER_GRAPH = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220835));
pub const VFW_E_DVD_NON_EVR_RENDERER_IN_FILTER_GRAPH = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220834));
pub const VFW_E_DVD_RESOLUTION_ERROR = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220833));
pub const E_PROP_SET_UNSUPPORTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147023726));
pub const E_PROP_ID_UNSUPPORTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147023728));
pub const VFW_E_CODECAPI_LINEAR_RANGE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220720));
pub const VFW_E_CODECAPI_ENUMERATED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220719));
pub const VFW_E_CODECAPI_NO_DEFAULT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220717));
pub const VFW_E_CODECAPI_NO_CURRENT_VALUE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220716));
pub const VFW_E_DVD_CHAPTER_DOES_NOT_EXIST = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220715));
pub const VFW_S_DVD_RENDER_STATUS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262944));
pub const CFSTR_VFW_FILTERLIST = "Video for Windows 4 Filters";
pub const DXVA_ModeNone = Guid.initString("1b81be00-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_A = Guid.initString("1b81be01-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH261_B = Guid.initString("1b81be02-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_A = Guid.initString("1b81be03-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_B = Guid.initString("1b81be04-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_C = Guid.initString("1b81be05-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_D = Guid.initString("1b81be06-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_E = Guid.initString("1b81be07-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH263_F = Guid.initString("1b81be08-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_A = Guid.initString("1b81be09-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG1_VLD = Guid.initString("6f3ec719-3735-42cc-8063-65cc3cb36616");
pub const DXVA_ModeMPEG2_A = Guid.initString("1b81be0a-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_B = Guid.initString("1b81be0b-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_C = Guid.initString("1b81be0c-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2_D = Guid.initString("1b81be0d-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG2and1_VLD = Guid.initString("86695f12-340e-4f04-9fd3-9253dd327460");
pub const DXVA_ModeH264_A = Guid.initString("1b81be64-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_B = Guid.initString("1b81be65-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_C = Guid.initString("1b81be66-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_D = Guid.initString("1b81be67-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_E = Guid.initString("1b81be68-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_F = Guid.initString("1b81be69-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeH264_VLD_WithFMOASO_NoFGT = Guid.initString("d5f04ff9-3418-45d8-9561-32a76aae2ddd");
pub const DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT = Guid.initString("d79be8da-0cf1-4c81-b82a-69a4e236f43d");
pub const DXVA_ModeH264_VLD_Stereo_NoFGT = Guid.initString("f9aaccbb-c2b6-4cfc-8779-5707b1760552");
pub const DXVA_ModeH264_VLD_Multiview_NoFGT = Guid.initString("705b9d82-76cf-49d6-b7e6-ac8872db013c");
pub const DXVA_ModeWMV8_A = Guid.initString("1b81be80-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV8_B = Guid.initString("1b81be81-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_A = Guid.initString("1b81be90-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_B = Guid.initString("1b81be91-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeWMV9_C = Guid.initString("1b81be94-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_A = Guid.initString("1b81bea0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_B = Guid.initString("1b81bea1-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_C = Guid.initString("1b81bea2-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D = Guid.initString("1b81bea3-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeVC1_D2010 = Guid.initString("1b81bea4-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_ModeMPEG4pt2_VLD_Simple = Guid.initString("efd64d74-c9e8-41d7-a5e9-e9b0e39fa319");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC = Guid.initString("ed418a9f-010d-4eda-9ae3-9a65358d8d2e");
pub const DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC = Guid.initString("ab998b5b-4258-44a9-9feb-94e597a6baae");
pub const DXVA_ModeHEVC_VLD_Main = Guid.initString("5b11d51b-2f4c-4452-bcc3-09f2a1160cc0");
pub const DXVA_ModeHEVC_VLD_Main10 = Guid.initString("107af0e0-ef1a-4d19-aba8-67a163073d13");
pub const DXVA_ModeVP9_VLD_Profile0 = Guid.initString("463707f8-a1d0-4585-876d-83aa6d60b89e");
pub const DXVA_ModeVP9_VLD_10bit_Profile2 = Guid.initString("a4c749ef-6ecf-48aa-8448-50a7a1165ff7");
pub const DXVA_ModeVP8_VLD = Guid.initString("90b899ea-3a62-4705-88b3-8df04b2744e7");
pub const DXVA_ModeAV1_VLD_Profile0 = Guid.initString("b8be4ccb-cf53-46ba-8d59-d6b8a6da5d2a");
pub const DXVA_ModeAV1_VLD_Profile1 = Guid.initString("6936ff0f-45b1-4163-9cc1-646ef6946108");
pub const DXVA_ModeAV1_VLD_Profile2 = Guid.initString("0c5f2aa1-e541-4089-bb7b-98110a19d7c8");
pub const DXVA_ModeAV1_VLD_12bit_Profile2 = Guid.initString("17127009-a00f-4ce1-994e-bf4081f6f3f0");
pub const DXVA_ModeAV1_VLD_12bit_Profile2_420 = Guid.initString("2d80bed6-9cac-4835-9e91-327bbc4f9ee8");
pub const DXVA_NoEncrypt = Guid.initString("1b81bed0-a0c7-11d3-b984-00c04f2e73c5");
pub const DXVA_RESTRICTED_MODE_UNRESTRICTED = @as(u32, 65535);
pub const DXVA_RESTRICTED_MODE_H261_A = @as(u32, 1);
pub const DXVA_RESTRICTED_MODE_H261_B = @as(u32, 2);
pub const DXVA_RESTRICTED_MODE_H263_A = @as(u32, 3);
pub const DXVA_RESTRICTED_MODE_H263_B = @as(u32, 4);
pub const DXVA_RESTRICTED_MODE_H263_C = @as(u32, 5);
pub const DXVA_RESTRICTED_MODE_H263_D = @as(u32, 6);
pub const DXVA_RESTRICTED_MODE_H263_E = @as(u32, 7);
pub const DXVA_RESTRICTED_MODE_H263_F = @as(u32, 8);
pub const DXVA_RESTRICTED_MODE_MPEG1_A = @as(u32, 9);
pub const DXVA_RESTRICTED_MODE_MPEG2_A = @as(u32, 10);
pub const DXVA_RESTRICTED_MODE_MPEG2_B = @as(u32, 11);
pub const DXVA_RESTRICTED_MODE_MPEG2_C = @as(u32, 12);
pub const DXVA_RESTRICTED_MODE_MPEG2_D = @as(u32, 13);
pub const DXVA_RESTRICTED_MODE_MPEG1_VLD = @as(u32, 16);
pub const DXVA_RESTRICTED_MODE_MPEG2and1_VLD = @as(u32, 17);
pub const DXVA_RESTRICTED_MODE_H264_A = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_B = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_C = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_D = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_E = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_F = @as(u32, 105);
pub const DXVA_RESTRICTED_MODE_H264_VLD_WITHFMOASO_NOFGT = @as(u32, 112);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_PROGRESSIVE_NOFGT = @as(u32, 113);
pub const DXVA_RESTRICTED_MODE_H264_VLD_STEREO_NOFGT = @as(u32, 114);
pub const DXVA_RESTRICTED_MODE_H264_VLD_MULTIVIEW_NOFGT = @as(u32, 115);
pub const DXVA_RESTRICTED_MODE_WMV8_A = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_B = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_A = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_B = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_C = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_A = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_B = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_C = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_D = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_VC1_D2010 = @as(u32, 164);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_SIMPLE = @as(u32, 176);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_NOGMC = @as(u32, 177);
pub const DXVA_RESTRICTED_MODE_MPEG4PT2_VLD_ADV_SIMPLE_GMC = @as(u32, 178);
pub const DXVA_RESTRICTED_MODE_WMV8_POSTPROC = @as(u32, 128);
pub const DXVA_RESTRICTED_MODE_WMV8_MOCOMP = @as(u32, 129);
pub const DXVA_RESTRICTED_MODE_WMV9_POSTPROC = @as(u32, 144);
pub const DXVA_RESTRICTED_MODE_WMV9_MOCOMP = @as(u32, 145);
pub const DXVA_RESTRICTED_MODE_WMV9_IDCT = @as(u32, 148);
pub const DXVA_RESTRICTED_MODE_VC1_POSTPROC = @as(u32, 160);
pub const DXVA_RESTRICTED_MODE_VC1_MOCOMP = @as(u32, 161);
pub const DXVA_RESTRICTED_MODE_VC1_IDCT = @as(u32, 162);
pub const DXVA_RESTRICTED_MODE_VC1_VLD = @as(u32, 163);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT = @as(u32, 100);
pub const DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT = @as(u32, 101);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT = @as(u32, 102);
pub const DXVA_RESTRICTED_MODE_H264_IDCT_FGT = @as(u32, 103);
pub const DXVA_RESTRICTED_MODE_H264_VLD_NOFGT = @as(u32, 104);
pub const DXVA_RESTRICTED_MODE_H264_VLD_FGT = @as(u32, 105);
pub const DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED = @as(u32, 0);
pub const DXVA_PICTURE_DECODE_BUFFER = @as(u32, 1);
pub const DXVA_MACROBLOCK_CONTROL_BUFFER = @as(u32, 2);
pub const DXVA_RESIDUAL_DIFFERENCE_BUFFER = @as(u32, 3);
pub const DXVA_DEBLOCKING_CONTROL_BUFFER = @as(u32, 4);
pub const DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER = @as(u32, 5);
pub const DXVA_SLICE_CONTROL_BUFFER = @as(u32, 6);
pub const DXVA_BITSTREAM_DATA_BUFFER = @as(u32, 7);
pub const DXVA_AYUV_BUFFER = @as(u32, 8);
pub const DXVA_IA44_SURFACE_BUFFER = @as(u32, 9);
pub const DXVA_DPXD_SURFACE_BUFFER = @as(u32, 10);
pub const DXVA_HIGHLIGHT_BUFFER = @as(u32, 11);
pub const DXVA_DCCMD_SURFACE_BUFFER = @as(u32, 12);
pub const DXVA_ALPHA_BLEND_COMBINATION_BUFFER = @as(u32, 13);
pub const DXVA_PICTURE_RESAMPLE_BUFFER = @as(u32, 14);
pub const DXVA_READ_BACK_BUFFER = @as(u32, 15);
pub const DXVA_MOTION_VECTOR_BUFFER = @as(u32, 16);
pub const DXVA_FILM_GRAIN_BUFFER = @as(u32, 17);
pub const DXVA_NUM_TYPES_COMP_BUFFERS = @as(u32, 18);
pub const DXVA_PICTURE_DECODING_FUNCTION = @as(u32, 1);
pub const DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION = @as(u32, 2);
pub const DXVA_ALPHA_BLEND_COMBINATION_FUNCTION = @as(u32, 3);
pub const DXVA_PICTURE_RESAMPLE_FUNCTION = @as(u32, 4);
pub const DXVA_DEBLOCKING_FILTER_FUNCTION = @as(u32, 5);
pub const DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION = @as(u32, 6);
pub const DXVA_STATUS_REPORTING_FUNCTION = @as(u32, 7);
pub const DXVA_EXECUTE_RETURN_OK = @as(u32, 0);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR = @as(u32, 1);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF = @as(u32, 2);
pub const DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE = @as(u32, 3);
pub const DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE = @as(u32, 4);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY = @as(u32, 16777201);
pub const DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY = @as(u32, 16777205);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY = @as(u32, 16777208);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS = @as(u32, 16777209);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY = @as(u32, 16777212);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS = @as(u32, 16777211);
pub const DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS = @as(u32, 16777215);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST = @as(u32, 16776960);
pub const DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL = @as(u32, 16776968);
pub const DXVA_CHROMA_FORMAT_420 = @as(u32, 1);
pub const DXVA_CHROMA_FORMAT_422 = @as(u32, 2);
pub const DXVA_CHROMA_FORMAT_444 = @as(u32, 3);
pub const DXVA_PICTURE_STRUCTURE_TOP_FIELD = @as(u32, 1);
pub const DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD = @as(u32, 2);
pub const DXVA_PICTURE_STRUCTURE_FRAME = @as(u32, 3);
pub const DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND = @as(u32, 0);
pub const DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2 = @as(u32, 0);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263 = @as(u32, 1);
pub const DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261 = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ZIG_ZAG = @as(u32, 0);
pub const DXVA_SCAN_METHOD_ALTERNATE_VERTICAL = @as(u32, 1);
pub const DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL = @as(u32, 2);
pub const DXVA_SCAN_METHOD_ARBITRARY = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_MILD = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE = @as(u32, 3);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED = @as(u32, 0);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA = @as(u32, 1);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD = @as(u32, 2);
pub const DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD = @as(u32, 3);
pub const DXVA_USUAL_BLOCK_WIDTH = @as(u32, 8);
pub const DXVA_USUAL_BLOCK_HEIGHT = @as(u32, 8);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_off = @as(u32, 4);
pub const DXVA_NumMV_OBMC_off_BinPBwith4MV_on = @as(u32, 5);
pub const DXVA_NumMV_OBMC_on__BinPB_off = @as(u32, 10);
pub const DXVA_NumMV_OBMC_on__BinPB_on = @as(u32, 11);
pub const DXVA_CONFIG_DATA_TYPE_IA44 = @as(u32, 0);
pub const DXVA_CONFIG_DATA_TYPE_AI44 = @as(u32, 1);
pub const DXVA_CONFIG_DATA_TYPE_DPXD = @as(u32, 2);
pub const DXVA_CONFIG_DATA_TYPE_AYUV = @as(u32, 3);
pub const DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER = @as(u32, 0);
pub const DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE = @as(u32, 1);
pub const DXVA_ExtColorData_ShiftBase = @as(u32, 8);
pub const DXVA_DeinterlaceBobDevice = Guid.initString("335aa36e-7884-43a4-9c91-7f87faf3e37e");
pub const DXVA_DeinterlaceContainerDevice = Guid.initString("0e85cb93-3046-4ff0-aecc-d58cb5f035fd");
pub const MAX_DEINTERLACE_SURFACES = @as(u32, 32);
pub const DXVA_DeinterlaceBltFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceBltExFnCode = @as(u32, 2);
pub const MAX_DEINTERLACE_DEVICE_GUIDS = @as(u32, 32);
pub const DXVA_DeinterlaceQueryAvailableModesFnCode = @as(u32, 1);
pub const DXVA_DeinterlaceQueryModeCapsFnCode = @as(u32, 2);
pub const DXVA_ProcAmpControlDevice = Guid.initString("9f200913-2ffd-4056-9f1e-e1b508f22dcf");
pub const DXVA_ProcAmpControlQueryCapsFnCode = @as(u32, 3);
pub const DXVA_ProcAmpControlQueryRangeFnCode = @as(u32, 4);
pub const DXVA_ProcAmpControlBltFnCode = @as(u32, 1);
pub const DXVA_COPPDevice = Guid.initString("d2457add-8999-45ed-8a8a-d1aa047ba4d5");
pub const DXVA_COPPGetCertificateLengthFnCode = @as(u32, 1);
pub const DXVA_COPPKeyExchangeFnCode = @as(u32, 2);
pub const DXVA_COPPSequenceStartFnCode = @as(u32, 3);
pub const DXVA_COPPCommandFnCode = @as(u32, 4);
pub const DXVA_COPPSetProtectionLevel = Guid.initString("9bb9327c-4eb5-4727-9f00-b42b0919c0da");
pub const COPP_NoProtectionLevelAvailable = @as(i32, -1);
pub const COPP_DefaultProtectionLevel = @as(u32, 0);
pub const DXVA_COPPSetSignaling = Guid.initString("09a631a5-d684-4c60-8e4d-d3bb0f0be3ee");
pub const COPP_ImageAspectRatio_EN300294_Mask = @as(u32, 7);
pub const DXVA_COPPQueryStatusFnCode = @as(u32, 5);
pub const DXVA_COPPQueryConnectorType = Guid.initString("81d0bfd5-6afe-48c2-99c0-95a08f97c5da");
pub const DXVA_COPPQueryProtectionType = Guid.initString("38f2a801-9a6c-48bb-9107-b6696e6f1797");
pub const DXVA_COPPQueryLocalProtectionLevel = Guid.initString("b2075857-3eda-4d5d-88db-748f8c1a0549");
pub const DXVA_COPPQueryGlobalProtectionLevel = Guid.initString("1957210a-7766-452a-b99a-d27aed54f03a");
pub const DXVA_COPPQueryDisplayData = Guid.initString("d7bf1ba3-ad13-4f8e-af98-0dcb3ca204cc");
pub const DXVA_COPPQueryHDCPKeyData = Guid.initString("0db59d74-a992-492e-a0bd-c23fda564e00");
pub const DXVA_COPPQueryBusData = Guid.initString("c6f4d673-6174-4184-8e35-f6db5200bcba");
pub const DXVA_COPPQuerySignaling = Guid.initString("6629a591-3b79-4cf3-924a-11e8e7811671");
pub const DXVA2Trace_Control = Guid.initString("a0386e75-f70c-464c-a9ce-33c44e091623");
pub const DXVA2Trace_DecodeDevCreated = Guid.initString("b4de17a1-c5b2-44fe-86d5-d97a648114ff");
pub const DXVA2Trace_DecodeDevDestroyed = Guid.initString("853ebdf2-4160-421d-8893-63dcea4f18bb");
pub const DXVA2Trace_DecodeDevBeginFrame = Guid.initString("9fd1acf6-44cb-4637-bc62-2c11a9608f90");
pub const DXVA2Trace_DecodeDevExecute = Guid.initString("850aeb4c-d19a-4609-b3b4-bcbf0e22121e");
pub const DXVA2Trace_DecodeDevGetBuffer = Guid.initString("57b128fb-72cb-4137-a575-d91fa3160897");
pub const DXVA2Trace_DecodeDevEndFrame = Guid.initString("9fb3cb33-47dc-4899-98c8-c0c6cd7cd3cb");
pub const DXVA2Trace_VideoProcessDevCreated = Guid.initString("895508c6-540d-4c87-98f8-8dcbf2dabb2a");
pub const DXVA2Trace_VideoProcessDevDestroyed = Guid.initString("f97f30b1-fb49-42c7-8ee8-88bdfa92d4e2");
pub const DXVA2Trace_VideoProcessBlt = Guid.initString("69089cc0-71ab-42d0-953a-2887bf05a8af");
pub const MSTapeDeviceGUID = Guid.initString("8c0f6af2-0edb-44c1-8aeb-59040bd830ed");
pub const g_wszExcludeScriptStreamDeliverySynchronization = "ExcludeScriptStreamDeliverySynchronization";
pub const MPEG2_BASE = @as(u32, 512);
pub const MPEG2_S_MORE_DATA_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262656));
pub const MPEG2_S_NO_MORE_DATA_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262657));
pub const MPEG2_S_SG_INFO_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262658));
pub const MPEG2_S_SG_INFO_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262659));
pub const MPEG2_S_MPE_INFO_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262660));
pub const MPEG2_S_MPE_INFO_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262661));
pub const MPEG2_S_NEW_MODULE_VERSION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 262662));
pub const MPEG2_E_UNINITIALIZED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const MPEG2_E_ALREADY_INITIALIZED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const MPEG2_E_OUT_OF_BOUNDS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const MPEG2_E_MALFORMED_TABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220989));
pub const MPEG2_E_UNDEFINED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220988));
pub const MPEG2_E_NOT_PRESENT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220987));
pub const MPEG2_E_SECTION_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220986));
pub const MPEG2_E_TX_STREAM_UNAVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220985));
pub const MPEG2_E_SERVICE_ID_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220984));
pub const MPEG2_E_SERVICE_PMT_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220983));
pub const MPEG2_E_DSI_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220982));
pub const MPEG2_E_SERVER_UNAVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220981));
pub const MPEG2_E_INVALID_CAROUSEL_ID = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220980));
pub const MPEG2_E_MALFORMED_DSMCC_MESSAGE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220979));
pub const MPEG2_E_INVALID_SG_OBJECT_KIND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220978));
pub const MPEG2_E_OBJECT_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220977));
pub const MPEG2_E_OBJECT_KIND_NOT_A_DIRECTORY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220976));
pub const MPEG2_E_OBJECT_KIND_NOT_A_FILE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220975));
pub const MPEG2_E_FILE_OFFSET_TOO_BIG = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220974));
pub const MPEG2_E_STREAM_STOPPED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220973));
pub const MPEG2_E_REGISTRY_ACCESS_FAILED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220972));
pub const MPEG2_E_INVALID_UDP_PORT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220971));
pub const MPEG2_E_DATA_SOURCE_FAILED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220970));
pub const MPEG2_E_DII_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220969));
pub const MPEG2_E_DSHOW_PIN_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220968));
pub const MPEG2_E_BUFFER_TOO_SMALL = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220967));
pub const MPEG2_E_MISSING_SECTIONS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220966));
pub const MPEG2_E_TOO_MANY_SECTIONS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220965));
pub const MPEG2_E_NEXT_TABLE_OPS_NOT_AVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220964));
pub const MPEG2_E_INCORRECT_DESCRIPTOR_TAG = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -2147220963));
pub const MSDRI_S_MMI_PENDING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 2));
pub const MSDRI_S_PENDING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, 1));
pub const BDA_E_FAILURE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479679));
pub const BDA_E_NOT_IMPLEMENTED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479678));
pub const BDA_E_NO_SUCH_COMMAND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479677));
pub const BDA_E_OUT_OF_BOUNDS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479676));
pub const BDA_E_INVALID_SCHEMA = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479675));
pub const BDA_E_INVALID_HANDLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479674));
pub const BDA_E_INVALID_TYPE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479673));
pub const BDA_E_READ_ONLY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479672));
pub const BDA_E_ACCESS_DENIED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479671));
pub const BDA_E_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479670));
pub const BDA_E_BUFFER_TOO_SMALL = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479669));
pub const BDA_E_OUT_OF_RESOURCES = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479668));
pub const BDA_E_OUT_OF_MEMORY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479667));
pub const BDA_E_DISABLED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479666));
pub const BDA_E_NO_HANDLER = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479665));
pub const BDA_E_INVALID_LANGUAGE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479664));
pub const BDA_E_TIMEOUT_ELAPSED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073479663));
pub const BDA_E_NO_MORE_EVENTS = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073475583));
pub const BDA_E_NO_MORE_DATA = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073475582));
pub const BDA_E_TUNER_INITIALIZING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073467391));
pub const BDA_E_TUNER_REQUIRED = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073467390));
pub const BDA_E_TUNER_CONFLICT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073467389));
pub const BDA_E_INVALID_TUNE_REQUEST = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073467388));
pub const BDA_E_INVALID_ENTITLEMENT_TOKEN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073463295));
pub const BDA_E_INVALID_CAPTURE_TOKEN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073463294));
pub const BDA_E_WOULD_DISRUPT_STREAMING = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073463293));
pub const BDA_E_INVALID_PURCHASE_TOKEN = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073463292));
pub const BDA_E_IPNETWORK_ERROR = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073459199));
pub const BDA_E_IPNETWORK_ADDRESS_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073459198));
pub const BDA_E_IPNETWORK_TIMEOUT = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073459197));
pub const BDA_E_IPNETWORK_UNAVAILABLE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073459196));
pub const BDA_E_TUNE_FAILED_SDV01 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455103));
pub const BDA_E_TUNE_FAILED_SDV02 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455102));
pub const BDA_E_TUNE_FAILED_SDV03 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455101));
pub const BDA_E_TUNE_FAILED_SDV04 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455100));
pub const BDA_E_TUNE_FAILED_SDV05 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455099));
pub const BDA_E_TUNE_FAILED_SDV06 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455098));
pub const BDA_E_TUNE_FAILED_SDV07 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455097));
pub const BDA_E_TUNE_FAILED_SDV08 = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073455096));
pub const BDA_E_TUNE_FAILED_SDVFF = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073454849));
pub const BDA_E_WMDRM_INVALID_SIGNATURE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418239));
pub const BDA_E_WMDRM_INVALID_CERTIFICATE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418238));
pub const BDA_E_WMDRM_INVALID_VERSION = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418236));
pub const BDA_E_WMDRM_INVALID_DATE = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418235));
pub const BDA_E_WMDRM_INVALID_PROXIMITY = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418234));
pub const BDA_E_WMDRM_KEY_ID_NOT_FOUND = @import("../../../zig.zig").typedConst(HRESULT, @as(i32, -1073418232));
pub const SPECIFYPAGES_STATISTICS = Guid.initString("4c437b92-6e9e-11d1-a704-006097c4e476");

//--------------------------------------------------------------------------------
// Section: Types (694)
//--------------------------------------------------------------------------------
pub const OA_BOOL = enum(i32) {
    TRUE = -1,
    FALSE = 0,
};
pub const OATRUE = OA_BOOL.TRUE;
pub const OAFALSE = OA_BOOL.FALSE;

pub const MPEGLAYER3WAVEFORMAT_FLAGS = enum(u32) {
    ISO = 0,
    ON = 1,
    OFF = 2,
};
pub const MPEGLAYER3_FLAG_PADDING_ISO = MPEGLAYER3WAVEFORMAT_FLAGS.ISO;
pub const MPEGLAYER3_FLAG_PADDING_ON = MPEGLAYER3WAVEFORMAT_FLAGS.ON;
pub const MPEGLAYER3_FLAG_PADDING_OFF = MPEGLAYER3WAVEFORMAT_FLAGS.OFF;

pub const AMVP_SELECT_FORMAT_BY = enum(i32) {
    DO_NOT_CARE = 0,
    BEST_BANDWIDTH = 1,
    INPUT_SAME_AS_OUTPUT = 2,
};
pub const AMVP_DO_NOT_CARE = AMVP_SELECT_FORMAT_BY.DO_NOT_CARE;
pub const AMVP_BEST_BANDWIDTH = AMVP_SELECT_FORMAT_BY.BEST_BANDWIDTH;
pub const AMVP_INPUT_SAME_AS_OUTPUT = AMVP_SELECT_FORMAT_BY.INPUT_SAME_AS_OUTPUT;

pub const AMVP_MODE = enum(i32) {
    WEAVE = 0,
    BOBINTERLEAVED = 1,
    BOBNONINTERLEAVED = 2,
    SKIPEVEN = 3,
    SKIPODD = 4,
};
pub const AMVP_MODE_WEAVE = AMVP_MODE.WEAVE;
pub const AMVP_MODE_BOBINTERLEAVED = AMVP_MODE.BOBINTERLEAVED;
pub const AMVP_MODE_BOBNONINTERLEAVED = AMVP_MODE.BOBNONINTERLEAVED;
pub const AMVP_MODE_SKIPEVEN = AMVP_MODE.SKIPEVEN;
pub const AMVP_MODE_SKIPODD = AMVP_MODE.SKIPODD;

pub const AMVPSIZE = extern struct {
    dwWidth: u32,
    dwHeight: u32,
};

pub const AMVPDIMINFO = extern struct {
    dwFieldWidth: u32,
    dwFieldHeight: u32,
    dwVBIWidth: u32,
    dwVBIHeight: u32,
    rcValidRegion: RECT,
};

pub const AMVPDATAINFO = extern struct {
    dwSize: u32,
    dwMicrosecondsPerField: u32,
    amvpDimInfo: AMVPDIMINFO,
    dwPictAspectRatioX: u32,
    dwPictAspectRatioY: u32,
    bEnableDoubleClock: BOOL,
    bEnableVACT: BOOL,
    bDataIsInterlaced: BOOL,
    lHalfLinesOdd: i32,
    bFieldPolarityInverted: BOOL,
    dwNumLinesInVREF: u32,
    lHalfLinesEven: i32,
    dwReserved1: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICreateDevEnum_Value = Guid.initString("29840822-5b84-11d0-bd3b-00a0c911ce86");
pub const IID_ICreateDevEnum = &IID_ICreateDevEnum_Value;
pub const ICreateDevEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateClassEnumerator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICreateDevEnum,
                clsidDeviceClass: ?*const Guid,
                ppEnumMoniker: ?*?*IEnumMoniker,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICreateDevEnum,
                clsidDeviceClass: ?*const Guid,
                ppEnumMoniker: ?*?*IEnumMoniker,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateDevEnum_CreateClassEnumerator(self: *const T, clsidDeviceClass: ?*const Guid, ppEnumMoniker: ?*?*IEnumMoniker, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ICreateDevEnum.VTable, @ptrCast(self.vtable)).CreateClassEnumerator(@as(*const ICreateDevEnum, @ptrCast(self)), clsidDeviceClass, ppEnumMoniker, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PIN_DIRECTION = enum(i32) {
    INPUT = 0,
    OUTPUT = 1,
};
pub const PINDIR_INPUT = PIN_DIRECTION.INPUT;
pub const PINDIR_OUTPUT = PIN_DIRECTION.OUTPUT;

pub const ALLOCATOR_PROPERTIES = extern struct {
    cBuffers: i32,
    cbBuffer: i32,
    cbAlign: i32,
    cbPrefix: i32,
};

pub const PIN_INFO = extern struct {
    pFilter: ?*IBaseFilter,
    dir: PIN_DIRECTION,
    achName: [128]u16,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPin_Value = Guid.initString("56a86891-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPin = &IID_IPin_Value;
pub const IPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pReceivePin: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pReceivePin: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReceiveConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pConnector: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pConnector: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectionMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPinInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pInfo: ?*PIN_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pInfo: ?*PIN_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryDirection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pPinDir: ?*PIN_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pPinDir: ?*PIN_DIRECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                Id: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                Id: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryAccept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMediaTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                ppEnum: ?*?*IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                ppEnum: ?*?*IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryInternalConnections: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                apPin: ?[*]?*IPin,
                nPin: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                apPin: ?[*]?*IPin,
                nPin: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginFlush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFlush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NewSegment: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPin,
                tStart: i64,
                tStop: i64,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPin,
                tStart: i64,
                tStop: i64,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_Connect(self: *const T, pReceivePin: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).Connect(@as(*const IPin, @ptrCast(self)), pReceivePin, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ReceiveConnection(self: *const T, pConnector: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).ReceiveConnection(@as(*const IPin, @ptrCast(self)), pConnector, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IPin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ConnectedTo(self: *const T, pPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).ConnectedTo(@as(*const IPin, @ptrCast(self)), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_ConnectionMediaType(self: *const T, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).ConnectionMediaType(@as(*const IPin, @ptrCast(self)), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryPinInfo(self: *const T, pInfo: ?*PIN_INFO) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryPinInfo(@as(*const IPin, @ptrCast(self)), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryDirection(self: *const T, pPinDir: ?*PIN_DIRECTION) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryDirection(@as(*const IPin, @ptrCast(self)), pPinDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryId(self: *const T, Id: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryId(@as(*const IPin, @ptrCast(self)), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryAccept(self: *const T, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryAccept(@as(*const IPin, @ptrCast(self)), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EnumMediaTypes(self: *const T, ppEnum: ?*?*IEnumMediaTypes) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).EnumMediaTypes(@as(*const IPin, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_QueryInternalConnections(self: *const T, apPin: ?[*]?*IPin, nPin: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).QueryInternalConnections(@as(*const IPin, @ptrCast(self)), apPin, nPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EndOfStream(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).EndOfStream(@as(*const IPin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_BeginFlush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).BeginFlush(@as(*const IPin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_EndFlush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).EndFlush(@as(*const IPin, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPin_NewSegment(self: *const T, tStart: i64, tStop: i64, dRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IPin.VTable, @ptrCast(self.vtable)).NewSegment(@as(*const IPin, @ptrCast(self)), tStart, tStop, dRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPins_Value = Guid.initString("56a86892-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumPins = &IID_IEnumPins_Value;
pub const IEnumPins = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPins,
                cPins: u32,
                ppPins: [*]?*IPin,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPins,
                cPins: u32,
                ppPins: [*]?*IPin,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPins,
                cPins: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPins,
                cPins: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPins,
                ppEnum: ?*?*IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPins,
                ppEnum: ?*?*IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Next(self: *const T, cPins: u32, ppPins: [*]?*IPin, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPins, @ptrCast(self)), cPins, ppPins, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Skip(self: *const T, cPins: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPins, @ptrCast(self)), cPins);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPins, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPins_Clone(self: *const T, ppEnum: ?*?*IEnumPins) callconv(.Inline) HRESULT {
            return @as(*const IEnumPins.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPins, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumMediaTypes_Value = Guid.initString("89c31040-846b-11ce-97d3-00aa0055595a");
pub const IID_IEnumMediaTypes = &IID_IEnumMediaTypes_Value;
pub const IEnumMediaTypes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMediaTypes,
                cMediaTypes: u32,
                ppMediaTypes: [*]?*AM_MEDIA_TYPE,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMediaTypes,
                cMediaTypes: u32,
                ppMediaTypes: [*]?*AM_MEDIA_TYPE,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMediaTypes,
                cMediaTypes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMediaTypes,
                cMediaTypes: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumMediaTypes,
                ppEnum: ?*?*IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumMediaTypes,
                ppEnum: ?*?*IEnumMediaTypes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Next(self: *const T, cMediaTypes: u32, ppMediaTypes: [*]?*AM_MEDIA_TYPE, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumMediaTypes, @ptrCast(self)), cMediaTypes, ppMediaTypes, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Skip(self: *const T, cMediaTypes: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumMediaTypes, @ptrCast(self)), cMediaTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumMediaTypes, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMediaTypes_Clone(self: *const T, ppEnum: ?*?*IEnumMediaTypes) callconv(.Inline) HRESULT {
            return @as(*const IEnumMediaTypes.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumMediaTypes, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph_Value = Guid.initString("56a8689f-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterGraph = &IID_IFilterGraph_Value;
pub const IFilterGraph = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                pFilter: ?*IBaseFilter,
                pName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                pFilter: ?*IBaseFilter,
                pName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                ppEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                ppEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindFilterByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                pName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                pName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectDirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                ppinOut: ?*IPin,
                ppinIn: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                ppinOut: ?*IPin,
                ppinIn: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                ppin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                ppin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
                ppin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
                ppin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultSyncSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_AddFilter(self: *const T, pFilter: ?*IBaseFilter, pName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).AddFilter(@as(*const IFilterGraph, @ptrCast(self)), pFilter, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_RemoveFilter(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).RemoveFilter(@as(*const IFilterGraph, @ptrCast(self)), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_EnumFilters(self: *const T, ppEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).EnumFilters(@as(*const IFilterGraph, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_FindFilterByName(self: *const T, pName: ?[*:0]align(1) const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).FindFilterByName(@as(*const IFilterGraph, @ptrCast(self)), pName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_ConnectDirect(self: *const T, ppinOut: ?*IPin, ppinIn: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).ConnectDirect(@as(*const IFilterGraph, @ptrCast(self)), ppinOut, ppinIn, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_Reconnect(self: *const T, ppin: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).Reconnect(@as(*const IFilterGraph, @ptrCast(self)), ppin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_Disconnect(self: *const T, ppin: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IFilterGraph, @ptrCast(self)), ppin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph_SetDefaultSyncSource(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph.VTable, @ptrCast(self.vtable)).SetDefaultSyncSource(@as(*const IFilterGraph, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumFilters_Value = Guid.initString("56a86893-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumFilters = &IID_IEnumFilters_Value;
pub const IEnumFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFilters,
                cFilters: u32,
                ppFilter: [*]?*IBaseFilter,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFilters,
                cFilters: u32,
                ppFilter: [*]?*IBaseFilter,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFilters,
                cFilters: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFilters,
                cFilters: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumFilters,
                ppEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumFilters,
                ppEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Next(self: *const T, cFilters: u32, ppFilter: [*]?*IBaseFilter, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumFilters, @ptrCast(self)), cFilters, ppFilter, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Skip(self: *const T, cFilters: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumFilters, @ptrCast(self)), cFilters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumFilters, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumFilters_Clone(self: *const T, ppEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @as(*const IEnumFilters.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumFilters, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_STATE = enum(i32) {
    Stopped = 0,
    Paused = 1,
    Running = 2,
};
pub const State_Stopped = FILTER_STATE.Stopped;
pub const State_Paused = FILTER_STATE.Paused;
pub const State_Running = FILTER_STATE.Running;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaFilter_Value = Guid.initString("56a86899-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaFilter = &IID_IMediaFilter_Value;
pub const IMediaFilter = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
                tStart: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
                tStart: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
                dwMilliSecsTimeout: u32,
                State: ?*FILTER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
                dwMilliSecsTimeout: u32,
                State: ?*FILTER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSyncSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaFilter,
                pClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaFilter,
                pClock: ?*?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMediaFilter, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMediaFilter, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_Run(self: *const T, tStart: i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).Run(@as(*const IMediaFilter, @ptrCast(self)), tStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_GetState(self: *const T, dwMilliSecsTimeout: u32, State: ?*FILTER_STATE) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMediaFilter, @ptrCast(self)), dwMilliSecsTimeout, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_SetSyncSource(self: *const T, pClock: ?*IReferenceClock) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).SetSyncSource(@as(*const IMediaFilter, @ptrCast(self)), pClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaFilter_GetSyncSource(self: *const T, pClock: ?*?*IReferenceClock) callconv(.Inline) HRESULT {
            return @as(*const IMediaFilter.VTable, @ptrCast(self.vtable)).GetSyncSource(@as(*const IMediaFilter, @ptrCast(self)), pClock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILTER_INFO = extern struct {
    achName: [128]u16,
    pGraph: ?*IFilterGraph,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBaseFilter_Value = Guid.initString("56a86895-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBaseFilter = &IID_IBaseFilter_Value;
pub const IBaseFilter = extern struct {
    pub const VTable = extern struct {
        base: IMediaFilter.VTable,
        EnumPins: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseFilter,
                ppEnum: ?*?*IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseFilter,
                ppEnum: ?*?*IEnumPins,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseFilter,
                Id: ?[*:0]align(1) const u16,
                ppPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseFilter,
                Id: ?[*:0]align(1) const u16,
                ppPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryFilterInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseFilter,
                pInfo: ?*FILTER_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseFilter,
                pInfo: ?*FILTER_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JoinFilterGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseFilter,
                pGraph: ?*IFilterGraph,
                pName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseFilter,
                pGraph: ?*IFilterGraph,
                pName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryVendorInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseFilter,
                pVendorInfo: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseFilter,
                pVendorInfo: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_EnumPins(self: *const T, ppEnum: ?*?*IEnumPins) callconv(.Inline) HRESULT {
            return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).EnumPins(@as(*const IBaseFilter, @ptrCast(self)), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_FindPin(self: *const T, Id: ?[*:0]align(1) const u16, ppPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).FindPin(@as(*const IBaseFilter, @ptrCast(self)), Id, ppPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_QueryFilterInfo(self: *const T, pInfo: ?*FILTER_INFO) callconv(.Inline) HRESULT {
            return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).QueryFilterInfo(@as(*const IBaseFilter, @ptrCast(self)), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_JoinFilterGraph(self: *const T, pGraph: ?*IFilterGraph, pName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).JoinFilterGraph(@as(*const IBaseFilter, @ptrCast(self)), pGraph, pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseFilter_QueryVendorInfo(self: *const T, pVendorInfo: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IBaseFilter.VTable, @ptrCast(self.vtable)).QueryVendorInfo(@as(*const IBaseFilter, @ptrCast(self)), pVendorInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample_Value = Guid.initString("56a8689a-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaSample = &IID_IMediaSample_Value;
pub const IMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                ppBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                ppBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSyncPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                bIsSyncPoint: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                bIsSyncPoint: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                bIsPreroll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                bIsPreroll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        SetActualDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                __MIDL__IMediaSample0000: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                __MIDL__IMediaSample0000: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDiscontinuity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDiscontinuity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                bDiscontinuity: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                bDiscontinuity: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetPointer(self: *const T, ppBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetPointer(@as(*const IMediaSample, @ptrCast(self)), ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetSize(self: *const T) callconv(.Inline) i32 {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IMediaSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IMediaSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetTime(@as(*const IMediaSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsSyncPoint(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsSyncPoint(@as(*const IMediaSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetSyncPoint(self: *const T, bIsSyncPoint: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetSyncPoint(@as(*const IMediaSample, @ptrCast(self)), bIsSyncPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsPreroll(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsPreroll(@as(*const IMediaSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetPreroll(self: *const T, bIsPreroll: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetPreroll(@as(*const IMediaSample, @ptrCast(self)), bIsPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetActualDataLength(self: *const T) callconv(.Inline) i32 {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetActualDataLength(@as(*const IMediaSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetActualDataLength(self: *const T, __MIDL__IMediaSample0000: i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetActualDataLength(@as(*const IMediaSample, @ptrCast(self)), __MIDL__IMediaSample0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetMediaType(self: *const T, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IMediaSample, @ptrCast(self)), ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetMediaType(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IMediaSample, @ptrCast(self)), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_IsDiscontinuity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).IsDiscontinuity(@as(*const IMediaSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetDiscontinuity(self: *const T, bDiscontinuity: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetDiscontinuity(@as(*const IMediaSample, @ptrCast(self)), bDiscontinuity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_GetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).GetMediaTime(@as(*const IMediaSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample_SetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample.VTable, @ptrCast(self.vtable)).SetMediaTime(@as(*const IMediaSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SAMPLE_PROPERTY_FLAGS = enum(i32) {
    AMPLE_SPLICEPOINT = 1,
    AMPLE_PREROLL = 2,
    AMPLE_DATADISCONTINUITY = 4,
    AMPLE_TYPECHANGED = 8,
    AMPLE_TIMEVALID = 16,
    AMPLE_TIMEDISCONTINUITY = 64,
    AMPLE_FLUSH_ON_PAUSE = 128,
    AMPLE_STOPVALID = 256,
    AMPLE_ENDOFSTREAM = 512,
    TREAM_MEDIA = 0,
    // TREAM_CONTROL = 1, this enum value conflicts with AMPLE_SPLICEPOINT
};
pub const AM_SAMPLE_SPLICEPOINT = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;
pub const AM_SAMPLE_PREROLL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_PREROLL;
pub const AM_SAMPLE_DATADISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_DATADISCONTINUITY;
pub const AM_SAMPLE_TYPECHANGED = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TYPECHANGED;
pub const AM_SAMPLE_TIMEVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEVALID;
pub const AM_SAMPLE_TIMEDISCONTINUITY = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_TIMEDISCONTINUITY;
pub const AM_SAMPLE_FLUSH_ON_PAUSE = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_FLUSH_ON_PAUSE;
pub const AM_SAMPLE_STOPVALID = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_STOPVALID;
pub const AM_SAMPLE_ENDOFSTREAM = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_ENDOFSTREAM;
pub const AM_STREAM_MEDIA = AM_SAMPLE_PROPERTY_FLAGS.TREAM_MEDIA;
pub const AM_STREAM_CONTROL = AM_SAMPLE_PROPERTY_FLAGS.AMPLE_SPLICEPOINT;

pub const AM_SAMPLE2_PROPERTIES = extern struct {
    cbData: u32,
    dwTypeSpecificFlags: u32,
    dwSampleFlags: u32,
    lActual: i32,
    tStart: i64,
    tStop: i64,
    dwStreamId: u32,
    pMediaType: ?*AM_MEDIA_TYPE,
    pbBuffer: ?*u8,
    cbBuffer: i32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSample2_Value = Guid.initString("36b73884-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSample2 = &IID_IMediaSample2_Value;
pub const IMediaSample2 = extern struct {
    pub const VTable = extern struct {
        base: IMediaSample.VTable,
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample2,
                cbProperties: u32,
                // TODO: what to do with BytesParamIndex 0?
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample2,
                cbProperties: u32,
                // TODO: what to do with BytesParamIndex 0?
                pbProperties: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample2,
                cbProperties: u32,
                // TODO: what to do with BytesParamIndex 0?
                pbProperties: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample2,
                cbProperties: u32,
                // TODO: what to do with BytesParamIndex 0?
                pbProperties: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2_GetProperties(self: *const T, cbProperties: u32, pbProperties: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample2.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IMediaSample2, @ptrCast(self)), cbProperties, pbProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2_SetProperties(self: *const T, cbProperties: u32, pbProperties: ?*const u8) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample2.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IMediaSample2, @ptrCast(self)), cbProperties, pbProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IMediaSample2Config_Value = Guid.initString("68961e68-832b-41ea-bc91-63593f3e70e3");
pub const IID_IMediaSample2Config = &IID_IMediaSample2Config_Value;
pub const IMediaSample2Config = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSample2Config,
                ppDirect3DSurface9: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSample2Config,
                ppDirect3DSurface9: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSample2Config_GetSurface(self: *const T, ppDirect3DSurface9: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IMediaSample2Config.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IMediaSample2Config, @ptrCast(self)), ppDirect3DSurface9);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocator_Value = Guid.initString("56a8689c-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemAllocator = &IID_IMemAllocator_Value;
pub const IMemAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
                pRequest: ?*ALLOCATOR_PROPERTIES,
                pActual: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
                pRequest: ?*ALLOCATOR_PROPERTIES,
                pActual: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Commit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Decommit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
                ppBuffer: ?*?*IMediaSample,
                pStartTime: ?*i64,
                pEndTime: ?*i64,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
                ppBuffer: ?*?*IMediaSample,
                pStartTime: ?*i64,
                pEndTime: ?*i64,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocator,
                pBuffer: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocator,
                pBuffer: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_SetProperties(self: *const T, pRequest: ?*ALLOCATOR_PROPERTIES, pActual: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).SetProperties(@as(*const IMemAllocator, @ptrCast(self)), pRequest, pActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_GetProperties(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).GetProperties(@as(*const IMemAllocator, @ptrCast(self)), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).Commit(@as(*const IMemAllocator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_Decommit(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).Decommit(@as(*const IMemAllocator, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_GetBuffer(self: *const T, ppBuffer: ?*?*IMediaSample, pStartTime: ?*i64, pEndTime: ?*i64, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IMemAllocator, @ptrCast(self)), ppBuffer, pStartTime, pEndTime, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocator_ReleaseBuffer(self: *const T, pBuffer: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocator.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IMemAllocator, @ptrCast(self)), pBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorCallbackTemp_Value = Guid.initString("379a0cf0-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorCallbackTemp = &IID_IMemAllocatorCallbackTemp_Value;
pub const IMemAllocatorCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IMemAllocator.VTable,
        SetNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocatorCallbackTemp,
                pNotify: ?*IMemAllocatorNotifyCallbackTemp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocatorCallbackTemp,
                pNotify: ?*IMemAllocatorNotifyCallbackTemp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFreeCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocatorCallbackTemp,
                plBuffersFree: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocatorCallbackTemp,
                plBuffersFree: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMemAllocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorCallbackTemp_SetNotify(self: *const T, pNotify: ?*IMemAllocatorNotifyCallbackTemp) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocatorCallbackTemp.VTable, @ptrCast(self.vtable)).SetNotify(@as(*const IMemAllocatorCallbackTemp, @ptrCast(self)), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorCallbackTemp_GetFreeCount(self: *const T, plBuffersFree: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocatorCallbackTemp.VTable, @ptrCast(self.vtable)).GetFreeCount(@as(*const IMemAllocatorCallbackTemp, @ptrCast(self)), plBuffersFree);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemAllocatorNotifyCallbackTemp_Value = Guid.initString("92980b30-c1de-11d2-abf5-00a0c905f375");
pub const IID_IMemAllocatorNotifyCallbackTemp = &IID_IMemAllocatorNotifyCallbackTemp_Value;
pub const IMemAllocatorNotifyCallbackTemp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemAllocatorNotifyCallbackTemp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemAllocatorNotifyCallbackTemp,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemAllocatorNotifyCallbackTemp_NotifyRelease(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMemAllocatorNotifyCallbackTemp.VTable, @ptrCast(self.vtable)).NotifyRelease(@as(*const IMemAllocatorNotifyCallbackTemp, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMemInputPin_Value = Guid.initString("56a8689d-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMemInputPin = &IID_IMemInputPin_Value;
pub const IMemInputPin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
                ppAllocator: ?*?*IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
                ppAllocator: ?*?*IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
                pAllocator: ?*IMemAllocator,
                bReadOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
                pAllocator: ?*IMemAllocator,
                bReadOnly: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatorRequirements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Receive: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
                pSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
                pSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReceiveMultiple: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
                pSamples: [*]?*IMediaSample,
                nSamples: i32,
                nSamplesProcessed: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
                pSamples: [*]?*IMediaSample,
                nSamples: i32,
                nSamplesProcessed: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReceiveCanBlock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemInputPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemInputPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_GetAllocator(self: *const T, ppAllocator: ?*?*IMemAllocator) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).GetAllocator(@as(*const IMemInputPin, @ptrCast(self)), ppAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_NotifyAllocator(self: *const T, pAllocator: ?*IMemAllocator, bReadOnly: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).NotifyAllocator(@as(*const IMemInputPin, @ptrCast(self)), pAllocator, bReadOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_GetAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).GetAllocatorRequirements(@as(*const IMemInputPin, @ptrCast(self)), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_Receive(self: *const T, pSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).Receive(@as(*const IMemInputPin, @ptrCast(self)), pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_ReceiveMultiple(self: *const T, pSamples: [*]?*IMediaSample, nSamples: i32, nSamplesProcessed: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).ReceiveMultiple(@as(*const IMemInputPin, @ptrCast(self)), pSamples, nSamples, nSamplesProcessed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemInputPin_ReceiveCanBlock(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMemInputPin.VTable, @ptrCast(self.vtable)).ReceiveCanBlock(@as(*const IMemInputPin, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMovieSetup_Value = Guid.initString("a3d8cec0-7e5a-11cf-bbc5-00805f6cef20");
pub const IID_IAMovieSetup = &IID_IAMovieSetup_Value;
pub const IAMovieSetup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMovieSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMovieSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unregister: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMovieSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMovieSetup,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMovieSetup_Register(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMovieSetup.VTable, @ptrCast(self.vtable)).Register(@as(*const IAMovieSetup, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMovieSetup_Unregister(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMovieSetup.VTable, @ptrCast(self.vtable)).Unregister(@as(*const IAMovieSetup, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_SEEKING_SEEKING_FLAGS = enum(i32) {
    NoPositioning = 0,
    AbsolutePositioning = 1,
    RelativePositioning = 2,
    IncrementalPositioning = 3,
    // PositioningBitsMask = 3, this enum value conflicts with IncrementalPositioning
    SeekToKeyFrame = 4,
    ReturnTime = 8,
    Segment = 16,
    NoFlush = 32,
};
pub const AM_SEEKING_NoPositioning = AM_SEEKING_SEEKING_FLAGS.NoPositioning;
pub const AM_SEEKING_AbsolutePositioning = AM_SEEKING_SEEKING_FLAGS.AbsolutePositioning;
pub const AM_SEEKING_RelativePositioning = AM_SEEKING_SEEKING_FLAGS.RelativePositioning;
pub const AM_SEEKING_IncrementalPositioning = AM_SEEKING_SEEKING_FLAGS.IncrementalPositioning;
pub const AM_SEEKING_PositioningBitsMask = AM_SEEKING_SEEKING_FLAGS.IncrementalPositioning;
pub const AM_SEEKING_SeekToKeyFrame = AM_SEEKING_SEEKING_FLAGS.SeekToKeyFrame;
pub const AM_SEEKING_ReturnTime = AM_SEEKING_SEEKING_FLAGS.ReturnTime;
pub const AM_SEEKING_Segment = AM_SEEKING_SEEKING_FLAGS.Segment;
pub const AM_SEEKING_NoFlush = AM_SEEKING_SEEKING_FLAGS.NoFlush;

pub const AM_SEEKING_SEEKING_CAPABILITIES = enum(i32) {
    CanSeekAbsolute = 1,
    CanSeekForwards = 2,
    CanSeekBackwards = 4,
    CanGetCurrentPos = 8,
    CanGetStopPos = 16,
    CanGetDuration = 32,
    CanPlayBackwards = 64,
    CanDoSegments = 128,
    Source = 256,
};
pub const AM_SEEKING_CanSeekAbsolute = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekAbsolute;
pub const AM_SEEKING_CanSeekForwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekForwards;
pub const AM_SEEKING_CanSeekBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanSeekBackwards;
pub const AM_SEEKING_CanGetCurrentPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetCurrentPos;
pub const AM_SEEKING_CanGetStopPos = AM_SEEKING_SEEKING_CAPABILITIES.CanGetStopPos;
pub const AM_SEEKING_CanGetDuration = AM_SEEKING_SEEKING_CAPABILITIES.CanGetDuration;
pub const AM_SEEKING_CanPlayBackwards = AM_SEEKING_SEEKING_CAPABILITIES.CanPlayBackwards;
pub const AM_SEEKING_CanDoSegments = AM_SEEKING_SEEKING_CAPABILITIES.CanDoSegments;
pub const AM_SEEKING_Source = AM_SEEKING_SEEKING_CAPABILITIES.Source;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaSeeking_Value = Guid.initString("36b73880-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IMediaSeeking = &IID_IMediaSeeking_Value;
pub const IMediaSeeking = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pCapabilities: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsFormatSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryPreferredFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStopPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pStop: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pStop: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConvertTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pTarget: ?*i64,
                pTargetFormat: ?*const Guid,
                Source: i64,
                pSourceFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pTarget: ?*i64,
                pTargetFormat: ?*const Guid,
                Source: i64,
                pSourceFormat: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPositions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
                dwCurrentFlags: u32,
                pStop: ?*i64,
                dwStopFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
                dwCurrentFlags: u32,
                pStop: ?*i64,
                dwStopFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPositions: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
                pStop: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pCurrent: ?*i64,
                pStop: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pEarliest: ?*i64,
                pLatest: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pEarliest: ?*i64,
                pLatest: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaSeeking,
                pllPreroll: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaSeeking,
                pllPreroll: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetCapabilities(self: *const T, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetCapabilities(@as(*const IMediaSeeking, @ptrCast(self)), pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_CheckCapabilities(self: *const T, pCapabilities: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).CheckCapabilities(@as(*const IMediaSeeking, @ptrCast(self)), pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_IsFormatSupported(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).IsFormatSupported(@as(*const IMediaSeeking, @ptrCast(self)), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_QueryPreferredFormat(self: *const T, pFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).QueryPreferredFormat(@as(*const IMediaSeeking, @ptrCast(self)), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetTimeFormat(self: *const T, pFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_IsUsingTimeFormat(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).IsUsingTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetTimeFormat(self: *const T, pFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), pFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetDuration(self: *const T, pDuration: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMediaSeeking, @ptrCast(self)), pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetStopPosition(self: *const T, pStop: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetStopPosition(@as(*const IMediaSeeking, @ptrCast(self)), pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetCurrentPosition(self: *const T, pCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetCurrentPosition(@as(*const IMediaSeeking, @ptrCast(self)), pCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_ConvertTimeFormat(self: *const T, pTarget: ?*i64, pTargetFormat: ?*const Guid, Source: i64, pSourceFormat: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).ConvertTimeFormat(@as(*const IMediaSeeking, @ptrCast(self)), pTarget, pTargetFormat, Source, pSourceFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetPositions(self: *const T, pCurrent: ?*i64, dwCurrentFlags: u32, pStop: ?*i64, dwStopFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetPositions(@as(*const IMediaSeeking, @ptrCast(self)), pCurrent, dwCurrentFlags, pStop, dwStopFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetPositions(self: *const T, pCurrent: ?*i64, pStop: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetPositions(@as(*const IMediaSeeking, @ptrCast(self)), pCurrent, pStop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetAvailable(self: *const T, pEarliest: ?*i64, pLatest: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetAvailable(@as(*const IMediaSeeking, @ptrCast(self)), pEarliest, pLatest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_SetRate(self: *const T, dRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).SetRate(@as(*const IMediaSeeking, @ptrCast(self)), dRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetRate(self: *const T, pdRate: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetRate(@as(*const IMediaSeeking, @ptrCast(self)), pdRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaSeeking_GetPreroll(self: *const T, pllPreroll: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaSeeking.VTable, @ptrCast(self.vtable)).GetPreroll(@as(*const IMediaSeeking, @ptrCast(self)), pllPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MEDIAEVENT_FLAGS = enum(i32) {
    Y = 1,
};
pub const AM_MEDIAEVENT_NONOTIFY = AM_MEDIAEVENT_FLAGS.Y;

pub const REGFILTER = extern struct {
    Clsid: Guid,
    Name: ?PWSTR,
};

const IID_IEnumRegFilters_Value = Guid.initString("56a868a4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IEnumRegFilters = &IID_IEnumRegFilters_Value;
pub const IEnumRegFilters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRegFilters,
                cFilters: u32,
                apRegFilter: [*]?*REGFILTER,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRegFilters,
                cFilters: u32,
                apRegFilter: [*]?*REGFILTER,
                pcFetched: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRegFilters,
                cFilters: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRegFilters,
                cFilters: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRegFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRegFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumRegFilters,
                ppEnum: ?*?*IEnumRegFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumRegFilters,
                ppEnum: ?*?*IEnumRegFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Next(self: *const T, cFilters: u32, apRegFilter: [*]?*REGFILTER, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumRegFilters, @ptrCast(self)), cFilters, apRegFilter, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Skip(self: *const T, cFilters: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumRegFilters, @ptrCast(self)), cFilters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumRegFilters, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRegFilters_Clone(self: *const T, ppEnum: ?*?*IEnumRegFilters) callconv(.Inline) HRESULT {
            return @as(*const IEnumRegFilters.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumRegFilters, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IFILTERMAPPER_MERIT = enum(i32) {
    PREFERRED = 8388608,
    NORMAL = 6291456,
    UNLIKELY = 4194304,
    DO_NOT_USE = 2097152,
    SW_COMPRESSOR = 1048576,
    HW_COMPRESSOR = 1048656,
};
pub const MERIT_PREFERRED = IFILTERMAPPER_MERIT.PREFERRED;
pub const MERIT_NORMAL = IFILTERMAPPER_MERIT.NORMAL;
pub const MERIT_UNLIKELY = IFILTERMAPPER_MERIT.UNLIKELY;
pub const MERIT_DO_NOT_USE = IFILTERMAPPER_MERIT.DO_NOT_USE;
pub const MERIT_SW_COMPRESSOR = IFILTERMAPPER_MERIT.SW_COMPRESSOR;
pub const MERIT_HW_COMPRESSOR = IFILTERMAPPER_MERIT.HW_COMPRESSOR;

const IID_IFilterMapper_Value = Guid.initString("56a868a3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterMapper = &IID_IFilterMapper_Value;
pub const IFilterMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                clsid: Guid,
                Name: ?[*:0]align(1) const u16,
                dwMerit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                clsid: Guid,
                Name: ?[*:0]align(1) const u16,
                dwMerit: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterFilterInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                clsid: Guid,
                Name: ?[*:0]align(1) const u16,
                MRId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                clsid: Guid,
                Name: ?[*:0]align(1) const u16,
                MRId: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                Filter: Guid,
                Name: ?[*:0]align(1) const u16,
                bRendered: BOOL,
                bOutput: BOOL,
                bZero: BOOL,
                bMany: BOOL,
                ConnectsToFilter: Guid,
                ConnectsToPin: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                Filter: Guid,
                Name: ?[*:0]align(1) const u16,
                bRendered: BOOL,
                bOutput: BOOL,
                bZero: BOOL,
                bMany: BOOL,
                ConnectsToFilter: Guid,
                ConnectsToPin: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterPinType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                clsFilter: Guid,
                strName: ?[*:0]align(1) const u16,
                clsMajorType: Guid,
                clsSubType: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                clsFilter: Guid,
                strName: ?[*:0]align(1) const u16,
                clsMajorType: Guid,
                clsSubType: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                Filter: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                Filter: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterFilterInstance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                MRId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                MRId: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                Filter: Guid,
                Name: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                Filter: Guid,
                Name: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMatchingFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper,
                ppEnum: ?*?*IEnumRegFilters,
                dwMerit: u32,
                bInputNeeded: BOOL,
                clsInMaj: Guid,
                clsInSub: Guid,
                bRender: BOOL,
                bOututNeeded: BOOL,
                clsOutMaj: Guid,
                clsOutSub: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper,
                ppEnum: ?*?*IEnumRegFilters,
                dwMerit: u32,
                bInputNeeded: BOOL,
                clsInMaj: Guid,
                clsInSub: Guid,
                bRender: BOOL,
                bOututNeeded: BOOL,
                clsOutMaj: Guid,
                clsOutSub: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterFilter(self: *const T, clsid: Guid, Name: ?[*:0]align(1) const u16, dwMerit: u32) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterFilter(@as(*const IFilterMapper, @ptrCast(self)), clsid, Name, dwMerit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterFilterInstance(self: *const T, clsid: Guid, Name: ?[*:0]align(1) const u16, MRId: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterFilterInstance(@as(*const IFilterMapper, @ptrCast(self)), clsid, Name, MRId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterPin(self: *const T, Filter: Guid, Name: ?[*:0]align(1) const u16, bRendered: BOOL, bOutput: BOOL, bZero: BOOL, bMany: BOOL, ConnectsToFilter: Guid, ConnectsToPin: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterPin(@as(*const IFilterMapper, @ptrCast(self)), Filter, Name, bRendered, bOutput, bZero, bMany, ConnectsToFilter, ConnectsToPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_RegisterPinType(self: *const T, clsFilter: Guid, strName: ?[*:0]align(1) const u16, clsMajorType: Guid, clsSubType: Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).RegisterPinType(@as(*const IFilterMapper, @ptrCast(self)), clsFilter, strName, clsMajorType, clsSubType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterFilter(self: *const T, Filter: Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterFilter(@as(*const IFilterMapper, @ptrCast(self)), Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterFilterInstance(self: *const T, MRId: Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterFilterInstance(@as(*const IFilterMapper, @ptrCast(self)), MRId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_UnregisterPin(self: *const T, Filter: Guid, Name: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).UnregisterPin(@as(*const IFilterMapper, @ptrCast(self)), Filter, Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper_EnumMatchingFilters(self: *const T, ppEnum: ?*?*IEnumRegFilters, dwMerit: u32, bInputNeeded: BOOL, clsInMaj: Guid, clsInSub: Guid, bRender: BOOL, bOututNeeded: BOOL, clsOutMaj: Guid, clsOutSub: Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper.VTable, @ptrCast(self.vtable)).EnumMatchingFilters(@as(*const IFilterMapper, @ptrCast(self)), ppEnum, dwMerit, bInputNeeded, clsInMaj, clsInSub, bRender, bOututNeeded, clsOutMaj, clsOutSub);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REGPINTYPES = extern struct {
    clsMajorType: ?*const Guid,
    clsMinorType: ?*const Guid,
};

pub const REGFILTERPINS = extern struct {
    strName: ?PWSTR,
    bRendered: BOOL,
    bOutput: BOOL,
    bZero: BOOL,
    bMany: BOOL,
    clsConnectsToFilter: ?*const Guid,
    strConnectsToPin: ?[*:0]align(1) const u16,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
};

pub const REGPINMEDIUM = extern struct {
    clsMedium: Guid,
    dw1: u32,
    dw2: u32,
};

pub const REG_PINFLAG = enum(i32) {
    ZERO = 1,
    RENDERER = 2,
    MANY = 4,
    OUTPUT = 8,
    _,
    pub fn initFlags(o: struct {
        ZERO: u1 = 0,
        RENDERER: u1 = 0,
        MANY: u1 = 0,
        OUTPUT: u1 = 0,
    }) REG_PINFLAG {
        return @as(REG_PINFLAG, @enumFromInt(
              (if (o.ZERO == 1) @intFromEnum(REG_PINFLAG.ZERO) else 0)
            | (if (o.RENDERER == 1) @intFromEnum(REG_PINFLAG.RENDERER) else 0)
            | (if (o.MANY == 1) @intFromEnum(REG_PINFLAG.MANY) else 0)
            | (if (o.OUTPUT == 1) @intFromEnum(REG_PINFLAG.OUTPUT) else 0)
        ));
    }
};
pub const REG_PINFLAG_B_ZERO = REG_PINFLAG.ZERO;
pub const REG_PINFLAG_B_RENDERER = REG_PINFLAG.RENDERER;
pub const REG_PINFLAG_B_MANY = REG_PINFLAG.MANY;
pub const REG_PINFLAG_B_OUTPUT = REG_PINFLAG.OUTPUT;

pub const REGFILTERPINS2 = extern struct {
    dwFlags: u32,
    cInstances: u32,
    nMediaTypes: u32,
    lpMediaType: ?*const REGPINTYPES,
    nMediums: u32,
    lpMedium: ?*const REGPINMEDIUM,
    clsPinCategory: ?*const Guid,
};

pub const REGFILTER2 = extern struct {
    dwVersion: u32,
    dwMerit: u32,
    Anonymous: extern union {
        Anonymous1: extern struct {
            cPins: u32,
            rgPins: ?*const REGFILTERPINS,
        },
        Anonymous2: extern struct {
            cPins2: u32,
            rgPins2: ?*const REGFILTERPINS2,
        },
    },
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterMapper2_Value = Guid.initString("b79bb0b0-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper2 = &IID_IFilterMapper2_Value;
pub const IFilterMapper2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCategory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper2,
                clsidCategory: ?*const Guid,
                dwCategoryMerit: u32,
                Description: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper2,
                clsidCategory: ?*const Guid,
                dwCategoryMerit: u32,
                Description: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper2,
                pclsidCategory: ?*const Guid,
                szInstance: ?[*:0]align(1) const u16,
                Filter: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper2,
                pclsidCategory: ?*const Guid,
                szInstance: ?[*:0]align(1) const u16,
                Filter: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper2,
                clsidFilter: ?*const Guid,
                Name: ?[*:0]align(1) const u16,
                ppMoniker: ?*?*IMoniker,
                pclsidCategory: ?*const Guid,
                szInstance: ?[*:0]align(1) const u16,
                prf2: ?*const REGFILTER2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper2,
                clsidFilter: ?*const Guid,
                Name: ?[*:0]align(1) const u16,
                ppMoniker: ?*?*IMoniker,
                pclsidCategory: ?*const Guid,
                szInstance: ?[*:0]align(1) const u16,
                prf2: ?*const REGFILTER2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMatchingFilters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper2,
                ppEnum: ?*?*IEnumMoniker,
                dwFlags: u32,
                bExactMatch: BOOL,
                dwMerit: u32,
                bInputNeeded: BOOL,
                cInputTypes: u32,
                pInputTypes: ?*const Guid,
                pMedIn: ?*const REGPINMEDIUM,
                pPinCategoryIn: ?*const Guid,
                bRender: BOOL,
                bOutputNeeded: BOOL,
                cOutputTypes: u32,
                pOutputTypes: ?*const Guid,
                pMedOut: ?*const REGPINMEDIUM,
                pPinCategoryOut: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper2,
                ppEnum: ?*?*IEnumMoniker,
                dwFlags: u32,
                bExactMatch: BOOL,
                dwMerit: u32,
                bInputNeeded: BOOL,
                cInputTypes: u32,
                pInputTypes: ?*const Guid,
                pMedIn: ?*const REGPINMEDIUM,
                pPinCategoryIn: ?*const Guid,
                bRender: BOOL,
                bOutputNeeded: BOOL,
                cOutputTypes: u32,
                pOutputTypes: ?*const Guid,
                pMedOut: ?*const REGPINMEDIUM,
                pPinCategoryOut: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_CreateCategory(self: *const T, clsidCategory: ?*const Guid, dwCategoryMerit: u32, Description: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).CreateCategory(@as(*const IFilterMapper2, @ptrCast(self)), clsidCategory, dwCategoryMerit, Description);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_UnregisterFilter(self: *const T, pclsidCategory: ?*const Guid, szInstance: ?[*:0]align(1) const u16, Filter: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).UnregisterFilter(@as(*const IFilterMapper2, @ptrCast(self)), pclsidCategory, szInstance, Filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_RegisterFilter(self: *const T, clsidFilter: ?*const Guid, Name: ?[*:0]align(1) const u16, ppMoniker: ?*?*IMoniker, pclsidCategory: ?*const Guid, szInstance: ?[*:0]align(1) const u16, prf2: ?*const REGFILTER2) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).RegisterFilter(@as(*const IFilterMapper2, @ptrCast(self)), clsidFilter, Name, ppMoniker, pclsidCategory, szInstance, prf2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper2_EnumMatchingFilters(self: *const T, ppEnum: ?*?*IEnumMoniker, dwFlags: u32, bExactMatch: BOOL, dwMerit: u32, bInputNeeded: BOOL, cInputTypes: u32, pInputTypes: ?*const Guid, pMedIn: ?*const REGPINMEDIUM, pPinCategoryIn: ?*const Guid, bRender: BOOL, bOutputNeeded: BOOL, cOutputTypes: u32, pOutputTypes: ?*const Guid, pMedOut: ?*const REGPINMEDIUM, pPinCategoryOut: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper2.VTable, @ptrCast(self.vtable)).EnumMatchingFilters(@as(*const IFilterMapper2, @ptrCast(self)), ppEnum, dwFlags, bExactMatch, dwMerit, bInputNeeded, cInputTypes, pInputTypes, pMedIn, pPinCategoryIn, bRender, bOutputNeeded, cOutputTypes, pOutputTypes, pMedOut, pPinCategoryOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterMapper3_Value = Guid.initString("b79bb0b1-33c1-11d1-abe1-00a0c905f375");
pub const IID_IFilterMapper3 = &IID_IFilterMapper3_Value;
pub const IFilterMapper3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterMapper2.VTable,
        GetICreateDevEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterMapper3,
                ppEnum: ?*?*ICreateDevEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterMapper3,
                ppEnum: ?*?*ICreateDevEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterMapper2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterMapper3_GetICreateDevEnum(self: *const T, ppEnum: ?*?*ICreateDevEnum) callconv(.Inline) HRESULT {
            return @as(*const IFilterMapper3.VTable, @ptrCast(self.vtable)).GetICreateDevEnum(@as(*const IFilterMapper3, @ptrCast(self)), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const QualityMessageType = enum(i32) {
    amine = 0,
    lood = 1,
};
pub const Famine = QualityMessageType.amine;
pub const Flood = QualityMessageType.lood;

pub const Quality = extern struct {
    Type: QualityMessageType,
    Proportion: i32,
    Late: i64,
    TimeStamp: i64,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQualityControl_Value = Guid.initString("56a868a5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQualityControl = &IID_IQualityControl_Value;
pub const IQualityControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IQualityControl,
                pSelf: ?*IBaseFilter,
                q: Quality,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IQualityControl,
                pSelf: ?*IBaseFilter,
                q: Quality,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSink: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IQualityControl,
                piqc: ?*IQualityControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IQualityControl,
                piqc: ?*IQualityControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualityControl_Notify(self: *const T, pSelf: ?*IBaseFilter, q: Quality) callconv(.Inline) HRESULT {
            return @as(*const IQualityControl.VTable, @ptrCast(self.vtable)).Notify(@as(*const IQualityControl, @ptrCast(self)), pSelf, q);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualityControl_SetSink(self: *const T, piqc: ?*IQualityControl) callconv(.Inline) HRESULT {
            return @as(*const IQualityControl.VTable, @ptrCast(self.vtable)).SetSink(@as(*const IQualityControl, @ptrCast(self)), piqc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const COLORKEY_TYPE = enum(i32) {
    NOCOLORKEY = 0,
    INDEX = 1,
    RGB = 2,
};
pub const CK_NOCOLORKEY = COLORKEY_TYPE.NOCOLORKEY;
pub const CK_INDEX = COLORKEY_TYPE.INDEX;
pub const CK_RGB = COLORKEY_TYPE.RGB;

pub const COLORKEY = extern struct {
    KeyType: u32,
    PaletteIndex: u32,
    LowColorValue: COLORREF,
    HighColorValue: COLORREF,
};

pub const ADVISE_TYPE = enum(i32) {
    NONE = 0,
    CLIPPING = 1,
    PALETTE = 2,
    COLORKEY = 4,
    POSITION = 8,
    DISPLAY_CHANGE = 16,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        CLIPPING: u1 = 0,
        PALETTE: u1 = 0,
        COLORKEY: u1 = 0,
        POSITION: u1 = 0,
        DISPLAY_CHANGE: u1 = 0,
    }) ADVISE_TYPE {
        return @as(ADVISE_TYPE, @enumFromInt(
              (if (o.NONE == 1) @intFromEnum(ADVISE_TYPE.NONE) else 0)
            | (if (o.CLIPPING == 1) @intFromEnum(ADVISE_TYPE.CLIPPING) else 0)
            | (if (o.PALETTE == 1) @intFromEnum(ADVISE_TYPE.PALETTE) else 0)
            | (if (o.COLORKEY == 1) @intFromEnum(ADVISE_TYPE.COLORKEY) else 0)
            | (if (o.POSITION == 1) @intFromEnum(ADVISE_TYPE.POSITION) else 0)
            | (if (o.DISPLAY_CHANGE == 1) @intFromEnum(ADVISE_TYPE.DISPLAY_CHANGE) else 0)
        ));
    }
};
pub const ADVISE_NONE = ADVISE_TYPE.NONE;
pub const ADVISE_CLIPPING = ADVISE_TYPE.CLIPPING;
pub const ADVISE_PALETTE = ADVISE_TYPE.PALETTE;
pub const ADVISE_COLORKEY = ADVISE_TYPE.COLORKEY;
pub const ADVISE_POSITION = ADVISE_TYPE.POSITION;
pub const ADVISE_DISPLAY_CHANGE = ADVISE_TYPE.DISPLAY_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify_Value = Guid.initString("56a868a0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlayNotify = &IID_IOverlayNotify_Value;
pub const IOverlayNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaletteChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlayNotify,
                dwColors: u32,
                pPalette: ?*const PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlayNotify,
                dwColors: u32,
                pPalette: ?*const PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnClipChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlayNotify,
                pSourceRect: ?*const RECT,
                pDestinationRect: ?*const RECT,
                pRgnData: ?*const RGNDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlayNotify,
                pSourceRect: ?*const RECT,
                pDestinationRect: ?*const RECT,
                pRgnData: ?*const RGNDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnColorKeyChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlayNotify,
                pColorKey: ?*const COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlayNotify,
                pColorKey: ?*const COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnPositionChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlayNotify,
                pSourceRect: ?*const RECT,
                pDestinationRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlayNotify,
                pSourceRect: ?*const RECT,
                pDestinationRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnPaletteChange(self: *const T, dwColors: u32, pPalette: ?*const PALETTEENTRY) callconv(.Inline) HRESULT {
            return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnPaletteChange(@as(*const IOverlayNotify, @ptrCast(self)), dwColors, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnClipChange(self: *const T, pSourceRect: ?*const RECT, pDestinationRect: ?*const RECT, pRgnData: ?*const RGNDATA) callconv(.Inline) HRESULT {
            return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnClipChange(@as(*const IOverlayNotify, @ptrCast(self)), pSourceRect, pDestinationRect, pRgnData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnColorKeyChange(self: *const T, pColorKey: ?*const COLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnColorKeyChange(@as(*const IOverlayNotify, @ptrCast(self)), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify_OnPositionChange(self: *const T, pSourceRect: ?*const RECT, pDestinationRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IOverlayNotify.VTable, @ptrCast(self.vtable)).OnPositionChange(@as(*const IOverlayNotify, @ptrCast(self)), pSourceRect, pDestinationRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlayNotify2_Value = Guid.initString("680efa10-d535-11d1-87c8-00a0c9223196");
pub const IID_IOverlayNotify2 = &IID_IOverlayNotify2_Value;
pub const IOverlayNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IOverlayNotify.VTable,
        OnDisplayChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlayNotify2,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlayNotify2,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IOverlayNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlayNotify2_OnDisplayChange(self: *const T, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @as(*const IOverlayNotify2.VTable, @ptrCast(self.vtable)).OnDisplayChange(@as(*const IOverlayNotify2, @ptrCast(self)), hMonitor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IOverlay_Value = Guid.initString("56a868a1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IOverlay = &IID_IOverlay_Value;
pub const IOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPalette: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pdwColors: ?*u32,
                ppPalette: ?*?*PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pdwColors: ?*u32,
                ppPalette: ?*?*PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPalette: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                dwColors: u32,
                pPalette: [*]PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                dwColors: u32,
                pPalette: [*]PALETTEENTRY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pHwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pHwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pSourceRect: ?*RECT,
                pDestinationRect: ?*RECT,
                ppRgnData: ?*?*RGNDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pSourceRect: ?*RECT,
                pDestinationRect: ?*RECT,
                ppRgnData: ?*?*RGNDATA,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pSourceRect: ?*RECT,
                pDestinationRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pSourceRect: ?*RECT,
                pDestinationRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
                pOverlayNotify: ?*IOverlayNotify,
                dwInterests: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
                pOverlayNotify: ?*IOverlayNotify,
                dwInterests: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Unadvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IOverlay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IOverlay,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetPalette(self: *const T, pdwColors: ?*u32, ppPalette: ?*?*PALETTEENTRY) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetPalette(@as(*const IOverlay, @ptrCast(self)), pdwColors, ppPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_SetPalette(self: *const T, dwColors: u32, pPalette: [*]PALETTEENTRY) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).SetPalette(@as(*const IOverlay, @ptrCast(self)), dwColors, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetDefaultColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetDefaultColorKey(@as(*const IOverlay, @ptrCast(self)), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IOverlay, @ptrCast(self)), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_SetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IOverlay, @ptrCast(self)), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetWindowHandle(self: *const T, pHwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetWindowHandle(@as(*const IOverlay, @ptrCast(self)), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetClipList(self: *const T, pSourceRect: ?*RECT, pDestinationRect: ?*RECT, ppRgnData: ?*?*RGNDATA) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetClipList(@as(*const IOverlay, @ptrCast(self)), pSourceRect, pDestinationRect, ppRgnData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_GetVideoPosition(self: *const T, pSourceRect: ?*RECT, pDestinationRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IOverlay, @ptrCast(self)), pSourceRect, pDestinationRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_Advise(self: *const T, pOverlayNotify: ?*IOverlayNotify, dwInterests: u32) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).Advise(@as(*const IOverlay, @ptrCast(self)), pOverlayNotify, dwInterests);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOverlay_Unadvise(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IOverlay.VTable, @ptrCast(self.vtable)).Unadvise(@as(*const IOverlay, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventSink_Value = Guid.initString("56a868a2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventSink = &IID_IMediaEventSink_Value;
pub const IMediaEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEventSink,
                EventCode: i32,
                EventParam1: isize,
                EventParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEventSink,
                EventCode: i32,
                EventParam1: isize,
                EventParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventSink_Notify(self: *const T, EventCode: i32, EventParam1: isize, EventParam2: isize) callconv(.Inline) HRESULT {
            return @as(*const IMediaEventSink.VTable, @ptrCast(self.vtable)).Notify(@as(*const IMediaEventSink, @ptrCast(self)), EventCode, EventParam1, EventParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSourceFilter_Value = Guid.initString("56a868a6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFileSourceFilter = &IID_IFileSourceFilter_Value;
pub const IFileSourceFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSourceFilter,
                pszFileName: ?[*:0]align(1) const u16,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSourceFilter,
                pszFileName: ?[*:0]align(1) const u16,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSourceFilter,
                ppszFileName: ?*?PWSTR,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSourceFilter,
                ppszFileName: ?*?PWSTR,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSourceFilter_Load(self: *const T, pszFileName: ?[*:0]align(1) const u16, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFileSourceFilter.VTable, @ptrCast(self.vtable)).Load(@as(*const IFileSourceFilter, @ptrCast(self)), pszFileName, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSourceFilter_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFileSourceFilter.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IFileSourceFilter, @ptrCast(self)), ppszFileName, pmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter_Value = Guid.initString("a2104830-7c70-11cf-8bce-00aa00a3f1a6");
pub const IID_IFileSinkFilter = &IID_IFileSinkFilter_Value;
pub const IFileSinkFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSinkFilter,
                pszFileName: ?[*:0]align(1) const u16,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSinkFilter,
                pszFileName: ?[*:0]align(1) const u16,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSinkFilter,
                ppszFileName: ?*?PWSTR,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSinkFilter,
                ppszFileName: ?*?PWSTR,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter_SetFileName(self: *const T, pszFileName: ?[*:0]align(1) const u16, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFileSinkFilter.VTable, @ptrCast(self.vtable)).SetFileName(@as(*const IFileSinkFilter, @ptrCast(self)), pszFileName, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter_GetCurFile(self: *const T, ppszFileName: ?*?PWSTR, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFileSinkFilter.VTable, @ptrCast(self.vtable)).GetCurFile(@as(*const IFileSinkFilter, @ptrCast(self)), ppszFileName, pmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFileSinkFilter2_Value = Guid.initString("00855b90-ce1b-11d0-bd4f-00a0c911ce86");
pub const IID_IFileSinkFilter2 = &IID_IFileSinkFilter2_Value;
pub const IFileSinkFilter2 = extern struct {
    pub const VTable = extern struct {
        base: IFileSinkFilter.VTable,
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSinkFilter2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSinkFilter2,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFileSinkFilter2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFileSinkFilter2,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFileSinkFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter2_SetMode(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IFileSinkFilter2.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IFileSinkFilter2, @ptrCast(self)), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileSinkFilter2_GetMode(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFileSinkFilter2.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IFileSinkFilter2, @ptrCast(self)), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_FILESINK_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILE_OVERWRITE = AM_FILESINK_FLAGS.E;

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphBuilder_Value = Guid.initString("56a868a9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphBuilder = &IID_IGraphBuilder_Value;
pub const IGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph.VTable,
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
                ppinOut: ?*IPin,
                ppinIn: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
                ppinOut: ?*IPin,
                ppinIn: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
                ppinOut: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
                ppinOut: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
                lpcwstrFile: ?[*:0]align(1) const u16,
                lpcwstrPlayList: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
                lpcwstrFile: ?[*:0]align(1) const u16,
                lpcwstrPlayList: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSourceFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
                lpcwstrFileName: ?[*:0]align(1) const u16,
                lpcwstrFilterName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
                lpcwstrFileName: ?[*:0]align(1) const u16,
                lpcwstrFilterName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLogFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
                hFile: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
                hFile: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShouldOperationContinue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterGraph.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Connect(self: *const T, ppinOut: ?*IPin, ppinIn: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Connect(@as(*const IGraphBuilder, @ptrCast(self)), ppinOut, ppinIn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Render(self: *const T, ppinOut: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Render(@as(*const IGraphBuilder, @ptrCast(self)), ppinOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_RenderFile(self: *const T, lpcwstrFile: ?[*:0]align(1) const u16, lpcwstrPlayList: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).RenderFile(@as(*const IGraphBuilder, @ptrCast(self)), lpcwstrFile, lpcwstrPlayList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_AddSourceFilter(self: *const T, lpcwstrFileName: ?[*:0]align(1) const u16, lpcwstrFilterName: ?[*:0]align(1) const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).AddSourceFilter(@as(*const IGraphBuilder, @ptrCast(self)), lpcwstrFileName, lpcwstrFilterName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_SetLogFile(self: *const T, hFile: usize) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).SetLogFile(@as(*const IGraphBuilder, @ptrCast(self)), hFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).Abort(@as(*const IGraphBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphBuilder_ShouldOperationContinue(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGraphBuilder.VTable, @ptrCast(self.vtable)).ShouldOperationContinue(@as(*const IGraphBuilder, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICaptureGraphBuilder_Value = Guid.initString("bf87b6e0-8c27-11d0-b3f0-00aa003761c5");
pub const IID_ICaptureGraphBuilder = &IID_ICaptureGraphBuilder_Value;
pub const ICaptureGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                pfg: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                pfg: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFiltergraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                ppfg: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                ppfg: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                pType: ?*const Guid,
                lpstrFile: ?[*:0]align(1) const u16,
                ppf: ?*?*IBaseFilter,
                ppSink: ?*?*IFileSinkFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                pType: ?*const Guid,
                lpstrFile: ?[*:0]align(1) const u16,
                ppf: ?*?*IBaseFilter,
                ppSink: ?*?*IFileSinkFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pf: ?*IBaseFilter,
                riid: ?*const Guid,
                ppint: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pf: ?*IBaseFilter,
                riid: ?*const Guid,
                ppint: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pSource: ?*IUnknown,
                pfCompressor: ?*IBaseFilter,
                pfRenderer: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pSource: ?*IUnknown,
                pfCompressor: ?*IBaseFilter,
                pfRenderer: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pFilter: ?*IBaseFilter,
                pstart: ?*i64,
                pstop: ?*i64,
                wStartCookie: u16,
                wStopCookie: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                pCategory: ?*const Guid,
                pFilter: ?*IBaseFilter,
                pstart: ?*i64,
                pstop: ?*i64,
                wStartCookie: u16,
                wStopCookie: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocCapFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                lpstr: ?[*:0]align(1) const u16,
                dwlSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                lpstr: ?[*:0]align(1) const u16,
                dwlSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyCaptureFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder,
                lpwstrOld: ?PWSTR,
                lpwstrNew: ?PWSTR,
                fAllowEscAbort: i32,
                pCallback: ?*IAMCopyCaptureFileProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder,
                lpwstrOld: ?PWSTR,
                lpwstrNew: ?PWSTR,
                fAllowEscAbort: i32,
                pCallback: ?*IAMCopyCaptureFileProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_SetFiltergraph(self: *const T, pfg: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).SetFiltergraph(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_GetFiltergraph(self: *const T, ppfg: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const ICaptureGraphBuilder, @ptrCast(self)), ppfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_SetOutputFileName(self: *const T, pType: ?*const Guid, lpstrFile: ?[*:0]align(1) const u16, ppf: ?*?*IBaseFilter, ppSink: ?*?*IFileSinkFilter) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pType, lpstrFile, ppf, ppSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_FindInterface(self: *const T, pCategory: ?*const Guid, pf: ?*IBaseFilter, riid: ?*const Guid, ppint: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).FindInterface(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pCategory, pf, riid, ppint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_RenderStream(self: *const T, pCategory: ?*const Guid, pSource: ?*IUnknown, pfCompressor: ?*IBaseFilter, pfRenderer: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).RenderStream(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pCategory, pSource, pfCompressor, pfRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_ControlStream(self: *const T, pCategory: ?*const Guid, pFilter: ?*IBaseFilter, pstart: ?*i64, pstop: ?*i64, wStartCookie: u16, wStopCookie: u16) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).ControlStream(@as(*const ICaptureGraphBuilder, @ptrCast(self)), pCategory, pFilter, pstart, pstop, wStartCookie, wStopCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_AllocCapFile(self: *const T, lpstr: ?[*:0]align(1) const u16, dwlSize: u64) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).AllocCapFile(@as(*const ICaptureGraphBuilder, @ptrCast(self)), lpstr, dwlSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder_CopyCaptureFile(self: *const T, lpwstrOld: ?PWSTR, lpwstrNew: ?PWSTR, fAllowEscAbort: i32, pCallback: ?*IAMCopyCaptureFileProgress) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder.VTable, @ptrCast(self.vtable)).CopyCaptureFile(@as(*const ICaptureGraphBuilder, @ptrCast(self)), lpwstrOld, lpwstrNew, fAllowEscAbort, pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCopyCaptureFileProgress_Value = Guid.initString("670d1d20-a068-11d0-b3f0-00aa003761c5");
pub const IID_IAMCopyCaptureFileProgress = &IID_IAMCopyCaptureFileProgress_Value;
pub const IAMCopyCaptureFileProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Progress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCopyCaptureFileProgress,
                iProgress: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCopyCaptureFileProgress,
                iProgress: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCopyCaptureFileProgress_Progress(self: *const T, iProgress: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCopyCaptureFileProgress.VTable, @ptrCast(self.vtable)).Progress(@as(*const IAMCopyCaptureFileProgress, @ptrCast(self)), iProgress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ICaptureGraphBuilder2_Value = Guid.initString("93e5a4e0-2d50-11d2-abfa-00a0c9c6e38d");
pub const IID_ICaptureGraphBuilder2 = &IID_ICaptureGraphBuilder2_Value;
pub const ICaptureGraphBuilder2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFiltergraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pfg: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pfg: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFiltergraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                ppfg: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                ppfg: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFileName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pType: ?*const Guid,
                lpstrFile: ?[*:0]align(1) const u16,
                ppf: ?*?*IBaseFilter,
                ppSink: ?*?*IFileSinkFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pType: ?*const Guid,
                lpstrFile: ?[*:0]align(1) const u16,
                ppf: ?*?*IBaseFilter,
                ppSink: ?*?*IFileSinkFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pf: ?*IBaseFilter,
                riid: ?*const Guid,
                ppint: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pf: ?*IBaseFilter,
                riid: ?*const Guid,
                ppint: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pSource: ?*IUnknown,
                pfCompressor: ?*IBaseFilter,
                pfRenderer: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pSource: ?*IUnknown,
                pfCompressor: ?*IBaseFilter,
                pfRenderer: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ControlStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pFilter: ?*IBaseFilter,
                pstart: ?*i64,
                pstop: ?*i64,
                wStartCookie: u16,
                wStopCookie: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                pFilter: ?*IBaseFilter,
                pstart: ?*i64,
                pstop: ?*i64,
                wStartCookie: u16,
                wStopCookie: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocCapFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                lpstr: ?[*:0]align(1) const u16,
                dwlSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                lpstr: ?[*:0]align(1) const u16,
                dwlSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CopyCaptureFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                lpwstrOld: ?PWSTR,
                lpwstrNew: ?PWSTR,
                fAllowEscAbort: i32,
                pCallback: ?*IAMCopyCaptureFileProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                lpwstrOld: ?PWSTR,
                lpwstrNew: ?PWSTR,
                fAllowEscAbort: i32,
                pCallback: ?*IAMCopyCaptureFileProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FindPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICaptureGraphBuilder2,
                pSource: ?*IUnknown,
                pindir: PIN_DIRECTION,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                fUnconnected: BOOL,
                num: i32,
                ppPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICaptureGraphBuilder2,
                pSource: ?*IUnknown,
                pindir: PIN_DIRECTION,
                pCategory: ?*const Guid,
                pType: ?*const Guid,
                fUnconnected: BOOL,
                num: i32,
                ppPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_SetFiltergraph(self: *const T, pfg: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).SetFiltergraph(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_GetFiltergraph(self: *const T, ppfg: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), ppfg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_SetOutputFileName(self: *const T, pType: ?*const Guid, lpstrFile: ?[*:0]align(1) const u16, ppf: ?*?*IBaseFilter, ppSink: ?*?*IFileSinkFilter) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).SetOutputFileName(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pType, lpstrFile, ppf, ppSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_FindInterface(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pf: ?*IBaseFilter, riid: ?*const Guid, ppint: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).FindInterface(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pCategory, pType, pf, riid, ppint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_RenderStream(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pSource: ?*IUnknown, pfCompressor: ?*IBaseFilter, pfRenderer: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).RenderStream(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pCategory, pType, pSource, pfCompressor, pfRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_ControlStream(self: *const T, pCategory: ?*const Guid, pType: ?*const Guid, pFilter: ?*IBaseFilter, pstart: ?*i64, pstop: ?*i64, wStartCookie: u16, wStopCookie: u16) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).ControlStream(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pCategory, pType, pFilter, pstart, pstop, wStartCookie, wStopCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_AllocCapFile(self: *const T, lpstr: ?[*:0]align(1) const u16, dwlSize: u64) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).AllocCapFile(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), lpstr, dwlSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_CopyCaptureFile(self: *const T, lpwstrOld: ?PWSTR, lpwstrNew: ?PWSTR, fAllowEscAbort: i32, pCallback: ?*IAMCopyCaptureFileProgress) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).CopyCaptureFile(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), lpwstrOld, lpwstrNew, fAllowEscAbort, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICaptureGraphBuilder2_FindPin(self: *const T, pSource: ?*IUnknown, pindir: PIN_DIRECTION, pCategory: ?*const Guid, pType: ?*const Guid, fUnconnected: BOOL, num: i32, ppPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @as(*const ICaptureGraphBuilder2.VTable, @ptrCast(self.vtable)).FindPin(@as(*const ICaptureGraphBuilder2, @ptrCast(self)), pSource, pindir, pCategory, pType, fUnconnected, num, ppPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_RENSDEREXFLAGS = enum(i32) {
    S = 1,
};
pub const AM_RENDEREX_RENDERTOEXISTINGRENDERERS = _AM_RENSDEREXFLAGS.S;

// TODO: this type is limited to platform 'windows5.0'
const IID_IFilterGraph2_Value = Guid.initString("36b73882-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IFilterGraph2 = &IID_IFilterGraph2_Value;
pub const IFilterGraph2 = extern struct {
    pub const VTable = extern struct {
        base: IGraphBuilder.VTable,
        AddSourceFilterForMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph2,
                pMoniker: ?*IMoniker,
                pCtx: ?*IBindCtx,
                lpcwstrFilterName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph2,
                pMoniker: ?*IMoniker,
                pCtx: ?*IBindCtx,
                lpcwstrFilterName: ?[*:0]align(1) const u16,
                ppFilter: ?*?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReconnectEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph2,
                ppin: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph2,
                ppin: ?*IPin,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph2,
                pPinOut: ?*IPin,
                dwFlags: u32,
                pvContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph2,
                pPinOut: ?*IPin,
                dwFlags: u32,
                pvContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IGraphBuilder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_AddSourceFilterForMoniker(self: *const T, pMoniker: ?*IMoniker, pCtx: ?*IBindCtx, lpcwstrFilterName: ?[*:0]align(1) const u16, ppFilter: ?*?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).AddSourceFilterForMoniker(@as(*const IFilterGraph2, @ptrCast(self)), pMoniker, pCtx, lpcwstrFilterName, ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_ReconnectEx(self: *const T, ppin: ?*IPin, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).ReconnectEx(@as(*const IFilterGraph2, @ptrCast(self)), ppin, pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph2_RenderEx(self: *const T, pPinOut: ?*IPin, dwFlags: u32, pvContext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph2.VTable, @ptrCast(self.vtable)).RenderEx(@as(*const IFilterGraph2, @ptrCast(self)), pPinOut, dwFlags, pvContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IFilterGraph3_Value = Guid.initString("aaf38154-b80b-422f-91e6-b66467509a07");
pub const IID_IFilterGraph3 = &IID_IFilterGraph3_Value;
pub const IFilterGraph3 = extern struct {
    pub const VTable = extern struct {
        base: IFilterGraph2.VTable,
        SetSyncSourceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterGraph3,
                pClockForMostOfFilterGraph: ?*IReferenceClock,
                pClockForFilter: ?*IReferenceClock,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterGraph3,
                pClockForMostOfFilterGraph: ?*IReferenceClock,
                pClockForFilter: ?*IReferenceClock,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFilterGraph2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterGraph3_SetSyncSourceEx(self: *const T, pClockForMostOfFilterGraph: ?*IReferenceClock, pClockForFilter: ?*IReferenceClock, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterGraph3.VTable, @ptrCast(self.vtable)).SetSyncSourceEx(@as(*const IFilterGraph3, @ptrCast(self)), pClockForMostOfFilterGraph, pClockForFilter, pFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IStreamBuilder_Value = Guid.initString("56a868bf-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IStreamBuilder = &IID_IStreamBuilder_Value;
pub const IStreamBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBuilder,
                ppinOut: ?*IPin,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBuilder,
                ppinOut: ?*IPin,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Backout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamBuilder,
                ppinOut: ?*IPin,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamBuilder,
                ppinOut: ?*IPin,
                pGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBuilder_Render(self: *const T, ppinOut: ?*IPin, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IStreamBuilder.VTable, @ptrCast(self.vtable)).Render(@as(*const IStreamBuilder, @ptrCast(self)), ppinOut, pGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamBuilder_Backout(self: *const T, ppinOut: ?*IPin, pGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IStreamBuilder.VTable, @ptrCast(self.vtable)).Backout(@as(*const IStreamBuilder, @ptrCast(self)), ppinOut, pGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAsyncReader_Value = Guid.initString("56a868aa-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAsyncReader = &IID_IAsyncReader_Value;
pub const IAsyncReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                pPreferred: ?*IMemAllocator,
                pProps: ?*ALLOCATOR_PROPERTIES,
                ppActual: ?*?*IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                pPreferred: ?*IMemAllocator,
                pProps: ?*ALLOCATOR_PROPERTIES,
                ppActual: ?*?*IMemAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Request: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                pSample: ?*IMediaSample,
                dwUser: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                pSample: ?*IMediaSample,
                dwUser: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                dwTimeout: u32,
                ppSample: ?*?*IMediaSample,
                pdwUser: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                dwTimeout: u32,
                ppSample: ?*?*IMediaSample,
                pdwUser: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncReadAligned: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                pSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                pSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncRead: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                llPosition: i64,
                lLength: i32,
                // TODO: what to do with BytesParamIndex 1?
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                llPosition: i64,
                lLength: i32,
                // TODO: what to do with BytesParamIndex 1?
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Length: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
                pTotal: ?*i64,
                pAvailable: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
                pTotal: ?*i64,
                pAvailable: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginFlush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFlush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAsyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAsyncReader,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_RequestAllocator(self: *const T, pPreferred: ?*IMemAllocator, pProps: ?*ALLOCATOR_PROPERTIES, ppActual: ?*?*IMemAllocator) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).RequestAllocator(@as(*const IAsyncReader, @ptrCast(self)), pPreferred, pProps, ppActual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_Request(self: *const T, pSample: ?*IMediaSample, dwUser: usize) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).Request(@as(*const IAsyncReader, @ptrCast(self)), pSample, dwUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_WaitForNext(self: *const T, dwTimeout: u32, ppSample: ?*?*IMediaSample, pdwUser: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).WaitForNext(@as(*const IAsyncReader, @ptrCast(self)), dwTimeout, ppSample, pdwUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_SyncReadAligned(self: *const T, pSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).SyncReadAligned(@as(*const IAsyncReader, @ptrCast(self)), pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_SyncRead(self: *const T, llPosition: i64, lLength: i32, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).SyncRead(@as(*const IAsyncReader, @ptrCast(self)), llPosition, lLength, pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_Length(self: *const T, pTotal: ?*i64, pAvailable: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).Length(@as(*const IAsyncReader, @ptrCast(self)), pTotal, pAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_BeginFlush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).BeginFlush(@as(*const IAsyncReader, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAsyncReader_EndFlush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAsyncReader.VTable, @ptrCast(self.vtable)).EndFlush(@as(*const IAsyncReader, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IGraphVersion_Value = Guid.initString("56a868ab-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IGraphVersion = &IID_IGraphVersion_Value;
pub const IGraphVersion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryVersion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphVersion,
                pVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphVersion,
                pVersion: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphVersion_QueryVersion(self: *const T, pVersion: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IGraphVersion.VTable, @ptrCast(self.vtable)).QueryVersion(@as(*const IGraphVersion, @ptrCast(self)), pVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceConsumer_Value = Guid.initString("56a868ad-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceConsumer = &IID_IResourceConsumer_Value;
pub const IResourceConsumer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceConsumer,
                idResource: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceConsumer,
                idResource: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceConsumer,
                idResource: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceConsumer,
                idResource: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceConsumer_AcquireResource(self: *const T, idResource: i32) callconv(.Inline) HRESULT {
            return @as(*const IResourceConsumer.VTable, @ptrCast(self.vtable)).AcquireResource(@as(*const IResourceConsumer, @ptrCast(self)), idResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceConsumer_ReleaseResource(self: *const T, idResource: i32) callconv(.Inline) HRESULT {
            return @as(*const IResourceConsumer.VTable, @ptrCast(self.vtable)).ReleaseResource(@as(*const IResourceConsumer, @ptrCast(self)), idResource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IResourceManager_Value = Guid.initString("56a868ac-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IResourceManager = &IID_IResourceManager_Value;
pub const IResourceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                pName: ?[*:0]align(1) const u16,
                cResource: i32,
                plToken: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                pName: ?[*:0]align(1) const u16,
                cResource: i32,
                plToken: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterGroup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                pName: ?[*:0]align(1) const u16,
                cResource: i32,
                palTokens: [*]i32,
                plToken: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                pName: ?[*:0]align(1) const u16,
                cResource: i32,
                palTokens: [*]i32,
                plToken: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestResource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                idResource: i32,
                pFocusObject: ?*IUnknown,
                pConsumer: ?*IResourceConsumer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                idResource: i32,
                pFocusObject: ?*IUnknown,
                pConsumer: ?*IResourceConsumer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyAcquire: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
                hr: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyRelease: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
                bStillWant: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
                bStillWant: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                idResource: i32,
                pConsumer: ?*IResourceConsumer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                pFocusObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                pFocusObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseFocus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IResourceManager,
                pFocusObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IResourceManager,
                pFocusObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_Register(self: *const T, pName: ?[*:0]align(1) const u16, cResource: i32, plToken: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).Register(@as(*const IResourceManager, @ptrCast(self)), pName, cResource, plToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_RegisterGroup(self: *const T, pName: ?[*:0]align(1) const u16, cResource: i32, palTokens: [*]i32, plToken: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).RegisterGroup(@as(*const IResourceManager, @ptrCast(self)), pName, cResource, palTokens, plToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_RequestResource(self: *const T, idResource: i32, pFocusObject: ?*IUnknown, pConsumer: ?*IResourceConsumer) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).RequestResource(@as(*const IResourceManager, @ptrCast(self)), idResource, pFocusObject, pConsumer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_NotifyAcquire(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer, hr: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).NotifyAcquire(@as(*const IResourceManager, @ptrCast(self)), idResource, pConsumer, hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_NotifyRelease(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer, bStillWant: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).NotifyRelease(@as(*const IResourceManager, @ptrCast(self)), idResource, pConsumer, bStillWant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_CancelRequest(self: *const T, idResource: i32, pConsumer: ?*IResourceConsumer) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).CancelRequest(@as(*const IResourceManager, @ptrCast(self)), idResource, pConsumer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_SetFocus(self: *const T, pFocusObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).SetFocus(@as(*const IResourceManager, @ptrCast(self)), pFocusObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IResourceManager_ReleaseFocus(self: *const T, pFocusObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IResourceManager.VTable, @ptrCast(self.vtable)).ReleaseFocus(@as(*const IResourceManager, @ptrCast(self)), pFocusObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDistributorNotify_Value = Guid.initString("56a868af-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDistributorNotify = &IID_IDistributorNotify_Value;
pub const IDistributorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDistributorNotify,
                tStart: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDistributorNotify,
                tStart: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDistributorNotify,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDistributorNotify,
                pClock: ?*IReferenceClock,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyGraphChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDistributorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Stop(@as(*const IDistributorNotify, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Pause(@as(*const IDistributorNotify, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_Run(self: *const T, tStart: i64) callconv(.Inline) HRESULT {
            return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).Run(@as(*const IDistributorNotify, @ptrCast(self)), tStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_SetSyncSource(self: *const T, pClock: ?*IReferenceClock) callconv(.Inline) HRESULT {
            return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).SetSyncSource(@as(*const IDistributorNotify, @ptrCast(self)), pClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDistributorNotify_NotifyGraphChange(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDistributorNotify.VTable, @ptrCast(self.vtable)).NotifyGraphChange(@as(*const IDistributorNotify, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_STREAM_INFO_FLAGS = enum(i32) {
    START_DEFINED = 1,
    STOP_DEFINED = 2,
    DISCARDING = 4,
    STOP_SEND_EXTRA = 16,
};
pub const AM_STREAM_INFO_START_DEFINED = AM_STREAM_INFO_FLAGS.START_DEFINED;
pub const AM_STREAM_INFO_STOP_DEFINED = AM_STREAM_INFO_FLAGS.STOP_DEFINED;
pub const AM_STREAM_INFO_DISCARDING = AM_STREAM_INFO_FLAGS.DISCARDING;
pub const AM_STREAM_INFO_STOP_SEND_EXTRA = AM_STREAM_INFO_FLAGS.STOP_SEND_EXTRA;

pub const AM_STREAM_INFO = extern struct {
    tStart: i64,
    tStop: i64,
    dwStartCookie: u32,
    dwStopCookie: u32,
    dwFlags: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamControl_Value = Guid.initString("36b73881-c2c8-11cf-8b46-00805f6cef60");
pub const IID_IAMStreamControl = &IID_IAMStreamControl_Value;
pub const IAMStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamControl,
                ptStart: ?*const i64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamControl,
                ptStart: ?*const i64,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopAt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamControl,
                ptStop: ?*const i64,
                bSendExtra: BOOL,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamControl,
                ptStop: ?*const i64,
                bSendExtra: BOOL,
                dwCookie: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamControl,
                pInfo: ?*AM_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamControl,
                pInfo: ?*AM_STREAM_INFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_StartAt(self: *const T, ptStart: ?*const i64, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).StartAt(@as(*const IAMStreamControl, @ptrCast(self)), ptStart, dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_StopAt(self: *const T, ptStop: ?*const i64, bSendExtra: BOOL, dwCookie: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).StopAt(@as(*const IAMStreamControl, @ptrCast(self)), ptStop, bSendExtra, dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamControl_GetInfo(self: *const T, pInfo: ?*AM_STREAM_INFO) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamControl.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMStreamControl, @ptrCast(self)), pInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_ISeekingPassThru_Value = Guid.initString("36b73883-c2c8-11cf-8b46-00805f6cef60");
pub const IID_ISeekingPassThru = &IID_ISeekingPassThru_Value;
pub const ISeekingPassThru = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISeekingPassThru,
                bSupportRendering: BOOL,
                pPin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISeekingPassThru,
                bSupportRendering: BOOL,
                pPin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISeekingPassThru_Init(self: *const T, bSupportRendering: BOOL, pPin: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const ISeekingPassThru.VTable, @ptrCast(self.vtable)).Init(@as(*const ISeekingPassThru, @ptrCast(self)), bSupportRendering, pPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VIDEO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    VideoStandard: u32,
    InputSize: SIZE,
    MinCroppingSize: SIZE,
    MaxCroppingSize: SIZE,
    CropGranularityX: i32,
    CropGranularityY: i32,
    CropAlignX: i32,
    CropAlignY: i32,
    MinOutputSize: SIZE,
    MaxOutputSize: SIZE,
    OutputGranularityX: i32,
    OutputGranularityY: i32,
    StretchTapsX: i32,
    StretchTapsY: i32,
    ShrinkTapsX: i32,
    ShrinkTapsY: i32,
    MinFrameInterval: i64,
    MaxFrameInterval: i64,
    MinBitsPerSecond: i32,
    MaxBitsPerSecond: i32,
};

pub const AUDIO_STREAM_CONFIG_CAPS = extern struct {
    guid: Guid,
    MinimumChannels: u32,
    MaximumChannels: u32,
    ChannelsGranularity: u32,
    MinimumBitsPerSample: u32,
    MaximumBitsPerSample: u32,
    BitsPerSampleGranularity: u32,
    MinimumSampleFrequency: u32,
    MaximumSampleFrequency: u32,
    SampleFrequencyGranularity: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamConfig_Value = Guid.initString("c6e13340-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMStreamConfig = &IID_IAMStreamConfig_Value;
pub const IAMStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamConfig,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamConfig,
                pmt: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamConfig,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamConfig,
                ppmt: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamConfig,
                piCount: ?*i32,
                piSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamConfig,
                piCount: ?*i32,
                piSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamConfig,
                iIndex: i32,
                ppmt: ?*?*AM_MEDIA_TYPE,
                pSCC: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamConfig,
                iIndex: i32,
                ppmt: ?*?*AM_MEDIA_TYPE,
                pSCC: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_SetFormat(self: *const T, pmt: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAMStreamConfig, @ptrCast(self)), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetFormat(self: *const T, ppmt: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAMStreamConfig, @ptrCast(self)), ppmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetNumberOfCapabilities(self: *const T, piCount: ?*i32, piSize: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetNumberOfCapabilities(@as(*const IAMStreamConfig, @ptrCast(self)), piCount, piSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamConfig_GetStreamCaps(self: *const T, iIndex: i32, ppmt: ?*?*AM_MEDIA_TYPE, pSCC: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamConfig.VTable, @ptrCast(self.vtable)).GetStreamCaps(@as(*const IAMStreamConfig, @ptrCast(self)), iIndex, ppmt, pSCC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const InterleavingMode = enum(i32) {
    NONE = 0,
    CAPTURE = 1,
    FULL = 2,
    NONE_BUFFERED = 3,
};
pub const INTERLEAVE_NONE = InterleavingMode.NONE;
pub const INTERLEAVE_CAPTURE = InterleavingMode.CAPTURE;
pub const INTERLEAVE_FULL = InterleavingMode.FULL;
pub const INTERLEAVE_NONE_BUFFERED = InterleavingMode.NONE_BUFFERED;

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigInterleaving_Value = Guid.initString("bee3d220-157b-11d0-bd23-00a0c911ce86");
pub const IID_IConfigInterleaving = &IID_IConfigInterleaving_Value;
pub const IConfigInterleaving = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IConfigInterleaving,
                mode: InterleavingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IConfigInterleaving,
                mode: InterleavingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IConfigInterleaving,
                pMode: ?*InterleavingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IConfigInterleaving,
                pMode: ?*InterleavingMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Interleaving: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigInterleaving,
                prtInterleave: ?*const i64,
                prtPreroll: ?*const i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigInterleaving,
                prtInterleave: ?*const i64,
                prtPreroll: ?*const i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Interleaving: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigInterleaving,
                prtInterleave: ?*i64,
                prtPreroll: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigInterleaving,
                prtInterleave: ?*i64,
                prtPreroll: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_put_Mode(self: *const T, mode: InterleavingMode) callconv(.Inline) HRESULT {
            return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IConfigInterleaving, @ptrCast(self)), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_get_Mode(self: *const T, pMode: ?*InterleavingMode) callconv(.Inline) HRESULT {
            return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IConfigInterleaving, @ptrCast(self)), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_put_Interleaving(self: *const T, prtInterleave: ?*const i64, prtPreroll: ?*const i64) callconv(.Inline) HRESULT {
            return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).put_Interleaving(@as(*const IConfigInterleaving, @ptrCast(self)), prtInterleave, prtPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigInterleaving_get_Interleaving(self: *const T, prtInterleave: ?*i64, prtPreroll: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IConfigInterleaving.VTable, @ptrCast(self.vtable)).get_Interleaving(@as(*const IConfigInterleaving, @ptrCast(self)), prtInterleave, prtPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IConfigAviMux_Value = Guid.initString("5acd6aa0-f482-11ce-8b67-00aa00a3f1a6");
pub const IID_IConfigAviMux = &IID_IConfigAviMux_Value;
pub const IConfigAviMux = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAviMux,
                iStream: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAviMux,
                iStream: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMasterStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAviMux,
                pStream: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAviMux,
                pStream: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputCompatibilityIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAviMux,
                fOldIndex: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAviMux,
                fOldIndex: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputCompatibilityIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAviMux,
                pfOldIndex: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAviMux,
                pfOldIndex: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_SetMasterStream(self: *const T, iStream: i32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).SetMasterStream(@as(*const IConfigAviMux, @ptrCast(self)), iStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_GetMasterStream(self: *const T, pStream: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).GetMasterStream(@as(*const IConfigAviMux, @ptrCast(self)), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_SetOutputCompatibilityIndex(self: *const T, fOldIndex: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).SetOutputCompatibilityIndex(@as(*const IConfigAviMux, @ptrCast(self)), fOldIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAviMux_GetOutputCompatibilityIndex(self: *const T, pfOldIndex: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IConfigAviMux.VTable, @ptrCast(self.vtable)).GetOutputCompatibilityIndex(@as(*const IConfigAviMux, @ptrCast(self)), pfOldIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CompressionCaps = enum(i32) {
    Quality = 1,
    Crunch = 2,
    KeyFrame = 4,
    BFrame = 8,
    Window = 16,
};
pub const CompressionCaps_CanQuality = CompressionCaps.Quality;
pub const CompressionCaps_CanCrunch = CompressionCaps.Crunch;
pub const CompressionCaps_CanKeyFrame = CompressionCaps.KeyFrame;
pub const CompressionCaps_CanBFrame = CompressionCaps.BFrame;
pub const CompressionCaps_CanWindow = CompressionCaps.Window;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoCompression_Value = Guid.initString("c6e13343-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoCompression = &IID_IAMVideoCompression_Value;
pub const IAMVideoCompression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_KeyFrameRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                KeyFrameRate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                KeyFrameRate: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_KeyFrameRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                pKeyFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                pKeyFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PFramesPerKeyFrame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                PFramesPerKeyFrame: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                PFramesPerKeyFrame: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PFramesPerKeyFrame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                pPFramesPerKeyFrame: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                pPFramesPerKeyFrame: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Quality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                Quality: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                Quality: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Quality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                pQuality: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                pQuality: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                WindowSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                WindowSize: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMVideoCompression,
                pWindowSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMVideoCompression,
                pWindowSize: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoCompression,
                // TODO: what to do with BytesParamIndex 1?
                pszVersion: ?PWSTR,
                pcbVersion: ?*i32,
                // TODO: what to do with BytesParamIndex 3?
                pszDescription: ?PWSTR,
                pcbDescription: ?*i32,
                pDefaultKeyFrameRate: ?*i32,
                pDefaultPFramesPerKey: ?*i32,
                pDefaultQuality: ?*f64,
                pCapabilities: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoCompression,
                // TODO: what to do with BytesParamIndex 1?
                pszVersion: ?PWSTR,
                pcbVersion: ?*i32,
                // TODO: what to do with BytesParamIndex 3?
                pszDescription: ?PWSTR,
                pcbDescription: ?*i32,
                pDefaultKeyFrameRate: ?*i32,
                pDefaultPFramesPerKey: ?*i32,
                pDefaultQuality: ?*f64,
                pCapabilities: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OverrideKeyFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoCompression,
                FrameNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoCompression,
                FrameNumber: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OverrideFrameSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoCompression,
                FrameNumber: i32,
                Size: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoCompression,
                FrameNumber: i32,
                Size: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_KeyFrameRate(self: *const T, KeyFrameRate: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_KeyFrameRate(@as(*const IAMVideoCompression, @ptrCast(self)), KeyFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_KeyFrameRate(self: *const T, pKeyFrameRate: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_KeyFrameRate(@as(*const IAMVideoCompression, @ptrCast(self)), pKeyFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_PFramesPerKeyFrame(self: *const T, PFramesPerKeyFrame: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_PFramesPerKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), PFramesPerKeyFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_PFramesPerKeyFrame(self: *const T, pPFramesPerKeyFrame: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_PFramesPerKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), pPFramesPerKeyFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_Quality(self: *const T, _param_Quality: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_Quality(@as(*const IAMVideoCompression, @ptrCast(self)), _param_Quality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_Quality(self: *const T, pQuality: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_Quality(@as(*const IAMVideoCompression, @ptrCast(self)), pQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_put_WindowSize(self: *const T, WindowSize: u64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).put_WindowSize(@as(*const IAMVideoCompression, @ptrCast(self)), WindowSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_get_WindowSize(self: *const T, pWindowSize: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).get_WindowSize(@as(*const IAMVideoCompression, @ptrCast(self)), pWindowSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_GetInfo(self: *const T, pszVersion: ?PWSTR, pcbVersion: ?*i32, pszDescription: ?PWSTR, pcbDescription: ?*i32, pDefaultKeyFrameRate: ?*i32, pDefaultPFramesPerKey: ?*i32, pDefaultQuality: ?*f64, pCapabilities: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMVideoCompression, @ptrCast(self)), pszVersion, pcbVersion, pszDescription, pcbDescription, pDefaultKeyFrameRate, pDefaultPFramesPerKey, pDefaultQuality, pCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_OverrideKeyFrame(self: *const T, FrameNumber: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).OverrideKeyFrame(@as(*const IAMVideoCompression, @ptrCast(self)), FrameNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoCompression_OverrideFrameSize(self: *const T, FrameNumber: i32, Size: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoCompression.VTable, @ptrCast(self.vtable)).OverrideFrameSize(@as(*const IAMVideoCompression, @ptrCast(self)), FrameNumber, Size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VfwCaptureDialogs = enum(i32) {
    Source = 1,
    Format = 2,
    Display = 4,
};
pub const VfwCaptureDialog_Source = VfwCaptureDialogs.Source;
pub const VfwCaptureDialog_Format = VfwCaptureDialogs.Format;
pub const VfwCaptureDialog_Display = VfwCaptureDialogs.Display;

pub const VfwCompressDialogs = enum(i32) {
    Config = 1,
    About = 2,
    QueryConfig = 4,
    QueryAbout = 8,
};
pub const VfwCompressDialog_Config = VfwCompressDialogs.Config;
pub const VfwCompressDialog_About = VfwCompressDialogs.About;
pub const VfwCompressDialog_QueryConfig = VfwCompressDialogs.QueryConfig;
pub const VfwCompressDialog_QueryAbout = VfwCompressDialogs.QueryAbout;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCaptureDialogs_Value = Guid.initString("d8d715a0-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCaptureDialogs = &IID_IAMVfwCaptureDialogs_Value;
pub const IAMVfwCaptureDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HasDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendDriverMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
                uMsg: i32,
                dw1: i32,
                dw2: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCaptureDialogs,
                iDialog: i32,
                uMsg: i32,
                dw1: i32,
                dw2: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_HasDialog(self: *const T, iDialog: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).HasDialog(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), iDialog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_ShowDialog(self: *const T, iDialog: i32, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).ShowDialog(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), iDialog, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCaptureDialogs_SendDriverMessage(self: *const T, iDialog: i32, uMsg: i32, dw1: i32, dw2: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCaptureDialogs.VTable, @ptrCast(self.vtable)).SendDriverMessage(@as(*const IAMVfwCaptureDialogs, @ptrCast(self)), iDialog, uMsg, dw1, dw2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVfwCompressDialogs_Value = Guid.initString("d8d715a3-6e5e-11d0-b3f0-00aa003761c5");
pub const IID_IAMVfwCompressDialogs = &IID_IAMVfwCompressDialogs_Value;
pub const IAMVfwCompressDialogs = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCompressDialogs,
                iDialog: i32,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCompressDialogs,
                iDialog: i32,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCompressDialogs,
                // TODO: what to do with BytesParamIndex 1?
                pState: ?*anyopaque,
                pcbState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCompressDialogs,
                // TODO: what to do with BytesParamIndex 1?
                pState: ?*anyopaque,
                pcbState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCompressDialogs,
                // TODO: what to do with BytesParamIndex 1?
                pState: ?*anyopaque,
                cbState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCompressDialogs,
                // TODO: what to do with BytesParamIndex 1?
                pState: ?*anyopaque,
                cbState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendDriverMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVfwCompressDialogs,
                uMsg: i32,
                dw1: i32,
                dw2: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVfwCompressDialogs,
                uMsg: i32,
                dw1: i32,
                dw2: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_ShowDialog(self: *const T, iDialog: i32, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).ShowDialog(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), iDialog, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_GetState(self: *const T, pState: ?*anyopaque, pcbState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).GetState(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), pState, pcbState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_SetState(self: *const T, pState: ?*anyopaque, cbState: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).SetState(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), pState, cbState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVfwCompressDialogs_SendDriverMessage(self: *const T, uMsg: i32, dw1: i32, dw2: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVfwCompressDialogs.VTable, @ptrCast(self.vtable)).SendDriverMessage(@as(*const IAMVfwCompressDialogs, @ptrCast(self)), uMsg, dw1, dw2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDroppedFrames_Value = Guid.initString("c6e13344-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMDroppedFrames = &IID_IAMDroppedFrames_Value;
pub const IAMDroppedFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumDropped: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDroppedFrames,
                plDropped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDroppedFrames,
                plDropped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumNotDropped: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDroppedFrames,
                plNotDropped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDroppedFrames,
                plNotDropped: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDroppedInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDroppedFrames,
                lSize: i32,
                plArray: ?*i32,
                plNumCopied: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDroppedFrames,
                lSize: i32,
                plArray: ?*i32,
                plNumCopied: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAverageFrameSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDroppedFrames,
                plAverageSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDroppedFrames,
                plAverageSize: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetNumDropped(self: *const T, plDropped: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetNumDropped(@as(*const IAMDroppedFrames, @ptrCast(self)), plDropped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetNumNotDropped(self: *const T, plNotDropped: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetNumNotDropped(@as(*const IAMDroppedFrames, @ptrCast(self)), plNotDropped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetDroppedInfo(self: *const T, lSize: i32, plArray: ?*i32, plNumCopied: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetDroppedInfo(@as(*const IAMDroppedFrames, @ptrCast(self)), lSize, plArray, plNumCopied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDroppedFrames_GetAverageFrameSize(self: *const T, plAverageSize: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMDroppedFrames.VTable, @ptrCast(self.vtable)).GetAverageFrameSize(@as(*const IAMDroppedFrames, @ptrCast(self)), plAverageSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAudioInputMixer_Value = Guid.initString("54c39221-8380-11d0-b3f0-00aa003761c5");
pub const IID_IAMAudioInputMixer = &IID_IAMAudioInputMixer_Value;
pub const IAMAudioInputMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Enable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                fEnable: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Enable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pfEnable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mono: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                fMono: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                fMono: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mono: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pfMono: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pfMono: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MixLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                Level: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                Level: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MixLevel: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pLevel: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pLevel: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                Pan: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                Pan: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pan: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pPan: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pPan: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Loudness: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                fLoudness: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                fLoudness: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Loudness: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pfLoudness: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pfLoudness: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Treble: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                Treble: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                Treble: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Treble: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pTreble: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pTreble: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TrebleRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pRange: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pRange: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                Bass: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                Bass: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bass: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pBass: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pBass: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BassRange: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAudioInputMixer,
                pRange: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAudioInputMixer,
                pRange: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Enable(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Enable(@as(*const IAMAudioInputMixer, @ptrCast(self)), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Enable(self: *const T, pfEnable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Enable(@as(*const IAMAudioInputMixer, @ptrCast(self)), pfEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Mono(self: *const T, fMono: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Mono(@as(*const IAMAudioInputMixer, @ptrCast(self)), fMono);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Mono(self: *const T, pfMono: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Mono(@as(*const IAMAudioInputMixer, @ptrCast(self)), pfMono);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_MixLevel(self: *const T, Level: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_MixLevel(@as(*const IAMAudioInputMixer, @ptrCast(self)), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_MixLevel(self: *const T, pLevel: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_MixLevel(@as(*const IAMAudioInputMixer, @ptrCast(self)), pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Pan(self: *const T, Pan: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Pan(@as(*const IAMAudioInputMixer, @ptrCast(self)), Pan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Pan(self: *const T, pPan: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Pan(@as(*const IAMAudioInputMixer, @ptrCast(self)), pPan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Loudness(self: *const T, fLoudness: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Loudness(@as(*const IAMAudioInputMixer, @ptrCast(self)), fLoudness);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Loudness(self: *const T, pfLoudness: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Loudness(@as(*const IAMAudioInputMixer, @ptrCast(self)), pfLoudness);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Treble(self: *const T, Treble: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Treble(@as(*const IAMAudioInputMixer, @ptrCast(self)), Treble);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Treble(self: *const T, pTreble: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Treble(@as(*const IAMAudioInputMixer, @ptrCast(self)), pTreble);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_TrebleRange(self: *const T, pRange: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_TrebleRange(@as(*const IAMAudioInputMixer, @ptrCast(self)), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_put_Bass(self: *const T, Bass: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).put_Bass(@as(*const IAMAudioInputMixer, @ptrCast(self)), Bass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_Bass(self: *const T, pBass: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_Bass(@as(*const IAMAudioInputMixer, @ptrCast(self)), pBass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioInputMixer_get_BassRange(self: *const T, pRange: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioInputMixer.VTable, @ptrCast(self.vtable)).get_BassRange(@as(*const IAMAudioInputMixer, @ptrCast(self)), pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMBufferNegotiation_Value = Guid.initString("56ed71a0-af5f-11d0-b3f0-00aa003761c5");
pub const IID_IAMBufferNegotiation = &IID_IAMBufferNegotiation_Value;
pub const IAMBufferNegotiation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SuggestAllocatorProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMBufferNegotiation,
                pprop: ?*const ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMBufferNegotiation,
                pprop: ?*const ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllocatorProperties: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMBufferNegotiation,
                pprop: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMBufferNegotiation,
                pprop: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMBufferNegotiation_SuggestAllocatorProperties(self: *const T, pprop: ?*const ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IAMBufferNegotiation.VTable, @ptrCast(self.vtable)).SuggestAllocatorProperties(@as(*const IAMBufferNegotiation, @ptrCast(self)), pprop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMBufferNegotiation_GetAllocatorProperties(self: *const T, pprop: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IAMBufferNegotiation.VTable, @ptrCast(self.vtable)).GetAllocatorProperties(@as(*const IAMBufferNegotiation, @ptrCast(self)), pprop);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AnalogVideoStandard = enum(i32) {
    _None = 0,
    _NTSC_M = 1,
    _NTSC_M_J = 2,
    _NTSC_433 = 4,
    _PAL_B = 16,
    _PAL_D = 32,
    _PAL_G = 64,
    _PAL_H = 128,
    _PAL_I = 256,
    _PAL_M = 512,
    _PAL_N = 1024,
    _PAL_60 = 2048,
    _SECAM_B = 4096,
    _SECAM_D = 8192,
    _SECAM_G = 16384,
    _SECAM_H = 32768,
    _SECAM_K = 65536,
    _SECAM_K1 = 131072,
    _SECAM_L = 262144,
    _SECAM_L1 = 524288,
    _PAL_N_COMBO = 1048576,
    Mask_MCE_NTSC = 1052167,
    Mask_MCE_PAL = 496,
    Mask_MCE_SECAM = 1044480,
};
pub const AnalogVideo_None = AnalogVideoStandard._None;
pub const AnalogVideo_NTSC_M = AnalogVideoStandard._NTSC_M;
pub const AnalogVideo_NTSC_M_J = AnalogVideoStandard._NTSC_M_J;
pub const AnalogVideo_NTSC_433 = AnalogVideoStandard._NTSC_433;
pub const AnalogVideo_PAL_B = AnalogVideoStandard._PAL_B;
pub const AnalogVideo_PAL_D = AnalogVideoStandard._PAL_D;
pub const AnalogVideo_PAL_G = AnalogVideoStandard._PAL_G;
pub const AnalogVideo_PAL_H = AnalogVideoStandard._PAL_H;
pub const AnalogVideo_PAL_I = AnalogVideoStandard._PAL_I;
pub const AnalogVideo_PAL_M = AnalogVideoStandard._PAL_M;
pub const AnalogVideo_PAL_N = AnalogVideoStandard._PAL_N;
pub const AnalogVideo_PAL_60 = AnalogVideoStandard._PAL_60;
pub const AnalogVideo_SECAM_B = AnalogVideoStandard._SECAM_B;
pub const AnalogVideo_SECAM_D = AnalogVideoStandard._SECAM_D;
pub const AnalogVideo_SECAM_G = AnalogVideoStandard._SECAM_G;
pub const AnalogVideo_SECAM_H = AnalogVideoStandard._SECAM_H;
pub const AnalogVideo_SECAM_K = AnalogVideoStandard._SECAM_K;
pub const AnalogVideo_SECAM_K1 = AnalogVideoStandard._SECAM_K1;
pub const AnalogVideo_SECAM_L = AnalogVideoStandard._SECAM_L;
pub const AnalogVideo_SECAM_L1 = AnalogVideoStandard._SECAM_L1;
pub const AnalogVideo_PAL_N_COMBO = AnalogVideoStandard._PAL_N_COMBO;
pub const AnalogVideoMask_MCE_NTSC = AnalogVideoStandard.Mask_MCE_NTSC;
pub const AnalogVideoMask_MCE_PAL = AnalogVideoStandard.Mask_MCE_PAL;
pub const AnalogVideoMask_MCE_SECAM = AnalogVideoStandard.Mask_MCE_SECAM;

pub const TunerInputType = enum(i32) {
    Cable = 0,
    Antenna = 1,
};
pub const TunerInputCable = TunerInputType.Cable;
pub const TunerInputAntenna = TunerInputType.Antenna;

pub const VideoCopyProtectionType = enum(i32) {
    Basic = 0,
    CBI = 1,
};
pub const VideoCopyProtectionMacrovisionBasic = VideoCopyProtectionType.Basic;
pub const VideoCopyProtectionMacrovisionCBI = VideoCopyProtectionType.CBI;

pub const PhysicalConnectorType = enum(i32) {
    Video_Tuner = 1,
    Video_Composite = 2,
    Video_SVideo = 3,
    Video_RGB = 4,
    Video_YRYBY = 5,
    Video_SerialDigital = 6,
    Video_ParallelDigital = 7,
    Video_SCSI = 8,
    Video_AUX = 9,
    Video_1394 = 10,
    Video_USB = 11,
    Video_VideoDecoder = 12,
    Video_VideoEncoder = 13,
    Video_SCART = 14,
    Video_Black = 15,
    Audio_Tuner = 4096,
    Audio_Line = 4097,
    Audio_Mic = 4098,
    Audio_AESDigital = 4099,
    Audio_SPDIFDigital = 4100,
    Audio_SCSI = 4101,
    Audio_AUX = 4102,
    Audio_1394 = 4103,
    Audio_USB = 4104,
    Audio_AudioDecoder = 4105,
};
pub const PhysConn_Video_Tuner = PhysicalConnectorType.Video_Tuner;
pub const PhysConn_Video_Composite = PhysicalConnectorType.Video_Composite;
pub const PhysConn_Video_SVideo = PhysicalConnectorType.Video_SVideo;
pub const PhysConn_Video_RGB = PhysicalConnectorType.Video_RGB;
pub const PhysConn_Video_YRYBY = PhysicalConnectorType.Video_YRYBY;
pub const PhysConn_Video_SerialDigital = PhysicalConnectorType.Video_SerialDigital;
pub const PhysConn_Video_ParallelDigital = PhysicalConnectorType.Video_ParallelDigital;
pub const PhysConn_Video_SCSI = PhysicalConnectorType.Video_SCSI;
pub const PhysConn_Video_AUX = PhysicalConnectorType.Video_AUX;
pub const PhysConn_Video_1394 = PhysicalConnectorType.Video_1394;
pub const PhysConn_Video_USB = PhysicalConnectorType.Video_USB;
pub const PhysConn_Video_VideoDecoder = PhysicalConnectorType.Video_VideoDecoder;
pub const PhysConn_Video_VideoEncoder = PhysicalConnectorType.Video_VideoEncoder;
pub const PhysConn_Video_SCART = PhysicalConnectorType.Video_SCART;
pub const PhysConn_Video_Black = PhysicalConnectorType.Video_Black;
pub const PhysConn_Audio_Tuner = PhysicalConnectorType.Audio_Tuner;
pub const PhysConn_Audio_Line = PhysicalConnectorType.Audio_Line;
pub const PhysConn_Audio_Mic = PhysicalConnectorType.Audio_Mic;
pub const PhysConn_Audio_AESDigital = PhysicalConnectorType.Audio_AESDigital;
pub const PhysConn_Audio_SPDIFDigital = PhysicalConnectorType.Audio_SPDIFDigital;
pub const PhysConn_Audio_SCSI = PhysicalConnectorType.Audio_SCSI;
pub const PhysConn_Audio_AUX = PhysicalConnectorType.Audio_AUX;
pub const PhysConn_Audio_1394 = PhysicalConnectorType.Audio_1394;
pub const PhysConn_Audio_USB = PhysicalConnectorType.Audio_USB;
pub const PhysConn_Audio_AudioDecoder = PhysicalConnectorType.Audio_AudioDecoder;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMAnalogVideoDecoder_Value = Guid.initString("c6e13350-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoDecoder = &IID_IAMAnalogVideoDecoder_Value;
pub const IAMAnalogVideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                lAnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                lAnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HorizontalLocked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                plLocked: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                plLocked: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VCRHorizontalLocking: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                lVCRHorizontalLocking: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                lVCRHorizontalLocking: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VCRHorizontalLocking: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                plVCRHorizontalLocking: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                plVCRHorizontalLocking: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumberOfLines: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                plNumberOfLines: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                plNumberOfLines: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OutputEnable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                lOutputEnable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                lOutputEnable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OutputEnable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoDecoder,
                plOutputEnable: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoDecoder,
                plOutputEnable: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_TVFormat(self: *const T, lAnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_TVFormat(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_HorizontalLocked(self: *const T, plLocked: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_HorizontalLocked(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), plLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_VCRHorizontalLocking(self: *const T, lVCRHorizontalLocking: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_VCRHorizontalLocking(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), lVCRHorizontalLocking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_VCRHorizontalLocking(self: *const T, plVCRHorizontalLocking: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_VCRHorizontalLocking(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), plVCRHorizontalLocking);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_NumberOfLines(self: *const T, plNumberOfLines: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_NumberOfLines(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), plNumberOfLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_put_OutputEnable(self: *const T, lOutputEnable: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).put_OutputEnable(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), lOutputEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoDecoder_get_OutputEnable(self: *const T, plOutputEnable: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoDecoder.VTable, @ptrCast(self.vtable)).get_OutputEnable(@as(*const IAMAnalogVideoDecoder, @ptrCast(self)), plOutputEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VideoProcAmpProperty = enum(i32) {
    Brightness = 0,
    Contrast = 1,
    Hue = 2,
    Saturation = 3,
    Sharpness = 4,
    Gamma = 5,
    ColorEnable = 6,
    WhiteBalance = 7,
    BacklightCompensation = 8,
    Gain = 9,
};
pub const VideoProcAmp_Brightness = VideoProcAmpProperty.Brightness;
pub const VideoProcAmp_Contrast = VideoProcAmpProperty.Contrast;
pub const VideoProcAmp_Hue = VideoProcAmpProperty.Hue;
pub const VideoProcAmp_Saturation = VideoProcAmpProperty.Saturation;
pub const VideoProcAmp_Sharpness = VideoProcAmpProperty.Sharpness;
pub const VideoProcAmp_Gamma = VideoProcAmpProperty.Gamma;
pub const VideoProcAmp_ColorEnable = VideoProcAmpProperty.ColorEnable;
pub const VideoProcAmp_WhiteBalance = VideoProcAmpProperty.WhiteBalance;
pub const VideoProcAmp_BacklightCompensation = VideoProcAmpProperty.BacklightCompensation;
pub const VideoProcAmp_Gain = VideoProcAmpProperty.Gain;

pub const VideoProcAmpFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const VideoProcAmp_Flags_Auto = VideoProcAmpFlags.Auto;
pub const VideoProcAmp_Flags_Manual = VideoProcAmpFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoProcAmp_Value = Guid.initString("c6e13360-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoProcAmp = &IID_IAMVideoProcAmp_Value;
pub const IAMVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                lValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                lValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                lValue: ?*i32,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoProcAmp,
                Property: i32,
                lValue: ?*i32,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_GetRange(self: *const T, Property: i32, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IAMVideoProcAmp, @ptrCast(self)), Property, pMin, pMax, pSteppingDelta, pDefault, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_Set(self: *const T, Property: i32, lValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).Set(@as(*const IAMVideoProcAmp, @ptrCast(self)), Property, lValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoProcAmp_Get(self: *const T, Property: i32, lValue: ?*i32, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoProcAmp.VTable, @ptrCast(self.vtable)).Get(@as(*const IAMVideoProcAmp, @ptrCast(self)), Property, lValue, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CameraControlProperty = enum(i32) {
    Pan = 0,
    Tilt = 1,
    Roll = 2,
    Zoom = 3,
    Exposure = 4,
    Iris = 5,
    Focus = 6,
};
pub const CameraControl_Pan = CameraControlProperty.Pan;
pub const CameraControl_Tilt = CameraControlProperty.Tilt;
pub const CameraControl_Roll = CameraControlProperty.Roll;
pub const CameraControl_Zoom = CameraControlProperty.Zoom;
pub const CameraControl_Exposure = CameraControlProperty.Exposure;
pub const CameraControl_Iris = CameraControlProperty.Iris;
pub const CameraControl_Focus = CameraControlProperty.Focus;

pub const CameraControlFlags = enum(i32) {
    Auto = 1,
    Manual = 2,
};
pub const CameraControl_Flags_Auto = CameraControlFlags.Auto;
pub const CameraControl_Flags_Manual = CameraControlFlags.Manual;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCameraControl_Value = Guid.initString("c6e13370-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCameraControl = &IID_IAMCameraControl_Value;
pub const IAMCameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCameraControl,
                Property: i32,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCameraControl,
                Property: i32,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCameraControl,
                Property: i32,
                lValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCameraControl,
                Property: i32,
                lValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCameraControl,
                Property: i32,
                lValue: ?*i32,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCameraControl,
                Property: i32,
                lValue: ?*i32,
                Flags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_GetRange(self: *const T, Property: i32, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).GetRange(@as(*const IAMCameraControl, @ptrCast(self)), Property, pMin, pMax, pSteppingDelta, pDefault, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_Set(self: *const T, Property: i32, lValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).Set(@as(*const IAMCameraControl, @ptrCast(self)), Property, lValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCameraControl_Get(self: *const T, Property: i32, lValue: ?*i32, Flags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCameraControl.VTable, @ptrCast(self.vtable)).Get(@as(*const IAMCameraControl, @ptrCast(self)), Property, lValue, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VideoControlFlags = enum(i32) {
    FlipHorizontal = 1,
    FlipVertical = 2,
    ExternalTriggerEnable = 4,
    Trigger = 8,
};
pub const VideoControlFlag_FlipHorizontal = VideoControlFlags.FlipHorizontal;
pub const VideoControlFlag_FlipVertical = VideoControlFlags.FlipVertical;
pub const VideoControlFlag_ExternalTriggerEnable = VideoControlFlags.ExternalTriggerEnable;
pub const VideoControlFlag_Trigger = VideoControlFlags.Trigger;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoControl_Value = Guid.initString("6a2e0670-28e4-11d0-a18c-00a0c9118956");
pub const IID_IAMVideoControl = &IID_IAMVideoControl_Value;
pub const IAMVideoControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                pCapsFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                Mode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                Mode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentActualFrameRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                ActualFrameRate: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                ActualFrameRate: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxAvailableFrameRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                iIndex: i32,
                Dimensions: SIZE,
                MaxAvailableFrameRate: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                iIndex: i32,
                Dimensions: SIZE,
                MaxAvailableFrameRate: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFrameRateList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                iIndex: i32,
                Dimensions: SIZE,
                ListSize: ?*i32,
                FrameRates: ?*?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoControl,
                pPin: ?*IPin,
                iIndex: i32,
                Dimensions: SIZE,
                ListSize: ?*i32,
                FrameRates: ?*?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetCaps(self: *const T, pPin: ?*IPin, pCapsFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IAMVideoControl, @ptrCast(self)), pPin, pCapsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_SetMode(self: *const T, pPin: ?*IPin, Mode: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).SetMode(@as(*const IAMVideoControl, @ptrCast(self)), pPin, Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetMode(self: *const T, pPin: ?*IPin, Mode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetMode(@as(*const IAMVideoControl, @ptrCast(self)), pPin, Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetCurrentActualFrameRate(self: *const T, pPin: ?*IPin, ActualFrameRate: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetCurrentActualFrameRate(@as(*const IAMVideoControl, @ptrCast(self)), pPin, ActualFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetMaxAvailableFrameRate(self: *const T, pPin: ?*IPin, iIndex: i32, Dimensions: SIZE, MaxAvailableFrameRate: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetMaxAvailableFrameRate(@as(*const IAMVideoControl, @ptrCast(self)), pPin, iIndex, Dimensions, MaxAvailableFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoControl_GetFrameRateList(self: *const T, pPin: ?*IPin, iIndex: i32, Dimensions: SIZE, ListSize: ?*i32, FrameRates: ?*?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoControl.VTable, @ptrCast(self.vtable)).GetFrameRateList(@as(*const IAMVideoControl, @ptrCast(self)), pPin, iIndex, Dimensions, ListSize, FrameRates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMCrossbar_Value = Guid.initString("c6e13380-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMCrossbar = &IID_IAMCrossbar_Value;
pub const IAMCrossbar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_PinCounts: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCrossbar,
                OutputPinCount: ?*i32,
                InputPinCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCrossbar,
                OutputPinCount: ?*i32,
                InputPinCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanRoute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Route: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_IsRoutedTo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCrossbar,
                OutputPinIndex: i32,
                InputPinIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_CrossbarPinInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCrossbar,
                IsInputPin: BOOL,
                PinIndex: i32,
                PinIndexRelated: ?*i32,
                PhysicalType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCrossbar,
                IsInputPin: BOOL,
                PinIndex: i32,
                PinIndexRelated: ?*i32,
                PhysicalType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_PinCounts(self: *const T, OutputPinCount: ?*i32, InputPinCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_PinCounts(@as(*const IAMCrossbar, @ptrCast(self)), OutputPinCount, InputPinCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_CanRoute(self: *const T, OutputPinIndex: i32, InputPinIndex: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).CanRoute(@as(*const IAMCrossbar, @ptrCast(self)), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_Route(self: *const T, OutputPinIndex: i32, InputPinIndex: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).Route(@as(*const IAMCrossbar, @ptrCast(self)), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_IsRoutedTo(self: *const T, OutputPinIndex: i32, InputPinIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_IsRoutedTo(@as(*const IAMCrossbar, @ptrCast(self)), OutputPinIndex, InputPinIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCrossbar_get_CrossbarPinInfo(self: *const T, IsInputPin: BOOL, PinIndex: i32, PinIndexRelated: ?*i32, PhysicalType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCrossbar.VTable, @ptrCast(self.vtable)).get_CrossbarPinInfo(@as(*const IAMCrossbar, @ptrCast(self)), IsInputPin, PinIndex, PinIndexRelated, PhysicalType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMTunerSubChannel = enum(i32) {
    NO_TUNE = -2,
    DEFAULT = -1,
};
pub const AMTUNER_SUBCHAN_NO_TUNE = AMTunerSubChannel.NO_TUNE;
pub const AMTUNER_SUBCHAN_DEFAULT = AMTunerSubChannel.DEFAULT;

pub const AMTunerSignalStrength = enum(i32) {
    HASNOSIGNALSTRENGTH = -1,
    NOSIGNAL = 0,
    SIGNALPRESENT = 1,
};
pub const AMTUNER_HASNOSIGNALSTRENGTH = AMTunerSignalStrength.HASNOSIGNALSTRENGTH;
pub const AMTUNER_NOSIGNAL = AMTunerSignalStrength.NOSIGNAL;
pub const AMTUNER_SIGNALPRESENT = AMTunerSignalStrength.SIGNALPRESENT;

pub const AMTunerModeType = enum(i32) {
    DEFAULT = 0,
    TV = 1,
    FM_RADIO = 2,
    AM_RADIO = 4,
    DSS = 8,
};
pub const AMTUNER_MODE_DEFAULT = AMTunerModeType.DEFAULT;
pub const AMTUNER_MODE_TV = AMTunerModeType.TV;
pub const AMTUNER_MODE_FM_RADIO = AMTunerModeType.FM_RADIO;
pub const AMTUNER_MODE_AM_RADIO = AMTunerModeType.AM_RADIO;
pub const AMTUNER_MODE_DSS = AMTunerModeType.DSS;

pub const AMTunerEventType = enum(i32) {
    D = 1,
};
pub const AMTUNER_EVENT_CHANGED = AMTunerEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTuner_Value = Guid.initString("211a8761-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTuner = &IID_IAMTuner_Value;
pub const IAMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        put_Channel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                lChannel: i32,
                lVideoSubChannel: i32,
                lAudioSubChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                lChannel: i32,
                lVideoSubChannel: i32,
                lAudioSubChannel: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Channel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                plChannel: ?*i32,
                plVideoSubChannel: ?*i32,
                plAudioSubChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                plChannel: ?*i32,
                plVideoSubChannel: ?*i32,
                plAudioSubChannel: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChannelMinMax: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                lChannelMin: ?*i32,
                lChannelMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                lChannelMin: ?*i32,
                lChannelMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                lCountryCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                lCountryCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                plCountryCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                lTuningSpace: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                lTuningSpace: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TuningSpace: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                plTuningSpace: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                plTuningSpace: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Logon: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                hCurrentUser: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                hCurrentUser: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Logout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SignalPresent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                plSignalStrength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                plSignalStrength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                lMode: AMTunerModeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                lMode: AMTunerModeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTuner,
                plMode: ?*AMTunerModeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTuner,
                plMode: ?*AMTunerModeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterNotificationCallBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                pNotify: ?*IAMTunerNotification,
                lEvents: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                pNotify: ?*IAMTunerNotification,
                lEvents: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterNotificationCallBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTuner,
                pNotify: ?*IAMTunerNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTuner,
                pNotify: ?*IAMTunerNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_Channel(self: *const T, lChannel: i32, lVideoSubChannel: i32, lAudioSubChannel: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_Channel(@as(*const IAMTuner, @ptrCast(self)), lChannel, lVideoSubChannel, lAudioSubChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_Channel(self: *const T, plChannel: ?*i32, plVideoSubChannel: ?*i32, plAudioSubChannel: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_Channel(@as(*const IAMTuner, @ptrCast(self)), plChannel, plVideoSubChannel, plAudioSubChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_ChannelMinMax(self: *const T, lChannelMin: ?*i32, lChannelMax: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).ChannelMinMax(@as(*const IAMTuner, @ptrCast(self)), lChannelMin, lChannelMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_CountryCode(self: *const T, lCountryCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IAMTuner, @ptrCast(self)), lCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_CountryCode(self: *const T, plCountryCode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IAMTuner, @ptrCast(self)), plCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_TuningSpace(self: *const T, lTuningSpace: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_TuningSpace(@as(*const IAMTuner, @ptrCast(self)), lTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_TuningSpace(self: *const T, plTuningSpace: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_TuningSpace(@as(*const IAMTuner, @ptrCast(self)), plTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_Logon(self: *const T, hCurrentUser: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).Logon(@as(*const IAMTuner, @ptrCast(self)), hCurrentUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_Logout(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).Logout(@as(*const IAMTuner, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_SignalPresent(self: *const T, plSignalStrength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).SignalPresent(@as(*const IAMTuner, @ptrCast(self)), plSignalStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_put_Mode(self: *const T, lMode: AMTunerModeType) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IAMTuner, @ptrCast(self)), lMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_get_Mode(self: *const T, plMode: ?*AMTunerModeType) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IAMTuner, @ptrCast(self)), plMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_GetAvailableModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).GetAvailableModes(@as(*const IAMTuner, @ptrCast(self)), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_RegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification, lEvents: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).RegisterNotificationCallBack(@as(*const IAMTuner, @ptrCast(self)), pNotify, lEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTuner_UnRegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification) callconv(.Inline) HRESULT {
            return @as(*const IAMTuner.VTable, @ptrCast(self.vtable)).UnRegisterNotificationCallBack(@as(*const IAMTuner, @ptrCast(self)), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTunerNotification_Value = Guid.initString("211a8760-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTunerNotification = &IID_IAMTunerNotification_Value;
pub const IAMTunerNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTunerNotification,
                Event: AMTunerEventType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTunerNotification,
                Event: AMTunerEventType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTunerNotification_OnEvent(self: *const T, Event: AMTunerEventType) callconv(.Inline) HRESULT {
            return @as(*const IAMTunerNotification.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IAMTunerNotification, @ptrCast(self)), Event);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVTuner_Value = Guid.initString("211a8766-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IAMTVTuner = &IID_IAMTVTuner_Value;
pub const IAMTVTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AutoTune: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVTuner,
                lChannel: i32,
                plFoundSignal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVTuner,
                lChannel: i32,
                plFoundSignal: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StoreAutoTune: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumInputConnections: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                plNumInputConnections: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                plNumInputConnections: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_InputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVTuner,
                lIndex: i32,
                InputType: TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVTuner,
                lIndex: i32,
                InputType: TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_InputType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVTuner,
                lIndex: i32,
                pInputType: ?*TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVTuner,
                lIndex: i32,
                pInputType: ?*TunerInputType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ConnectInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                lIndex: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectInput: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                lFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                lFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVTuner,
                lFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVTuner,
                lFreq: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMTVTuner, @ptrCast(self)), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMTVTuner, @ptrCast(self)), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_AutoTune(self: *const T, lChannel: i32, plFoundSignal: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).AutoTune(@as(*const IAMTVTuner, @ptrCast(self)), lChannel, plFoundSignal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_StoreAutoTune(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).StoreAutoTune(@as(*const IAMTVTuner, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_NumInputConnections(self: *const T, plNumInputConnections: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_NumInputConnections(@as(*const IAMTVTuner, @ptrCast(self)), plNumInputConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_put_InputType(self: *const T, lIndex: i32, InputType: TunerInputType) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).put_InputType(@as(*const IAMTVTuner, @ptrCast(self)), lIndex, InputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_InputType(self: *const T, lIndex: i32, pInputType: ?*TunerInputType) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_InputType(@as(*const IAMTVTuner, @ptrCast(self)), lIndex, pInputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_put_ConnectInput(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).put_ConnectInput(@as(*const IAMTVTuner, @ptrCast(self)), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_ConnectInput(self: *const T, plIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_ConnectInput(@as(*const IAMTVTuner, @ptrCast(self)), plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_VideoFrequency(self: *const T, lFreq: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_VideoFrequency(@as(*const IAMTVTuner, @ptrCast(self)), lFreq);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVTuner_get_AudioFrequency(self: *const T, lFreq: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVTuner.VTable, @ptrCast(self.vtable)).get_AudioFrequency(@as(*const IAMTVTuner, @ptrCast(self)), lFreq);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBPCSatelliteTuner_Value = Guid.initString("211a8765-03ac-11d1-8d13-00aa00bd8339");
pub const IID_IBPCSatelliteTuner = &IID_IBPCSatelliteTuner_Value;
pub const IBPCSatelliteTuner = extern struct {
    pub const VTable = extern struct {
        base: IAMTuner.VTable,
        get_DefaultSubChannelTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBPCSatelliteTuner,
                plDefaultVideoType: ?*i32,
                plDefaultAudioType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBPCSatelliteTuner,
                plDefaultVideoType: ?*i32,
                plDefaultAudioType: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_DefaultSubChannelTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBPCSatelliteTuner,
                lDefaultVideoType: i32,
                lDefaultAudioType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBPCSatelliteTuner,
                lDefaultVideoType: i32,
                lDefaultAudioType: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsTapingPermitted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBPCSatelliteTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBPCSatelliteTuner,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMTuner.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_get_DefaultSubChannelTypes(self: *const T, plDefaultVideoType: ?*i32, plDefaultAudioType: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).get_DefaultSubChannelTypes(@as(*const IBPCSatelliteTuner, @ptrCast(self)), plDefaultVideoType, plDefaultAudioType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_put_DefaultSubChannelTypes(self: *const T, lDefaultVideoType: i32, lDefaultAudioType: i32) callconv(.Inline) HRESULT {
            return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).put_DefaultSubChannelTypes(@as(*const IBPCSatelliteTuner, @ptrCast(self)), lDefaultVideoType, lDefaultAudioType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBPCSatelliteTuner_IsTapingPermitted(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBPCSatelliteTuner.VTable, @ptrCast(self.vtable)).IsTapingPermitted(@as(*const IBPCSatelliteTuner, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TVAudioMode = enum(i32) {
    MODE_MONO = 1,
    MODE_STEREO = 2,
    MODE_LANG_A = 16,
    MODE_LANG_B = 32,
    MODE_LANG_C = 64,
    PRESET_STEREO = 512,
    PRESET_LANG_A = 4096,
    PRESET_LANG_B = 8192,
    PRESET_LANG_C = 16384,
};
pub const AMTVAUDIO_MODE_MONO = TVAudioMode.MODE_MONO;
pub const AMTVAUDIO_MODE_STEREO = TVAudioMode.MODE_STEREO;
pub const AMTVAUDIO_MODE_LANG_A = TVAudioMode.MODE_LANG_A;
pub const AMTVAUDIO_MODE_LANG_B = TVAudioMode.MODE_LANG_B;
pub const AMTVAUDIO_MODE_LANG_C = TVAudioMode.MODE_LANG_C;
pub const AMTVAUDIO_PRESET_STEREO = TVAudioMode.PRESET_STEREO;
pub const AMTVAUDIO_PRESET_LANG_A = TVAudioMode.PRESET_LANG_A;
pub const AMTVAUDIO_PRESET_LANG_B = TVAudioMode.PRESET_LANG_B;
pub const AMTVAUDIO_PRESET_LANG_C = TVAudioMode.PRESET_LANG_C;

pub const AMTVAudioEventType = enum(i32) {
    D = 1,
};
pub const AMTVAUDIO_EVENT_CHANGED = AMTVAudioEventType.D;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTVAudio_Value = Guid.initString("83ec1c30-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudio = &IID_IAMTVAudio_Value;
pub const IAMTVAudio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHardwareSupportedTVAudioModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVAudio,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVAudio,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableTVAudioModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVAudio,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVAudio,
                plModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVAudioMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVAudio,
                plMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVAudio,
                plMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVAudioMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTVAudio,
                lMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTVAudio,
                lMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterNotificationCallBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVAudio,
                pNotify: ?*IAMTunerNotification,
                lEvents: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVAudio,
                pNotify: ?*IAMTunerNotification,
                lEvents: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterNotificationCallBack: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVAudio,
                pNotify: ?*IAMTunerNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVAudio,
                pNotify: ?*IAMTunerNotification,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_GetHardwareSupportedTVAudioModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).GetHardwareSupportedTVAudioModes(@as(*const IAMTVAudio, @ptrCast(self)), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_GetAvailableTVAudioModes(self: *const T, plModes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).GetAvailableTVAudioModes(@as(*const IAMTVAudio, @ptrCast(self)), plModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_get_TVAudioMode(self: *const T, plMode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).get_TVAudioMode(@as(*const IAMTVAudio, @ptrCast(self)), plMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_put_TVAudioMode(self: *const T, lMode: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).put_TVAudioMode(@as(*const IAMTVAudio, @ptrCast(self)), lMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_RegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification, lEvents: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).RegisterNotificationCallBack(@as(*const IAMTVAudio, @ptrCast(self)), pNotify, lEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudio_UnRegisterNotificationCallBack(self: *const T, pNotify: ?*IAMTunerNotification) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudio.VTable, @ptrCast(self.vtable)).UnRegisterNotificationCallBack(@as(*const IAMTVAudio, @ptrCast(self)), pNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMTVAudioNotification_Value = Guid.initString("83ec1c33-23d1-11d1-99e6-00a0c9560266");
pub const IID_IAMTVAudioNotification = &IID_IAMTVAudioNotification_Value;
pub const IAMTVAudioNotification = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTVAudioNotification,
                Event: AMTVAudioEventType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTVAudioNotification,
                Event: AMTVAudioEventType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTVAudioNotification_OnEvent(self: *const T, Event: AMTVAudioEventType) callconv(.Inline) HRESULT {
            return @as(*const IAMTVAudioNotification.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IAMTVAudioNotification, @ptrCast(self)), Event);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMAnalogVideoEncoder_Value = Guid.initString("c6e133b0-30ac-11d0-a18c-00a0c9118956");
pub const IID_IAMAnalogVideoEncoder = &IID_IAMAnalogVideoEncoder_Value;
pub const IAMAnalogVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvailableTVFormats: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TVFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lAnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lAnalogVideoStandard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TVFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                plAnalogVideoStandard: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CopyProtection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lVideoCopyProtection: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lVideoCopyProtection: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CopyProtection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lVideoCopyProtection: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lVideoCopyProtection: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CCEnable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lCCEnable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lCCEnable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CCEnable: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMAnalogVideoEncoder,
                lCCEnable: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMAnalogVideoEncoder,
                lCCEnable: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_AvailableTVFormats(self: *const T, lAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_AvailableTVFormats(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_TVFormat(self: *const T, lAnalogVideoStandard: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_TVFormat(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_TVFormat(self: *const T, plAnalogVideoStandard: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_TVFormat(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), plAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_CopyProtection(self: *const T, lVideoCopyProtection: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_CopyProtection(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lVideoCopyProtection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_CopyProtection(self: *const T, lVideoCopyProtection: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_CopyProtection(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lVideoCopyProtection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_put_CCEnable(self: *const T, lCCEnable: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).put_CCEnable(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lCCEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAnalogVideoEncoder_get_CCEnable(self: *const T, lCCEnable: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMAnalogVideoEncoder.VTable, @ptrCast(self.vtable)).get_CCEnable(@as(*const IAMAnalogVideoEncoder, @ptrCast(self)), lCCEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMPROPERTY_PIN = enum(i32) {
    CATEGORY = 0,
    MEDIUM = 1,
};
pub const AMPROPERTY_PIN_CATEGORY = AMPROPERTY_PIN.CATEGORY;
pub const AMPROPERTY_PIN_MEDIUM = AMPROPERTY_PIN.MEDIUM;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPropertyBag_Value = Guid.initString("6025a880-c0d5-11d0-bd4e-00a0c911ce86");
pub const IID_IMediaPropertyBag = &IID_IMediaPropertyBag_Value;
pub const IMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
        EnumProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaPropertyBag,
                iProperty: u32,
                pvarPropertyName: ?*VARIANT,
                pvarPropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaPropertyBag,
                iProperty: u32,
                pvarPropertyName: ?*VARIANT,
                pvarPropertyValue: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyBag.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPropertyBag_EnumProperty(self: *const T, iProperty: u32, pvarPropertyName: ?*VARIANT, pvarPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IMediaPropertyBag.VTable, @ptrCast(self.vtable)).EnumProperty(@as(*const IMediaPropertyBag, @ptrCast(self)), iProperty, pvarPropertyName, pvarPropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IPersistMediaPropertyBag_Value = Guid.initString("5738e040-b67f-11d0-bd4d-00a0c911ce86");
pub const IID_IPersistMediaPropertyBag = &IID_IPersistMediaPropertyBag_Value;
pub const IPersistMediaPropertyBag = extern struct {
    pub const VTable = extern struct {
        base: IPersist.VTable,
        InitNew: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMediaPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMediaPropertyBag,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Load: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMediaPropertyBag,
                pPropBag: ?*IMediaPropertyBag,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMediaPropertyBag,
                pPropBag: ?*IMediaPropertyBag,
                pErrorLog: ?*IErrorLog,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Save: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPersistMediaPropertyBag,
                pPropBag: ?*IMediaPropertyBag,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPersistMediaPropertyBag,
                pPropBag: ?*IMediaPropertyBag,
                fClearDirty: BOOL,
                fSaveAllProperties: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersist.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).InitNew(@as(*const IPersistMediaPropertyBag, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_Load(self: *const T, pPropBag: ?*IMediaPropertyBag, pErrorLog: ?*IErrorLog) callconv(.Inline) HRESULT {
            return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).Load(@as(*const IPersistMediaPropertyBag, @ptrCast(self)), pPropBag, pErrorLog);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPersistMediaPropertyBag_Save(self: *const T, pPropBag: ?*IMediaPropertyBag, fClearDirty: BOOL, fSaveAllProperties: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IPersistMediaPropertyBag.VTable, @ptrCast(self.vtable)).Save(@as(*const IPersistMediaPropertyBag, @ptrCast(self)), pPropBag, fClearDirty, fSaveAllProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMPhysicalPinInfo_Value = Guid.initString("f938c991-3029-11cf-8c44-00aa006b6814");
pub const IID_IAMPhysicalPinInfo = &IID_IAMPhysicalPinInfo_Value;
pub const IAMPhysicalPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPhysicalType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPhysicalPinInfo,
                pType: ?*i32,
                ppszType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPhysicalPinInfo,
                pType: ?*i32,
                ppszType: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPhysicalPinInfo_GetPhysicalType(self: *const T, pType: ?*i32, ppszType: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMPhysicalPinInfo.VTable, @ptrCast(self.vtable)).GetPhysicalType(@as(*const IAMPhysicalPinInfo, @ptrCast(self)), pType, ppszType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtDevice_Value = Guid.initString("b5730a90-1a2c-11cf-8c23-00aa006b6814");
pub const IID_IAMExtDevice = &IID_IAMExtDevice_Value;
pub const IAMExtDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtDevice,
                Capability: i32,
                pValue: ?*i32,
                pdblValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtDevice,
                Capability: i32,
                pValue: ?*i32,
                pdblValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExternalDeviceVersion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePower: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                PowerMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                PowerMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePower: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                pPowerMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                pPowerMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Calibrate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtDevice,
                hEvent: usize,
                Mode: i32,
                pStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtDevice,
                hEvent: usize,
                Mode: i32,
                pStatus: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DevicePort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                DevicePort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                DevicePort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevicePort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtDevice,
                pDevicePort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtDevice,
                pDevicePort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_GetCapability(self: *const T, Capability: i32, pValue: ?*i32, pdblValue: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).GetCapability(@as(*const IAMExtDevice, @ptrCast(self)), Capability, pValue, pdblValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_ExternalDeviceID(self: *const T, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_ExternalDeviceID(@as(*const IAMExtDevice, @ptrCast(self)), ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_ExternalDeviceVersion(self: *const T, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_ExternalDeviceVersion(@as(*const IAMExtDevice, @ptrCast(self)), ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_put_DevicePower(self: *const T, PowerMode: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).put_DevicePower(@as(*const IAMExtDevice, @ptrCast(self)), PowerMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_DevicePower(self: *const T, pPowerMode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_DevicePower(@as(*const IAMExtDevice, @ptrCast(self)), pPowerMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_Calibrate(self: *const T, hEvent: usize, Mode: i32, pStatus: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).Calibrate(@as(*const IAMExtDevice, @ptrCast(self)), hEvent, Mode, pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_put_DevicePort(self: *const T, DevicePort: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).put_DevicePort(@as(*const IAMExtDevice, @ptrCast(self)), DevicePort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtDevice_get_DevicePort(self: *const T, pDevicePort: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtDevice.VTable, @ptrCast(self.vtable)).get_DevicePort(@as(*const IAMExtDevice, @ptrCast(self)), pDevicePort);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtTransport_Value = Guid.initString("a03cd5f0-3045-11cf-8c44-00aa006b6814");
pub const IID_IAMExtTransport = &IID_IAMExtTransport_Value;
pub const IAMExtTransport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Capability: i32,
                pValue: ?*i32,
                pdblValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Capability: i32,
                pValue: ?*i32,
                pdblValue: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MediaState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                StatusItem: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                StatusItem: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportBasicParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
                ppszData: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransportBasicParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
                pszData: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
                pszData: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportVideoParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransportVideoParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTransportAudioParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTransportAudioParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Mode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                dblRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                dblRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pdblRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pdblRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                pEnabled: ?*i32,
                pOffset: ?*i32,
                phEvent: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                pEnabled: ?*i32,
                pOffset: ?*i32,
                phEvent: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetChase: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Enable: i32,
                Offset: i32,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Enable: i32,
                Offset: i32,
                hEvent: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBump: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                pSpeed: ?*i32,
                pDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                pSpeed: ?*i32,
                pDuration: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBump: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                Speed: i32,
                Duration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                Speed: i32,
                Duration: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AntiClogControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pEnabled: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pEnabled: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AntiClogControl: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                Enable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                Enable: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEditPropertySet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                EditID: i32,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                EditID: i32,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEditPropertySet: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                pEditID: ?*i32,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                pEditID: ?*i32,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEditProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                EditID: i32,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                EditID: i32,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEditProperty: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtTransport,
                EditID: i32,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtTransport,
                EditID: i32,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EditStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EditStart: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtTransport,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtTransport,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetCapability(self: *const T, Capability: i32, pValue: ?*i32, pdblValue: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetCapability(@as(*const IAMExtTransport, @ptrCast(self)), Capability, pValue, pdblValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_MediaState(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_MediaState(@as(*const IAMExtTransport, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_MediaState(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_MediaState(@as(*const IAMExtTransport, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_LocalControl(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_LocalControl(@as(*const IAMExtTransport, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_LocalControl(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_LocalControl(@as(*const IAMExtTransport, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetStatus(self: *const T, StatusItem: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IAMExtTransport, @ptrCast(self)), StatusItem, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportBasicParameters(self: *const T, Param: i32, pValue: ?*i32, ppszData: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportBasicParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, pValue, ppszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportBasicParameters(self: *const T, Param: i32, Value: i32, pszData: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportBasicParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, Value, pszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportVideoParameters(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportVideoParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportVideoParameters(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportVideoParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetTransportAudioParameters(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetTransportAudioParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetTransportAudioParameters(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetTransportAudioParameters(@as(*const IAMExtTransport, @ptrCast(self)), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_Mode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_Mode(@as(*const IAMExtTransport, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_Mode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_Mode(@as(*const IAMExtTransport, @ptrCast(self)), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_Rate(self: *const T, dblRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IAMExtTransport, @ptrCast(self)), dblRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_Rate(self: *const T, pdblRate: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IAMExtTransport, @ptrCast(self)), pdblRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetChase(self: *const T, pEnabled: ?*i32, pOffset: ?*i32, phEvent: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetChase(@as(*const IAMExtTransport, @ptrCast(self)), pEnabled, pOffset, phEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetChase(self: *const T, Enable: i32, Offset: i32, hEvent: usize) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetChase(@as(*const IAMExtTransport, @ptrCast(self)), Enable, Offset, hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetBump(self: *const T, pSpeed: ?*i32, pDuration: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetBump(@as(*const IAMExtTransport, @ptrCast(self)), pSpeed, pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetBump(self: *const T, Speed: i32, Duration: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetBump(@as(*const IAMExtTransport, @ptrCast(self)), Speed, Duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_AntiClogControl(self: *const T, pEnabled: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_AntiClogControl(@as(*const IAMExtTransport, @ptrCast(self)), pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_AntiClogControl(self: *const T, Enable: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_AntiClogControl(@as(*const IAMExtTransport, @ptrCast(self)), Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetEditPropertySet(self: *const T, EditID: i32, pState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetEditPropertySet(@as(*const IAMExtTransport, @ptrCast(self)), EditID, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetEditPropertySet(self: *const T, pEditID: ?*i32, State: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetEditPropertySet(@as(*const IAMExtTransport, @ptrCast(self)), pEditID, State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_GetEditProperty(self: *const T, EditID: i32, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).GetEditProperty(@as(*const IAMExtTransport, @ptrCast(self)), EditID, Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_SetEditProperty(self: *const T, EditID: i32, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).SetEditProperty(@as(*const IAMExtTransport, @ptrCast(self)), EditID, Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_get_EditStart(self: *const T, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).get_EditStart(@as(*const IAMExtTransport, @ptrCast(self)), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtTransport_put_EditStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtTransport.VTable, @ptrCast(self.vtable)).put_EditStart(@as(*const IAMExtTransport, @ptrCast(self)), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeReader_Value = Guid.initString("9b496ce1-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeReader = &IID_IAMTimecodeReader_Value;
pub const IAMTimecodeReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCRMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeReader,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeReader,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTCRMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeReader,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeReader,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTimecodeReader,
                Line: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTimecodeReader,
                Line: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTimecodeReader,
                pLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTimecodeReader,
                pLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeReader,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeReader,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_GetTCRMode(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).GetTCRMode(@as(*const IAMTimecodeReader, @ptrCast(self)), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_SetTCRMode(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).SetTCRMode(@as(*const IAMTimecodeReader, @ptrCast(self)), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_put_VITCLine(self: *const T, Line: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).put_VITCLine(@as(*const IAMTimecodeReader, @ptrCast(self)), Line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_get_VITCLine(self: *const T, pLine: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).get_VITCLine(@as(*const IAMTimecodeReader, @ptrCast(self)), pLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeReader_GetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeReader.VTable, @ptrCast(self.vtable)).GetTimecode(@as(*const IAMTimecodeReader, @ptrCast(self)), pTimecodeSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeGenerator_Value = Guid.initString("9b496ce0-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeGenerator = &IID_IAMTimecodeGenerator_Value;
pub const IAMTimecodeGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCGMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTCGMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_VITCLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                Line: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                Line: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VITCLine: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                pLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                pLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimecode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeGenerator,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeGenerator,
                pTimecodeSample: ?*TIMECODE_SAMPLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_GetTCGMode(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).GetTCGMode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_SetTCGMode(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).SetTCGMode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), Param, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_put_VITCLine(self: *const T, Line: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).put_VITCLine(@as(*const IAMTimecodeGenerator, @ptrCast(self)), Line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_get_VITCLine(self: *const T, pLine: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).get_VITCLine(@as(*const IAMTimecodeGenerator, @ptrCast(self)), pLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_SetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).SetTimecode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), pTimecodeSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeGenerator_GetTimecode(self: *const T, pTimecodeSample: ?*TIMECODE_SAMPLE) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeGenerator.VTable, @ptrCast(self.vtable)).GetTimecode(@as(*const IAMTimecodeGenerator, @ptrCast(self)), pTimecodeSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMTimecodeDisplay_Value = Guid.initString("9b496ce2-811b-11cf-8c77-00aa006b6814");
pub const IID_IAMTimecodeDisplay = &IID_IAMTimecodeDisplay_Value;
pub const IAMTimecodeDisplay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTCDisplayEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeDisplay,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeDisplay,
                pState: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTCDisplayEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeDisplay,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeDisplay,
                State: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTCDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeDisplay,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeDisplay,
                Param: i32,
                pValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTCDisplay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMTimecodeDisplay,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMTimecodeDisplay,
                Param: i32,
                Value: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_GetTCDisplayEnable(self: *const T, pState: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).GetTCDisplayEnable(@as(*const IAMTimecodeDisplay, @ptrCast(self)), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_SetTCDisplayEnable(self: *const T, State: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).SetTCDisplayEnable(@as(*const IAMTimecodeDisplay, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_GetTCDisplay(self: *const T, Param: i32, pValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).GetTCDisplay(@as(*const IAMTimecodeDisplay, @ptrCast(self)), Param, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMTimecodeDisplay_SetTCDisplay(self: *const T, Param: i32, Value: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMTimecodeDisplay.VTable, @ptrCast(self.vtable)).SetTCDisplay(@as(*const IAMTimecodeDisplay, @ptrCast(self)), Param, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryAllocator_Value = Guid.initString("c6545bf0-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryAllocator = &IID_IAMDevMemoryAllocator_Value;
pub const IAMDevMemoryAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryAllocator,
                pdwcbTotalFree: ?*u32,
                pdwcbLargestFree: ?*u32,
                pdwcbTotalMemory: ?*u32,
                pdwcbMinimumChunk: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryAllocator,
                pdwcbTotalFree: ?*u32,
                pdwcbLargestFree: ?*u32,
                pdwcbTotalMemory: ?*u32,
                pdwcbMinimumChunk: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckMemory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryAllocator,
                pBuffer: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryAllocator,
                pBuffer: ?*const u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Alloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryAllocator,
                ppBuffer: ?*?*u8,
                pdwcbBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryAllocator,
                ppBuffer: ?*?*u8,
                pdwcbBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Free: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryAllocator,
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryAllocator,
                pBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevMemoryObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryAllocator,
                ppUnkInnner: ?*?*IUnknown,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryAllocator,
                ppUnkInnner: ?*?*IUnknown,
                pUnkOuter: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_GetInfo(self: *const T, pdwcbTotalFree: ?*u32, pdwcbLargestFree: ?*u32, pdwcbTotalMemory: ?*u32, pdwcbMinimumChunk: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pdwcbTotalFree, pdwcbLargestFree, pdwcbTotalMemory, pdwcbMinimumChunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_CheckMemory(self: *const T, pBuffer: ?*const u8) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).CheckMemory(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_Alloc(self: *const T, ppBuffer: ?*?*u8, pdwcbBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), ppBuffer, pdwcbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_Free(self: *const T, pBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).Free(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryAllocator_GetDevMemoryObject(self: *const T, ppUnkInnner: ?*?*IUnknown, pUnkOuter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryAllocator.VTable, @ptrCast(self.vtable)).GetDevMemoryObject(@as(*const IAMDevMemoryAllocator, @ptrCast(self)), ppUnkInnner, pUnkOuter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMDevMemoryControl_Value = Guid.initString("c6545bf1-e76b-11d0-bd52-00a0c911ce86");
pub const IID_IAMDevMemoryControl = &IID_IAMDevMemoryControl_Value;
pub const IAMDevMemoryControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryWriteSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WriteSync: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDevId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDevMemoryControl,
                pdwDevId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDevMemoryControl,
                pdwDevId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_QueryWriteSync(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).QueryWriteSync(@as(*const IAMDevMemoryControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_WriteSync(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).WriteSync(@as(*const IAMDevMemoryControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDevMemoryControl_GetDevId(self: *const T, pdwDevId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMDevMemoryControl.VTable, @ptrCast(self.vtable)).GetDevId(@as(*const IAMDevMemoryControl, @ptrCast(self)), pdwDevId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AMSTREAMSELECTINFOFLAGS = enum(i32) {
    NABLED = 1,
    XCLUSIVE = 2,
};
pub const AMSTREAMSELECTINFO_ENABLED = _AMSTREAMSELECTINFOFLAGS.NABLED;
pub const AMSTREAMSELECTINFO_EXCLUSIVE = _AMSTREAMSELECTINFOFLAGS.XCLUSIVE;

pub const _AMSTREAMSELECTENABLEFLAGS = enum(i32) {
    E = 1,
    ALL = 2,
};
pub const AMSTREAMSELECTENABLE_ENABLE = _AMSTREAMSELECTENABLEFLAGS.E;
pub const AMSTREAMSELECTENABLE_ENABLEALL = _AMSTREAMSELECTENABLEFLAGS.ALL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMStreamSelect_Value = Guid.initString("c1960960-17f5-11d1-abe1-00a0c905f375");
pub const IID_IAMStreamSelect = &IID_IAMStreamSelect_Value;
pub const IAMStreamSelect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Count: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamSelect,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamSelect,
                pcStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Info: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamSelect,
                lIndex: i32,
                ppmt: ?*?*AM_MEDIA_TYPE,
                pdwFlags: ?*u32,
                plcid: ?*u32,
                pdwGroup: ?*u32,
                ppszName: ?*?PWSTR,
                ppObject: ?*?*IUnknown,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamSelect,
                lIndex: i32,
                ppmt: ?*?*AM_MEDIA_TYPE,
                pdwFlags: ?*u32,
                plcid: ?*u32,
                pdwGroup: ?*u32,
                ppszName: ?*?PWSTR,
                ppObject: ?*?*IUnknown,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Enable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStreamSelect,
                lIndex: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStreamSelect,
                lIndex: i32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Count(self: *const T, pcStreams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Count(@as(*const IAMStreamSelect, @ptrCast(self)), pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Info(self: *const T, lIndex: i32, ppmt: ?*?*AM_MEDIA_TYPE, pdwFlags: ?*u32, plcid: ?*u32, pdwGroup: ?*u32, ppszName: ?*?PWSTR, ppObject: ?*?*IUnknown, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Info(@as(*const IAMStreamSelect, @ptrCast(self)), lIndex, ppmt, pdwFlags, plcid, pdwGroup, ppszName, ppObject, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStreamSelect_Enable(self: *const T, lIndex: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMStreamSelect.VTable, @ptrCast(self.vtable)).Enable(@as(*const IAMStreamSelect, @ptrCast(self)), lIndex, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AMRESCTL_RESERVEFLAGS = enum(i32) {
    RESERVE = 0,
    UNRESERVE = 1,
};
pub const AMRESCTL_RESERVEFLAGS_RESERVE = _AMRESCTL_RESERVEFLAGS.RESERVE;
pub const AMRESCTL_RESERVEFLAGS_UNRESERVE = _AMRESCTL_RESERVEFLAGS.UNRESERVE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMResourceControl_Value = Guid.initString("8389d2d0-77d7-11d1-abe6-00a0c905f375");
pub const IID_IAMResourceControl = &IID_IAMResourceControl_Value;
pub const IAMResourceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reserve: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMResourceControl,
                dwFlags: u32,
                pvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMResourceControl,
                dwFlags: u32,
                pvReserved: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMResourceControl_Reserve(self: *const T, dwFlags: u32, pvReserved: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IAMResourceControl.VTable, @ptrCast(self.vtable)).Reserve(@as(*const IAMResourceControl, @ptrCast(self)), dwFlags, pvReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMClockAdjust_Value = Guid.initString("4d5466b0-a49c-11d1-abe8-00a0c905f375");
pub const IID_IAMClockAdjust = &IID_IAMClockAdjust_Value;
pub const IAMClockAdjust = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetClockDelta: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMClockAdjust,
                rtDelta: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMClockAdjust,
                rtDelta: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockAdjust_SetClockDelta(self: *const T, rtDelta: i64) callconv(.Inline) HRESULT {
            return @as(*const IAMClockAdjust.VTable, @ptrCast(self.vtable)).SetClockDelta(@as(*const IAMClockAdjust, @ptrCast(self)), rtDelta);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_FILTER_MISC_FLAGS = enum(i32) {
    RENDERER = 1,
    SOURCE = 2,
};
pub const AM_FILTER_MISC_FLAGS_IS_RENDERER = _AM_FILTER_MISC_FLAGS.RENDERER;
pub const AM_FILTER_MISC_FLAGS_IS_SOURCE = _AM_FILTER_MISC_FLAGS.SOURCE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterMiscFlags_Value = Guid.initString("2dd74950-a890-11d1-abe8-00a0c905f375");
pub const IID_IAMFilterMiscFlags = &IID_IAMFilterMiscFlags_Value;
pub const IAMFilterMiscFlags = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMiscFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMFilterMiscFlags,
            ) callconv(@import("std").os.windows.WINAPI) u32,
            else => *const fn(
                self: *const IAMFilterMiscFlags,
            ) callconv(@import("std").os.windows.WINAPI) u32,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMFilterMiscFlags_GetMiscFlags(self: *const T) callconv(.Inline) u32 {
            return @as(*const IAMFilterMiscFlags.VTable, @ptrCast(self.vtable)).GetMiscFlags(@as(*const IAMFilterMiscFlags, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDrawVideoImage_Value = Guid.initString("48efb120-ab49-11d2-aed2-00a0c995e8d5");
pub const IID_IDrawVideoImage = &IID_IDrawVideoImage_Value;
pub const IDrawVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DrawVideoImageBegin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDrawVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDrawVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawVideoImageEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDrawVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDrawVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DrawVideoImageDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDrawVideoImage,
                hdc: ?HDC,
                lprcSrc: ?*RECT,
                lprcDst: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDrawVideoImage,
                hdc: ?HDC,
                lprcSrc: ?*RECT,
                lprcDst: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageBegin(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageBegin(@as(*const IDrawVideoImage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageEnd(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageEnd(@as(*const IDrawVideoImage, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDrawVideoImage_DrawVideoImageDraw(self: *const T, hdc: ?HDC, lprcSrc: ?*RECT, lprcDst: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IDrawVideoImage.VTable, @ptrCast(self.vtable)).DrawVideoImageDraw(@as(*const IDrawVideoImage, @ptrCast(self)), hdc, lprcSrc, lprcDst);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDecimateVideoImage_Value = Guid.initString("2e5ea3e0-e924-11d2-b6da-00a0c995e8df");
pub const IID_IDecimateVideoImage = &IID_IDecimateVideoImage_Value;
pub const IDecimateVideoImage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDecimationImageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDecimateVideoImage,
                lWidth: i32,
                lHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDecimateVideoImage,
                lWidth: i32,
                lHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetDecimationImageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDecimateVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDecimateVideoImage,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDecimateVideoImage_SetDecimationImageSize(self: *const T, lWidth: i32, lHeight: i32) callconv(.Inline) HRESULT {
            return @as(*const IDecimateVideoImage.VTable, @ptrCast(self.vtable)).SetDecimationImageSize(@as(*const IDecimateVideoImage, @ptrCast(self)), lWidth, lHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDecimateVideoImage_ResetDecimationImageSize(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDecimateVideoImage.VTable, @ptrCast(self.vtable)).ResetDecimationImageSize(@as(*const IDecimateVideoImage, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DECIMATION_USAGE = enum(i32) {
    LEGACY = 0,
    USE_DECODER_ONLY = 1,
    USE_VIDEOPORT_ONLY = 2,
    USE_OVERLAY_ONLY = 3,
    DEFAULT = 4,
};
pub const DECIMATION_LEGACY = DECIMATION_USAGE.LEGACY;
pub const DECIMATION_USE_DECODER_ONLY = DECIMATION_USAGE.USE_DECODER_ONLY;
pub const DECIMATION_USE_VIDEOPORT_ONLY = DECIMATION_USAGE.USE_VIDEOPORT_ONLY;
pub const DECIMATION_USE_OVERLAY_ONLY = DECIMATION_USAGE.USE_OVERLAY_ONLY;
pub const DECIMATION_DEFAULT = DECIMATION_USAGE.DEFAULT;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMVideoDecimationProperties_Value = Guid.initString("60d32930-13da-11d3-9ec6-c4fcaef5c7be");
pub const IID_IAMVideoDecimationProperties = &IID_IAMVideoDecimationProperties_Value;
pub const IAMVideoDecimationProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryDecimationUsage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoDecimationProperties,
                lpUsage: ?*DECIMATION_USAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoDecimationProperties,
                lpUsage: ?*DECIMATION_USAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDecimationUsage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoDecimationProperties,
                Usage: DECIMATION_USAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoDecimationProperties,
                Usage: DECIMATION_USAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoDecimationProperties_QueryDecimationUsage(self: *const T, lpUsage: ?*DECIMATION_USAGE) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoDecimationProperties.VTable, @ptrCast(self.vtable)).QueryDecimationUsage(@as(*const IAMVideoDecimationProperties, @ptrCast(self)), lpUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoDecimationProperties_SetDecimationUsage(self: *const T, Usage: DECIMATION_USAGE) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoDecimationProperties.VTable, @ptrCast(self.vtable)).SetDecimationUsage(@as(*const IAMVideoDecimationProperties, @ptrCast(self)), Usage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoFrameStep_Value = Guid.initString("e46a9787-2b71-444d-a4b5-1fab7b708d6a");
pub const IID_IVideoFrameStep = &IID_IVideoFrameStep_Value;
pub const IVideoFrameStep = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Step: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoFrameStep,
                dwFrames: u32,
                pStepObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoFrameStep,
                dwFrames: u32,
                pStepObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoFrameStep,
                bMultiple: i32,
                pStepObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoFrameStep,
                bMultiple: i32,
                pStepObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelStep: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoFrameStep,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoFrameStep,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_Step(self: *const T, dwFrames: u32, pStepObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).Step(@as(*const IVideoFrameStep, @ptrCast(self)), dwFrames, pStepObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_CanStep(self: *const T, bMultiple: i32, pStepObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).CanStep(@as(*const IVideoFrameStep, @ptrCast(self)), bMultiple, pStepObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoFrameStep_CancelStep(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVideoFrameStep.VTable, @ptrCast(self.vtable)).CancelStep(@as(*const IVideoFrameStep, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PUSHSOURCE_FLAGS = enum(i32) {
    CAPS_INTERNAL_RM = 1,
    CAPS_NOT_LIVE = 2,
    CAPS_PRIVATE_CLOCK = 4,
    REQS_USE_STREAM_CLOCK = 65536,
    REQS_USE_CLOCK_CHAIN = 131072,
};
pub const AM_PUSHSOURCECAPS_INTERNAL_RM = _AM_PUSHSOURCE_FLAGS.CAPS_INTERNAL_RM;
pub const AM_PUSHSOURCECAPS_NOT_LIVE = _AM_PUSHSOURCE_FLAGS.CAPS_NOT_LIVE;
pub const AM_PUSHSOURCECAPS_PRIVATE_CLOCK = _AM_PUSHSOURCE_FLAGS.CAPS_PRIVATE_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_STREAM_CLOCK = _AM_PUSHSOURCE_FLAGS.REQS_USE_STREAM_CLOCK;
pub const AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN = _AM_PUSHSOURCE_FLAGS.REQS_USE_CLOCK_CHAIN;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMLatency_Value = Guid.initString("62ea93ba-ec62-11d2-b770-00c04fb6bd3d");
pub const IID_IAMLatency = &IID_IAMLatency_Value;
pub const IAMLatency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLatency,
                prtLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLatency,
                prtLatency: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLatency_GetLatency(self: *const T, prtLatency: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMLatency.VTable, @ptrCast(self.vtable)).GetLatency(@as(*const IAMLatency, @ptrCast(self)), prtLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMPushSource_Value = Guid.initString("f185fe76-e64e-11d2-b76e-00c04fb6bd3d");
pub const IID_IAMPushSource = &IID_IAMPushSource_Value;
pub const IAMPushSource = extern struct {
    pub const VTable = extern struct {
        base: IAMLatency.VTable,
        GetPushSourceFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                pFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPushSourceFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                rtOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                rtOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                prtOffset: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                prtOffset: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxStreamOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                prtMaxOffset: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                prtMaxOffset: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxStreamOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPushSource,
                rtMaxOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPushSource,
                rtMaxOffset: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IAMLatency.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetPushSourceFlags(self: *const T, pFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetPushSourceFlags(@as(*const IAMPushSource, @ptrCast(self)), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetPushSourceFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetPushSourceFlags(@as(*const IAMPushSource, @ptrCast(self)), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetStreamOffset(self: *const T, rtOffset: i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), rtOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetStreamOffset(self: *const T, prtOffset: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), prtOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_GetMaxStreamOffset(self: *const T, prtMaxOffset: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).GetMaxStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), prtMaxOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPushSource_SetMaxStreamOffset(self: *const T, rtMaxOffset: i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPushSource.VTable, @ptrCast(self.vtable)).SetMaxStreamOffset(@as(*const IAMPushSource, @ptrCast(self)), rtMaxOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDeviceRemoval_Value = Guid.initString("f90a6130-b658-11d2-ae49-0000f8754b99");
pub const IID_IAMDeviceRemoval = &IID_IAMDeviceRemoval_Value;
pub const IAMDeviceRemoval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeviceInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDeviceRemoval,
                pclsidInterfaceClass: ?*Guid,
                pwszSymbolicLink: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDeviceRemoval,
                pclsidInterfaceClass: ?*Guid,
                pwszSymbolicLink: ?*?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reassociate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDeviceRemoval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDeviceRemoval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disassociate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDeviceRemoval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDeviceRemoval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_DeviceInfo(self: *const T, pclsidInterfaceClass: ?*Guid, pwszSymbolicLink: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).DeviceInfo(@as(*const IAMDeviceRemoval, @ptrCast(self)), pclsidInterfaceClass, pwszSymbolicLink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_Reassociate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).Reassociate(@as(*const IAMDeviceRemoval, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDeviceRemoval_Disassociate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMDeviceRemoval.VTable, @ptrCast(self.vtable)).Disassociate(@as(*const IAMDeviceRemoval, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVINFO = extern struct {
    dwDVAAuxSrc: u32,
    dwDVAAuxCtl: u32,
    dwDVAAuxSrc1: u32,
    dwDVAAuxCtl1: u32,
    dwDVVAuxSrc: u32,
    dwDVVAuxCtl: u32,
    dwDVReserved: [2]u32,
};

pub const _DVENCODERRESOLUTION = enum(i32) {
    @"720x480" = 2012,
    @"360x240" = 2013,
    @"180x120" = 2014,
    @"88x60" = 2015,
};
pub const DVENCODERRESOLUTION_720x480 = _DVENCODERRESOLUTION.@"720x480";
pub const DVENCODERRESOLUTION_360x240 = _DVENCODERRESOLUTION.@"360x240";
pub const DVENCODERRESOLUTION_180x120 = _DVENCODERRESOLUTION.@"180x120";
pub const DVENCODERRESOLUTION_88x60 = _DVENCODERRESOLUTION.@"88x60";

pub const _DVENCODERVIDEOFORMAT = enum(i32) {
    NTSC = 2000,
    PAL = 2001,
};
pub const DVENCODERVIDEOFORMAT_NTSC = _DVENCODERVIDEOFORMAT.NTSC;
pub const DVENCODERVIDEOFORMAT_PAL = _DVENCODERVIDEOFORMAT.PAL;

pub const _DVENCODERFORMAT = enum(i32) {
    SD = 2007,
    HD = 2008,
    SL = 2009,
};
pub const DVENCODERFORMAT_DVSD = _DVENCODERFORMAT.SD;
pub const DVENCODERFORMAT_DVHD = _DVENCODERFORMAT.HD;
pub const DVENCODERFORMAT_DVSL = _DVENCODERFORMAT.SL;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDVEnc_Value = Guid.initString("d18e17a0-aacb-11d0-afb0-00aa00b67a42");
pub const IID_IDVEnc = &IID_IDVEnc_Value;
pub const IDVEnc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_IFormatResolution: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVEnc,
                VideoFormat: ?*i32,
                DVFormat: ?*i32,
                Resolution: ?*i32,
                fDVInfo: u8,
                sDVInfo: ?*DVINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVEnc,
                VideoFormat: ?*i32,
                DVFormat: ?*i32,
                Resolution: ?*i32,
                fDVInfo: u8,
                sDVInfo: ?*DVINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_IFormatResolution: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVEnc,
                VideoFormat: i32,
                DVFormat: i32,
                Resolution: i32,
                fDVInfo: u8,
                sDVInfo: ?*DVINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVEnc,
                VideoFormat: i32,
                DVFormat: i32,
                Resolution: i32,
                fDVInfo: u8,
                sDVInfo: ?*DVINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVEnc_get_IFormatResolution(self: *const T, VideoFormat: ?*i32, DVFormat: ?*i32, Resolution: ?*i32, fDVInfo: u8, sDVInfo: ?*DVINFO) callconv(.Inline) HRESULT {
            return @as(*const IDVEnc.VTable, @ptrCast(self.vtable)).get_IFormatResolution(@as(*const IDVEnc, @ptrCast(self)), VideoFormat, DVFormat, Resolution, fDVInfo, sDVInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVEnc_put_IFormatResolution(self: *const T, VideoFormat: i32, DVFormat: i32, Resolution: i32, fDVInfo: u8, sDVInfo: ?*DVINFO) callconv(.Inline) HRESULT {
            return @as(*const IDVEnc.VTable, @ptrCast(self.vtable)).put_IFormatResolution(@as(*const IDVEnc, @ptrCast(self)), VideoFormat, DVFormat, Resolution, fDVInfo, sDVInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _DVDECODERRESOLUTION = enum(i32) {
    @"720x480" = 1000,
    @"360x240" = 1001,
    @"180x120" = 1002,
    @"88x60" = 1003,
};
pub const DVDECODERRESOLUTION_720x480 = _DVDECODERRESOLUTION.@"720x480";
pub const DVDECODERRESOLUTION_360x240 = _DVDECODERRESOLUTION.@"360x240";
pub const DVDECODERRESOLUTION_180x120 = _DVDECODERRESOLUTION.@"180x120";
pub const DVDECODERRESOLUTION_88x60 = _DVDECODERRESOLUTION.@"88x60";

pub const _DVRESOLUTION = enum(i32) {
    FULL = 1000,
    HALF = 1001,
    QUARTER = 1002,
    DC = 1003,
};
pub const DVRESOLUTION_FULL = _DVRESOLUTION.FULL;
pub const DVRESOLUTION_HALF = _DVRESOLUTION.HALF;
pub const DVRESOLUTION_QUARTER = _DVRESOLUTION.QUARTER;
pub const DVRESOLUTION_DC = _DVRESOLUTION.DC;

// TODO: this type is limited to platform 'windows5.0'
const IID_IIPDVDec_Value = Guid.initString("b8e8bd60-0bfe-11d0-af91-00aa00b67a42");
pub const IID_IIPDVDec = &IID_IIPDVDec_Value;
pub const IIPDVDec = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IPDisplay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIPDVDec,
                displayPix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIPDVDec,
                displayPix: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IPDisplay: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IIPDVDec,
                displayPix: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IIPDVDec,
                displayPix: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIPDVDec_get_IPDisplay(self: *const T, displayPix: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IIPDVDec.VTable, @ptrCast(self.vtable)).get_IPDisplay(@as(*const IIPDVDec, @ptrCast(self)), displayPix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIPDVDec_put_IPDisplay(self: *const T, displayPix: i32) callconv(.Inline) HRESULT {
            return @as(*const IIPDVDec.VTable, @ptrCast(self.vtable)).put_IPDisplay(@as(*const IIPDVDec, @ptrCast(self)), displayPix);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVRGB219_Value = Guid.initString("58473a19-2bc8-4663-8012-25f81babddd1");
pub const IID_IDVRGB219 = &IID_IDVRGB219_Value;
pub const IDVRGB219 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRGB219: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVRGB219,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVRGB219,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVRGB219_SetRGB219(self: *const T, bState: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDVRGB219.VTable, @ptrCast(self.vtable)).SetRGB219(@as(*const IDVRGB219, @ptrCast(self)), bState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDVSplitter_Value = Guid.initString("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02");
pub const IID_IDVSplitter = &IID_IDVSplitter_Value;
pub const IDVSplitter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DiscardAlternateVideoFrames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDVSplitter,
                nDiscard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDVSplitter,
                nDiscard: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDVSplitter_DiscardAlternateVideoFrames(self: *const T, nDiscard: i32) callconv(.Inline) HRESULT {
            return @as(*const IDVSplitter.VTable, @ptrCast(self.vtable)).DiscardAlternateVideoFrames(@as(*const IDVSplitter, @ptrCast(self)), nDiscard);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_AUDIO_RENDERER_STAT_PARAM = enum(i32) {
    BREAK_COUNT = 1,
    SLAVE_MODE = 2,
    SILENCE_DUR = 3,
    LAST_BUFFER_DUR = 4,
    DISCONTINUITIES = 5,
    SLAVE_RATE = 6,
    SLAVE_DROPWRITE_DUR = 7,
    SLAVE_HIGHLOWERROR = 8,
    SLAVE_LASTHIGHLOWERROR = 9,
    SLAVE_ACCUMERROR = 10,
    BUFFERFULLNESS = 11,
    JITTER = 12,
};
pub const AM_AUDREND_STAT_PARAM_BREAK_COUNT = _AM_AUDIO_RENDERER_STAT_PARAM.BREAK_COUNT;
pub const AM_AUDREND_STAT_PARAM_SLAVE_MODE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_MODE;
pub const AM_AUDREND_STAT_PARAM_SILENCE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SILENCE_DUR;
pub const AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.LAST_BUFFER_DUR;
pub const AM_AUDREND_STAT_PARAM_DISCONTINUITIES = _AM_AUDIO_RENDERER_STAT_PARAM.DISCONTINUITIES;
pub const AM_AUDREND_STAT_PARAM_SLAVE_RATE = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_RATE;
pub const AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_DROPWRITE_DUR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_HIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_LASTHIGHLOWERROR;
pub const AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR = _AM_AUDIO_RENDERER_STAT_PARAM.SLAVE_ACCUMERROR;
pub const AM_AUDREND_STAT_PARAM_BUFFERFULLNESS = _AM_AUDIO_RENDERER_STAT_PARAM.BUFFERFULLNESS;
pub const AM_AUDREND_STAT_PARAM_JITTER = _AM_AUDIO_RENDERER_STAT_PARAM.JITTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMAudioRendererStats_Value = Guid.initString("22320cb2-d41a-11d2-bf7c-d7cb9df0bf93");
pub const IID_IAMAudioRendererStats = &IID_IAMAudioRendererStats_Value;
pub const IAMAudioRendererStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMAudioRendererStats,
                dwParam: u32,
                pdwParam1: ?*u32,
                pdwParam2: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMAudioRendererStats,
                dwParam: u32,
                pdwParam1: ?*u32,
                pdwParam2: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAudioRendererStats_GetStatParam(self: *const T, dwParam: u32, pdwParam1: ?*u32, pdwParam2: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMAudioRendererStats.VTable, @ptrCast(self.vtable)).GetStatParam(@as(*const IAMAudioRendererStats, @ptrCast(self)), dwParam, pdwParam1, pdwParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_INTF_SEARCH_FLAGS = enum(i32) {
    INPUT_PIN = 1,
    OUTPUT_PIN = 2,
    FILTER = 4,
};
pub const AM_INTF_SEARCH_INPUT_PIN = _AM_INTF_SEARCH_FLAGS.INPUT_PIN;
pub const AM_INTF_SEARCH_OUTPUT_PIN = _AM_INTF_SEARCH_FLAGS.OUTPUT_PIN;
pub const AM_INTF_SEARCH_FILTER = _AM_INTF_SEARCH_FLAGS.FILTER;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMGraphStreams_Value = Guid.initString("632105fa-072e-11d3-8af9-00c04fb6bd3d");
pub const IID_IAMGraphStreams = &IID_IAMGraphStreams_Value;
pub const IAMGraphStreams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindUpstreamInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMGraphStreams,
                pPin: ?*IPin,
                riid: ?*const Guid,
                ppvInterface: ?*?*anyopaque,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMGraphStreams,
                pPin: ?*IPin,
                riid: ?*const Guid,
                ppvInterface: ?*?*anyopaque,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SyncUsingStreamOffset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMGraphStreams,
                bUseStreamOffset: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMGraphStreams,
                bUseStreamOffset: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxGraphLatency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMGraphStreams,
                rtMaxGraphLatency: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMGraphStreams,
                rtMaxGraphLatency: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_FindUpstreamInterface(self: *const T, pPin: ?*IPin, riid: ?*const Guid, ppvInterface: ?*?*anyopaque, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).FindUpstreamInterface(@as(*const IAMGraphStreams, @ptrCast(self)), pPin, riid, ppvInterface, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_SyncUsingStreamOffset(self: *const T, bUseStreamOffset: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).SyncUsingStreamOffset(@as(*const IAMGraphStreams, @ptrCast(self)), bUseStreamOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphStreams_SetMaxGraphLatency(self: *const T, rtMaxGraphLatency: i64) callconv(.Inline) HRESULT {
            return @as(*const IAMGraphStreams.VTable, @ptrCast(self.vtable)).SetMaxGraphLatency(@as(*const IAMGraphStreams, @ptrCast(self)), rtMaxGraphLatency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMOVERLAYFX = enum(i32) {
    NOFX = 0,
    MIRRORLEFTRIGHT = 2,
    MIRRORUPDOWN = 4,
    DEINTERLACE = 8,
};
pub const AMOVERFX_NOFX = AMOVERLAYFX.NOFX;
pub const AMOVERFX_MIRRORLEFTRIGHT = AMOVERLAYFX.MIRRORLEFTRIGHT;
pub const AMOVERFX_MIRRORUPDOWN = AMOVERLAYFX.MIRRORUPDOWN;
pub const AMOVERFX_DEINTERLACE = AMOVERLAYFX.DEINTERLACE;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMOverlayFX_Value = Guid.initString("62fae250-7e65-4460-bfc9-6398b322073c");
pub const IID_IAMOverlayFX = &IID_IAMOverlayFX_Value;
pub const IAMOverlayFX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryOverlayFXCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMOverlayFX,
                lpdwOverlayFXCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMOverlayFX,
                lpdwOverlayFXCaps: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOverlayFX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMOverlayFX,
                dwOverlayFX: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMOverlayFX,
                dwOverlayFX: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlayFX: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMOverlayFX,
                lpdwOverlayFX: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMOverlayFX,
                lpdwOverlayFX: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_QueryOverlayFXCaps(self: *const T, lpdwOverlayFXCaps: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).QueryOverlayFXCaps(@as(*const IAMOverlayFX, @ptrCast(self)), lpdwOverlayFXCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_SetOverlayFX(self: *const T, dwOverlayFX: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).SetOverlayFX(@as(*const IAMOverlayFX, @ptrCast(self)), dwOverlayFX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOverlayFX_GetOverlayFX(self: *const T, lpdwOverlayFX: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMOverlayFX.VTable, @ptrCast(self.vtable)).GetOverlayFX(@as(*const IAMOverlayFX, @ptrCast(self)), lpdwOverlayFX);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMOpenProgress_Value = Guid.initString("8e1c39a1-de53-11cf-aa63-0080c744528d");
pub const IID_IAMOpenProgress = &IID_IAMOpenProgress_Value;
pub const IAMOpenProgress = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryProgress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMOpenProgress,
                pllTotal: ?*i64,
                pllCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMOpenProgress,
                pllTotal: ?*i64,
                pllCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AbortOperation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMOpenProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMOpenProgress,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOpenProgress_QueryProgress(self: *const T, pllTotal: ?*i64, pllCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMOpenProgress.VTable, @ptrCast(self.vtable)).QueryProgress(@as(*const IAMOpenProgress, @ptrCast(self)), pllTotal, pllCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMOpenProgress_AbortOperation(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMOpenProgress.VTable, @ptrCast(self.vtable)).AbortOperation(@as(*const IAMOpenProgress, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMpeg2Demultiplexer_Value = Guid.initString("436eee9c-264f-4242-90e1-4e330c107512");
pub const IID_IMpeg2Demultiplexer = &IID_IMpeg2Demultiplexer_Value;
pub const IMpeg2Demultiplexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateOutputPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Demultiplexer,
                pMediaType: ?*AM_MEDIA_TYPE,
                pszPinName: ?PWSTR,
                ppIPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Demultiplexer,
                pMediaType: ?*AM_MEDIA_TYPE,
                pszPinName: ?PWSTR,
                ppIPin: ?*?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputPinMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Demultiplexer,
                pszPinName: ?PWSTR,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Demultiplexer,
                pszPinName: ?PWSTR,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteOutputPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMpeg2Demultiplexer,
                pszPinName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMpeg2Demultiplexer,
                pszPinName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_CreateOutputPin(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, pszPinName: ?PWSTR, ppIPin: ?*?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).CreateOutputPin(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), pMediaType, pszPinName, ppIPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_SetOutputPinMediaType(self: *const T, pszPinName: ?PWSTR, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).SetOutputPinMediaType(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), pszPinName, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpeg2Demultiplexer_DeleteOutputPin(self: *const T, pszPinName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const IMpeg2Demultiplexer.VTable, @ptrCast(self.vtable)).DeleteOutputPin(@as(*const IMpeg2Demultiplexer, @ptrCast(self)), pszPinName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_ID_MAP = extern struct {
    stream_id: u32,
    dwMediaSampleContent: u32,
    ulSubstreamFilterValue: u32,
    iDataOffset: i32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IEnumStreamIdMap_Value = Guid.initString("945c1566-6202-46fc-96c7-d87f289c6534");
pub const IID_IEnumStreamIdMap = &IID_IEnumStreamIdMap_Value;
pub const IEnumStreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamIdMap,
                cRequest: u32,
                pStreamIdMap: [*]STREAM_ID_MAP,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamIdMap,
                cRequest: u32,
                pStreamIdMap: [*]STREAM_ID_MAP,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamIdMap,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamIdMap,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumStreamIdMap,
                ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumStreamIdMap,
                ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Next(self: *const T, cRequest: u32, pStreamIdMap: [*]STREAM_ID_MAP, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumStreamIdMap, @ptrCast(self)), cRequest, pStreamIdMap, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumStreamIdMap, @ptrCast(self)), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumStreamIdMap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumStreamIdMap_Clone(self: *const T, ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap) callconv(.Inline) HRESULT {
            return @as(*const IEnumStreamIdMap.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumStreamIdMap, @ptrCast(self)), ppIEnumStreamIdMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2StreamIdMap_Value = Guid.initString("d0e04c47-25b8-4369-925a-362a01d95444");
pub const IID_IMPEG2StreamIdMap = &IID_IMPEG2StreamIdMap_Value;
pub const IMPEG2StreamIdMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2StreamIdMap,
                ulStreamId: u32,
                MediaSampleContent: u32,
                ulSubstreamFilterValue: u32,
                iDataOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2StreamIdMap,
                ulStreamId: u32,
                MediaSampleContent: u32,
                ulSubstreamFilterValue: u32,
                iDataOffset: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnmapStreamId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2StreamIdMap,
                culStreamId: u32,
                pulStreamId: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2StreamIdMap,
                culStreamId: u32,
                pulStreamId: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumStreamIdMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2StreamIdMap,
                ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2StreamIdMap,
                ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_MapStreamId(self: *const T, ulStreamId: u32, MediaSampleContent: u32, ulSubstreamFilterValue: u32, iDataOffset: i32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).MapStreamId(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), ulStreamId, MediaSampleContent, ulSubstreamFilterValue, iDataOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_UnmapStreamId(self: *const T, culStreamId: u32, pulStreamId: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).UnmapStreamId(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), culStreamId, pulStreamId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2StreamIdMap_EnumStreamIdMap(self: *const T, ppIEnumStreamIdMap: ?*?*IEnumStreamIdMap) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2StreamIdMap.VTable, @ptrCast(self.vtable)).EnumStreamIdMap(@as(*const IMPEG2StreamIdMap, @ptrCast(self)), ppIEnumStreamIdMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IRegisterServiceProvider_Value = Guid.initString("7b3a2f01-0751-48dd-b556-004785171c54");
pub const IID_IRegisterServiceProvider = &IID_IRegisterServiceProvider_Value;
pub const IRegisterServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegisterServiceProvider,
                guidService: ?*const Guid,
                pUnkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegisterServiceProvider,
                guidService: ?*const Guid,
                pUnkObject: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterServiceProvider_RegisterService(self: *const T, guidService: ?*const Guid, pUnkObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IRegisterServiceProvider.VTable, @ptrCast(self.vtable)).RegisterService(@as(*const IRegisterServiceProvider, @ptrCast(self)), guidService, pUnkObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMClockSlave_Value = Guid.initString("9fd52741-176d-4b36-8f51-ca8f933223be");
pub const IID_IAMClockSlave = &IID_IAMClockSlave_Value;
pub const IAMClockSlave = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetErrorTolerance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMClockSlave,
                dwTolerance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMClockSlave,
                dwTolerance: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetErrorTolerance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMClockSlave,
                pdwTolerance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMClockSlave,
                pdwTolerance: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockSlave_SetErrorTolerance(self: *const T, dwTolerance: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMClockSlave.VTable, @ptrCast(self.vtable)).SetErrorTolerance(@as(*const IAMClockSlave, @ptrCast(self)), dwTolerance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMClockSlave_GetErrorTolerance(self: *const T, pdwTolerance: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMClockSlave.VTable, @ptrCast(self.vtable)).GetErrorTolerance(@as(*const IAMClockSlave, @ptrCast(self)), pdwTolerance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMGraphBuilderCallback_Value = Guid.initString("4995f511-9ddb-4f12-bd3b-f04611807b79");
pub const IID_IAMGraphBuilderCallback = &IID_IAMGraphBuilderCallback_Value;
pub const IAMGraphBuilderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SelectedFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMGraphBuilderCallback,
                pMon: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMGraphBuilderCallback,
                pMon: ?*IMoniker,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatedFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMGraphBuilderCallback,
                pFil: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMGraphBuilderCallback,
                pFil: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphBuilderCallback_SelectedFilter(self: *const T, pMon: ?*IMoniker) callconv(.Inline) HRESULT {
            return @as(*const IAMGraphBuilderCallback.VTable, @ptrCast(self.vtable)).SelectedFilter(@as(*const IAMGraphBuilderCallback, @ptrCast(self)), pMon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMGraphBuilderCallback_CreatedFilter(self: *const T, pFil: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IAMGraphBuilderCallback.VTable, @ptrCast(self.vtable)).CreatedFilter(@as(*const IAMGraphBuilderCallback, @ptrCast(self)), pFil);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMFilterGraphCallback_Value = Guid.initString("56a868fd-0ad4-11ce-b0a3-0020af0ba770");
pub const IID_IAMFilterGraphCallback = &IID_IAMFilterGraphCallback_Value;
pub const IAMFilterGraphCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UnableToRender: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMFilterGraphCallback,
                pPin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMFilterGraphCallback,
                pPin: ?*IPin,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMFilterGraphCallback_UnableToRender(self: *const T, pPin: ?*IPin) callconv(.Inline) HRESULT {
            return @as(*const IAMFilterGraphCallback.VTable, @ptrCast(self.vtable)).UnableToRender(@as(*const IAMFilterGraphCallback, @ptrCast(self)), pPin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGetCapabilitiesKey_Value = Guid.initString("a8809222-07bb-48ea-951c-33158100625b");
pub const IID_IGetCapabilitiesKey = &IID_IGetCapabilitiesKey_Value;
pub const IGetCapabilitiesKey = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilitiesKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGetCapabilitiesKey,
                pHKey: ?*?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGetCapabilitiesKey,
                pHKey: ?*?HKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetCapabilitiesKey_GetCapabilitiesKey(self: *const T, pHKey: ?*?HKEY) callconv(.Inline) HRESULT {
            return @as(*const IGetCapabilitiesKey.VTable, @ptrCast(self.vtable)).GetCapabilitiesKey(@as(*const IGetCapabilitiesKey, @ptrCast(self)), pHKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEncoderAPI_Value = Guid.initString("70423839-6acc-4b23-b079-21dbf08156a5");
pub const IID_IEncoderAPI = &IID_IEncoderAPI_Value;
pub const IEncoderAPI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameterRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                ValueMin: ?*VARIANT,
                ValueMax: ?*VARIANT,
                SteppingDelta: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                ValueMin: ?*VARIANT,
                ValueMax: ?*VARIANT,
                SteppingDelta: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParameterValues: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Values: ?*?*VARIANT,
                ValuesCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Values: ?*?*VARIANT,
                ValuesCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEncoderAPI,
                Api: ?*const Guid,
                Value: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_IsSupported(self: *const T, Api: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).IsSupported(@as(*const IEncoderAPI, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_IsAvailable(self: *const T, Api: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).IsAvailable(@as(*const IEncoderAPI, @ptrCast(self)), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetParameterRange(self: *const T, Api: ?*const Guid, ValueMin: ?*VARIANT, ValueMax: ?*VARIANT, SteppingDelta: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetParameterRange(@as(*const IEncoderAPI, @ptrCast(self)), Api, ValueMin, ValueMax, SteppingDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetParameterValues(self: *const T, Api: ?*const Guid, Values: ?*?*VARIANT, ValuesCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetParameterValues(@as(*const IEncoderAPI, @ptrCast(self)), Api, Values, ValuesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetDefaultValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetDefaultValue(@as(*const IEncoderAPI, @ptrCast(self)), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_GetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IEncoderAPI, @ptrCast(self)), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEncoderAPI_SetValue(self: *const T, Api: ?*const Guid, Value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IEncoderAPI.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IEncoderAPI, @ptrCast(self)), Api, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVideoEncoder_Value = Guid.initString("02997c3b-8e1b-460e-9270-545e0de9563e");
pub const IID_IVideoEncoder = &IID_IVideoEncoder_Value;
pub const IVideoEncoder = extern struct {
    pub const VTable = extern struct {
        base: IEncoderAPI.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEncoderAPI.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMDecoderCaps_Value = Guid.initString("c0dff467-d499-4986-972b-e1d9090fa941");
pub const IID_IAMDecoderCaps = &IID_IAMDecoderCaps_Value;
pub const IAMDecoderCaps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDecoderCaps,
                dwCapIndex: u32,
                lpdwCap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDecoderCaps,
                dwCapIndex: u32,
                lpdwCap: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDecoderCaps_GetDecoderCaps(self: *const T, dwCapIndex: u32, lpdwCap: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMDecoderCaps.VTable, @ptrCast(self.vtable)).GetDecoderCaps(@as(*const IAMDecoderCaps, @ptrCast(self)), dwCapIndex, lpdwCap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMCOPPSignature = extern struct {
    Signature: [256]u8,
};

pub const AMCOPPCommand = extern struct {
    macKDI: Guid,
    guidCommandID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    CommandData: [4056]u8,
};

pub const AMCOPPStatusInput = extern struct {
    rApp: Guid,
    guidStatusRequestID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    StatusData: [4056]u8,
};

pub const AMCOPPStatusOutput = extern struct {
    macKDI: Guid,
    cbSizeData: u32,
    COPPStatus: [4076]u8,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMCertifiedOutputProtection_Value = Guid.initString("6feded3e-0ff1-4901-a2f1-43f7012c8515");
pub const IID_IAMCertifiedOutputProtection = &IID_IAMCertifiedOutputProtection_Value;
pub const IAMCertifiedOutputProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyExchange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCertifiedOutputProtection,
                pRandom: ?*Guid,
                VarLenCertGH: ?*?*u8,
                pdwLengthCertGH: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCertifiedOutputProtection,
                pRandom: ?*Guid,
                VarLenCertGH: ?*?*u8,
                pdwLengthCertGH: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SessionSequenceStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCertifiedOutputProtection,
                pSig: ?*AMCOPPSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCertifiedOutputProtection,
                pSig: ?*AMCOPPSignature,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProtectionCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCertifiedOutputProtection,
                cmd: ?*const AMCOPPCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCertifiedOutputProtection,
                cmd: ?*const AMCOPPCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProtectionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCertifiedOutputProtection,
                pStatusInput: ?*const AMCOPPStatusInput,
                pStatusOutput: ?*AMCOPPStatusOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCertifiedOutputProtection,
                pStatusInput: ?*const AMCOPPStatusInput,
                pStatusOutput: ?*AMCOPPStatusOutput,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_KeyExchange(self: *const T, pRandom: ?*Guid, VarLenCertGH: ?*?*u8, pdwLengthCertGH: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).KeyExchange(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), pRandom, VarLenCertGH, pdwLengthCertGH);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_SessionSequenceStart(self: *const T, pSig: ?*AMCOPPSignature) callconv(.Inline) HRESULT {
            return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).SessionSequenceStart(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), pSig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_ProtectionCommand(self: *const T, cmd: ?*const AMCOPPCommand) callconv(.Inline) HRESULT {
            return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).ProtectionCommand(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), cmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCertifiedOutputProtection_ProtectionStatus(self: *const T, pStatusInput: ?*const AMCOPPStatusInput, pStatusOutput: ?*AMCOPPStatusOutput) callconv(.Inline) HRESULT {
            return @as(*const IAMCertifiedOutputProtection.VTable, @ptrCast(self.vtable)).ProtectionStatus(@as(*const IAMCertifiedOutputProtection, @ptrCast(self)), pStatusInput, pStatusOutput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMAsyncReaderTimestampScaling_Value = Guid.initString("cf7b26fc-9a00-485b-8147-3e789d5e8f67");
pub const IID_IAMAsyncReaderTimestampScaling = &IID_IAMAsyncReaderTimestampScaling_Value;
pub const IAMAsyncReaderTimestampScaling = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestampMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMAsyncReaderTimestampScaling,
                pfRaw: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMAsyncReaderTimestampScaling,
                pfRaw: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimestampMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMAsyncReaderTimestampScaling,
                fRaw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMAsyncReaderTimestampScaling,
                fRaw: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAsyncReaderTimestampScaling_GetTimestampMode(self: *const T, pfRaw: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAsyncReaderTimestampScaling.VTable, @ptrCast(self.vtable)).GetTimestampMode(@as(*const IAMAsyncReaderTimestampScaling, @ptrCast(self)), pfRaw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMAsyncReaderTimestampScaling_SetTimestampMode(self: *const T, fRaw: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMAsyncReaderTimestampScaling.VTable, @ptrCast(self.vtable)).SetTimestampMode(@as(*const IAMAsyncReaderTimestampScaling, @ptrCast(self)), fRaw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IAMPluginControl_Value = Guid.initString("0e26a181-f40c-4635-8786-976284b52981");
pub const IID_IAMPluginControl = &IID_IAMPluginControl_Value;
pub const IAMPluginControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreferredClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                subType: ?*const Guid,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                subType: ?*const Guid,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPreferredClsidByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                index: u32,
                subType: ?*Guid,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                index: u32,
                subType: ?*Guid,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreferredClsid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                subType: ?*const Guid,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                subType: ?*const Guid,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                clsid: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDisabledByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                index: u32,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                index: u32,
                clsid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                clsid: ?*const Guid,
                disabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                clsid: ?*const Guid,
                disabled: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLegacyDisabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPluginControl,
                dllName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPluginControl,
                dllName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetPreferredClsid(self: *const T, subType: ?*const Guid, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsid(@as(*const IAMPluginControl, @ptrCast(self)), subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetPreferredClsidByIndex(self: *const T, index: u32, subType: ?*Guid, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetPreferredClsidByIndex(@as(*const IAMPluginControl, @ptrCast(self)), index, subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_SetPreferredClsid(self: *const T, subType: ?*const Guid, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).SetPreferredClsid(@as(*const IAMPluginControl, @ptrCast(self)), subType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_IsDisabled(self: *const T, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).IsDisabled(@as(*const IAMPluginControl, @ptrCast(self)), clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_GetDisabledByIndex(self: *const T, index: u32, clsid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).GetDisabledByIndex(@as(*const IAMPluginControl, @ptrCast(self)), index, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_SetDisabled(self: *const T, clsid: ?*const Guid, disabled: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).SetDisabled(@as(*const IAMPluginControl, @ptrCast(self)), clsid, disabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPluginControl_IsLegacyDisabled(self: *const T, dllName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IAMPluginControl.VTable, @ptrCast(self.vtable)).IsLegacyDisabled(@as(*const IAMPluginControl, @ptrCast(self)), dllName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinConnection_Value = Guid.initString("4a9a62d3-27d4-403d-91e9-89f540e55534");
pub const IID_IPinConnection = &IID_IPinConnection_Value;
pub const IPinConnection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DynamicQueryAccept: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinConnection,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinConnection,
                pmt: ?*const AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinConnection,
                hNotifyEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinConnection,
                hNotifyEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsEndPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DynamicDisconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinConnection,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_DynamicQueryAccept(self: *const T, pmt: ?*const AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).DynamicQueryAccept(@as(*const IPinConnection, @ptrCast(self)), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_NotifyEndOfStream(self: *const T, hNotifyEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).NotifyEndOfStream(@as(*const IPinConnection, @ptrCast(self)), hNotifyEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_IsEndPin(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).IsEndPin(@as(*const IPinConnection, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinConnection_DynamicDisconnect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPinConnection.VTable, @ptrCast(self.vtable)).DynamicDisconnect(@as(*const IPinConnection, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IPinFlowControl_Value = Guid.initString("c56e9858-dbf3-4f6b-8119-384af2060deb");
pub const IID_IPinFlowControl = &IID_IPinFlowControl_Value;
pub const IPinFlowControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Block: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinFlowControl,
                dwBlockFlags: u32,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinFlowControl,
                dwBlockFlags: u32,
                hEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinFlowControl_Block(self: *const T, dwBlockFlags: u32, hEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IPinFlowControl.VTable, @ptrCast(self.vtable)).Block(@as(*const IPinFlowControl, @ptrCast(self)), dwBlockFlags, hEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS = enum(i32) {
    K = 1,
};
pub const AM_PIN_FLOW_CONTROL_BLOCK = _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS.K;

pub const AM_GRAPH_CONFIG_RECONNECT_FLAGS = enum(i32) {
    DIRECTCONNECT = 1,
    CACHE_REMOVED_FILTERS = 2,
    USE_ONLY_CACHED_FILTERS = 4,
};
pub const AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT = AM_GRAPH_CONFIG_RECONNECT_FLAGS.DIRECTCONNECT;
pub const AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.CACHE_REMOVED_FILTERS;
pub const AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS = AM_GRAPH_CONFIG_RECONNECT_FLAGS.USE_ONLY_CACHED_FILTERS;

pub const _REM_FILTER_FLAGS = enum(i32) {
    D = 1,
};
pub const REMFILTERF_LEAVECONNECTED = _REM_FILTER_FLAGS.D;

pub const AM_FILTER_FLAGS = enum(i32) {
    E = 1,
};
pub const AM_FILTER_FLAGS_REMOVABLE = AM_FILTER_FLAGS.E;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfig_Value = Guid.initString("03a1eb8e-32bf-4245-8502-114d08a9cb88");
pub const IID_IGraphConfig = &IID_IGraphConfig_Value;
pub const IGraphConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pOutputPin: ?*IPin,
                pInputPin: ?*IPin,
                pmtFirstConnection: ?*const AM_MEDIA_TYPE,
                pUsingFilter: ?*IBaseFilter,
                hAbortEvent: ?HANDLE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pOutputPin: ?*IPin,
                pInputPin: ?*IPin,
                pmtFirstConnection: ?*const AM_MEDIA_TYPE,
                pUsingFilter: ?*IBaseFilter,
                hAbortEvent: ?HANDLE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reconfigure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pCallback: ?*IGraphConfigCallback,
                pvContext: ?*anyopaque,
                dwFlags: u32,
                hAbortEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pCallback: ?*IGraphConfigCallback,
                pvContext: ?*anyopaque,
                dwFlags: u32,
                hAbortEvent: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddFilterToCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCacheFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pEnum: ?*?*IEnumFilters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFilterFromCache: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PushThroughData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pOutputPin: ?*IPin,
                pConnection: ?*IPinConnection,
                hEventAbort: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pOutputPin: ?*IPin,
                pConnection: ?*IPinConnection,
                hEventAbort: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFilterFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveFilterEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfig,
                pFilter: ?*IBaseFilter,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_Reconnect(self: *const T, pOutputPin: ?*IPin, pInputPin: ?*IPin, pmtFirstConnection: ?*const AM_MEDIA_TYPE, pUsingFilter: ?*IBaseFilter, hAbortEvent: ?HANDLE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).Reconnect(@as(*const IGraphConfig, @ptrCast(self)), pOutputPin, pInputPin, pmtFirstConnection, pUsingFilter, hAbortEvent, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_Reconfigure(self: *const T, pCallback: ?*IGraphConfigCallback, pvContext: ?*anyopaque, dwFlags: u32, hAbortEvent: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).Reconfigure(@as(*const IGraphConfig, @ptrCast(self)), pCallback, pvContext, dwFlags, hAbortEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_AddFilterToCache(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).AddFilterToCache(@as(*const IGraphConfig, @ptrCast(self)), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_EnumCacheFilter(self: *const T, pEnum: ?*?*IEnumFilters) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).EnumCacheFilter(@as(*const IGraphConfig, @ptrCast(self)), pEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_RemoveFilterFromCache(self: *const T, pFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).RemoveFilterFromCache(@as(*const IGraphConfig, @ptrCast(self)), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_GetStartTime(self: *const T, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).GetStartTime(@as(*const IGraphConfig, @ptrCast(self)), prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_PushThroughData(self: *const T, pOutputPin: ?*IPin, pConnection: ?*IPinConnection, hEventAbort: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).PushThroughData(@as(*const IGraphConfig, @ptrCast(self)), pOutputPin, pConnection, hEventAbort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_SetFilterFlags(self: *const T, pFilter: ?*IBaseFilter, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).SetFilterFlags(@as(*const IGraphConfig, @ptrCast(self)), pFilter, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_GetFilterFlags(self: *const T, pFilter: ?*IBaseFilter, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).GetFilterFlags(@as(*const IGraphConfig, @ptrCast(self)), pFilter, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfig_RemoveFilterEx(self: *const T, pFilter: ?*IBaseFilter, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfig.VTable, @ptrCast(self.vtable)).RemoveFilterEx(@as(*const IGraphConfig, @ptrCast(self)), pFilter, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IGraphConfigCallback_Value = Guid.initString("ade0fd60-d19d-11d2-abf6-00a0c905f375");
pub const IID_IGraphConfigCallback = &IID_IGraphConfigCallback_Value;
pub const IGraphConfigCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconfigure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGraphConfigCallback,
                pvContext: ?*anyopaque,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGraphConfigCallback,
                pvContext: ?*anyopaque,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGraphConfigCallback_Reconfigure(self: *const T, pvContext: ?*anyopaque, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IGraphConfigCallback.VTable, @ptrCast(self.vtable)).Reconfigure(@as(*const IGraphConfigCallback, @ptrCast(self)), pvContext, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IFilterChain_Value = Guid.initString("dcfbdcf6-0dc2-45f5-9ab2-7c330ea09c29");
pub const IID_IFilterChain = &IID_IFilterChain_Value;
pub const IFilterChain = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveChain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterChain,
                pStartFilter: ?*IBaseFilter,
                pEndFilter: ?*IBaseFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_StartChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).StartChain(@as(*const IFilterChain, @ptrCast(self)), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_PauseChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).PauseChain(@as(*const IFilterChain, @ptrCast(self)), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_StopChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).StopChain(@as(*const IFilterChain, @ptrCast(self)), pStartFilter, pEndFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterChain_RemoveChain(self: *const T, pStartFilter: ?*IBaseFilter, pEndFilter: ?*IBaseFilter) callconv(.Inline) HRESULT {
            return @as(*const IFilterChain.VTable, @ptrCast(self.vtable)).RemoveChain(@as(*const IFilterChain, @ptrCast(self)), pStartFilter, pEndFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRPresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMRSample_SyncPoint = VMRPresentationFlags.SyncPoint;
pub const VMRSample_Preroll = VMRPresentationFlags.Preroll;
pub const VMRSample_Discontinuity = VMRPresentationFlags.Discontinuity;
pub const VMRSample_TimeValid = VMRPresentationFlags.TimeValid;
pub const VMRSample_SrcDstRectsValid = VMRPresentationFlags.SrcDstRectsValid;

pub const VMRPRESENTATIONINFO = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirectDrawSurface7,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwTypeSpecificFlags: u32,
    dwInterlaceFlags: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter_Value = Guid.initString("ce704fe7-e71e-41fb-baa2-c4403e1182f5");
pub const IID_IVMRImagePresenter = &IID_IVMRImagePresenter_Value;
pub const IVMRImagePresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopPresenting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PresentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
                lpPresInfo: ?*VMRPRESENTATIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter,
                dwUserID: usize,
                lpPresInfo: ?*VMRPRESENTATIONINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_StartPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).StartPresenting(@as(*const IVMRImagePresenter, @ptrCast(self)), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_StopPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).StopPresenting(@as(*const IVMRImagePresenter, @ptrCast(self)), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter_PresentImage(self: *const T, dwUserID: usize, lpPresInfo: ?*VMRPRESENTATIONINFO) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter.VTable, @ptrCast(self.vtable)).PresentImage(@as(*const IVMRImagePresenter, @ptrCast(self)), dwUserID, lpPresInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRSurfaceAllocationFlags = enum(i32) {
    PIXELFORMAT_VALID = 1,
    @"3D_TARGET" = 2,
    ALLOW_SYSMEM = 4,
    FORCE_SYSMEM = 8,
    DIRECTED_FLIP = 16,
    DXVA_TARGET = 32,
};
pub const AMAP_PIXELFORMAT_VALID = VMRSurfaceAllocationFlags.PIXELFORMAT_VALID;
pub const AMAP_3D_TARGET = VMRSurfaceAllocationFlags.@"3D_TARGET";
pub const AMAP_ALLOW_SYSMEM = VMRSurfaceAllocationFlags.ALLOW_SYSMEM;
pub const AMAP_FORCE_SYSMEM = VMRSurfaceAllocationFlags.FORCE_SYSMEM;
pub const AMAP_DIRECTED_FLIP = VMRSurfaceAllocationFlags.DIRECTED_FLIP;
pub const AMAP_DXVA_TARGET = VMRSurfaceAllocationFlags.DXVA_TARGET;

pub const VMRALLOCATIONINFO = extern struct {
    dwFlags: u32,
    lpHdr: ?*BITMAPINFOHEADER,
    lpPixFmt: ?*DDPIXELFORMAT,
    szAspectRatio: SIZE,
    dwMinBuffers: u32,
    dwMaxBuffers: u32,
    dwInterlaceFlags: u32,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator_Value = Guid.initString("31ce832e-4484-458b-8cca-f4d7e3db0b52");
pub const IID_IVMRSurfaceAllocator = &IID_IVMRSurfaceAllocator_Value;
pub const IVMRSurfaceAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AllocateSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator,
                dwUserID: usize,
                lpAllocInfo: ?*VMRALLOCATIONINFO,
                lpdwActualBuffers: ?*u32,
                lplpSurface: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator,
                dwUserID: usize,
                lpAllocInfo: ?*VMRALLOCATIONINFO,
                lpdwActualBuffers: ?*u32,
                lplpSurface: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator,
                dwID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator,
                dwID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrepareSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator,
                dwUserID: usize,
                lpSurface: ?*IDirectDrawSurface7,
                dwSurfaceFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator,
                dwUserID: usize,
                lpSurface: ?*IDirectDrawSurface7,
                dwSurfaceFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator,
                lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator,
                lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_AllocateSurface(self: *const T, dwUserID: usize, lpAllocInfo: ?*VMRALLOCATIONINFO, lpdwActualBuffers: ?*u32, lplpSurface: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).AllocateSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dwUserID, lpAllocInfo, lpdwActualBuffers, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_FreeSurface(self: *const T, dwID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).FreeSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dwID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_PrepareSurface(self: *const T, dwUserID: usize, lpSurface: ?*IDirectDrawSurface7, dwSurfaceFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).PrepareSurface(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), dwUserID, lpSurface, dwSurfaceFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator_AdviseNotify(self: *const T, lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator.VTable, @ptrCast(self.vtable)).AdviseNotify(@as(*const IVMRSurfaceAllocator, @ptrCast(self)), lpIVMRSurfAllocNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify_Value = Guid.initString("aada05a8-5a4e-4729-af0b-cea27aed51e2");
pub const IID_IVMRSurfaceAllocatorNotify = &IID_IVMRSurfaceAllocatorNotify_Value;
pub const IVMRSurfaceAllocatorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
                dwUserID: usize,
                lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
                dwUserID: usize,
                lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDDrawDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
                lpDDrawDevice: ?*IDirectDraw7,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
                lpDDrawDevice: ?*IDirectDraw7,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeDDrawDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
                lpDDrawDevice: ?*IDirectDraw7,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
                lpDDrawDevice: ?*IDirectDraw7,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreDDrawSurfaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
                EventCode: i32,
                Param1: isize,
                Param2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
                EventCode: i32,
                Param1: isize,
                Param2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify,
                clrBorder: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify,
                clrBorder: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator(self: *const T, dwUserID: usize, lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).AdviseSurfaceAllocator(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), dwUserID, lpIVRMSurfaceAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_SetDDrawDevice(self: *const T, lpDDrawDevice: ?*IDirectDraw7, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).SetDDrawDevice(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), lpDDrawDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_ChangeDDrawDevice(self: *const T, lpDDrawDevice: ?*IDirectDraw7, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).ChangeDDrawDevice(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), lpDDrawDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).RestoreDDrawSurfaces(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_NotifyEvent(self: *const T, EventCode: i32, Param1: isize, Param2: isize) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).NotifyEvent(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), EventCode, Param1, Param2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify_SetBorderColor(self: *const T, clrBorder: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRSurfaceAllocatorNotify, @ptrCast(self)), clrBorder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR_ASPECT_RATIO_MODE = enum(i32) {
    NONE = 0,
    LETTER_BOX = 1,
};
pub const VMR_ARMODE_NONE = VMR_ASPECT_RATIO_MODE.NONE;
pub const VMR_ARMODE_LETTER_BOX = VMR_ASPECT_RATIO_MODE.LETTER_BOX;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl_Value = Guid.initString("0eb1088c-4dcd-46f0-878f-39dae86a51b7");
pub const IID_IVMRWindowlessControl = &IID_IVMRWindowlessControl_Value;
pub const IVMRWindowlessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
                lpARWidth: ?*i32,
                lpARHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
                lpARWidth: ?*i32,
                lpARHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpSRCRect: ?*const RECT,
                lpDSTRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpSRCRect: ?*const RECT,
                lpDSTRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpSRCRect: ?*RECT,
                lpDSTRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpSRCRect: ?*RECT,
                lpDSTRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                AspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                AspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoClippingWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RepaintVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                hwnd: ?HWND,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                hwnd: ?HWND,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayModeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpDib: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpDib: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetNativeVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32, lpARWidth: ?*i32, lpARHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpWidth, lpHeight, lpARWidth, lpARHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetMinIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetMinIdealVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetMaxIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetMaxIdealVideoSize(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetVideoPosition(self: *const T, lpSRCRect: ?*const RECT, lpDSTRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetVideoPosition(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetVideoPosition(self: *const T, lpSRCRect: ?*RECT, lpDSTRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetAspectRatioMode(self: *const T, lpAspectRatioMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetAspectRatioMode(self: *const T, AspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRWindowlessControl, @ptrCast(self)), AspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetVideoClippingWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetVideoClippingWindow(@as(*const IVMRWindowlessControl, @ptrCast(self)), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_RepaintVideo(self: *const T, hwnd: ?HWND, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).RepaintVideo(@as(*const IVMRWindowlessControl, @ptrCast(self)), hwnd, hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_DisplayModeChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).DisplayModeChanged(@as(*const IVMRWindowlessControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetCurrentImage(self: *const T, lpDib: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpDib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetBorderColor(self: *const T, Clr: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRWindowlessControl, @ptrCast(self)), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetBorderColor(self: *const T, lpClr: ?*COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_SetColorKey(self: *const T, Clr: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IVMRWindowlessControl, @ptrCast(self)), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl_GetColorKey(self: *const T, lpClr: ?*COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IVMRWindowlessControl, @ptrCast(self)), lpClr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRMixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    DecimationReserved = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    FilteringMask = 240,
    RenderTargetRGB = 256,
    RenderTargetYUV = 4096,
    RenderTargetYUV420 = 512,
    RenderTargetYUV422 = 1024,
    RenderTargetYUV444 = 2048,
    RenderTargetReserved = 57344,
    RenderTargetMask = 65280,
    DynamicSwitchToBOB = 65536,
    DynamicDecimateBy2 = 131072,
    DynamicReserved = 786432,
    DynamicMask = 983040,
};
pub const MixerPref_NoDecimation = VMRMixerPrefs.NoDecimation;
pub const MixerPref_DecimateOutput = VMRMixerPrefs.DecimateOutput;
pub const MixerPref_ARAdjustXorY = VMRMixerPrefs.ARAdjustXorY;
pub const MixerPref_DecimationReserved = VMRMixerPrefs.DecimationReserved;
pub const MixerPref_DecimateMask = VMRMixerPrefs.DecimateMask;
pub const MixerPref_BiLinearFiltering = VMRMixerPrefs.BiLinearFiltering;
pub const MixerPref_PointFiltering = VMRMixerPrefs.PointFiltering;
pub const MixerPref_FilteringMask = VMRMixerPrefs.FilteringMask;
pub const MixerPref_RenderTargetRGB = VMRMixerPrefs.RenderTargetRGB;
pub const MixerPref_RenderTargetYUV = VMRMixerPrefs.RenderTargetYUV;
pub const MixerPref_RenderTargetYUV420 = VMRMixerPrefs.RenderTargetYUV420;
pub const MixerPref_RenderTargetYUV422 = VMRMixerPrefs.RenderTargetYUV422;
pub const MixerPref_RenderTargetYUV444 = VMRMixerPrefs.RenderTargetYUV444;
pub const MixerPref_RenderTargetReserved = VMRMixerPrefs.RenderTargetReserved;
pub const MixerPref_RenderTargetMask = VMRMixerPrefs.RenderTargetMask;
pub const MixerPref_DynamicSwitchToBOB = VMRMixerPrefs.DynamicSwitchToBOB;
pub const MixerPref_DynamicDecimateBy2 = VMRMixerPrefs.DynamicDecimateBy2;
pub const MixerPref_DynamicReserved = VMRMixerPrefs.DynamicReserved;
pub const MixerPref_DynamicMask = VMRMixerPrefs.DynamicMask;

pub const NORMALIZEDRECT = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl_Value = Guid.initString("1c1a17b0-bed0-415d-974b-dc6696131599");
pub const IID_IVMRMixerControl = &IID_IVMRMixerControl_Value;
pub const IVMRMixerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                Alpha: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                Alpha: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pAlpha: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pAlpha: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pRect: ?*const NORMALIZEDRECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pRect: ?*const NORMALIZEDRECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pRect: ?*NORMALIZEDRECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwStreamID: u32,
                pRect: ?*NORMALIZEDRECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundClr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                ClrBkg: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                ClrBkg: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundClr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                lpClrBkg: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                lpClrBkg: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                dwMixerPrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                dwMixerPrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl,
                pdwMixerPrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl,
                pdwMixerPrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetAlpha(self: *const T, dwStreamID: u32, Alpha: f32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetAlpha(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetAlpha(self: *const T, dwStreamID: u32, pAlpha: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetAlpha(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, pAlpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetZOrder(self: *const T, dwStreamID: u32, dwZ: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, dwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetZOrder(self: *const T, dwStreamID: u32, pZ: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, pZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*const NORMALIZEDRECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetOutputRect(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*NORMALIZEDRECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetOutputRect(@as(*const IVMRMixerControl, @ptrCast(self)), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetBackgroundClr(self: *const T, ClrBkg: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetBackgroundClr(@as(*const IVMRMixerControl, @ptrCast(self)), ClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetBackgroundClr(self: *const T, lpClrBkg: ?*COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetBackgroundClr(@as(*const IVMRMixerControl, @ptrCast(self)), lpClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_SetMixingPrefs(self: *const T, dwMixerPrefs: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).SetMixingPrefs(@as(*const IVMRMixerControl, @ptrCast(self)), dwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl_GetMixingPrefs(self: *const T, pdwMixerPrefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl.VTable, @ptrCast(self.vtable)).GetMixingPrefs(@as(*const IVMRMixerControl, @ptrCast(self)), pdwMixerPrefs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRGUID = extern struct {
    pGUID: ?*Guid,
    GUID: Guid,
};

pub const VMRMONITORINFO = extern struct {
    guid: VMRGUID,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [256]u16,
    liDriverVersion: i64,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig_Value = Guid.initString("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce");
pub const IID_IVMRMonitorConfig = &IID_IVMRMonitorConfig_Value;
pub const IVMRMonitorConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*const VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*const VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*const VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*const VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig,
                pGUID: ?*VMRGUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableMonitors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig,
                pInfo: [*]VMRMONITORINFO,
                dwMaxInfoArraySize: u32,
                pdwNumDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig,
                pInfo: [*]VMRMONITORINFO,
                dwMaxInfoArraySize: u32,
                pdwNumDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_SetMonitor(self: *const T, pGUID: ?*const VMRGUID) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetMonitor(self: *const T, pGUID: ?*VMRGUID) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_SetDefaultMonitor(self: *const T, pGUID: ?*const VMRGUID) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).SetDefaultMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetDefaultMonitor(self: *const T, pGUID: ?*VMRGUID) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetDefaultMonitor(@as(*const IVMRMonitorConfig, @ptrCast(self)), pGUID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig_GetAvailableMonitors(self: *const T, pInfo: [*]VMRMONITORINFO, dwMaxInfoArraySize: u32, pdwNumDevices: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig.VTable, @ptrCast(self.vtable)).GetAvailableMonitors(@as(*const IVMRMonitorConfig, @ptrCast(self)), pInfo, dwMaxInfoArraySize, pdwNumDevices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRRenderPrefs = enum(i32) {
    RestrictToInitialMonitor = 0,
    ForceOffscreen = 1,
    ForceOverlays = 2,
    // AllowOverlays = 0, this enum value conflicts with RestrictToInitialMonitor
    // AllowOffscreen = 0, this enum value conflicts with RestrictToInitialMonitor
    DoNotRenderColorKeyAndBorder = 8,
    Reserved = 16,
    PreferAGPMemWhenMixing = 32,
    Mask = 63,
};
pub const RenderPrefs_RestrictToInitialMonitor = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_ForceOffscreen = VMRRenderPrefs.ForceOffscreen;
pub const RenderPrefs_ForceOverlays = VMRRenderPrefs.ForceOverlays;
pub const RenderPrefs_AllowOverlays = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_AllowOffscreen = VMRRenderPrefs.RestrictToInitialMonitor;
pub const RenderPrefs_DoNotRenderColorKeyAndBorder = VMRRenderPrefs.DoNotRenderColorKeyAndBorder;
pub const RenderPrefs_Reserved = VMRRenderPrefs.Reserved;
pub const RenderPrefs_PreferAGPMemWhenMixing = VMRRenderPrefs.PreferAGPMemWhenMixing;
pub const RenderPrefs_Mask = VMRRenderPrefs.Mask;

pub const VMRMode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMRMode_Windowed = VMRMode.Windowed;
pub const VMRMode_Windowless = VMRMode.Windowless;
pub const VMRMode_Renderless = VMRMode.Renderless;
pub const VMRMode_Mask = VMRMode.Mask;

pub const STREAMIF_CONSTANTS = enum(i32) {
    S = 16,
};
pub const MAX_NUMBER_OF_STREAMS = STREAMIF_CONSTANTS.S;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig_Value = Guid.initString("9e5530c5-7034-48b4-bb46-0b8a6efc8e36");
pub const IID_IVMRFilterConfig = &IID_IVMRFilterConfig_Value;
pub const IVMRFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                lpVMRImgCompositor: ?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                lpVMRImgCompositor: ?*IVMRImageCompositor,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                Mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                Mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig,
                pMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig,
                pMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetImageCompositor(self: *const T, lpVMRImgCompositor: ?*IVMRImageCompositor) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetImageCompositor(@as(*const IVMRFilterConfig, @ptrCast(self)), lpVMRImgCompositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetNumberOfStreams(@as(*const IVMRFilterConfig, @ptrCast(self)), dwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetNumberOfStreams(self: *const T, pdwMaxStreams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IVMRFilterConfig, @ptrCast(self)), pdwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRFilterConfig, @ptrCast(self)), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetRenderingPrefs(self: *const T, pdwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRFilterConfig, @ptrCast(self)), pdwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_SetRenderingMode(self: *const T, Mode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).SetRenderingMode(@as(*const IVMRFilterConfig, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig_GetRenderingMode(self: *const T, pMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig.VTable, @ptrCast(self.vtable)).GetRenderingMode(@as(*const IVMRFilterConfig, @ptrCast(self)), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl_Value = Guid.initString("ede80b5c-bad6-4623-b537-65586c9f8dfd");
pub const IID_IVMRAspectRatioControl = &IID_IVMRAspectRatioControl_Value;
pub const IVMRAspectRatioControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRAspectRatioControl,
                lpdwARMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRAspectRatioControl,
                lpdwARMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRAspectRatioControl,
                dwARMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRAspectRatioControl,
                dwARMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl_GetAspectRatioMode(self: *const T, lpdwARMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRAspectRatioControl.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRAspectRatioControl, @ptrCast(self)), lpdwARMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl_SetAspectRatioMode(self: *const T, dwARMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRAspectRatioControl.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRAspectRatioControl, @ptrCast(self)), dwARMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRDeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref_NextBest = VMRDeinterlacePrefs.NextBest;
pub const DeinterlacePref_BOB = VMRDeinterlacePrefs.BOB;
pub const DeinterlacePref_Weave = VMRDeinterlacePrefs.Weave;
pub const DeinterlacePref_Mask = VMRDeinterlacePrefs.Mask;

pub const VMRDeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech_Unknown = VMRDeinterlaceTech.Unknown;
pub const DeinterlaceTech_BOBLineReplicate = VMRDeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech_BOBVerticalStretch = VMRDeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech_MedianFiltering = VMRDeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech_EdgeFiltering = VMRDeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech_FieldAdaptive = VMRDeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech_PixelAdaptive = VMRDeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech_MotionVectorSteered = VMRDeinterlaceTech.MotionVectorSteered;

pub const VMRFrequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMRVideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SingleFieldPerSample: BOOL,
    dwFourCC: u32,
    InputSampleFreq: VMRFrequency,
    OutputFrameFreq: VMRFrequency,
};

pub const VMRDeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMRDeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl_Value = Guid.initString("bb057577-0db8-4e6a-87a7-1a8c9a505a0f");
pub const IID_IVMRDeinterlaceControl = &IID_IVMRDeinterlaceControl_Value;
pub const IVMRDeinterlaceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                lpVideoDescription: ?*VMRVideoDesc,
                lpdwNumDeinterlaceModes: ?*u32,
                lpDeinterlaceModes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                lpVideoDescription: ?*VMRVideoDesc,
                lpdwNumDeinterlaceModes: ?*u32,
                lpDeinterlaceModes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlaceModeCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                lpDeinterlaceMode: ?*Guid,
                lpVideoDescription: ?*VMRVideoDesc,
                lpDeinterlaceCaps: ?*VMRDeinterlaceCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                lpDeinterlaceMode: ?*Guid,
                lpVideoDescription: ?*VMRVideoDesc,
                lpDeinterlaceCaps: ?*VMRDeinterlaceCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlacePrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                lpdwDeinterlacePrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                lpdwDeinterlacePrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeinterlacePrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                dwDeinterlacePrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                dwDeinterlacePrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes(self: *const T, lpVideoDescription: ?*VMRVideoDesc, lpdwNumDeinterlaceModes: ?*u32, lpDeinterlaceModes: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetNumberOfDeinterlaceModes(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lpVideoDescription, lpdwNumDeinterlaceModes, lpDeinterlaceModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlaceModeCaps(self: *const T, lpDeinterlaceMode: ?*Guid, lpVideoDescription: ?*VMRVideoDesc, lpDeinterlaceCaps: ?*VMRDeinterlaceCaps) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlaceModeCaps(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lpDeinterlaceMode, lpVideoDescription, lpDeinterlaceCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_SetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetDeinterlacePrefs(self: *const T, lpdwDeinterlacePrefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), lpdwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_SetDeinterlacePrefs(self: *const T, dwDeinterlacePrefs: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).SetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl_GetActualDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl.VTable, @ptrCast(self.vtable)).GetActualDeinterlaceMode(@as(*const IVMRDeinterlaceControl, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRALPHABITMAP = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirectDrawSurface7,
    rSrc: RECT,
    rDest: NORMALIZEDRECT,
    fAlpha: f32,
    clrSrcKey: COLORREF,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap_Value = Guid.initString("1e673275-0257-40aa-af20-7c608d4a0428");
pub const IID_IVMRMixerBitmap = &IID_IVMRMixerBitmap_Value;
pub const IVMRMixerBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*const VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*const VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap,
                pBmpParms: ?*VMRALPHABITMAP,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_SetAlphaBitmap(self: *const T, pBmpParms: ?*const VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).SetAlphaBitmap(@as(*const IVMRMixerBitmap, @ptrCast(self)), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).UpdateAlphaBitmapParameters(@as(*const IVMRMixerBitmap, @ptrCast(self)), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap_GetAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMRALPHABITMAP) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap.VTable, @ptrCast(self.vtable)).GetAlphaBitmapParameters(@as(*const IVMRMixerBitmap, @ptrCast(self)), pBmpParms);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMRVIDEOSTREAMINFO = extern struct {
    pddsVideoSurface: ?*IDirectDrawSurface7,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    ddClrKey: DDCOLORKEY,
    rNormal: NORMALIZEDRECT,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor_Value = Guid.initString("7a4fb5af-479f-4074-bb40-ce6722e43c82");
pub const IID_IVMRImageCompositor = &IID_IVMRImageCompositor_Value;
pub const IVMRImageCompositor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TermCompositionTarget: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor,
                dwStrmID: u32,
                pmt: ?*AM_MEDIA_TYPE,
                fTexture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor,
                dwStrmID: u32,
                pmt: ?*AM_MEDIA_TYPE,
                fTexture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompositeImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
                pmtRenderTarget: ?*AM_MEDIA_TYPE,
                rtStart: i64,
                rtEnd: i64,
                dwClrBkGnd: u32,
                pVideoStreamInfo: ?*VMRVIDEOSTREAMINFO,
                cStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirectDrawSurface7,
                pmtRenderTarget: ?*AM_MEDIA_TYPE,
                rtStart: i64,
                rtEnd: i64,
                dwClrBkGnd: u32,
                pVideoStreamInfo: ?*VMRVIDEOSTREAMINFO,
                cStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_InitCompositionTarget(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).InitCompositionTarget(@as(*const IVMRImageCompositor, @ptrCast(self)), pD3DDevice, pddsRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_TermCompositionTarget(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).TermCompositionTarget(@as(*const IVMRImageCompositor, @ptrCast(self)), pD3DDevice, pddsRenderTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_SetStreamMediaType(self: *const T, dwStrmID: u32, pmt: ?*AM_MEDIA_TYPE, fTexture: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).SetStreamMediaType(@as(*const IVMRImageCompositor, @ptrCast(self)), dwStrmID, pmt, fTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor_CompositeImage(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirectDrawSurface7, pmtRenderTarget: ?*AM_MEDIA_TYPE, rtStart: i64, rtEnd: i64, dwClrBkGnd: u32, pVideoStreamInfo: ?*VMRVIDEOSTREAMINFO, cStreams: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor.VTable, @ptrCast(self.vtable)).CompositeImage(@as(*const IVMRImageCompositor, @ptrCast(self)), pD3DDevice, pddsRenderTarget, pmtRenderTarget, rtStart, rtEnd, dwClrBkGnd, pVideoStreamInfo, cStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl_Value = Guid.initString("058d1f11-2a54-4bef-bd54-df706626b727");
pub const IID_IVMRVideoStreamControl = &IID_IVMRVideoStreamControl_Value;
pub const IVMRVideoStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl,
                lpClrKey: ?*DDCOLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl,
                lpClrKey: ?*DDCOLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl,
                lpClrKey: ?*DDCOLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl,
                lpClrKey: ?*DDCOLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_SetColorKey(self: *const T, lpClrKey: ?*DDCOLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lpClrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_GetColorKey(self: *const T, lpClrKey: ?*DDCOLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lpClrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_SetStreamActiveState(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).SetStreamActiveState(@as(*const IVMRVideoStreamControl, @ptrCast(self)), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl_GetStreamActiveState(self: *const T, lpfActive: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl.VTable, @ptrCast(self.vtable)).GetStreamActiveState(@as(*const IVMRVideoStreamControl, @ptrCast(self)), lpfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface_Value = Guid.initString("a9849bbe-9ec8-4263-b764-62730f0d15d0");
pub const IID_IVMRSurface = &IID_IVMRSurface_Value;
pub const IVMRSurface = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface,
                lpSurface: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface,
                lpSurface: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface,
                lplpSurface: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface,
                lplpSurface: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_IsSurfaceLocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).IsSurfaceLocked(@as(*const IVMRSurface, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_LockSurface(self: *const T, lpSurface: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).LockSurface(@as(*const IVMRSurface, @ptrCast(self)), lpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_UnlockSurface(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).UnlockSurface(@as(*const IVMRSurface, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface_GetSurface(self: *const T, lplpSurface: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurface, @ptrCast(self)), lplpSurface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig_Value = Guid.initString("9f3a1c85-8555-49ba-935f-be5b5b29d178");
pub const IID_IVMRImagePresenterConfig = &IID_IVMRImagePresenterConfig_Value;
pub const IVMRImagePresenterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterConfig,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterConfig,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterConfig,
                dwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterConfig,
                dwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterConfig.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRImagePresenterConfig, @ptrCast(self)), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig_GetRenderingPrefs(self: *const T, dwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterConfig.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRImagePresenterConfig, @ptrCast(self)), dwRenderFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterExclModeConfig_Value = Guid.initString("e6f7ce40-4673-44f1-8f77-5499d68cb4ea");
pub const IID_IVMRImagePresenterExclModeConfig = &IID_IVMRImagePresenterExclModeConfig_Value;
pub const IVMRImagePresenterExclModeConfig = extern struct {
    pub const VTable = extern struct {
        base: IVMRImagePresenterConfig.VTable,
        SetXlcModeDDObjAndPrimarySurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterExclModeConfig,
                lpDDObj: ?*IDirectDraw7,
                lpPrimarySurf: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterExclModeConfig,
                lpDDObj: ?*IDirectDraw7,
                lpPrimarySurf: ?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetXlcModeDDObjAndPrimarySurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterExclModeConfig,
                lpDDObj: ?*?*IDirectDraw7,
                lpPrimarySurf: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterExclModeConfig,
                lpDDObj: ?*?*IDirectDraw7,
                lpPrimarySurf: ?*?*IDirectDrawSurface7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVMRImagePresenterConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface(self: *const T, lpDDObj: ?*IDirectDraw7, lpPrimarySurf: ?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterExclModeConfig.VTable, @ptrCast(self.vtable)).SetXlcModeDDObjAndPrimarySurface(@as(*const IVMRImagePresenterExclModeConfig, @ptrCast(self)), lpDDObj, lpPrimarySurf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface(self: *const T, lpDDObj: ?*?*IDirectDraw7, lpPrimarySurf: ?*?*IDirectDrawSurface7) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterExclModeConfig.VTable, @ptrCast(self.vtable)).GetXlcModeDDObjAndPrimarySurface(@as(*const IVMRImagePresenterExclModeConfig, @ptrCast(self)), lpDDObj, lpPrimarySurf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVPManager_Value = Guid.initString("aac18c18-e186-46d2-825d-a1f8dc8e395a");
pub const IID_IVPManager = &IID_IVPManager_Value;
pub const IVPManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVideoPortIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPManager,
                dwVideoPortIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPManager,
                dwVideoPortIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPortIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPManager,
                pdwVideoPortIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPManager,
                pdwVideoPortIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPManager_SetVideoPortIndex(self: *const T, dwVideoPortIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const IVPManager.VTable, @ptrCast(self.vtable)).SetVideoPortIndex(@as(*const IVPManager, @ptrCast(self)), dwVideoPortIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPManager_GetVideoPortIndex(self: *const T, pdwVideoPortIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVPManager.VTable, @ptrCast(self.vtable)).GetVideoPortIndex(@as(*const IVPManager, @ptrCast(self)), pdwVideoPortIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_DOMAIN = enum(i32) {
    FirstPlay = 1,
    VideoManagerMenu = 2,
    VideoTitleSetMenu = 3,
    Title = 4,
    Stop = 5,
};
pub const DVD_DOMAIN_FirstPlay = DVD_DOMAIN.FirstPlay;
pub const DVD_DOMAIN_VideoManagerMenu = DVD_DOMAIN.VideoManagerMenu;
pub const DVD_DOMAIN_VideoTitleSetMenu = DVD_DOMAIN.VideoTitleSetMenu;
pub const DVD_DOMAIN_Title = DVD_DOMAIN.Title;
pub const DVD_DOMAIN_Stop = DVD_DOMAIN.Stop;

pub const DVD_MENU_ID = enum(i32) {
    Title = 2,
    Root = 3,
    Subpicture = 4,
    Audio = 5,
    Angle = 6,
    Chapter = 7,
};
pub const DVD_MENU_Title = DVD_MENU_ID.Title;
pub const DVD_MENU_Root = DVD_MENU_ID.Root;
pub const DVD_MENU_Subpicture = DVD_MENU_ID.Subpicture;
pub const DVD_MENU_Audio = DVD_MENU_ID.Audio;
pub const DVD_MENU_Angle = DVD_MENU_ID.Angle;
pub const DVD_MENU_Chapter = DVD_MENU_ID.Chapter;

pub const DVD_DISC_SIDE = enum(i32) {
    A = 1,
    B = 2,
};
pub const DVD_SIDE_A = DVD_DISC_SIDE.A;
pub const DVD_SIDE_B = DVD_DISC_SIDE.B;

pub const DVD_PREFERRED_DISPLAY_MODE = enum(i32) {
    CONTENT_DEFAULT = 0,
    @"16x9" = 1,
    @"4x3_PANSCAN_PREFERRED" = 2,
    @"4x3_LETTERBOX_PREFERRED" = 3,
};
pub const DISPLAY_CONTENT_DEFAULT = DVD_PREFERRED_DISPLAY_MODE.CONTENT_DEFAULT;
pub const DISPLAY_16x9 = DVD_PREFERRED_DISPLAY_MODE.@"16x9";
pub const DISPLAY_4x3_PANSCAN_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_PANSCAN_PREFERRED";
pub const DISPLAY_4x3_LETTERBOX_PREFERRED = DVD_PREFERRED_DISPLAY_MODE.@"4x3_LETTERBOX_PREFERRED";

pub const DVD_ATR = extern struct {
    ulCAT: u32,
    pbATRI: [768]u8,
};

pub const DVD_FRAMERATE = enum(i32) {
    @"25" = 1,
    @"30NonDrop" = 3,
};
pub const DVD_FPS_25 = DVD_FRAMERATE.@"25";
pub const DVD_FPS_30NonDrop = DVD_FRAMERATE.@"30NonDrop";

pub const DVD_TIMECODE = extern struct {
    _bitfield: u32,
};

pub const DVD_NavCmdType = enum(i32) {
    Pre = 1,
    Post = 2,
    Cell = 3,
    Button = 4,
};
pub const DVD_NavCmdType_Pre = DVD_NavCmdType.Pre;
pub const DVD_NavCmdType_Post = DVD_NavCmdType.Post;
pub const DVD_NavCmdType_Cell = DVD_NavCmdType.Cell;
pub const DVD_NavCmdType_Button = DVD_NavCmdType.Button;

pub const DVD_TIMECODE_FLAGS = enum(i32) {
    @"25fps" = 1,
    @"30fps" = 2,
    DropFrame = 4,
    Interpolated = 8,
};
pub const DVD_TC_FLAG_25fps = DVD_TIMECODE_FLAGS.@"25fps";
pub const DVD_TC_FLAG_30fps = DVD_TIMECODE_FLAGS.@"30fps";
pub const DVD_TC_FLAG_DropFrame = DVD_TIMECODE_FLAGS.DropFrame;
pub const DVD_TC_FLAG_Interpolated = DVD_TIMECODE_FLAGS.Interpolated;

pub const DVD_HMSF_TIMECODE = extern struct {
    bHours: u8,
    bMinutes: u8,
    bSeconds: u8,
    bFrames: u8,
};

pub const DVD_PLAYBACK_LOCATION2 = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: DVD_HMSF_TIMECODE,
    TimeCodeFlags: u32,
};

pub const DVD_PLAYBACK_LOCATION = extern struct {
    TitleNum: u32,
    ChapterNum: u32,
    TimeCode: u32,
};

pub const VALID_UOP_FLAG = enum(i32) {
    Play_Title_Or_AtTime = 1,
    Play_Chapter = 2,
    Play_Title = 4,
    Stop = 8,
    ReturnFromSubMenu = 16,
    Play_Chapter_Or_AtTime = 32,
    PlayPrev_Or_Replay_Chapter = 64,
    PlayNext_Chapter = 128,
    Play_Forwards = 256,
    Play_Backwards = 512,
    ShowMenu_Title = 1024,
    ShowMenu_Root = 2048,
    ShowMenu_SubPic = 4096,
    ShowMenu_Audio = 8192,
    ShowMenu_Angle = 16384,
    ShowMenu_Chapter = 32768,
    Resume = 65536,
    Select_Or_Activate_Button = 131072,
    Still_Off = 262144,
    Pause_On = 524288,
    Select_Audio_Stream = 1048576,
    Select_SubPic_Stream = 2097152,
    Select_Angle = 4194304,
    Select_Karaoke_Audio_Presentation_Mode = 8388608,
    Select_Video_Mode_Preference = 16777216,
};
pub const UOP_FLAG_Play_Title_Or_AtTime = VALID_UOP_FLAG.Play_Title_Or_AtTime;
pub const UOP_FLAG_Play_Chapter = VALID_UOP_FLAG.Play_Chapter;
pub const UOP_FLAG_Play_Title = VALID_UOP_FLAG.Play_Title;
pub const UOP_FLAG_Stop = VALID_UOP_FLAG.Stop;
pub const UOP_FLAG_ReturnFromSubMenu = VALID_UOP_FLAG.ReturnFromSubMenu;
pub const UOP_FLAG_Play_Chapter_Or_AtTime = VALID_UOP_FLAG.Play_Chapter_Or_AtTime;
pub const UOP_FLAG_PlayPrev_Or_Replay_Chapter = VALID_UOP_FLAG.PlayPrev_Or_Replay_Chapter;
pub const UOP_FLAG_PlayNext_Chapter = VALID_UOP_FLAG.PlayNext_Chapter;
pub const UOP_FLAG_Play_Forwards = VALID_UOP_FLAG.Play_Forwards;
pub const UOP_FLAG_Play_Backwards = VALID_UOP_FLAG.Play_Backwards;
pub const UOP_FLAG_ShowMenu_Title = VALID_UOP_FLAG.ShowMenu_Title;
pub const UOP_FLAG_ShowMenu_Root = VALID_UOP_FLAG.ShowMenu_Root;
pub const UOP_FLAG_ShowMenu_SubPic = VALID_UOP_FLAG.ShowMenu_SubPic;
pub const UOP_FLAG_ShowMenu_Audio = VALID_UOP_FLAG.ShowMenu_Audio;
pub const UOP_FLAG_ShowMenu_Angle = VALID_UOP_FLAG.ShowMenu_Angle;
pub const UOP_FLAG_ShowMenu_Chapter = VALID_UOP_FLAG.ShowMenu_Chapter;
pub const UOP_FLAG_Resume = VALID_UOP_FLAG.Resume;
pub const UOP_FLAG_Select_Or_Activate_Button = VALID_UOP_FLAG.Select_Or_Activate_Button;
pub const UOP_FLAG_Still_Off = VALID_UOP_FLAG.Still_Off;
pub const UOP_FLAG_Pause_On = VALID_UOP_FLAG.Pause_On;
pub const UOP_FLAG_Select_Audio_Stream = VALID_UOP_FLAG.Select_Audio_Stream;
pub const UOP_FLAG_Select_SubPic_Stream = VALID_UOP_FLAG.Select_SubPic_Stream;
pub const UOP_FLAG_Select_Angle = VALID_UOP_FLAG.Select_Angle;
pub const UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode = VALID_UOP_FLAG.Select_Karaoke_Audio_Presentation_Mode;
pub const UOP_FLAG_Select_Video_Mode_Preference = VALID_UOP_FLAG.Select_Video_Mode_Preference;

pub const DVD_CMD_FLAGS = enum(i32) {
    None = 0,
    Flush = 1,
    SendEvents = 2,
    Block = 4,
    StartWhenRendered = 8,
    EndAfterRendered = 16,
};
pub const DVD_CMD_FLAG_None = DVD_CMD_FLAGS.None;
pub const DVD_CMD_FLAG_Flush = DVD_CMD_FLAGS.Flush;
pub const DVD_CMD_FLAG_SendEvents = DVD_CMD_FLAGS.SendEvents;
pub const DVD_CMD_FLAG_Block = DVD_CMD_FLAGS.Block;
pub const DVD_CMD_FLAG_StartWhenRendered = DVD_CMD_FLAGS.StartWhenRendered;
pub const DVD_CMD_FLAG_EndAfterRendered = DVD_CMD_FLAGS.EndAfterRendered;

pub const DVD_OPTION_FLAG = enum(i32) {
    ResetOnStop = 1,
    NotifyParentalLevelChange = 2,
    HMSF_TimeCodeEvents = 3,
    AudioDuringFFwdRew = 4,
    EnableNonblockingAPIs = 5,
    CacheSizeInMB = 6,
    EnablePortableBookmarks = 7,
    EnableExtendedCopyProtectErrors = 8,
    NotifyPositionChange = 9,
    IncreaseOutputControl = 10,
    EnableStreaming = 11,
    EnableESOutput = 12,
    EnableTitleLength = 13,
    DisableStillThrottle = 14,
    EnableLoggingEvents = 15,
    MaxReadBurstInKB = 16,
    ReadBurstPeriodInMS = 17,
    RestartDisc = 18,
    EnableCC = 19,
};
pub const DVD_ResetOnStop = DVD_OPTION_FLAG.ResetOnStop;
pub const DVD_NotifyParentalLevelChange = DVD_OPTION_FLAG.NotifyParentalLevelChange;
pub const DVD_HMSF_TimeCodeEvents = DVD_OPTION_FLAG.HMSF_TimeCodeEvents;
pub const DVD_AudioDuringFFwdRew = DVD_OPTION_FLAG.AudioDuringFFwdRew;
pub const DVD_EnableNonblockingAPIs = DVD_OPTION_FLAG.EnableNonblockingAPIs;
pub const DVD_CacheSizeInMB = DVD_OPTION_FLAG.CacheSizeInMB;
pub const DVD_EnablePortableBookmarks = DVD_OPTION_FLAG.EnablePortableBookmarks;
pub const DVD_EnableExtendedCopyProtectErrors = DVD_OPTION_FLAG.EnableExtendedCopyProtectErrors;
pub const DVD_NotifyPositionChange = DVD_OPTION_FLAG.NotifyPositionChange;
pub const DVD_IncreaseOutputControl = DVD_OPTION_FLAG.IncreaseOutputControl;
pub const DVD_EnableStreaming = DVD_OPTION_FLAG.EnableStreaming;
pub const DVD_EnableESOutput = DVD_OPTION_FLAG.EnableESOutput;
pub const DVD_EnableTitleLength = DVD_OPTION_FLAG.EnableTitleLength;
pub const DVD_DisableStillThrottle = DVD_OPTION_FLAG.DisableStillThrottle;
pub const DVD_EnableLoggingEvents = DVD_OPTION_FLAG.EnableLoggingEvents;
pub const DVD_MaxReadBurstInKB = DVD_OPTION_FLAG.MaxReadBurstInKB;
pub const DVD_ReadBurstPeriodInMS = DVD_OPTION_FLAG.ReadBurstPeriodInMS;
pub const DVD_RestartDisc = DVD_OPTION_FLAG.RestartDisc;
pub const DVD_EnableCC = DVD_OPTION_FLAG.EnableCC;

pub const DVD_RELATIVE_BUTTON = enum(i32) {
    Upper = 1,
    Lower = 2,
    Left = 3,
    Right = 4,
};
pub const DVD_Relative_Upper = DVD_RELATIVE_BUTTON.Upper;
pub const DVD_Relative_Lower = DVD_RELATIVE_BUTTON.Lower;
pub const DVD_Relative_Left = DVD_RELATIVE_BUTTON.Left;
pub const DVD_Relative_Right = DVD_RELATIVE_BUTTON.Right;

pub const DVD_PARENTAL_LEVEL = enum(i32) {
    @"8" = 32768,
    @"7" = 16384,
    @"6" = 8192,
    @"5" = 4096,
    @"4" = 2048,
    @"3" = 1024,
    @"2" = 512,
    @"1" = 256,
};
pub const DVD_PARENTAL_LEVEL_8 = DVD_PARENTAL_LEVEL.@"8";
pub const DVD_PARENTAL_LEVEL_7 = DVD_PARENTAL_LEVEL.@"7";
pub const DVD_PARENTAL_LEVEL_6 = DVD_PARENTAL_LEVEL.@"6";
pub const DVD_PARENTAL_LEVEL_5 = DVD_PARENTAL_LEVEL.@"5";
pub const DVD_PARENTAL_LEVEL_4 = DVD_PARENTAL_LEVEL.@"4";
pub const DVD_PARENTAL_LEVEL_3 = DVD_PARENTAL_LEVEL.@"3";
pub const DVD_PARENTAL_LEVEL_2 = DVD_PARENTAL_LEVEL.@"2";
pub const DVD_PARENTAL_LEVEL_1 = DVD_PARENTAL_LEVEL.@"1";

pub const DVD_AUDIO_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Captions = 1,
    VisuallyImpaired = 2,
    DirectorComments1 = 3,
    DirectorComments2 = 4,
};
pub const DVD_AUD_EXT_NotSpecified = DVD_AUDIO_LANG_EXT.NotSpecified;
pub const DVD_AUD_EXT_Captions = DVD_AUDIO_LANG_EXT.Captions;
pub const DVD_AUD_EXT_VisuallyImpaired = DVD_AUDIO_LANG_EXT.VisuallyImpaired;
pub const DVD_AUD_EXT_DirectorComments1 = DVD_AUDIO_LANG_EXT.DirectorComments1;
pub const DVD_AUD_EXT_DirectorComments2 = DVD_AUDIO_LANG_EXT.DirectorComments2;

pub const DVD_SUBPICTURE_LANG_EXT = enum(i32) {
    NotSpecified = 0,
    Caption_Normal = 1,
    Caption_Big = 2,
    Caption_Children = 3,
    CC_Normal = 5,
    CC_Big = 6,
    CC_Children = 7,
    Forced = 9,
    DirectorComments_Normal = 13,
    DirectorComments_Big = 14,
    DirectorComments_Children = 15,
};
pub const DVD_SP_EXT_NotSpecified = DVD_SUBPICTURE_LANG_EXT.NotSpecified;
pub const DVD_SP_EXT_Caption_Normal = DVD_SUBPICTURE_LANG_EXT.Caption_Normal;
pub const DVD_SP_EXT_Caption_Big = DVD_SUBPICTURE_LANG_EXT.Caption_Big;
pub const DVD_SP_EXT_Caption_Children = DVD_SUBPICTURE_LANG_EXT.Caption_Children;
pub const DVD_SP_EXT_CC_Normal = DVD_SUBPICTURE_LANG_EXT.CC_Normal;
pub const DVD_SP_EXT_CC_Big = DVD_SUBPICTURE_LANG_EXT.CC_Big;
pub const DVD_SP_EXT_CC_Children = DVD_SUBPICTURE_LANG_EXT.CC_Children;
pub const DVD_SP_EXT_Forced = DVD_SUBPICTURE_LANG_EXT.Forced;
pub const DVD_SP_EXT_DirectorComments_Normal = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Normal;
pub const DVD_SP_EXT_DirectorComments_Big = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Big;
pub const DVD_SP_EXT_DirectorComments_Children = DVD_SUBPICTURE_LANG_EXT.DirectorComments_Children;

pub const DVD_AUDIO_APPMODE = enum(i32) {
    None = 0,
    Karaoke = 1,
    Surround = 2,
    Other = 3,
};
pub const DVD_AudioMode_None = DVD_AUDIO_APPMODE.None;
pub const DVD_AudioMode_Karaoke = DVD_AUDIO_APPMODE.Karaoke;
pub const DVD_AudioMode_Surround = DVD_AUDIO_APPMODE.Surround;
pub const DVD_AudioMode_Other = DVD_AUDIO_APPMODE.Other;

pub const DVD_AUDIO_FORMAT = enum(i32) {
    AC3 = 0,
    MPEG1 = 1,
    MPEG1_DRC = 2,
    MPEG2 = 3,
    MPEG2_DRC = 4,
    LPCM = 5,
    DTS = 6,
    SDDS = 7,
    Other = 8,
};
pub const DVD_AudioFormat_AC3 = DVD_AUDIO_FORMAT.AC3;
pub const DVD_AudioFormat_MPEG1 = DVD_AUDIO_FORMAT.MPEG1;
pub const DVD_AudioFormat_MPEG1_DRC = DVD_AUDIO_FORMAT.MPEG1_DRC;
pub const DVD_AudioFormat_MPEG2 = DVD_AUDIO_FORMAT.MPEG2;
pub const DVD_AudioFormat_MPEG2_DRC = DVD_AUDIO_FORMAT.MPEG2_DRC;
pub const DVD_AudioFormat_LPCM = DVD_AUDIO_FORMAT.LPCM;
pub const DVD_AudioFormat_DTS = DVD_AUDIO_FORMAT.DTS;
pub const DVD_AudioFormat_SDDS = DVD_AUDIO_FORMAT.SDDS;
pub const DVD_AudioFormat_Other = DVD_AUDIO_FORMAT.Other;

pub const DVD_KARAOKE_DOWNMIX = enum(i32) {
    @"0to0" = 1,
    @"1to0" = 2,
    @"2to0" = 4,
    @"3to0" = 8,
    @"4to0" = 16,
    Lto0 = 32,
    Rto0 = 64,
    @"0to1" = 256,
    @"1to1" = 512,
    @"2to1" = 1024,
    @"3to1" = 2048,
    @"4to1" = 4096,
    Lto1 = 8192,
    Rto1 = 16384,
};
pub const DVD_Mix_0to0 = DVD_KARAOKE_DOWNMIX.@"0to0";
pub const DVD_Mix_1to0 = DVD_KARAOKE_DOWNMIX.@"1to0";
pub const DVD_Mix_2to0 = DVD_KARAOKE_DOWNMIX.@"2to0";
pub const DVD_Mix_3to0 = DVD_KARAOKE_DOWNMIX.@"3to0";
pub const DVD_Mix_4to0 = DVD_KARAOKE_DOWNMIX.@"4to0";
pub const DVD_Mix_Lto0 = DVD_KARAOKE_DOWNMIX.Lto0;
pub const DVD_Mix_Rto0 = DVD_KARAOKE_DOWNMIX.Rto0;
pub const DVD_Mix_0to1 = DVD_KARAOKE_DOWNMIX.@"0to1";
pub const DVD_Mix_1to1 = DVD_KARAOKE_DOWNMIX.@"1to1";
pub const DVD_Mix_2to1 = DVD_KARAOKE_DOWNMIX.@"2to1";
pub const DVD_Mix_3to1 = DVD_KARAOKE_DOWNMIX.@"3to1";
pub const DVD_Mix_4to1 = DVD_KARAOKE_DOWNMIX.@"4to1";
pub const DVD_Mix_Lto1 = DVD_KARAOKE_DOWNMIX.Lto1;
pub const DVD_Mix_Rto1 = DVD_KARAOKE_DOWNMIX.Rto1;

pub const DVD_AudioAttributes = extern struct {
    AppMode: DVD_AUDIO_APPMODE,
    AppModeData: u8,
    AudioFormat: DVD_AUDIO_FORMAT,
    Language: u32,
    LanguageExtension: DVD_AUDIO_LANG_EXT,
    fHasMultichannelInfo: BOOL,
    dwFrequency: u32,
    bQuantization: u8,
    bNumberOfChannels: u8,
    dwReserved: [2]u32,
};

pub const DVD_MUA_MixingInfo = extern struct {
    fMixTo0: BOOL,
    fMixTo1: BOOL,
    fMix0InPhase: BOOL,
    fMix1InPhase: BOOL,
    dwSpeakerPosition: u32,
};

pub const DVD_MUA_Coeff = extern struct {
    log2_alpha: f64,
    log2_beta: f64,
};

pub const DVD_MultichannelAudioAttributes = extern struct {
    Info: [8]DVD_MUA_MixingInfo,
    Coeff: [8]DVD_MUA_Coeff,
};

pub const DVD_KARAOKE_CONTENTS = enum(i32) {
    GuideVocal1 = 1,
    GuideVocal2 = 2,
    GuideMelody1 = 4,
    GuideMelody2 = 8,
    GuideMelodyA = 16,
    GuideMelodyB = 32,
    SoundEffectA = 64,
    SoundEffectB = 128,
};
pub const DVD_Karaoke_GuideVocal1 = DVD_KARAOKE_CONTENTS.GuideVocal1;
pub const DVD_Karaoke_GuideVocal2 = DVD_KARAOKE_CONTENTS.GuideVocal2;
pub const DVD_Karaoke_GuideMelody1 = DVD_KARAOKE_CONTENTS.GuideMelody1;
pub const DVD_Karaoke_GuideMelody2 = DVD_KARAOKE_CONTENTS.GuideMelody2;
pub const DVD_Karaoke_GuideMelodyA = DVD_KARAOKE_CONTENTS.GuideMelodyA;
pub const DVD_Karaoke_GuideMelodyB = DVD_KARAOKE_CONTENTS.GuideMelodyB;
pub const DVD_Karaoke_SoundEffectA = DVD_KARAOKE_CONTENTS.SoundEffectA;
pub const DVD_Karaoke_SoundEffectB = DVD_KARAOKE_CONTENTS.SoundEffectB;

pub const DVD_KARAOKE_ASSIGNMENT = enum(i32) {
    reserved0 = 0,
    reserved1 = 1,
    LR = 2,
    LRM = 3,
    LR1 = 4,
    LRM1 = 5,
    LR12 = 6,
    LRM12 = 7,
};
pub const DVD_Assignment_reserved0 = DVD_KARAOKE_ASSIGNMENT.reserved0;
pub const DVD_Assignment_reserved1 = DVD_KARAOKE_ASSIGNMENT.reserved1;
pub const DVD_Assignment_LR = DVD_KARAOKE_ASSIGNMENT.LR;
pub const DVD_Assignment_LRM = DVD_KARAOKE_ASSIGNMENT.LRM;
pub const DVD_Assignment_LR1 = DVD_KARAOKE_ASSIGNMENT.LR1;
pub const DVD_Assignment_LRM1 = DVD_KARAOKE_ASSIGNMENT.LRM1;
pub const DVD_Assignment_LR12 = DVD_KARAOKE_ASSIGNMENT.LR12;
pub const DVD_Assignment_LRM12 = DVD_KARAOKE_ASSIGNMENT.LRM12;

pub const DVD_KaraokeAttributes = extern struct {
    bVersion: u8,
    fMasterOfCeremoniesInGuideVocal1: BOOL,
    fDuet: BOOL,
    ChannelAssignment: DVD_KARAOKE_ASSIGNMENT,
    wChannelContents: [8]u16,
};

pub const DVD_VIDEO_COMPRESSION = enum(i32) {
    Other = 0,
    MPEG1 = 1,
    MPEG2 = 2,
};
pub const DVD_VideoCompression_Other = DVD_VIDEO_COMPRESSION.Other;
pub const DVD_VideoCompression_MPEG1 = DVD_VIDEO_COMPRESSION.MPEG1;
pub const DVD_VideoCompression_MPEG2 = DVD_VIDEO_COMPRESSION.MPEG2;

pub const DVD_VideoAttributes = extern struct {
    fPanscanPermitted: BOOL,
    fLetterboxPermitted: BOOL,
    ulAspectX: u32,
    ulAspectY: u32,
    ulFrameRate: u32,
    ulFrameHeight: u32,
    Compression: DVD_VIDEO_COMPRESSION,
    fLine21Field1InGOP: BOOL,
    fLine21Field2InGOP: BOOL,
    ulSourceResolutionX: u32,
    ulSourceResolutionY: u32,
    fIsSourceLetterboxed: BOOL,
    fIsFilmMode: BOOL,
};

pub const DVD_SUBPICTURE_TYPE = enum(i32) {
    NotSpecified = 0,
    Language = 1,
    Other = 2,
};
pub const DVD_SPType_NotSpecified = DVD_SUBPICTURE_TYPE.NotSpecified;
pub const DVD_SPType_Language = DVD_SUBPICTURE_TYPE.Language;
pub const DVD_SPType_Other = DVD_SUBPICTURE_TYPE.Other;

pub const DVD_SUBPICTURE_CODING = enum(i32) {
    RunLength = 0,
    Extended = 1,
    Other = 2,
};
pub const DVD_SPCoding_RunLength = DVD_SUBPICTURE_CODING.RunLength;
pub const DVD_SPCoding_Extended = DVD_SUBPICTURE_CODING.Extended;
pub const DVD_SPCoding_Other = DVD_SUBPICTURE_CODING.Other;

pub const DVD_SubpictureAttributes = extern struct {
    Type: DVD_SUBPICTURE_TYPE,
    CodingMode: DVD_SUBPICTURE_CODING,
    Language: u32,
    LanguageExtension: DVD_SUBPICTURE_LANG_EXT,
};

pub const DVD_TITLE_APPMODE = enum(i32) {
    Not_Specified = 0,
    Karaoke = 1,
    Other = 3,
};
pub const DVD_AppMode_Not_Specified = DVD_TITLE_APPMODE.Not_Specified;
pub const DVD_AppMode_Karaoke = DVD_TITLE_APPMODE.Karaoke;
pub const DVD_AppMode_Other = DVD_TITLE_APPMODE.Other;

pub const DVD_TitleAttributes = extern struct {
    Anonymous: extern union {
        AppMode: DVD_TITLE_APPMODE,
        TitleLength: DVD_HMSF_TIMECODE,
    },
    VideoAttributes: DVD_VideoAttributes,
    ulNumberOfAudioStreams: u32,
    AudioAttributes: [8]DVD_AudioAttributes,
    MultichannelAudioAttributes: [8]DVD_MultichannelAudioAttributes,
    ulNumberOfSubpictureStreams: u32,
    SubpictureAttributes: [32]DVD_SubpictureAttributes,
};

pub const DVD_MenuAttributes = extern struct {
    fCompatibleRegion: [8]BOOL,
    VideoAttributes: DVD_VideoAttributes,
    fAudioPresent: BOOL,
    AudioAttributes: DVD_AudioAttributes,
    fSubpicturePresent: BOOL,
    SubpictureAttributes: DVD_SubpictureAttributes,
};

const IID_IDvdControl_Value = Guid.initString("a70efe61-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdControl = &IID_IDvdControl_Value;
pub const IDvdControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TitlePlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulTitle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulTitle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChapterPlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulTitle: u32,
                ulChapter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulTitle: u32,
                ulChapter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TimePlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulTitle: u32,
                bcdTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulTitle: u32,
                bcdTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopForResume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GoUp: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TimeSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                bcdTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                bcdTime: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChapterSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulChapter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulChapter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PrevPGSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TopPGSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextPGSearch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ForwardScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                dwSpeed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                dwSpeed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BackwardScan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                dwSpeed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                dwSpeed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MenuCall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                MenuID: DVD_MENU_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                MenuID: DVD_MENU_ID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpperButtonSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LowerButtonSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LeftButtonSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RightButtonSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ButtonActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ButtonSelectAndActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StillOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseOn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PauseOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MenuLanguageSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                Language: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                Language: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AudioStreamChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulAudio: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulAudio: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SubpictureStreamChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulSubPicture: u32,
                bDisplay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulSubPicture: u32,
                bDisplay: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AngleChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulAngle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulAngle: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParentalLevelSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulParentalLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulParentalLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ParentalCountrySelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                wCountry: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                wCountry: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KaraokeAudioPresentationModeChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VideoModePreferrence: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulPreferredDisplayMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulPreferredDisplayMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                pszPath: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                pszPath: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MouseActivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MouseSelect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChapterPlayAutoStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl,
                ulTitle: u32,
                ulChapter: u32,
                ulChaptersToPlay: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl,
                ulTitle: u32,
                ulChapter: u32,
                ulChaptersToPlay: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TitlePlay(self: *const T, ulTitle: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TitlePlay(@as(*const IDvdControl, @ptrCast(self)), ulTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterPlay(self: *const T, ulTitle: u32, ulChapter: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterPlay(@as(*const IDvdControl, @ptrCast(self)), ulTitle, ulChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TimePlay(self: *const T, ulTitle: u32, bcdTime: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TimePlay(@as(*const IDvdControl, @ptrCast(self)), ulTitle, bcdTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_StopForResume(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).StopForResume(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_GoUp(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).GoUp(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TimeSearch(self: *const T, bcdTime: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TimeSearch(@as(*const IDvdControl, @ptrCast(self)), bcdTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterSearch(self: *const T, ulChapter: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterSearch(@as(*const IDvdControl, @ptrCast(self)), ulChapter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PrevPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PrevPGSearch(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_TopPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).TopPGSearch(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_NextPGSearch(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).NextPGSearch(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ForwardScan(self: *const T, dwSpeed: f64) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ForwardScan(@as(*const IDvdControl, @ptrCast(self)), dwSpeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_BackwardScan(self: *const T, dwSpeed: f64) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).BackwardScan(@as(*const IDvdControl, @ptrCast(self)), dwSpeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MenuCall(self: *const T, MenuID: DVD_MENU_ID) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MenuCall(@as(*const IDvdControl, @ptrCast(self)), MenuID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).Resume(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_UpperButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).UpperButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_LowerButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).LowerButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_LeftButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).LeftButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_RightButtonSelect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).RightButtonSelect(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ButtonActivate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ButtonActivate(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ButtonSelectAndActivate(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ButtonSelectAndActivate(@as(*const IDvdControl, @ptrCast(self)), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PauseOn(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PauseOn(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_PauseOff(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).PauseOff(@as(*const IDvdControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MenuLanguageSelect(self: *const T, Language: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MenuLanguageSelect(@as(*const IDvdControl, @ptrCast(self)), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_AudioStreamChange(self: *const T, ulAudio: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).AudioStreamChange(@as(*const IDvdControl, @ptrCast(self)), ulAudio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_SubpictureStreamChange(self: *const T, ulSubPicture: u32, bDisplay: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).SubpictureStreamChange(@as(*const IDvdControl, @ptrCast(self)), ulSubPicture, bDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_AngleChange(self: *const T, ulAngle: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).AngleChange(@as(*const IDvdControl, @ptrCast(self)), ulAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ParentalLevelSelect(self: *const T, ulParentalLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ParentalLevelSelect(@as(*const IDvdControl, @ptrCast(self)), ulParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ParentalCountrySelect(self: *const T, wCountry: u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ParentalCountrySelect(@as(*const IDvdControl, @ptrCast(self)), wCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_KaraokeAudioPresentationModeChange(self: *const T, ulMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).KaraokeAudioPresentationModeChange(@as(*const IDvdControl, @ptrCast(self)), ulMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_VideoModePreferrence(self: *const T, ulPreferredDisplayMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).VideoModePreferrence(@as(*const IDvdControl, @ptrCast(self)), ulPreferredDisplayMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_SetRoot(self: *const T, pszPath: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).SetRoot(@as(*const IDvdControl, @ptrCast(self)), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MouseActivate(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MouseActivate(@as(*const IDvdControl, @ptrCast(self)), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_MouseSelect(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).MouseSelect(@as(*const IDvdControl, @ptrCast(self)), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl_ChapterPlayAutoStop(self: *const T, ulTitle: u32, ulChapter: u32, ulChaptersToPlay: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl.VTable, @ptrCast(self.vtable)).ChapterPlayAutoStop(@as(*const IDvdControl, @ptrCast(self)), ulTitle, ulChapter, ulChaptersToPlay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDvdInfo_Value = Guid.initString("a70efe60-e2a3-11d0-a9be-00aa0061be93");
pub const IID_IDvdInfo = &IID_IDvdInfo_Value;
pub const IDvdInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pDomain: ?*DVD_DOMAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pDomain: ?*DVD_DOMAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pLocation: ?*DVD_PLAYBACK_LOCATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pLocation: ?*DVD_PLAYBACK_LOCATION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalTitleTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulTotalTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulTotalTime: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulButtonsAvailable: ?*u32,
                pulCurrentButton: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulButtonsAvailable: ?*u32,
                pulCurrentButton: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAngle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulAnglesAvailable: ?*u32,
                pulCurrentAngle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulAnglesAvailable: ?*u32,
                pulCurrentAngle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSubpicture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
                pIsDisabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
                pIsDisabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentUOPS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pUOP: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pUOP: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllSPRMs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllGPRMs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitleAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pATR: ?*DVD_ATR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pATR: ?*DVD_ATR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVMGAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pATR: ?*DVD_ATR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pATR: ?*DVD_ATR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentVideoAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAudioAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSubpictureAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pATR: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentVolumeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulNumOfVol: ?*u32,
                pulThisVolNum: ?*u32,
                pSide: ?*DVD_DISC_SIDE,
                pulNumOfTitles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulNumOfVol: ?*u32,
                pulThisVolNum: ?*u32,
                pSide: ?*DVD_DISC_SIDE,
                pulNumOfTitles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDTextInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                // TODO: what to do with BytesParamIndex 1?
                pTextManager: ?*u8,
                ulBufSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                // TODO: what to do with BytesParamIndex 1?
                pTextManager: ?*u8,
                ulBufSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayerParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pulParentalLevel: ?*u32,
                pulCountryCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pulParentalLevel: ?*u32,
                pulCountryCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfChapters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pulNumberOfChapters: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pulNumberOfChapters: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitleParentalLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pulParentalLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                ulTitle: u32,
                pulParentalLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRoot: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo,
                pRoot: [*:0]u8,
                ulBufSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo,
                pRoot: [*:0]u8,
                ulBufSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentDomain(self: *const T, pDomain: ?*DVD_DOMAIN) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentDomain(@as(*const IDvdInfo, @ptrCast(self)), pDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentLocation(self: *const T, pLocation: ?*DVD_PLAYBACK_LOCATION) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentLocation(@as(*const IDvdInfo, @ptrCast(self)), pLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTotalTitleTime(self: *const T, pulTotalTime: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTotalTitleTime(@as(*const IDvdInfo, @ptrCast(self)), pulTotalTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentButton(self: *const T, pulButtonsAvailable: ?*u32, pulCurrentButton: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentButton(@as(*const IDvdInfo, @ptrCast(self)), pulButtonsAvailable, pulCurrentButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAngle(self: *const T, pulAnglesAvailable: ?*u32, pulCurrentAngle: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAngle(@as(*const IDvdInfo, @ptrCast(self)), pulAnglesAvailable, pulCurrentAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAudio(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAudio(@as(*const IDvdInfo, @ptrCast(self)), pulStreamsAvailable, pulCurrentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentSubpicture(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32, pIsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentSubpicture(@as(*const IDvdInfo, @ptrCast(self)), pulStreamsAvailable, pulCurrentStream, pIsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentUOPS(self: *const T, pUOP: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentUOPS(@as(*const IDvdInfo, @ptrCast(self)), pUOP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAllSPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAllSPRMs(@as(*const IDvdInfo, @ptrCast(self)), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAllGPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAllGPRMs(@as(*const IDvdInfo, @ptrCast(self)), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetAudioLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetAudioLanguage(@as(*const IDvdInfo, @ptrCast(self)), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetSubpictureLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetSubpictureLanguage(@as(*const IDvdInfo, @ptrCast(self)), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTitleAttributes(self: *const T, ulTitle: u32, pATR: ?*DVD_ATR) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTitleAttributes(@as(*const IDvdInfo, @ptrCast(self)), ulTitle, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetVMGAttributes(self: *const T, pATR: ?*DVD_ATR) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetVMGAttributes(@as(*const IDvdInfo, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentVideoAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentVideoAttributes(@as(*const IDvdInfo, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentAudioAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentAudioAttributes(@as(*const IDvdInfo, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentSubpictureAttributes(self: *const T, pATR: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentSubpictureAttributes(@as(*const IDvdInfo, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetCurrentVolumeInfo(self: *const T, pulNumOfVol: ?*u32, pulThisVolNum: ?*u32, pSide: ?*DVD_DISC_SIDE, pulNumOfTitles: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetCurrentVolumeInfo(@as(*const IDvdInfo, @ptrCast(self)), pulNumOfVol, pulThisVolNum, pSide, pulNumOfTitles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetDVDTextInfo(self: *const T, pTextManager: ?*u8, ulBufSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetDVDTextInfo(@as(*const IDvdInfo, @ptrCast(self)), pTextManager, ulBufSize, pulActualSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetPlayerParentalLevel(self: *const T, pulParentalLevel: ?*u32, pulCountryCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetPlayerParentalLevel(@as(*const IDvdInfo, @ptrCast(self)), pulParentalLevel, pulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetNumberOfChapters(self: *const T, ulTitle: u32, pulNumberOfChapters: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetNumberOfChapters(@as(*const IDvdInfo, @ptrCast(self)), ulTitle, pulNumberOfChapters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetTitleParentalLevels(self: *const T, ulTitle: u32, pulParentalLevels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetTitleParentalLevels(@as(*const IDvdInfo, @ptrCast(self)), ulTitle, pulParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo_GetRoot(self: *const T, pRoot: [*:0]u8, ulBufSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo.VTable, @ptrCast(self.vtable)).GetRoot(@as(*const IDvdInfo, @ptrCast(self)), pRoot, ulBufSize, pulActualSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdCmd_Value = Guid.initString("5a4a97e4-94ee-4a55-9751-74b5643aa27d");
pub const IID_IDvdCmd = &IID_IDvdCmd_Value;
pub const IDvdCmd = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        WaitForStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForEnd: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdCmd_WaitForStart(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdCmd.VTable, @ptrCast(self.vtable)).WaitForStart(@as(*const IDvdCmd, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdCmd_WaitForEnd(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdCmd.VTable, @ptrCast(self.vtable)).WaitForEnd(@as(*const IDvdCmd, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdState_Value = Guid.initString("86303d6d-1c4a-4087-ab42-f711167048ef");
pub const IID_IDvdState = &IID_IDvdState_Value;
pub const IDvdState = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDiscID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdState,
                pullUniqueID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdState,
                pullUniqueID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdState,
                pulParentalLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdState,
                pulParentalLevel: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdState_GetDiscID(self: *const T, pullUniqueID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDvdState.VTable, @ptrCast(self.vtable)).GetDiscID(@as(*const IDvdState, @ptrCast(self)), pullUniqueID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdState_GetParentalLevel(self: *const T, pulParentalLevel: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdState.VTable, @ptrCast(self.vtable)).GetParentalLevel(@as(*const IDvdState, @ptrCast(self)), pulParentalLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdControl2_Value = Guid.initString("33bc7430-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdControl2 = &IID_IDvdControl2_Value;
pub const IDvdControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PlayTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapterInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                ulChapter: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                ulChapter: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTimeInTitle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                pStartTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                pStartTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReturnFromSubmenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayAtTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                pTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                pTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulChapter: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulChapter: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayPrevChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReplayChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayNextChapter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayForwards: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dSpeed: f64,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dSpeed: f64,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayBackwards: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dSpeed: f64,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dSpeed: f64,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ShowMenu: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                MenuID: DVD_MENU_ID,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                MenuID: DVD_MENU_ID,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Resume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectRelativeButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                buttonDir: DVD_RELATIVE_BUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                buttonDir: DVD_RELATIVE_BUTTON,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAndActivateButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulButton: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StillOff: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                bState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAudioStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulAudio: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulAudio: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectSubpictureStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulSubPicture: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulSubPicture: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSubpictureState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                bState: BOOL,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                bState: BOOL,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAngle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulAngle: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulAngle: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulParentalLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulParentalLevel: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectParentalCountry: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                bCountry: *[2]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                bCountry: *[2]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectKaraokeAudioPresentationMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectVideoModePreference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulPreferredDisplayMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulPreferredDisplayMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDVDDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                pszwPath: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                pszwPath: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ActivateAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                point: POINT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayChaptersAutoStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                ulChapter: u32,
                ulChaptersToPlay: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                ulChapter: u32,
                ulChaptersToPlay: u32,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcceptParentalLevelChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                bAccept: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                bAccept: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                flag: DVD_OPTION_FLAG,
                fState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                flag: DVD_OPTION_FLAG,
                fState: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                pState: ?*IDvdState,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                pState: ?*IDvdState,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PlayPeriodInTitleAutoStop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                pStartTime: ?*DVD_HMSF_TIMECODE,
                pEndTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulTitle: u32,
                pStartTime: ?*DVD_HMSF_TIMECODE,
                pEndTime: ?*DVD_HMSF_TIMECODE,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGPRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                ulIndex: u32,
                wValue: u16,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                ulIndex: u32,
                wValue: u16,
                dwFlags: u32,
                ppCmd: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectDefaultMenuLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                Language: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                Language: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectDefaultAudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                Language: u32,
                audioExtension: DVD_AUDIO_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                Language: u32,
                audioExtension: DVD_AUDIO_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SelectDefaultSubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdControl2,
                Language: u32,
                subpictureExtension: DVD_SUBPICTURE_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdControl2,
                Language: u32,
                subpictureExtension: DVD_SUBPICTURE_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayTitle(self: *const T, ulTitle: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayTitle(@as(*const IDvdControl2, @ptrCast(self)), ulTitle, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChapterInTitle(self: *const T, ulTitle: u32, ulChapter: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChapterInTitle(@as(*const IDvdControl2, @ptrCast(self)), ulTitle, ulChapter, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayAtTimeInTitle(self: *const T, ulTitle: u32, pStartTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayAtTimeInTitle(@as(*const IDvdControl2, @ptrCast(self)), ulTitle, pStartTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Stop(@as(*const IDvdControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ReturnFromSubmenu(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ReturnFromSubmenu(@as(*const IDvdControl2, @ptrCast(self)), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayAtTime(self: *const T, pTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayAtTime(@as(*const IDvdControl2, @ptrCast(self)), pTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChapter(self: *const T, ulChapter: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChapter(@as(*const IDvdControl2, @ptrCast(self)), ulChapter, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayPrevChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayPrevChapter(@as(*const IDvdControl2, @ptrCast(self)), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ReplayChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ReplayChapter(@as(*const IDvdControl2, @ptrCast(self)), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayNextChapter(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayNextChapter(@as(*const IDvdControl2, @ptrCast(self)), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayForwards(self: *const T, dSpeed: f64, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayForwards(@as(*const IDvdControl2, @ptrCast(self)), dSpeed, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayBackwards(self: *const T, dSpeed: f64, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayBackwards(@as(*const IDvdControl2, @ptrCast(self)), dSpeed, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ShowMenu(self: *const T, MenuID: DVD_MENU_ID, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ShowMenu(@as(*const IDvdControl2, @ptrCast(self)), MenuID, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Resume(self: *const T, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Resume(@as(*const IDvdControl2, @ptrCast(self)), dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectRelativeButton(self: *const T, buttonDir: DVD_RELATIVE_BUTTON) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectRelativeButton(@as(*const IDvdControl2, @ptrCast(self)), buttonDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ActivateButton(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ActivateButton(@as(*const IDvdControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectButton(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectButton(@as(*const IDvdControl2, @ptrCast(self)), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAndActivateButton(self: *const T, ulButton: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAndActivateButton(@as(*const IDvdControl2, @ptrCast(self)), ulButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_StillOff(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).StillOff(@as(*const IDvdControl2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_Pause(self: *const T, bState: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).Pause(@as(*const IDvdControl2, @ptrCast(self)), bState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAudioStream(self: *const T, ulAudio: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAudioStream(@as(*const IDvdControl2, @ptrCast(self)), ulAudio, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectSubpictureStream(self: *const T, ulSubPicture: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectSubpictureStream(@as(*const IDvdControl2, @ptrCast(self)), ulSubPicture, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetSubpictureState(self: *const T, bState: BOOL, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetSubpictureState(@as(*const IDvdControl2, @ptrCast(self)), bState, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAngle(self: *const T, ulAngle: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAngle(@as(*const IDvdControl2, @ptrCast(self)), ulAngle, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectParentalLevel(self: *const T, ulParentalLevel: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectParentalLevel(@as(*const IDvdControl2, @ptrCast(self)), ulParentalLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectParentalCountry(self: *const T, bCountry: *[2]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectParentalCountry(@as(*const IDvdControl2, @ptrCast(self)), bCountry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectKaraokeAudioPresentationMode(self: *const T, ulMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectKaraokeAudioPresentationMode(@as(*const IDvdControl2, @ptrCast(self)), ulMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectVideoModePreference(self: *const T, ulPreferredDisplayMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectVideoModePreference(@as(*const IDvdControl2, @ptrCast(self)), ulPreferredDisplayMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetDVDDirectory(self: *const T, pszwPath: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetDVDDirectory(@as(*const IDvdControl2, @ptrCast(self)), pszwPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_ActivateAtPosition(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).ActivateAtPosition(@as(*const IDvdControl2, @ptrCast(self)), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectAtPosition(self: *const T, point: POINT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectAtPosition(@as(*const IDvdControl2, @ptrCast(self)), point);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayChaptersAutoStop(self: *const T, ulTitle: u32, ulChapter: u32, ulChaptersToPlay: u32, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayChaptersAutoStop(@as(*const IDvdControl2, @ptrCast(self)), ulTitle, ulChapter, ulChaptersToPlay, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_AcceptParentalLevelChange(self: *const T, bAccept: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).AcceptParentalLevelChange(@as(*const IDvdControl2, @ptrCast(self)), bAccept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetOption(self: *const T, flag: DVD_OPTION_FLAG, fState: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetOption(@as(*const IDvdControl2, @ptrCast(self)), flag, fState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetState(self: *const T, pState: ?*IDvdState, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetState(@as(*const IDvdControl2, @ptrCast(self)), pState, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_PlayPeriodInTitleAutoStop(self: *const T, ulTitle: u32, pStartTime: ?*DVD_HMSF_TIMECODE, pEndTime: ?*DVD_HMSF_TIMECODE, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).PlayPeriodInTitleAutoStop(@as(*const IDvdControl2, @ptrCast(self)), ulTitle, pStartTime, pEndTime, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SetGPRM(self: *const T, ulIndex: u32, wValue: u16, dwFlags: u32, ppCmd: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SetGPRM(@as(*const IDvdControl2, @ptrCast(self)), ulIndex, wValue, dwFlags, ppCmd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultMenuLanguage(self: *const T, Language: u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultMenuLanguage(@as(*const IDvdControl2, @ptrCast(self)), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultAudioLanguage(self: *const T, Language: u32, audioExtension: DVD_AUDIO_LANG_EXT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultAudioLanguage(@as(*const IDvdControl2, @ptrCast(self)), Language, audioExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdControl2_SelectDefaultSubpictureLanguage(self: *const T, Language: u32, subpictureExtension: DVD_SUBPICTURE_LANG_EXT) callconv(.Inline) HRESULT {
            return @as(*const IDvdControl2.VTable, @ptrCast(self.vtable)).SelectDefaultSubpictureLanguage(@as(*const IDvdControl2, @ptrCast(self)), Language, subpictureExtension);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DVD_TextStringType = enum(i32) {
    Struct_Volume = 1,
    Struct_Title = 2,
    Struct_ParentalID = 3,
    Struct_PartOfTitle = 4,
    Struct_Cell = 5,
    Stream_Audio = 16,
    Stream_Subpicture = 17,
    Stream_Angle = 18,
    Channel_Audio = 32,
    General_Name = 48,
    General_Comments = 49,
    Title_Series = 56,
    Title_Movie = 57,
    Title_Video = 58,
    Title_Album = 59,
    Title_Song = 60,
    Title_Other = 63,
    Title_Sub_Series = 64,
    Title_Sub_Movie = 65,
    Title_Sub_Video = 66,
    Title_Sub_Album = 67,
    Title_Sub_Song = 68,
    Title_Sub_Other = 71,
    Title_Orig_Series = 72,
    Title_Orig_Movie = 73,
    Title_Orig_Video = 74,
    Title_Orig_Album = 75,
    Title_Orig_Song = 76,
    Title_Orig_Other = 79,
    Other_Scene = 80,
    Other_Cut = 81,
    Other_Take = 82,
};
pub const DVD_Struct_Volume = DVD_TextStringType.Struct_Volume;
pub const DVD_Struct_Title = DVD_TextStringType.Struct_Title;
pub const DVD_Struct_ParentalID = DVD_TextStringType.Struct_ParentalID;
pub const DVD_Struct_PartOfTitle = DVD_TextStringType.Struct_PartOfTitle;
pub const DVD_Struct_Cell = DVD_TextStringType.Struct_Cell;
pub const DVD_Stream_Audio = DVD_TextStringType.Stream_Audio;
pub const DVD_Stream_Subpicture = DVD_TextStringType.Stream_Subpicture;
pub const DVD_Stream_Angle = DVD_TextStringType.Stream_Angle;
pub const DVD_Channel_Audio = DVD_TextStringType.Channel_Audio;
pub const DVD_General_Name = DVD_TextStringType.General_Name;
pub const DVD_General_Comments = DVD_TextStringType.General_Comments;
pub const DVD_Title_Series = DVD_TextStringType.Title_Series;
pub const DVD_Title_Movie = DVD_TextStringType.Title_Movie;
pub const DVD_Title_Video = DVD_TextStringType.Title_Video;
pub const DVD_Title_Album = DVD_TextStringType.Title_Album;
pub const DVD_Title_Song = DVD_TextStringType.Title_Song;
pub const DVD_Title_Other = DVD_TextStringType.Title_Other;
pub const DVD_Title_Sub_Series = DVD_TextStringType.Title_Sub_Series;
pub const DVD_Title_Sub_Movie = DVD_TextStringType.Title_Sub_Movie;
pub const DVD_Title_Sub_Video = DVD_TextStringType.Title_Sub_Video;
pub const DVD_Title_Sub_Album = DVD_TextStringType.Title_Sub_Album;
pub const DVD_Title_Sub_Song = DVD_TextStringType.Title_Sub_Song;
pub const DVD_Title_Sub_Other = DVD_TextStringType.Title_Sub_Other;
pub const DVD_Title_Orig_Series = DVD_TextStringType.Title_Orig_Series;
pub const DVD_Title_Orig_Movie = DVD_TextStringType.Title_Orig_Movie;
pub const DVD_Title_Orig_Video = DVD_TextStringType.Title_Orig_Video;
pub const DVD_Title_Orig_Album = DVD_TextStringType.Title_Orig_Album;
pub const DVD_Title_Orig_Song = DVD_TextStringType.Title_Orig_Song;
pub const DVD_Title_Orig_Other = DVD_TextStringType.Title_Orig_Other;
pub const DVD_Other_Scene = DVD_TextStringType.Other_Scene;
pub const DVD_Other_Cut = DVD_TextStringType.Other_Cut;
pub const DVD_Other_Take = DVD_TextStringType.Other_Take;

pub const DVD_TextCharSet = enum(i32) {
    Unicode = 0,
    ISO646 = 1,
    JIS_Roman_Kanji = 2,
    ISO8859_1 = 3,
    ShiftJIS_Kanji_Roman_Katakana = 4,
};
pub const DVD_CharSet_Unicode = DVD_TextCharSet.Unicode;
pub const DVD_CharSet_ISO646 = DVD_TextCharSet.ISO646;
pub const DVD_CharSet_JIS_Roman_Kanji = DVD_TextCharSet.JIS_Roman_Kanji;
pub const DVD_CharSet_ISO8859_1 = DVD_TextCharSet.ISO8859_1;
pub const DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana = DVD_TextCharSet.ShiftJIS_Kanji_Roman_Katakana;

pub const DVD_DECODER_CAPS = extern struct {
    dwSize: u32,
    dwAudioCaps: u32,
    dFwdMaxRateVideo: f64,
    dFwdMaxRateAudio: f64,
    dFwdMaxRateSP: f64,
    dBwdMaxRateVideo: f64,
    dBwdMaxRateAudio: f64,
    dBwdMaxRateSP: f64,
    dwRes1: u32,
    dwRes2: u32,
    dwRes3: u32,
    dwRes4: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDvdInfo2_Value = Guid.initString("34151510-eec0-11d2-8201-00a0c9d74842");
pub const IID_IDvdInfo2 = &IID_IDvdInfo2_Value;
pub const IDvdInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pDomain: ?*DVD_DOMAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pDomain: ?*DVD_DOMAIN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentLocation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pLocation: ?*DVD_PLAYBACK_LOCATION2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pLocation: ?*DVD_PLAYBACK_LOCATION2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTotalTitleTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pTotalTime: ?*DVD_HMSF_TIMECODE,
                ulTimeCodeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pTotalTime: ?*DVD_HMSF_TIMECODE,
                ulTimeCodeFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentButton: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulButtonsAvailable: ?*u32,
                pulCurrentButton: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulButtonsAvailable: ?*u32,
                pulCurrentButton: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAngle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulAnglesAvailable: ?*u32,
                pulCurrentAngle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulAnglesAvailable: ?*u32,
                pulCurrentAngle: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAudio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSubpicture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
                pbIsDisabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulStreamsAvailable: ?*u32,
                pulCurrentStream: ?*u32,
                pbIsDisabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentUOPS: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulUOPs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulUOPs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllSPRMs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAllGPRMs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pRegisterArray: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitleAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pMenu: ?*DVD_MenuAttributes,
                pTitle: ?*DVD_TitleAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pMenu: ?*DVD_MenuAttributes,
                pTitle: ?*DVD_TitleAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVMGAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pATR: ?*DVD_MenuAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pATR: ?*DVD_MenuAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentVideoAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pATR: ?*DVD_VideoAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pATR: ?*DVD_VideoAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAudioAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pATR: ?*DVD_AudioAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pATR: ?*DVD_AudioAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKaraokeAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pAttributes: ?*DVD_KaraokeAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pAttributes: ?*DVD_KaraokeAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSubpictureAttributes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pATR: ?*DVD_SubpictureAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStream: u32,
                pATR: ?*DVD_SubpictureAttributes,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDVolumeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulNumOfVolumes: ?*u32,
                pulVolume: ?*u32,
                pSide: ?*DVD_DISC_SIDE,
                pulNumOfTitles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulNumOfVolumes: ?*u32,
                pulVolume: ?*u32,
                pSide: ?*DVD_DISC_SIDE,
                pulNumOfTitles: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDTextNumberOfLanguages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulNumOfLangs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulNumOfLangs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDTextLanguageInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                pulNumOfStrings: ?*u32,
                pLangCode: ?*u32,
                pbCharacterSet: ?*DVD_TextCharSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                pulNumOfStrings: ?*u32,
                pLangCode: ?*u32,
                pbCharacterSet: ?*DVD_TextCharSet,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDTextStringAsNative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                ulStringIndex: u32,
                pbBuffer: ?*u8,
                ulMaxBufferSize: u32,
                pulActualSize: ?*u32,
                pType: ?*DVD_TextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                ulStringIndex: u32,
                pbBuffer: ?*u8,
                ulMaxBufferSize: u32,
                pulActualSize: ?*u32,
                pType: ?*DVD_TextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDTextStringAsUnicode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                ulStringIndex: u32,
                pchwBuffer: ?PWSTR,
                ulMaxBufferSize: u32,
                pulActualSize: ?*u32,
                pType: ?*DVD_TextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulLangIndex: u32,
                ulStringIndex: u32,
                pchwBuffer: ?PWSTR,
                ulMaxBufferSize: u32,
                pulActualSize: ?*u32,
                pType: ?*DVD_TextStringType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPlayerParentalLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pulParentalLevel: ?*u32,
                pbCountryCode: *[2]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pulParentalLevel: ?*u32,
                pbCountryCode: *[2]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfChapters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pulNumOfChapters: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pulNumOfChapters: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTitleParentalLevels: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pulParentalLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulTitle: u32,
                pulParentalLevels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDVDDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pszwPath: [*:0]u16,
                ulMaxSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pszwPath: [*:0]u16,
                ulMaxSize: u32,
                pulActualSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAudioStreamEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStreamNum: u32,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStreamNum: u32,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDiscID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pszwPath: ?[*:0]align(1) const u16,
                pullDiscID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pszwPath: ?[*:0]align(1) const u16,
                pullDiscID: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pStateData: ?*?*IDvdState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pStateData: ?*?*IDvdState,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMenuLanguages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pLanguages: ?*u32,
                ulMaxLanguages: u32,
                pulActualLanguages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pLanguages: ?*u32,
                ulMaxLanguages: u32,
                pulActualLanguages: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetButtonAtPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                point: POINT,
                pulButtonIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                point: POINT,
                pulButtonIndex: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCmdFromEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                lParam1: isize,
                pCmdObj: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                lParam1: isize,
                pCmdObj: ?*?*IDvdCmd,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMenuLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultAudioLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
                pAudioExtension: ?*DVD_AUDIO_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
                pAudioExtension: ?*DVD_AUDIO_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultSubpictureLanguage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
                pSubpictureExtension: ?*DVD_SUBPICTURE_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pLanguage: ?*u32,
                pSubpictureExtension: ?*DVD_SUBPICTURE_LANG_EXT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDecoderCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                pCaps: ?*DVD_DECODER_CAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                pCaps: ?*DVD_DECODER_CAPS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetButtonRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulButton: u32,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulButton: u32,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSubpictureStreamEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdInfo2,
                ulStreamNum: u32,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdInfo2,
                ulStreamNum: u32,
                pbEnabled: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentDomain(self: *const T, pDomain: ?*DVD_DOMAIN) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentDomain(@as(*const IDvdInfo2, @ptrCast(self)), pDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentLocation(self: *const T, pLocation: ?*DVD_PLAYBACK_LOCATION2) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentLocation(@as(*const IDvdInfo2, @ptrCast(self)), pLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTotalTitleTime(self: *const T, pTotalTime: ?*DVD_HMSF_TIMECODE, ulTimeCodeFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTotalTitleTime(@as(*const IDvdInfo2, @ptrCast(self)), pTotalTime, ulTimeCodeFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentButton(self: *const T, pulButtonsAvailable: ?*u32, pulCurrentButton: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentButton(@as(*const IDvdInfo2, @ptrCast(self)), pulButtonsAvailable, pulCurrentButton);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentAngle(self: *const T, pulAnglesAvailable: ?*u32, pulCurrentAngle: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentAngle(@as(*const IDvdInfo2, @ptrCast(self)), pulAnglesAvailable, pulCurrentAngle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentAudio(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentAudio(@as(*const IDvdInfo2, @ptrCast(self)), pulStreamsAvailable, pulCurrentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentSubpicture(self: *const T, pulStreamsAvailable: ?*u32, pulCurrentStream: ?*u32, pbIsDisabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentSubpicture(@as(*const IDvdInfo2, @ptrCast(self)), pulStreamsAvailable, pulCurrentStream, pbIsDisabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentUOPS(self: *const T, pulUOPs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentUOPS(@as(*const IDvdInfo2, @ptrCast(self)), pulUOPs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAllSPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAllSPRMs(@as(*const IDvdInfo2, @ptrCast(self)), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAllGPRMs(self: *const T, pRegisterArray: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAllGPRMs(@as(*const IDvdInfo2, @ptrCast(self)), pRegisterArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAudioLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAudioLanguage(@as(*const IDvdInfo2, @ptrCast(self)), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetSubpictureLanguage(self: *const T, ulStream: u32, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetSubpictureLanguage(@as(*const IDvdInfo2, @ptrCast(self)), ulStream, pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTitleAttributes(self: *const T, ulTitle: u32, pMenu: ?*DVD_MenuAttributes, pTitle: ?*DVD_TitleAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTitleAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ulTitle, pMenu, pTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetVMGAttributes(self: *const T, pATR: ?*DVD_MenuAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetVMGAttributes(@as(*const IDvdInfo2, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCurrentVideoAttributes(self: *const T, pATR: ?*DVD_VideoAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCurrentVideoAttributes(@as(*const IDvdInfo2, @ptrCast(self)), pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetAudioAttributes(self: *const T, ulStream: u32, pATR: ?*DVD_AudioAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetAudioAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ulStream, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetKaraokeAttributes(self: *const T, ulStream: u32, pAttributes: ?*DVD_KaraokeAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetKaraokeAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ulStream, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetSubpictureAttributes(self: *const T, ulStream: u32, pATR: ?*DVD_SubpictureAttributes) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetSubpictureAttributes(@as(*const IDvdInfo2, @ptrCast(self)), ulStream, pATR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDVolumeInfo(self: *const T, pulNumOfVolumes: ?*u32, pulVolume: ?*u32, pSide: ?*DVD_DISC_SIDE, pulNumOfTitles: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDVolumeInfo(@as(*const IDvdInfo2, @ptrCast(self)), pulNumOfVolumes, pulVolume, pSide, pulNumOfTitles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextNumberOfLanguages(self: *const T, pulNumOfLangs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextNumberOfLanguages(@as(*const IDvdInfo2, @ptrCast(self)), pulNumOfLangs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextLanguageInfo(self: *const T, ulLangIndex: u32, pulNumOfStrings: ?*u32, pLangCode: ?*u32, pbCharacterSet: ?*DVD_TextCharSet) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextLanguageInfo(@as(*const IDvdInfo2, @ptrCast(self)), ulLangIndex, pulNumOfStrings, pLangCode, pbCharacterSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextStringAsNative(self: *const T, ulLangIndex: u32, ulStringIndex: u32, pbBuffer: ?*u8, ulMaxBufferSize: u32, pulActualSize: ?*u32, pType: ?*DVD_TextStringType) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextStringAsNative(@as(*const IDvdInfo2, @ptrCast(self)), ulLangIndex, ulStringIndex, pbBuffer, ulMaxBufferSize, pulActualSize, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDTextStringAsUnicode(self: *const T, ulLangIndex: u32, ulStringIndex: u32, pchwBuffer: ?PWSTR, ulMaxBufferSize: u32, pulActualSize: ?*u32, pType: ?*DVD_TextStringType) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDTextStringAsUnicode(@as(*const IDvdInfo2, @ptrCast(self)), ulLangIndex, ulStringIndex, pchwBuffer, ulMaxBufferSize, pulActualSize, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetPlayerParentalLevel(self: *const T, pulParentalLevel: ?*u32, pbCountryCode: *[2]u8) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetPlayerParentalLevel(@as(*const IDvdInfo2, @ptrCast(self)), pulParentalLevel, pbCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetNumberOfChapters(self: *const T, ulTitle: u32, pulNumOfChapters: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetNumberOfChapters(@as(*const IDvdInfo2, @ptrCast(self)), ulTitle, pulNumOfChapters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetTitleParentalLevels(self: *const T, ulTitle: u32, pulParentalLevels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetTitleParentalLevels(@as(*const IDvdInfo2, @ptrCast(self)), ulTitle, pulParentalLevels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDVDDirectory(self: *const T, pszwPath: [*:0]u16, ulMaxSize: u32, pulActualSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDVDDirectory(@as(*const IDvdInfo2, @ptrCast(self)), pszwPath, ulMaxSize, pulActualSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_IsAudioStreamEnabled(self: *const T, ulStreamNum: u32, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).IsAudioStreamEnabled(@as(*const IDvdInfo2, @ptrCast(self)), ulStreamNum, pbEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDiscID(self: *const T, pszwPath: ?[*:0]align(1) const u16, pullDiscID: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDiscID(@as(*const IDvdInfo2, @ptrCast(self)), pszwPath, pullDiscID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetState(self: *const T, pStateData: ?*?*IDvdState) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetState(@as(*const IDvdInfo2, @ptrCast(self)), pStateData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetMenuLanguages(self: *const T, pLanguages: ?*u32, ulMaxLanguages: u32, pulActualLanguages: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetMenuLanguages(@as(*const IDvdInfo2, @ptrCast(self)), pLanguages, ulMaxLanguages, pulActualLanguages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetButtonAtPosition(self: *const T, point: POINT, pulButtonIndex: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetButtonAtPosition(@as(*const IDvdInfo2, @ptrCast(self)), point, pulButtonIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetCmdFromEvent(self: *const T, lParam1: isize, pCmdObj: ?*?*IDvdCmd) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetCmdFromEvent(@as(*const IDvdInfo2, @ptrCast(self)), lParam1, pCmdObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultMenuLanguage(self: *const T, pLanguage: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultMenuLanguage(@as(*const IDvdInfo2, @ptrCast(self)), pLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultAudioLanguage(self: *const T, pLanguage: ?*u32, pAudioExtension: ?*DVD_AUDIO_LANG_EXT) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultAudioLanguage(@as(*const IDvdInfo2, @ptrCast(self)), pLanguage, pAudioExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDefaultSubpictureLanguage(self: *const T, pLanguage: ?*u32, pSubpictureExtension: ?*DVD_SUBPICTURE_LANG_EXT) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDefaultSubpictureLanguage(@as(*const IDvdInfo2, @ptrCast(self)), pLanguage, pSubpictureExtension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetDecoderCaps(self: *const T, pCaps: ?*DVD_DECODER_CAPS) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetDecoderCaps(@as(*const IDvdInfo2, @ptrCast(self)), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_GetButtonRect(self: *const T, ulButton: u32, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).GetButtonRect(@as(*const IDvdInfo2, @ptrCast(self)), ulButton, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdInfo2_IsSubpictureStreamEnabled(self: *const T, ulStreamNum: u32, pbEnabled: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDvdInfo2.VTable, @ptrCast(self.vtable)).IsSubpictureStreamEnabled(@as(*const IDvdInfo2, @ptrCast(self)), ulStreamNum, pbEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_DVD_GRAPH_FLAGS = enum(i32) {
    HWDEC_PREFER = 1,
    HWDEC_ONLY = 2,
    SWDEC_PREFER = 4,
    SWDEC_ONLY = 8,
    NOVPE = 256,
    DO_NOT_CLEAR = 512,
    VMR9_ONLY = 2048,
    EVR_ONLY = 4096,
    EVR_QOS = 8192,
    ADAPT_GRAPH = 16384,
    MASK = 65535,
};
pub const AM_DVD_HWDEC_PREFER = AM_DVD_GRAPH_FLAGS.HWDEC_PREFER;
pub const AM_DVD_HWDEC_ONLY = AM_DVD_GRAPH_FLAGS.HWDEC_ONLY;
pub const AM_DVD_SWDEC_PREFER = AM_DVD_GRAPH_FLAGS.SWDEC_PREFER;
pub const AM_DVD_SWDEC_ONLY = AM_DVD_GRAPH_FLAGS.SWDEC_ONLY;
pub const AM_DVD_NOVPE = AM_DVD_GRAPH_FLAGS.NOVPE;
pub const AM_DVD_DO_NOT_CLEAR = AM_DVD_GRAPH_FLAGS.DO_NOT_CLEAR;
pub const AM_DVD_VMR9_ONLY = AM_DVD_GRAPH_FLAGS.VMR9_ONLY;
pub const AM_DVD_EVR_ONLY = AM_DVD_GRAPH_FLAGS.EVR_ONLY;
pub const AM_DVD_EVR_QOS = AM_DVD_GRAPH_FLAGS.EVR_QOS;
pub const AM_DVD_ADAPT_GRAPH = AM_DVD_GRAPH_FLAGS.ADAPT_GRAPH;
pub const AM_DVD_MASK = AM_DVD_GRAPH_FLAGS.MASK;

pub const AM_DVD_STREAM_FLAGS = enum(i32) {
    VIDEO = 1,
    AUDIO = 2,
    SUBPIC = 4,
};
pub const AM_DVD_STREAM_VIDEO = AM_DVD_STREAM_FLAGS.VIDEO;
pub const AM_DVD_STREAM_AUDIO = AM_DVD_STREAM_FLAGS.AUDIO;
pub const AM_DVD_STREAM_SUBPIC = AM_DVD_STREAM_FLAGS.SUBPIC;

pub const AM_DVD_RENDERSTATUS = extern struct {
    hrVPEStatus: HRESULT,
    bDvdVolInvalid: BOOL,
    bDvdVolUnknown: BOOL,
    bNoLine21In: BOOL,
    bNoLine21Out: BOOL,
    iNumStreams: i32,
    iNumStreamsFailed: i32,
    dwFailedStreamsFlag: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDvdGraphBuilder_Value = Guid.initString("fcc152b6-f372-11d0-8e00-00c04fd7c08b");
pub const IID_IDvdGraphBuilder = &IID_IDvdGraphBuilder_Value;
pub const IDvdGraphBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFiltergraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdGraphBuilder,
                ppGB: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdGraphBuilder,
                ppGB: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDvdInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdGraphBuilder,
                riid: ?*const Guid,
                ppvIF: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdGraphBuilder,
                riid: ?*const Guid,
                ppvIF: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderDvdVideoVolume: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDvdGraphBuilder,
                lpcwszPathName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pStatus: ?*AM_DVD_RENDERSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDvdGraphBuilder,
                lpcwszPathName: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pStatus: ?*AM_DVD_RENDERSTATUS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_GetFiltergraph(self: *const T, ppGB: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).GetFiltergraph(@as(*const IDvdGraphBuilder, @ptrCast(self)), ppGB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_GetDvdInterface(self: *const T, riid: ?*const Guid, ppvIF: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).GetDvdInterface(@as(*const IDvdGraphBuilder, @ptrCast(self)), riid, ppvIF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDvdGraphBuilder_RenderDvdVideoVolume(self: *const T, lpcwszPathName: ?[*:0]align(1) const u16, dwFlags: u32, pStatus: ?*AM_DVD_RENDERSTATUS) callconv(.Inline) HRESULT {
            return @as(*const IDvdGraphBuilder.VTable, @ptrCast(self.vtable)).RenderDvdVideoVolume(@as(*const IDvdGraphBuilder, @ptrCast(self)), lpcwszPathName, dwFlags, pStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideo_Value = Guid.initString("153acc21-d83b-11d1-82bf-00a0c9696c8f");
pub const IID_IDDrawExclModeVideo = &IID_IDDrawExclModeVideo_Value;
pub const IDDrawExclModeVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDDrawObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                pDDrawObject: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                pDDrawObject: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDDrawObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                ppDDrawObject: ?*?*IDirectDraw,
                pbUsingExternal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                ppDDrawObject: ?*?*IDirectDraw,
                pbUsingExternal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDDrawSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                pDDrawSurface: ?*IDirectDrawSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                pDDrawSurface: ?*IDirectDrawSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDDrawSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                ppDDrawSurface: ?*?*IDirectDrawSurface,
                pbUsingExternal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                ppDDrawSurface: ?*?*IDirectDrawSurface,
                pbUsingExternal: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDrawParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                prcSource: ?*const RECT,
                prcTarget: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                prcSource: ?*const RECT,
                prcTarget: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNativeVideoProps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                pdwVideoWidth: ?*u32,
                pdwVideoHeight: ?*u32,
                pdwPictAspectRatioX: ?*u32,
                pdwPictAspectRatioY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                pdwVideoWidth: ?*u32,
                pdwVideoHeight: ?*u32,
                pdwPictAspectRatioX: ?*u32,
                pdwPictAspectRatioY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCallbackInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideo,
                pCallback: ?*IDDrawExclModeVideoCallback,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideo,
                pCallback: ?*IDDrawExclModeVideoCallback,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDDrawObject(self: *const T, pDDrawObject: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDDrawObject(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pDDrawObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetDDrawObject(self: *const T, ppDDrawObject: ?*?*IDirectDraw, pbUsingExternal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetDDrawObject(@as(*const IDDrawExclModeVideo, @ptrCast(self)), ppDDrawObject, pbUsingExternal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDDrawSurface(self: *const T, pDDrawSurface: ?*IDirectDrawSurface) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDDrawSurface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pDDrawSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetDDrawSurface(self: *const T, ppDDrawSurface: ?*?*IDirectDrawSurface, pbUsingExternal: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetDDrawSurface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), ppDDrawSurface, pbUsingExternal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetDrawParameters(self: *const T, prcSource: ?*const RECT, prcTarget: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetDrawParameters(@as(*const IDDrawExclModeVideo, @ptrCast(self)), prcSource, prcTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_GetNativeVideoProps(self: *const T, pdwVideoWidth: ?*u32, pdwVideoHeight: ?*u32, pdwPictAspectRatioX: ?*u32, pdwPictAspectRatioY: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).GetNativeVideoProps(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pdwVideoWidth, pdwVideoHeight, pdwPictAspectRatioX, pdwPictAspectRatioY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideo_SetCallbackInterface(self: *const T, pCallback: ?*IDDrawExclModeVideoCallback, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideo.VTable, @ptrCast(self.vtable)).SetCallbackInterface(@as(*const IDDrawExclModeVideo, @ptrCast(self)), pCallback, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _AM_OVERLAY_NOTIFY_FLAGS = enum(i32) {
    VISIBLE_CHANGE = 1,
    SOURCE_CHANGE = 2,
    DEST_CHANGE = 4,
};
pub const AM_OVERLAY_NOTIFY_VISIBLE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.VISIBLE_CHANGE;
pub const AM_OVERLAY_NOTIFY_SOURCE_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.SOURCE_CHANGE;
pub const AM_OVERLAY_NOTIFY_DEST_CHANGE = _AM_OVERLAY_NOTIFY_FLAGS.DEST_CHANGE;

// TODO: this type is limited to platform 'windows5.0'
const IID_IDDrawExclModeVideoCallback_Value = Guid.initString("913c24a0-20ab-11d2-9038-00a0c9697298");
pub const IID_IDDrawExclModeVideoCallback = &IID_IDDrawExclModeVideoCallback_Value;
pub const IDDrawExclModeVideoCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateOverlay: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideoCallback,
                bBefore: BOOL,
                dwFlags: u32,
                bOldVisible: BOOL,
                prcOldSrc: ?*const RECT,
                prcOldDest: ?*const RECT,
                bNewVisible: BOOL,
                prcNewSrc: ?*const RECT,
                prcNewDest: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideoCallback,
                bBefore: BOOL,
                dwFlags: u32,
                bOldVisible: BOOL,
                prcOldSrc: ?*const RECT,
                prcOldDest: ?*const RECT,
                bNewVisible: BOOL,
                prcNewSrc: ?*const RECT,
                prcNewDest: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUpdateColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideoCallback,
                pKey: ?*const COLORKEY,
                dwColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideoCallback,
                pKey: ?*const COLORKEY,
                dwColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnUpdateSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDDrawExclModeVideoCallback,
                dwWidth: u32,
                dwHeight: u32,
                dwARWidth: u32,
                dwARHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDDrawExclModeVideoCallback,
                dwWidth: u32,
                dwHeight: u32,
                dwARWidth: u32,
                dwARHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateOverlay(self: *const T, bBefore: BOOL, dwFlags: u32, bOldVisible: BOOL, prcOldSrc: ?*const RECT, prcOldDest: ?*const RECT, bNewVisible: BOOL, prcNewSrc: ?*const RECT, prcNewDest: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateOverlay(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), bBefore, dwFlags, bOldVisible, prcOldSrc, prcOldDest, bNewVisible, prcNewSrc, prcNewDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateColorKey(self: *const T, pKey: ?*const COLORKEY, dwColor: u32) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateColorKey(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), pKey, dwColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDDrawExclModeVideoCallback_OnUpdateSize(self: *const T, dwWidth: u32, dwHeight: u32, dwARWidth: u32, dwARHeight: u32) callconv(.Inline) HRESULT {
            return @as(*const IDDrawExclModeVideoCallback.VTable, @ptrCast(self.vtable)).OnUpdateSize(@as(*const IDDrawExclModeVideoCallback, @ptrCast(self)), dwWidth, dwHeight, dwARWidth, dwARHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BDA_TEMPLATE_CONNECTION = extern struct {
    FromNodeType: u32,
    FromNodePinType: u32,
    ToNodeType: u32,
    ToNodePinType: u32,
};

pub const BDA_TEMPLATE_PIN_JOINT = extern struct {
    uliTemplateConnection: u32,
    ulcInstancesMax: u32,
};

pub const BDA_EVENT_ID = enum(i32) {
    SIGNAL_LOSS = 0,
    SIGNAL_LOCK = 1,
    DATA_START = 2,
    DATA_STOP = 3,
    CHANNEL_ACQUIRED = 4,
    CHANNEL_LOST = 5,
    CHANNEL_SOURCE_CHANGED = 6,
    CHANNEL_ACTIVATED = 7,
    CHANNEL_DEACTIVATED = 8,
    SUBCHANNEL_ACQUIRED = 9,
    SUBCHANNEL_LOST = 10,
    SUBCHANNEL_SOURCE_CHANGED = 11,
    SUBCHANNEL_ACTIVATED = 12,
    SUBCHANNEL_DEACTIVATED = 13,
    ACCESS_GRANTED = 14,
    ACCESS_DENIED = 15,
    OFFER_EXTENDED = 16,
    PURCHASE_COMPLETED = 17,
    SMART_CARD_INSERTED = 18,
    SMART_CARD_REMOVED = 19,
};
pub const BDA_EVENT_SIGNAL_LOSS = BDA_EVENT_ID.SIGNAL_LOSS;
pub const BDA_EVENT_SIGNAL_LOCK = BDA_EVENT_ID.SIGNAL_LOCK;
pub const BDA_EVENT_DATA_START = BDA_EVENT_ID.DATA_START;
pub const BDA_EVENT_DATA_STOP = BDA_EVENT_ID.DATA_STOP;
pub const BDA_EVENT_CHANNEL_ACQUIRED = BDA_EVENT_ID.CHANNEL_ACQUIRED;
pub const BDA_EVENT_CHANNEL_LOST = BDA_EVENT_ID.CHANNEL_LOST;
pub const BDA_EVENT_CHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.CHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_CHANNEL_ACTIVATED = BDA_EVENT_ID.CHANNEL_ACTIVATED;
pub const BDA_EVENT_CHANNEL_DEACTIVATED = BDA_EVENT_ID.CHANNEL_DEACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_ACQUIRED = BDA_EVENT_ID.SUBCHANNEL_ACQUIRED;
pub const BDA_EVENT_SUBCHANNEL_LOST = BDA_EVENT_ID.SUBCHANNEL_LOST;
pub const BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED = BDA_EVENT_ID.SUBCHANNEL_SOURCE_CHANGED;
pub const BDA_EVENT_SUBCHANNEL_ACTIVATED = BDA_EVENT_ID.SUBCHANNEL_ACTIVATED;
pub const BDA_EVENT_SUBCHANNEL_DEACTIVATED = BDA_EVENT_ID.SUBCHANNEL_DEACTIVATED;
pub const BDA_EVENT_ACCESS_GRANTED = BDA_EVENT_ID.ACCESS_GRANTED;
pub const BDA_EVENT_ACCESS_DENIED = BDA_EVENT_ID.ACCESS_DENIED;
pub const BDA_EVENT_OFFER_EXTENDED = BDA_EVENT_ID.OFFER_EXTENDED;
pub const BDA_EVENT_PURCHASE_COMPLETED = BDA_EVENT_ID.PURCHASE_COMPLETED;
pub const BDA_EVENT_SMART_CARD_INSERTED = BDA_EVENT_ID.SMART_CARD_INSERTED;
pub const BDA_EVENT_SMART_CARD_REMOVED = BDA_EVENT_ID.SMART_CARD_REMOVED;

pub const KS_BDA_FRAME_INFO = extern struct {
    ExtendedHeaderSize: u32,
    dwFrameFlags: u32,
    ulEvent: u32,
    ulChannelNumber: u32,
    ulSubchannelNumber: u32,
    ulReason: u32,
};

pub const BDA_ETHERNET_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_ETHERNET_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_ETHERNET_ADDRESS,
};

pub const BDA_MULTICAST_MODE = enum(i32) {
    PROMISCUOUS_MULTICAST = 0,
    FILTERED_MULTICAST = 1,
    NO_MULTICAST = 2,
};
pub const BDA_PROMISCUOUS_MULTICAST = BDA_MULTICAST_MODE.PROMISCUOUS_MULTICAST;
pub const BDA_FILTERED_MULTICAST = BDA_MULTICAST_MODE.FILTERED_MULTICAST;
pub const BDA_NO_MULTICAST = BDA_MULTICAST_MODE.NO_MULTICAST;

pub const BDA_IPv4_ADDRESS = extern struct {
    rgbAddress: [4]u8,
};

pub const BDA_IPv4_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv4_ADDRESS,
};

pub const BDA_IPv6_ADDRESS = extern struct {
    rgbAddress: [6]u8,
};

pub const BDA_IPv6_ADDRESS_LIST = extern struct {
    ulcAddresses: u32,
    rgAddressl: [1]BDA_IPv6_ADDRESS,
};

pub const BDA_SIGNAL_STATE = enum(i32) {
    UNAVAILABLE = 0,
    INACTIVE = 1,
    ACTIVE = 2,
};
pub const BDA_SIGNAL_UNAVAILABLE = BDA_SIGNAL_STATE.UNAVAILABLE;
pub const BDA_SIGNAL_INACTIVE = BDA_SIGNAL_STATE.INACTIVE;
pub const BDA_SIGNAL_ACTIVE = BDA_SIGNAL_STATE.ACTIVE;

pub const BDA_CHANGE_STATE = enum(i32) {
    COMPLETE = 0,
    PENDING = 1,
};
pub const BDA_CHANGES_COMPLETE = BDA_CHANGE_STATE.COMPLETE;
pub const BDA_CHANGES_PENDING = BDA_CHANGE_STATE.PENDING;

pub const BDANODE_DESCRIPTOR = extern struct {
    ulBdaNodeType: u32,
    guidFunction: Guid,
    guidName: Guid,
};

pub const BDA_TABLE_SECTION = extern struct {
    ulPrimarySectionId: u32,
    ulSecondarySectionId: u32,
    ulcbSectionLength: u32,
    argbSectionData: [1]u32,
};

pub const BDA_DISEQC_SEND = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const BDA_DISEQC_RESPONSE = extern struct {
    ulRequestId: u32,
    ulPacketLength: u32,
    argbPacketData: [8]u8,
};

pub const MEDIA_SAMPLE_CONTENT = enum(i32) {
    TRANSPORT_PACKET = 0,
    ELEMENTARY_STREAM = 1,
    MPEG2_PSI = 2,
    TRANSPORT_PAYLOAD = 3,
};
pub const MEDIA_TRANSPORT_PACKET = MEDIA_SAMPLE_CONTENT.TRANSPORT_PACKET;
pub const MEDIA_ELEMENTARY_STREAM = MEDIA_SAMPLE_CONTENT.ELEMENTARY_STREAM;
pub const MEDIA_MPEG2_PSI = MEDIA_SAMPLE_CONTENT.MPEG2_PSI;
pub const MEDIA_TRANSPORT_PAYLOAD = MEDIA_SAMPLE_CONTENT.TRANSPORT_PAYLOAD;

pub const PID_MAP = extern struct {
    ulPID: u32,
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
};

pub const BDA_PID_MAP = extern struct {
    MediaSampleContent: MEDIA_SAMPLE_CONTENT,
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_PID_UNMAP = extern struct {
    ulcPIDs: u32,
    aulPIDs: [1]u32,
};

pub const BDA_CA_MODULE_UI = extern struct {
    ulFormat: u32,
    ulbcDesc: u32,
    ulDesc: [1]u32,
};

pub const BDA_PROGRAM_PID_LIST = extern struct {
    ulProgramNumber: u32,
    ulcPIDs: u32,
    ulPID: [1]u32,
};

pub const BDA_DRM_DRMSTATUS = extern struct {
    lResult: i32,
    DRMuuid: Guid,
    ulDrmUuidListStringSize: u32,
    argbDrmUuidListString: [1]Guid,
};

pub const BDA_WMDRM_STATUS = extern struct {
    lResult: i32,
    ulMaxCaptureTokenSize: u32,
    uMaxStreamingPid: u32,
    ulMaxLicense: u32,
    ulMinSecurityLevel: u32,
    ulRevInfoSequenceNumber: u32,
    ulRevInfoIssuedTime: u64,
    ulRevListVersion: u32,
    ulRevInfoTTL: u32,
    ulState: u32,
};

pub const BDA_WMDRM_KEYINFOLIST = extern struct {
    lResult: i32,
    ulKeyuuidBufferLen: u32,
    argKeyuuidBuffer: [1]Guid,
};

pub const BDA_BUFFER = extern struct {
    lResult: i32,
    ulBufferSize: u32,
    argbBuffer: [1]u8,
};

pub const BDA_WMDRM_RENEWLICENSE = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulXmrLicenseOutputLength: u32,
    argbXmrLicenceOutputBuffer: [1]u8,
};

pub const BDA_WMDRMTUNER_PIDPROTECTION = extern struct {
    lResult: i32,
    uuidKeyID: Guid,
};

pub const BDA_WMDRMTUNER_PURCHASEENTITLEMENT = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
    ulCaptureTokenLength: u32,
    argbCaptureTokenBuffer: [1]u8,
};

pub const BDA_TUNER_TUNERSTATE = extern struct {
    lResult: i32,
    ulTuneLength: u32,
    argbTuneData: [1]u8,
};

pub const BDA_TUNER_DIAGNOSTICS = extern struct {
    lResult: i32,
    ulSignalLevel: u32,
    ulSignalLevelQuality: u32,
    ulSignalNoiseRatio: u32,
};

pub const BDA_STRING = extern struct {
    lResult: i32,
    ulStringSize: u32,
    argbString: [1]u8,
};

pub const BDA_SCAN_CAPABILTIES = extern struct {
    lResult: i32,
    ul64AnalogStandardsSupported: u64,
};

pub const BDA_SCAN_STATE = extern struct {
    lResult: i32,
    ulSignalLock: u32,
    ulSecondsLeft: u32,
    ulCurrentFrequency: u32,
};

pub const BDA_SCAN_START = extern struct {
    lResult: i32,
    LowerFrequency: u32,
    HigerFrequency: u32,
};

pub const BDA_GDDS_DATATYPE = extern struct {
    lResult: i32,
    uuidDataType: Guid,
};

pub const BDA_GDDS_DATA = extern struct {
    lResult: i32,
    ulDataLength: u32,
    ulPercentageProgress: u32,
    argbData: [1]u8,
};

pub const BDA_USERACTIVITY_INTERVAL = extern struct {
    lResult: i32,
    ulActivityInterval: u32,
};

pub const BDA_CAS_CHECK_ENTITLEMENTTOKEN = extern struct {
    lResult: i32,
    ulDescrambleStatus: u32,
};

pub const BDA_CAS_CLOSE_MMIDIALOG = extern struct {
    lResult: i32,
    SessionResult: u32,
};

pub const BDA_CAS_REQUESTTUNERDATA = extern struct {
    ucRequestPriority: u8,
    ucRequestReason: u8,
    ucRequestConsequences: u8,
    ulEstimatedTime: u32,
};

pub const BDA_CAS_OPENMMIDATA = extern struct {
    ulDialogNumber: u32,
    ulDialogRequest: u32,
    uuidDialogType: Guid,
    usDialogDataLength: u16,
    argbDialogData: [1]u8,
};

pub const BDA_CAS_CLOSEMMIDATA = extern struct {
    ulDialogNumber: u32,
};

pub const ISDBCAS_REQUEST_ID = enum(i32) {
    G = 56,
    D = 58,
};
pub const ISDBCAS_REQUEST_ID_EMG = ISDBCAS_REQUEST_ID.G;
pub const ISDBCAS_REQUEST_ID_EMD = ISDBCAS_REQUEST_ID.D;

pub const BDA_ISDBCAS_REQUESTHEADER = extern struct {
    bInstruction: u8 align(1),
    bReserved: [3]u8 align(1),
    ulDataLength: u32 align(1),
    argbIsdbCommand: [1]u8 align(1),
};

pub const BDA_ISDBCAS_RESPONSEDATA = extern struct {
    lResult: i32 align(1),
    ulRequestID: u32 align(1),
    ulIsdbStatus: u32 align(1),
    ulIsdbDataSize: u32 align(1),
    argbIsdbCommandData: [1]u8 align(1),
};

pub const BDA_ISDBCAS_EMG_REQ = extern struct {
    bCLA: u8,
    bINS: u8,
    bP1: u8,
    bP2: u8,
    bLC: u8,
    bCardId: [6]u8,
    bProtocol: u8,
    bCABroadcasterGroupId: u8,
    bMessageControl: u8,
    bMessageCode: [1]u8,
};

pub const MUX_PID_TYPE = enum(i32) {
    OTHER = -1,
    ELEMENTARY_STREAM = 0,
    MPEG2_SECTION_PSI_SI = 1,
};
pub const PID_OTHER = MUX_PID_TYPE.OTHER;
pub const PID_ELEMENTARY_STREAM = MUX_PID_TYPE.ELEMENTARY_STREAM;
pub const PID_MPEG2_SECTION_PSI_SI = MUX_PID_TYPE.MPEG2_SECTION_PSI_SI;

pub const BDA_MUX_PIDLISTITEM = extern struct {
    usPIDNumber: u16 align(2),
    usProgramNumber: u16 align(2),
    ePIDType: MUX_PID_TYPE align(2),
};

pub const BDA_TS_SELECTORINFO = extern struct {
    bTSInfolength: u8 align(1),
    bReserved: [2]u8 align(1),
    guidNetworkType: Guid align(1),
    bTSIDCount: u8 align(1),
    usTSID: [1]u16 align(1),
};

pub const BDA_TS_SELECTORINFO_ISDBS_EXT = extern struct {
    bTMCC: [48]u8,
};

pub const BDA_DVBT2_L1_SIGNALLING_DATA = extern struct {
    L1Pre_TYPE: u8,
    L1Pre_BWT_S1_S2: u8,
    L1Pre_REPETITION_GUARD_PAPR: u8,
    L1Pre_MOD_COD_FEC: u8,
    L1Pre_POSTSIZE_INFO_PILOT: [5]u8,
    L1Pre_TX_ID_AVAIL: u8,
    L1Pre_CELL_ID: [2]u8,
    L1Pre_NETWORK_ID: [2]u8,
    L1Pre_T2SYSTEM_ID: [2]u8,
    L1Pre_NUM_T2_FRAMES: u8,
    L1Pre_NUM_DATA_REGENFLAG_L1POSTEXT: [2]u8,
    L1Pre_NUMRF_CURRENTRF_RESERVED: [2]u8,
    L1Pre_CRC32: [4]u8,
    L1PostData: [1]u8,
};

pub const BDA_RATING_PINRESET = extern struct {
    bPinLength: u8,
    argbNewPin: [1]u8,
};

pub const DVBSystemType = enum(i32) {
    DVB_Cable = 0,
    DVB_Terrestrial = 1,
    DVB_Satellite = 2,
    ISDB_Terrestrial = 3,
    ISDB_Satellite = 4,
};
pub const DVB_Cable = DVBSystemType.DVB_Cable;
pub const DVB_Terrestrial = DVBSystemType.DVB_Terrestrial;
pub const DVB_Satellite = DVBSystemType.DVB_Satellite;
pub const ISDB_Terrestrial = DVBSystemType.ISDB_Terrestrial;
pub const ISDB_Satellite = DVBSystemType.ISDB_Satellite;

pub const BDA_Channel = enum(i32) {
    L = -1,
};
pub const BDA_UNDEFINED_CHANNEL = BDA_Channel.L;

pub const ComponentCategory = enum(i32) {
    ategoryNotSet = -1,
    ategoryOther = 0,
    ategoryVideo = 1,
    ategoryAudio = 2,
    ategoryText = 3,
    ategorySubtitles = 4,
    ategoryCaptions = 5,
    ategorySuperimpose = 6,
    ategoryData = 7,
    ATEGORY_COUNT = 8,
};
pub const CategoryNotSet = ComponentCategory.ategoryNotSet;
pub const CategoryOther = ComponentCategory.ategoryOther;
pub const CategoryVideo = ComponentCategory.ategoryVideo;
pub const CategoryAudio = ComponentCategory.ategoryAudio;
pub const CategoryText = ComponentCategory.ategoryText;
pub const CategorySubtitles = ComponentCategory.ategorySubtitles;
pub const CategoryCaptions = ComponentCategory.ategoryCaptions;
pub const CategorySuperimpose = ComponentCategory.ategorySuperimpose;
pub const CategoryData = ComponentCategory.ategoryData;
pub const CATEGORY_COUNT = ComponentCategory.ATEGORY_COUNT;

pub const ComponentStatus = enum(i32) {
    Active = 0,
    Inactive = 1,
    Unavailable = 2,
};
pub const StatusActive = ComponentStatus.Active;
pub const StatusInactive = ComponentStatus.Inactive;
pub const StatusUnavailable = ComponentStatus.Unavailable;

pub const MPEG2StreamType = enum(i32) {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0,
    ISO_IEC_11172_2_VIDEO = 1,
    ISO_IEC_13818_2_VIDEO = 2,
    ISO_IEC_11172_3_AUDIO = 3,
    ISO_IEC_13818_3_AUDIO = 4,
    ISO_IEC_13818_1_PRIVATE_SECTION = 5,
    ISO_IEC_13818_1_PES = 6,
    ISO_IEC_13522_MHEG = 7,
    ANNEX_A_DSM_CC = 8,
    ITU_T_REC_H_222_1 = 9,
    ISO_IEC_13818_6_TYPE_A = 10,
    ISO_IEC_13818_6_TYPE_B = 11,
    ISO_IEC_13818_6_TYPE_C = 12,
    ISO_IEC_13818_6_TYPE_D = 13,
    ISO_IEC_13818_1_AUXILIARY = 14,
    ISO_IEC_13818_7_AUDIO = 15,
    ISO_IEC_14496_2_VISUAL = 16,
    ISO_IEC_14496_3_AUDIO = 17,
    ISO_IEC_14496_1_IN_PES = 18,
    ISO_IEC_14496_1_IN_SECTION = 19,
    ISO_IEC_13818_6_DOWNLOAD = 20,
    METADATA_IN_PES = 21,
    METADATA_IN_SECTION = 22,
    METADATA_IN_DATA_CAROUSEL = 23,
    METADATA_IN_OBJECT_CAROUSEL = 24,
    METADATA_IN_DOWNLOAD_PROTOCOL = 25,
    IRPM_STREAMM = 26,
    ITU_T_H264 = 27,
    ISO_IEC_13818_1_RESERVED = 28,
    // USER_PRIVATE = 16, this enum value conflicts with ISO_IEC_14496_2_VISUAL
    HEVC_VIDEO_OR_TEMPORAL_VIDEO = 36,
    HEVC_TEMPORAL_VIDEO_SUBSET = 37,
    ISO_IEC_USER_PRIVATE = 128,
    DOLBY_AC3_AUDIO = 129,
    DOLBY_DIGITAL_PLUS_AUDIO_ATSC = 135,
};
pub const BDA_UNITIALIZED_MPEG2STREAMTYPE = MPEG2StreamType.BDA_UNITIALIZED_MPEG2STREAMTYPE;
pub const Reserved1 = MPEG2StreamType.Reserved1;
pub const ISO_IEC_11172_2_VIDEO = MPEG2StreamType.ISO_IEC_11172_2_VIDEO;
pub const ISO_IEC_13818_2_VIDEO = MPEG2StreamType.ISO_IEC_13818_2_VIDEO;
pub const ISO_IEC_11172_3_AUDIO = MPEG2StreamType.ISO_IEC_11172_3_AUDIO;
pub const ISO_IEC_13818_3_AUDIO = MPEG2StreamType.ISO_IEC_13818_3_AUDIO;
pub const ISO_IEC_13818_1_PRIVATE_SECTION = MPEG2StreamType.ISO_IEC_13818_1_PRIVATE_SECTION;
pub const ISO_IEC_13818_1_PES = MPEG2StreamType.ISO_IEC_13818_1_PES;
pub const ISO_IEC_13522_MHEG = MPEG2StreamType.ISO_IEC_13522_MHEG;
pub const ANNEX_A_DSM_CC = MPEG2StreamType.ANNEX_A_DSM_CC;
pub const ITU_T_REC_H_222_1 = MPEG2StreamType.ITU_T_REC_H_222_1;
pub const ISO_IEC_13818_6_TYPE_A = MPEG2StreamType.ISO_IEC_13818_6_TYPE_A;
pub const ISO_IEC_13818_6_TYPE_B = MPEG2StreamType.ISO_IEC_13818_6_TYPE_B;
pub const ISO_IEC_13818_6_TYPE_C = MPEG2StreamType.ISO_IEC_13818_6_TYPE_C;
pub const ISO_IEC_13818_6_TYPE_D = MPEG2StreamType.ISO_IEC_13818_6_TYPE_D;
pub const ISO_IEC_13818_1_AUXILIARY = MPEG2StreamType.ISO_IEC_13818_1_AUXILIARY;
pub const ISO_IEC_13818_7_AUDIO = MPEG2StreamType.ISO_IEC_13818_7_AUDIO;
pub const ISO_IEC_14496_2_VISUAL = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const ISO_IEC_14496_3_AUDIO = MPEG2StreamType.ISO_IEC_14496_3_AUDIO;
pub const ISO_IEC_14496_1_IN_PES = MPEG2StreamType.ISO_IEC_14496_1_IN_PES;
pub const ISO_IEC_14496_1_IN_SECTION = MPEG2StreamType.ISO_IEC_14496_1_IN_SECTION;
pub const ISO_IEC_13818_6_DOWNLOAD = MPEG2StreamType.ISO_IEC_13818_6_DOWNLOAD;
pub const METADATA_IN_PES = MPEG2StreamType.METADATA_IN_PES;
pub const METADATA_IN_SECTION = MPEG2StreamType.METADATA_IN_SECTION;
pub const METADATA_IN_DATA_CAROUSEL = MPEG2StreamType.METADATA_IN_DATA_CAROUSEL;
pub const METADATA_IN_OBJECT_CAROUSEL = MPEG2StreamType.METADATA_IN_OBJECT_CAROUSEL;
pub const METADATA_IN_DOWNLOAD_PROTOCOL = MPEG2StreamType.METADATA_IN_DOWNLOAD_PROTOCOL;
pub const IRPM_STREAMM = MPEG2StreamType.IRPM_STREAMM;
pub const ITU_T_H264 = MPEG2StreamType.ITU_T_H264;
pub const ISO_IEC_13818_1_RESERVED = MPEG2StreamType.ISO_IEC_13818_1_RESERVED;
pub const USER_PRIVATE = MPEG2StreamType.ISO_IEC_14496_2_VISUAL;
pub const HEVC_VIDEO_OR_TEMPORAL_VIDEO = MPEG2StreamType.HEVC_VIDEO_OR_TEMPORAL_VIDEO;
pub const HEVC_TEMPORAL_VIDEO_SUBSET = MPEG2StreamType.HEVC_TEMPORAL_VIDEO_SUBSET;
pub const ISO_IEC_USER_PRIVATE = MPEG2StreamType.ISO_IEC_USER_PRIVATE;
pub const DOLBY_AC3_AUDIO = MPEG2StreamType.DOLBY_AC3_AUDIO;
pub const DOLBY_DIGITAL_PLUS_AUDIO_ATSC = MPEG2StreamType.DOLBY_DIGITAL_PLUS_AUDIO_ATSC;

pub const MPEG2_TRANSPORT_STRIDE = extern struct {
    dwOffset: u32,
    dwPacketLength: u32,
    dwStride: u32,
};

pub const ATSCComponentTypeFlags = enum(i32) {
    @"3" = 1,
};
pub const ATSCCT_AC3 = ATSCComponentTypeFlags.@"3";

pub const BinaryConvolutionCodeRate = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_2" = 1,
    @"2_3" = 2,
    @"3_4" = 3,
    @"3_5" = 4,
    @"4_5" = 5,
    @"5_6" = 6,
    @"5_11" = 7,
    @"7_8" = 8,
    @"1_4" = 9,
    @"1_3" = 10,
    @"2_5" = 11,
    @"6_7" = 12,
    @"8_9" = 13,
    @"9_10" = 14,
    MAX = 15,
};
pub const BDA_BCC_RATE_NOT_SET = BinaryConvolutionCodeRate.NOT_SET;
pub const BDA_BCC_RATE_NOT_DEFINED = BinaryConvolutionCodeRate.NOT_DEFINED;
pub const BDA_BCC_RATE_1_2 = BinaryConvolutionCodeRate.@"1_2";
pub const BDA_BCC_RATE_2_3 = BinaryConvolutionCodeRate.@"2_3";
pub const BDA_BCC_RATE_3_4 = BinaryConvolutionCodeRate.@"3_4";
pub const BDA_BCC_RATE_3_5 = BinaryConvolutionCodeRate.@"3_5";
pub const BDA_BCC_RATE_4_5 = BinaryConvolutionCodeRate.@"4_5";
pub const BDA_BCC_RATE_5_6 = BinaryConvolutionCodeRate.@"5_6";
pub const BDA_BCC_RATE_5_11 = BinaryConvolutionCodeRate.@"5_11";
pub const BDA_BCC_RATE_7_8 = BinaryConvolutionCodeRate.@"7_8";
pub const BDA_BCC_RATE_1_4 = BinaryConvolutionCodeRate.@"1_4";
pub const BDA_BCC_RATE_1_3 = BinaryConvolutionCodeRate.@"1_3";
pub const BDA_BCC_RATE_2_5 = BinaryConvolutionCodeRate.@"2_5";
pub const BDA_BCC_RATE_6_7 = BinaryConvolutionCodeRate.@"6_7";
pub const BDA_BCC_RATE_8_9 = BinaryConvolutionCodeRate.@"8_9";
pub const BDA_BCC_RATE_9_10 = BinaryConvolutionCodeRate.@"9_10";
pub const BDA_BCC_RATE_MAX = BinaryConvolutionCodeRate.MAX;

pub const FECMethod = enum(i32) {
    METHOD_NOT_SET = -1,
    METHOD_NOT_DEFINED = 0,
    VITERBI = 1,
    RS_204_188 = 2,
    LDPC = 3,
    BCH = 4,
    RS_147_130 = 5,
    MAX = 6,
};
pub const BDA_FEC_METHOD_NOT_SET = FECMethod.METHOD_NOT_SET;
pub const BDA_FEC_METHOD_NOT_DEFINED = FECMethod.METHOD_NOT_DEFINED;
pub const BDA_FEC_VITERBI = FECMethod.VITERBI;
pub const BDA_FEC_RS_204_188 = FECMethod.RS_204_188;
pub const BDA_FEC_LDPC = FECMethod.LDPC;
pub const BDA_FEC_BCH = FECMethod.BCH;
pub const BDA_FEC_RS_147_130 = FECMethod.RS_147_130;
pub const BDA_FEC_MAX = FECMethod.MAX;

pub const ModulationType = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"16QAM" = 1,
    @"32QAM" = 2,
    @"64QAM" = 3,
    @"80QAM" = 4,
    @"96QAM" = 5,
    @"112QAM" = 6,
    @"128QAM" = 7,
    @"160QAM" = 8,
    @"192QAM" = 9,
    @"224QAM" = 10,
    @"256QAM" = 11,
    @"320QAM" = 12,
    @"384QAM" = 13,
    @"448QAM" = 14,
    @"512QAM" = 15,
    @"640QAM" = 16,
    @"768QAM" = 17,
    @"896QAM" = 18,
    @"1024QAM" = 19,
    QPSK = 20,
    BPSK = 21,
    OQPSK = 22,
    @"8VSB" = 23,
    @"16VSB" = 24,
    ANALOG_AMPLITUDE = 25,
    ANALOG_FREQUENCY = 26,
    @"8PSK" = 27,
    RF = 28,
    @"16APSK" = 29,
    @"32APSK" = 30,
    NBC_QPSK = 31,
    NBC_8PSK = 32,
    DIRECTV = 33,
    ISDB_T_TMCC = 34,
    ISDB_S_TMCC = 35,
    MAX = 36,
};
pub const BDA_MOD_NOT_SET = ModulationType.NOT_SET;
pub const BDA_MOD_NOT_DEFINED = ModulationType.NOT_DEFINED;
pub const BDA_MOD_16QAM = ModulationType.@"16QAM";
pub const BDA_MOD_32QAM = ModulationType.@"32QAM";
pub const BDA_MOD_64QAM = ModulationType.@"64QAM";
pub const BDA_MOD_80QAM = ModulationType.@"80QAM";
pub const BDA_MOD_96QAM = ModulationType.@"96QAM";
pub const BDA_MOD_112QAM = ModulationType.@"112QAM";
pub const BDA_MOD_128QAM = ModulationType.@"128QAM";
pub const BDA_MOD_160QAM = ModulationType.@"160QAM";
pub const BDA_MOD_192QAM = ModulationType.@"192QAM";
pub const BDA_MOD_224QAM = ModulationType.@"224QAM";
pub const BDA_MOD_256QAM = ModulationType.@"256QAM";
pub const BDA_MOD_320QAM = ModulationType.@"320QAM";
pub const BDA_MOD_384QAM = ModulationType.@"384QAM";
pub const BDA_MOD_448QAM = ModulationType.@"448QAM";
pub const BDA_MOD_512QAM = ModulationType.@"512QAM";
pub const BDA_MOD_640QAM = ModulationType.@"640QAM";
pub const BDA_MOD_768QAM = ModulationType.@"768QAM";
pub const BDA_MOD_896QAM = ModulationType.@"896QAM";
pub const BDA_MOD_1024QAM = ModulationType.@"1024QAM";
pub const BDA_MOD_QPSK = ModulationType.QPSK;
pub const BDA_MOD_BPSK = ModulationType.BPSK;
pub const BDA_MOD_OQPSK = ModulationType.OQPSK;
pub const BDA_MOD_8VSB = ModulationType.@"8VSB";
pub const BDA_MOD_16VSB = ModulationType.@"16VSB";
pub const BDA_MOD_ANALOG_AMPLITUDE = ModulationType.ANALOG_AMPLITUDE;
pub const BDA_MOD_ANALOG_FREQUENCY = ModulationType.ANALOG_FREQUENCY;
pub const BDA_MOD_8PSK = ModulationType.@"8PSK";
pub const BDA_MOD_RF = ModulationType.RF;
pub const BDA_MOD_16APSK = ModulationType.@"16APSK";
pub const BDA_MOD_32APSK = ModulationType.@"32APSK";
pub const BDA_MOD_NBC_QPSK = ModulationType.NBC_QPSK;
pub const BDA_MOD_NBC_8PSK = ModulationType.NBC_8PSK;
pub const BDA_MOD_DIRECTV = ModulationType.DIRECTV;
pub const BDA_MOD_ISDB_T_TMCC = ModulationType.ISDB_T_TMCC;
pub const BDA_MOD_ISDB_S_TMCC = ModulationType.ISDB_S_TMCC;
pub const BDA_MOD_MAX = ModulationType.MAX;

pub const ScanModulationTypes = enum(i32) {
    BDA_SCAN_MOD_16QAM = 1,
    BDA_SCAN_MOD_32QAM = 2,
    BDA_SCAN_MOD_64QAM = 4,
    BDA_SCAN_MOD_80QAM = 8,
    BDA_SCAN_MOD_96QAM = 16,
    BDA_SCAN_MOD_112QAM = 32,
    BDA_SCAN_MOD_128QAM = 64,
    BDA_SCAN_MOD_160QAM = 128,
    BDA_SCAN_MOD_192QAM = 256,
    BDA_SCAN_MOD_224QAM = 512,
    BDA_SCAN_MOD_256QAM = 1024,
    BDA_SCAN_MOD_320QAM = 2048,
    BDA_SCAN_MOD_384QAM = 4096,
    BDA_SCAN_MOD_448QAM = 8192,
    BDA_SCAN_MOD_512QAM = 16384,
    BDA_SCAN_MOD_640QAM = 32768,
    BDA_SCAN_MOD_768QAM = 65536,
    BDA_SCAN_MOD_896QAM = 131072,
    BDA_SCAN_MOD_1024QAM = 262144,
    BDA_SCAN_MOD_QPSK = 524288,
    BDA_SCAN_MOD_BPSK = 1048576,
    BDA_SCAN_MOD_OQPSK = 2097152,
    BDA_SCAN_MOD_8VSB = 4194304,
    BDA_SCAN_MOD_16VSB = 8388608,
    BDA_SCAN_MOD_AM_RADIO = 16777216,
    BDA_SCAN_MOD_FM_RADIO = 33554432,
    BDA_SCAN_MOD_8PSK = 67108864,
    BDA_SCAN_MOD_RF = 134217728,
    ScanModulationTypesMask_MCE_DigitalCable = 11,
    ScanModulationTypesMask_MCE_TerrestrialATSC = 23,
    ScanModulationTypesMask_MCE_AnalogTv = 28,
    ScanModulationTypesMask_MCE_All_TV = -1,
    ScanModulationTypesMask_DVBC = 75,
    BDA_SCAN_MOD_16APSK = 268435456,
    BDA_SCAN_MOD_32APSK = 536870912,
};
pub const BDA_SCAN_MOD_16QAM = ScanModulationTypes.BDA_SCAN_MOD_16QAM;
pub const BDA_SCAN_MOD_32QAM = ScanModulationTypes.BDA_SCAN_MOD_32QAM;
pub const BDA_SCAN_MOD_64QAM = ScanModulationTypes.BDA_SCAN_MOD_64QAM;
pub const BDA_SCAN_MOD_80QAM = ScanModulationTypes.BDA_SCAN_MOD_80QAM;
pub const BDA_SCAN_MOD_96QAM = ScanModulationTypes.BDA_SCAN_MOD_96QAM;
pub const BDA_SCAN_MOD_112QAM = ScanModulationTypes.BDA_SCAN_MOD_112QAM;
pub const BDA_SCAN_MOD_128QAM = ScanModulationTypes.BDA_SCAN_MOD_128QAM;
pub const BDA_SCAN_MOD_160QAM = ScanModulationTypes.BDA_SCAN_MOD_160QAM;
pub const BDA_SCAN_MOD_192QAM = ScanModulationTypes.BDA_SCAN_MOD_192QAM;
pub const BDA_SCAN_MOD_224QAM = ScanModulationTypes.BDA_SCAN_MOD_224QAM;
pub const BDA_SCAN_MOD_256QAM = ScanModulationTypes.BDA_SCAN_MOD_256QAM;
pub const BDA_SCAN_MOD_320QAM = ScanModulationTypes.BDA_SCAN_MOD_320QAM;
pub const BDA_SCAN_MOD_384QAM = ScanModulationTypes.BDA_SCAN_MOD_384QAM;
pub const BDA_SCAN_MOD_448QAM = ScanModulationTypes.BDA_SCAN_MOD_448QAM;
pub const BDA_SCAN_MOD_512QAM = ScanModulationTypes.BDA_SCAN_MOD_512QAM;
pub const BDA_SCAN_MOD_640QAM = ScanModulationTypes.BDA_SCAN_MOD_640QAM;
pub const BDA_SCAN_MOD_768QAM = ScanModulationTypes.BDA_SCAN_MOD_768QAM;
pub const BDA_SCAN_MOD_896QAM = ScanModulationTypes.BDA_SCAN_MOD_896QAM;
pub const BDA_SCAN_MOD_1024QAM = ScanModulationTypes.BDA_SCAN_MOD_1024QAM;
pub const BDA_SCAN_MOD_QPSK = ScanModulationTypes.BDA_SCAN_MOD_QPSK;
pub const BDA_SCAN_MOD_BPSK = ScanModulationTypes.BDA_SCAN_MOD_BPSK;
pub const BDA_SCAN_MOD_OQPSK = ScanModulationTypes.BDA_SCAN_MOD_OQPSK;
pub const BDA_SCAN_MOD_8VSB = ScanModulationTypes.BDA_SCAN_MOD_8VSB;
pub const BDA_SCAN_MOD_16VSB = ScanModulationTypes.BDA_SCAN_MOD_16VSB;
pub const BDA_SCAN_MOD_AM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_AM_RADIO;
pub const BDA_SCAN_MOD_FM_RADIO = ScanModulationTypes.BDA_SCAN_MOD_FM_RADIO;
pub const BDA_SCAN_MOD_8PSK = ScanModulationTypes.BDA_SCAN_MOD_8PSK;
pub const BDA_SCAN_MOD_RF = ScanModulationTypes.BDA_SCAN_MOD_RF;
pub const ScanModulationTypesMask_MCE_DigitalCable = ScanModulationTypes.ScanModulationTypesMask_MCE_DigitalCable;
pub const ScanModulationTypesMask_MCE_TerrestrialATSC = ScanModulationTypes.ScanModulationTypesMask_MCE_TerrestrialATSC;
pub const ScanModulationTypesMask_MCE_AnalogTv = ScanModulationTypes.ScanModulationTypesMask_MCE_AnalogTv;
pub const ScanModulationTypesMask_MCE_All_TV = ScanModulationTypes.ScanModulationTypesMask_MCE_All_TV;
pub const ScanModulationTypesMask_DVBC = ScanModulationTypes.ScanModulationTypesMask_DVBC;
pub const BDA_SCAN_MOD_16APSK = ScanModulationTypes.BDA_SCAN_MOD_16APSK;
pub const BDA_SCAN_MOD_32APSK = ScanModulationTypes.BDA_SCAN_MOD_32APSK;

pub const SpectralInversion = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    AUTOMATIC = 1,
    NORMAL = 2,
    INVERTED = 3,
    MAX = 4,
};
pub const BDA_SPECTRAL_INVERSION_NOT_SET = SpectralInversion.NOT_SET;
pub const BDA_SPECTRAL_INVERSION_NOT_DEFINED = SpectralInversion.NOT_DEFINED;
pub const BDA_SPECTRAL_INVERSION_AUTOMATIC = SpectralInversion.AUTOMATIC;
pub const BDA_SPECTRAL_INVERSION_NORMAL = SpectralInversion.NORMAL;
pub const BDA_SPECTRAL_INVERSION_INVERTED = SpectralInversion.INVERTED;
pub const BDA_SPECTRAL_INVERSION_MAX = SpectralInversion.MAX;

pub const Polarisation = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    LINEAR_H = 1,
    LINEAR_V = 2,
    CIRCULAR_L = 3,
    CIRCULAR_R = 4,
    MAX = 5,
};
pub const BDA_POLARISATION_NOT_SET = Polarisation.NOT_SET;
pub const BDA_POLARISATION_NOT_DEFINED = Polarisation.NOT_DEFINED;
pub const BDA_POLARISATION_LINEAR_H = Polarisation.LINEAR_H;
pub const BDA_POLARISATION_LINEAR_V = Polarisation.LINEAR_V;
pub const BDA_POLARISATION_CIRCULAR_L = Polarisation.CIRCULAR_L;
pub const BDA_POLARISATION_CIRCULAR_R = Polarisation.CIRCULAR_R;
pub const BDA_POLARISATION_MAX = Polarisation.MAX;

pub const LNB_Source = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    A = 1,
    B = 2,
    C = 3,
    D = 4,
    MAX = 5,
};
pub const BDA_LNB_SOURCE_NOT_SET = LNB_Source.NOT_SET;
pub const BDA_LNB_SOURCE_NOT_DEFINED = LNB_Source.NOT_DEFINED;
pub const BDA_LNB_SOURCE_A = LNB_Source.A;
pub const BDA_LNB_SOURCE_B = LNB_Source.B;
pub const BDA_LNB_SOURCE_C = LNB_Source.C;
pub const BDA_LNB_SOURCE_D = LNB_Source.D;
pub const BDA_LNB_SOURCE_MAX = LNB_Source.MAX;

pub const GuardInterval = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1_32" = 1,
    @"1_16" = 2,
    @"1_8" = 3,
    @"1_4" = 4,
    @"1_128" = 5,
    @"19_128" = 6,
    @"19_256" = 7,
    MAX = 8,
};
pub const BDA_GUARD_NOT_SET = GuardInterval.NOT_SET;
pub const BDA_GUARD_NOT_DEFINED = GuardInterval.NOT_DEFINED;
pub const BDA_GUARD_1_32 = GuardInterval.@"1_32";
pub const BDA_GUARD_1_16 = GuardInterval.@"1_16";
pub const BDA_GUARD_1_8 = GuardInterval.@"1_8";
pub const BDA_GUARD_1_4 = GuardInterval.@"1_4";
pub const BDA_GUARD_1_128 = GuardInterval.@"1_128";
pub const BDA_GUARD_19_128 = GuardInterval.@"19_128";
pub const BDA_GUARD_19_256 = GuardInterval.@"19_256";
pub const BDA_GUARD_MAX = GuardInterval.MAX;

pub const HierarchyAlpha = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"1" = 1,
    @"2" = 2,
    @"4" = 3,
    MAX = 4,
};
pub const BDA_HALPHA_NOT_SET = HierarchyAlpha.NOT_SET;
pub const BDA_HALPHA_NOT_DEFINED = HierarchyAlpha.NOT_DEFINED;
pub const BDA_HALPHA_1 = HierarchyAlpha.@"1";
pub const BDA_HALPHA_2 = HierarchyAlpha.@"2";
pub const BDA_HALPHA_4 = HierarchyAlpha.@"4";
pub const BDA_HALPHA_MAX = HierarchyAlpha.MAX;

pub const TransmissionMode = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"2K" = 1,
    @"8K" = 2,
    @"4K" = 3,
    @"2K_INTERLEAVED" = 4,
    @"4K_INTERLEAVED" = 5,
    @"1K" = 6,
    @"16K" = 7,
    @"32K" = 8,
    MAX = 9,
};
pub const BDA_XMIT_MODE_NOT_SET = TransmissionMode.NOT_SET;
pub const BDA_XMIT_MODE_NOT_DEFINED = TransmissionMode.NOT_DEFINED;
pub const BDA_XMIT_MODE_2K = TransmissionMode.@"2K";
pub const BDA_XMIT_MODE_8K = TransmissionMode.@"8K";
pub const BDA_XMIT_MODE_4K = TransmissionMode.@"4K";
pub const BDA_XMIT_MODE_2K_INTERLEAVED = TransmissionMode.@"2K_INTERLEAVED";
pub const BDA_XMIT_MODE_4K_INTERLEAVED = TransmissionMode.@"4K_INTERLEAVED";
pub const BDA_XMIT_MODE_1K = TransmissionMode.@"1K";
pub const BDA_XMIT_MODE_16K = TransmissionMode.@"16K";
pub const BDA_XMIT_MODE_32K = TransmissionMode.@"32K";
pub const BDA_XMIT_MODE_MAX = TransmissionMode.MAX;

pub const RollOff = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    @"20" = 1,
    @"25" = 2,
    @"35" = 3,
    MAX = 4,
};
pub const BDA_ROLL_OFF_NOT_SET = RollOff.NOT_SET;
pub const BDA_ROLL_OFF_NOT_DEFINED = RollOff.NOT_DEFINED;
pub const BDA_ROLL_OFF_20 = RollOff.@"20";
pub const BDA_ROLL_OFF_25 = RollOff.@"25";
pub const BDA_ROLL_OFF_35 = RollOff.@"35";
pub const BDA_ROLL_OFF_MAX = RollOff.MAX;

pub const Pilot = enum(i32) {
    NOT_SET = -1,
    NOT_DEFINED = 0,
    OFF = 1,
    ON = 2,
    MAX = 3,
};
pub const BDA_PILOT_NOT_SET = Pilot.NOT_SET;
pub const BDA_PILOT_NOT_DEFINED = Pilot.NOT_DEFINED;
pub const BDA_PILOT_OFF = Pilot.OFF;
pub const BDA_PILOT_ON = Pilot.ON;
pub const BDA_PILOT_MAX = Pilot.MAX;

pub const BDA_SIGNAL_TIMEOUTS = extern struct {
    ulCarrierTimeoutMs: u32,
    ulScanningTimeoutMs: u32,
    ulTuningTimeoutMs: u32,
};

pub const BDA_Frequency = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_NOT_SET = BDA_Frequency.SET;
pub const BDA_FREQUENCY_NOT_DEFINED = BDA_Frequency.DEFINED;

pub const BDA_Range = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_RANGE_NOT_SET = BDA_Range.SET;
pub const BDA_RANGE_NOT_DEFINED = BDA_Range.DEFINED;

pub const BDA_Channel_Bandwidth = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_CHAN_BANDWITH_NOT_SET = BDA_Channel_Bandwidth.SET;
pub const BDA_CHAN_BANDWITH_NOT_DEFINED = BDA_Channel_Bandwidth.DEFINED;

pub const BDA_Frequency_Multiplier = enum(i32) {
    SET = -1,
    DEFINED = 0,
};
pub const BDA_FREQUENCY_MULTIPLIER_NOT_SET = BDA_Frequency_Multiplier.SET;
pub const BDA_FREQUENCY_MULTIPLIER_NOT_DEFINED = BDA_Frequency_Multiplier.DEFINED;

pub const BDA_Comp_Flags = enum(i32) {
    NOT_DEFINED = 0,
    EXCLUDE_TS_FROM_TR = 1,
    INCLUDE_LOCATOR_IN_TR = 2,
    INCLUDE_COMPONENTS_IN_TR = 4,
};
pub const BDACOMP_NOT_DEFINED = BDA_Comp_Flags.NOT_DEFINED;
pub const BDACOMP_EXCLUDE_TS_FROM_TR = BDA_Comp_Flags.EXCLUDE_TS_FROM_TR;
pub const BDACOMP_INCLUDE_LOCATOR_IN_TR = BDA_Comp_Flags.INCLUDE_LOCATOR_IN_TR;
pub const BDACOMP_INCLUDE_COMPONENTS_IN_TR = BDA_Comp_Flags.INCLUDE_COMPONENTS_IN_TR;

pub const ApplicationTypeType = enum(i32) {
    ConditionalAccess = 0,
    POD_Host_Binding_Information = 1,
    IPService = 2,
    NetworkInterface_SCTE55_2 = 3,
    NetworkInterface_SCTE55_1 = 4,
    CopyProtection = 5,
    Diagnostic = 6,
    Undesignated = 7,
    Reserved = 8,
};
pub const SCTE28_ConditionalAccess = ApplicationTypeType.ConditionalAccess;
pub const SCTE28_POD_Host_Binding_Information = ApplicationTypeType.POD_Host_Binding_Information;
pub const SCTE28_IPService = ApplicationTypeType.IPService;
pub const SCTE28_NetworkInterface_SCTE55_2 = ApplicationTypeType.NetworkInterface_SCTE55_2;
pub const SCTE28_NetworkInterface_SCTE55_1 = ApplicationTypeType.NetworkInterface_SCTE55_1;
pub const SCTE28_CopyProtection = ApplicationTypeType.CopyProtection;
pub const SCTE28_Diagnostic = ApplicationTypeType.Diagnostic;
pub const SCTE28_Undesignated = ApplicationTypeType.Undesignated;
pub const SCTE28_Reserved = ApplicationTypeType.Reserved;

pub const BDA_CONDITIONALACCESS_REQUESTTYPE = enum(i32) {
    UNSPECIFIED = 0,
    NOT_POSSIBLE = 1,
    POSSIBLE = 2,
    POSSIBLE_NO_STREAMING_DISRUPTION = 3,
};
pub const CONDITIONALACCESS_ACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_REQUESTTYPE.UNSPECIFIED;
pub const CONDITIONALACCESS_ACCESS_NOT_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.NOT_POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE;
pub const CONDITIONALACCESS_ACCESS_POSSIBLE_NO_STREAMING_DISRUPTION = BDA_CONDITIONALACCESS_REQUESTTYPE.POSSIBLE_NO_STREAMING_DISRUPTION;

pub const BDA_CONDITIONALACCESS_MMICLOSEREASON = enum(i32) {
    UNSPECIFIED = 0,
    CLOSED_ITSELF = 1,
    TUNER_REQUESTED_CLOSE = 2,
    DIALOG_TIMEOUT = 3,
    DIALOG_FOCUS_CHANGE = 4,
    DIALOG_USER_DISMISSED = 5,
    DIALOG_USER_NOT_AVAILABLE = 6,
};
pub const CONDITIONALACCESS_UNSPECIFIED = BDA_CONDITIONALACCESS_MMICLOSEREASON.UNSPECIFIED;
pub const CONDITIONALACCESS_CLOSED_ITSELF = BDA_CONDITIONALACCESS_MMICLOSEREASON.CLOSED_ITSELF;
pub const CONDITIONALACCESS_TUNER_REQUESTED_CLOSE = BDA_CONDITIONALACCESS_MMICLOSEREASON.TUNER_REQUESTED_CLOSE;
pub const CONDITIONALACCESS_DIALOG_TIMEOUT = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_TIMEOUT;
pub const CONDITIONALACCESS_DIALOG_FOCUS_CHANGE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_FOCUS_CHANGE;
pub const CONDITIONALACCESS_DIALOG_USER_DISMISSED = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_DISMISSED;
pub const CONDITIONALACCESS_DIALOG_USER_NOT_AVAILABLE = BDA_CONDITIONALACCESS_MMICLOSEREASON.DIALOG_USER_NOT_AVAILABLE;

pub const BDA_CONDITIONALACCESS_SESSION_RESULT = enum(i32) {
    SUCCESSFULL = 0,
    ENDED_NOCHANGE = 1,
    ABORTED = 2,
};
pub const CONDITIONALACCESS_SUCCESSFULL = BDA_CONDITIONALACCESS_SESSION_RESULT.SUCCESSFULL;
pub const CONDITIONALACCESS_ENDED_NOCHANGE = BDA_CONDITIONALACCESS_SESSION_RESULT.ENDED_NOCHANGE;
pub const CONDITIONALACCESS_ABORTED = BDA_CONDITIONALACCESS_SESSION_RESULT.ABORTED;

pub const BDA_DISCOVERY_STATE = enum(i32) {
    UNSPECIFIED = 0,
    REQUIRED = 1,
    COMPLETE = 2,
};
pub const BDA_DISCOVERY_UNSPECIFIED = BDA_DISCOVERY_STATE.UNSPECIFIED;
pub const BDA_DISCOVERY_REQUIRED = BDA_DISCOVERY_STATE.REQUIRED;
pub const BDA_DISCOVERY_COMPLETE = BDA_DISCOVERY_STATE.COMPLETE;

pub const SmartCardStatusType = enum(i32) {
    Inserted = 0,
    Removed = 1,
    Error = 2,
    DataChanged = 3,
    FirmwareUpgrade = 4,
};
pub const CardInserted = SmartCardStatusType.Inserted;
pub const CardRemoved = SmartCardStatusType.Removed;
pub const CardError = SmartCardStatusType.Error;
pub const CardDataChanged = SmartCardStatusType.DataChanged;
pub const CardFirmwareUpgrade = SmartCardStatusType.FirmwareUpgrade;

pub const SmartCardAssociationType = enum(i32) {
    NotAssociated = 0,
    Associated = 1,
    AssociationUnknown = 2,
};
pub const NotAssociated = SmartCardAssociationType.NotAssociated;
pub const Associated = SmartCardAssociationType.Associated;
pub const AssociationUnknown = SmartCardAssociationType.AssociationUnknown;

pub const LocationCodeSchemeType = enum(i32) {
    @"8" = 0,
};
pub const SCTE_18 = LocationCodeSchemeType.@"8";

pub const EALocationCodeType = extern struct {
    LocationCodeScheme: LocationCodeSchemeType,
    state_code: u8,
    county_subdivision: u8,
    county_code: u16,
};

pub const EntitlementType = enum(i32) {
    Entitled = 0,
    NotEntitled = 1,
    TechnicalFailure = 2,
};
pub const Entitled = EntitlementType.Entitled;
pub const NotEntitled = EntitlementType.NotEntitled;
pub const TechnicalFailure = EntitlementType.TechnicalFailure;

pub const UICloseReasonType = enum(i32) {
    NotReady = 0,
    UserClosed = 1,
    SystemClosed = 2,
    DeviceClosed = 3,
    ErrorClosed = 4,
};
pub const NotReady = UICloseReasonType.NotReady;
pub const UserClosed = UICloseReasonType.UserClosed;
pub const SystemClosed = UICloseReasonType.SystemClosed;
pub const DeviceClosed = UICloseReasonType.DeviceClosed;
pub const ErrorClosed = UICloseReasonType.ErrorClosed;

pub const SmartCardApplication = extern struct {
    ApplicationType: ApplicationTypeType,
    ApplicationVersion: u16,
    pbstrApplicationName: ?BSTR,
    pbstrApplicationURL: ?BSTR,
};

pub const BDA_DrmPairingError = enum(i32) {
    Succeeded = 0,
    HardwareFailure = 1,
    NeedRevocationData = 2,
    NeedIndiv = 3,
    Other = 4,
    DrmInitFailed = 5,
    DrmNotPaired = 6,
    DrmRePairSoon = 7,
    Aborted = 8,
    NeedSDKUpdate = 9,
};
pub const BDA_DrmPairing_Succeeded = BDA_DrmPairingError.Succeeded;
pub const BDA_DrmPairing_HardwareFailure = BDA_DrmPairingError.HardwareFailure;
pub const BDA_DrmPairing_NeedRevocationData = BDA_DrmPairingError.NeedRevocationData;
pub const BDA_DrmPairing_NeedIndiv = BDA_DrmPairingError.NeedIndiv;
pub const BDA_DrmPairing_Other = BDA_DrmPairingError.Other;
pub const BDA_DrmPairing_DrmInitFailed = BDA_DrmPairingError.DrmInitFailed;
pub const BDA_DrmPairing_DrmNotPaired = BDA_DrmPairingError.DrmNotPaired;
pub const BDA_DrmPairing_DrmRePairSoon = BDA_DrmPairingError.DrmRePairSoon;
pub const BDA_DrmPairing_Aborted = BDA_DrmPairingError.Aborted;
pub const BDA_DrmPairing_NeedSDKUpdate = BDA_DrmPairingError.NeedSDKUpdate;

const IID_IBDA_NetworkProvider_Value = Guid.initString("fd501041-8ebe-11ce-8183-00aa00577da2");
pub const IID_IBDA_NetworkProvider = &IID_IBDA_NetworkProvider_Value;
pub const IBDA_NetworkProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutSignalSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                ulSignalSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                ulSignalSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignalSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                pulSignalSource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                pulSignalSource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                pguidNetworkType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                pguidNetworkType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutTuningSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                guidTuningSpace: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                guidTuningSpace: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTuningSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                pguidTuingSpace: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                pguidTuingSpace: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterDeviceFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                pUnkFilterControl: ?*IUnknown,
                ppvRegisitrationContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                pUnkFilterControl: ?*IUnknown,
                ppvRegisitrationContext: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnRegisterDeviceFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NetworkProvider,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NetworkProvider,
                pvRegistrationContext: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_PutSignalSource(self: *const T, ulSignalSource: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).PutSignalSource(@as(*const IBDA_NetworkProvider, @ptrCast(self)), ulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetSignalSource(self: *const T, pulSignalSource: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetSignalSource(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetNetworkType(self: *const T, pguidNetworkType: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetNetworkType(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pguidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_PutTuningSpace(self: *const T, guidTuningSpace: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).PutTuningSpace(@as(*const IBDA_NetworkProvider, @ptrCast(self)), guidTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_GetTuningSpace(self: *const T, pguidTuingSpace: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).GetTuningSpace(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pguidTuingSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_RegisterDeviceFilter(self: *const T, pUnkFilterControl: ?*IUnknown, ppvRegisitrationContext: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).RegisterDeviceFilter(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pUnkFilterControl, ppvRegisitrationContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NetworkProvider_UnRegisterDeviceFilter(self: *const T, pvRegistrationContext: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NetworkProvider.VTable, @ptrCast(self.vtable)).UnRegisterDeviceFilter(@as(*const IBDA_NetworkProvider, @ptrCast(self)), pvRegistrationContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_EthernetFilter_Value = Guid.initString("71985f43-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_EthernetFilter = &IID_IBDA_EthernetFilter_Value;
pub const IBDA_EthernetFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EthernetFilter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EthernetFilter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EthernetFilter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EthernetFilter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EthernetFilter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EthernetFilter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EthernetFilter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EthernetFilter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EthernetFilter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EthernetFilter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_EthernetFilter, @ptrCast(self)), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_EthernetFilter, @ptrCast(self)), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EthernetFilter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EthernetFilter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_EthernetFilter, @ptrCast(self)), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV4Filter_Value = Guid.initString("71985f44-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_IPV4Filter = &IID_IBDA_IPV4Filter_Value;
pub const IBDA_IPV4Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV4Filter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV4Filter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV4Filter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV4Filter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV4Filter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV4Filter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV4Filter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV4Filter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV4Filter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV4Filter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_IPV4Filter, @ptrCast(self)), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_IPV4Filter, @ptrCast(self)), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV4Filter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV4Filter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_IPV4Filter, @ptrCast(self)), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPV6Filter_Value = Guid.initString("e1785a74-2a23-4fb3-9245-a8f88017ef33");
pub const IID_IBDA_IPV6Filter = &IID_IBDA_IPV6Filter_Value;
pub const IBDA_IPV6Filter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastListSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV6Filter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV6Filter,
                pulcbAddresses: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV6Filter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV6Filter,
                ulcbAddresses: u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV6Filter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV6Filter,
                pulcbAddresses: ?*u32,
                pAddressList: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV6Filter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV6Filter,
                ulModeMask: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMulticastMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPV6Filter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPV6Filter,
                pulModeMask: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastListSize(self: *const T, pulcbAddresses: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastListSize(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pulcbAddresses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_PutMulticastList(self: *const T, ulcbAddresses: u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).PutMulticastList(@as(*const IBDA_IPV6Filter, @ptrCast(self)), ulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastList(self: *const T, pulcbAddresses: ?*u32, pAddressList: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pulcbAddresses, pAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_PutMulticastMode(self: *const T, ulModeMask: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).PutMulticastMode(@as(*const IBDA_IPV6Filter, @ptrCast(self)), ulModeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPV6Filter_GetMulticastMode(self: *const T, pulModeMask: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPV6Filter.VTable, @ptrCast(self.vtable)).GetMulticastMode(@as(*const IBDA_IPV6Filter, @ptrCast(self)), pulModeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DeviceControl_Value = Guid.initString("fd0a5af3-b41d-11d2-9c95-00c04f7971e0");
pub const IID_IBDA_DeviceControl = &IID_IBDA_DeviceControl_Value;
pub const IBDA_DeviceControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CheckChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CommitChanges: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DeviceControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetChangeState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DeviceControl,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DeviceControl,
                pState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_StartChanges(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).StartChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_CheckChanges(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).CheckChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_CommitChanges(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).CommitChanges(@as(*const IBDA_DeviceControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DeviceControl_GetChangeState(self: *const T, pState: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DeviceControl.VTable, @ptrCast(self.vtable)).GetChangeState(@as(*const IBDA_DeviceControl, @ptrCast(self)), pState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_PinControl_Value = Guid.initString("0ded49d5-a8b7-4d5d-97a1-12b0c195874d");
pub const IID_IBDA_PinControl = &IID_IBDA_PinControl_Value;
pub const IBDA_PinControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPinID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_PinControl,
                pulPinID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_PinControl,
                pulPinID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPinType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_PinControl,
                pulPinType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_PinControl,
                pulPinType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegistrationContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_PinControl,
                pulRegistrationCtx: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_PinControl,
                pulRegistrationCtx: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_GetPinID(self: *const T, pulPinID: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).GetPinID(@as(*const IBDA_PinControl, @ptrCast(self)), pulPinID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_GetPinType(self: *const T, pulPinType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).GetPinType(@as(*const IBDA_PinControl, @ptrCast(self)), pulPinType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_PinControl_RegistrationContext(self: *const T, pulRegistrationCtx: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_PinControl.VTable, @ptrCast(self.vtable)).RegistrationContext(@as(*const IBDA_PinControl, @ptrCast(self)), pulRegistrationCtx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalProperties_Value = Guid.initString("d2f1644b-b409-11d2-bc69-00a0c9ee9e16");
pub const IID_IBDA_SignalProperties = &IID_IBDA_SignalProperties_Value;
pub const IBDA_SignalProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutNetworkType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                guidNetworkType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                guidNetworkType: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNetworkType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                pguidNetworkType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                pguidNetworkType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutSignalSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                ulSignalSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                ulSignalSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSignalSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                pulSignalSource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                pulSignalSource: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PutTuningSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                guidTuningSpace: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                guidTuningSpace: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTuningSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_SignalProperties,
                pguidTuingSpace: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_SignalProperties,
                pguidTuingSpace: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutNetworkType(self: *const T, guidNetworkType: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutNetworkType(@as(*const IBDA_SignalProperties, @ptrCast(self)), guidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetNetworkType(self: *const T, pguidNetworkType: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetNetworkType(@as(*const IBDA_SignalProperties, @ptrCast(self)), pguidNetworkType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutSignalSource(self: *const T, ulSignalSource: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutSignalSource(@as(*const IBDA_SignalProperties, @ptrCast(self)), ulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetSignalSource(self: *const T, pulSignalSource: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetSignalSource(@as(*const IBDA_SignalProperties, @ptrCast(self)), pulSignalSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_PutTuningSpace(self: *const T, guidTuningSpace: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).PutTuningSpace(@as(*const IBDA_SignalProperties, @ptrCast(self)), guidTuningSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalProperties_GetTuningSpace(self: *const T, pguidTuingSpace: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalProperties.VTable, @ptrCast(self.vtable)).GetTuningSpace(@as(*const IBDA_SignalProperties, @ptrCast(self)), pguidTuingSpace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_SignalStatistics_Value = Guid.initString("1347d106-cf3a-428a-a5cb-ac0d9a2a4338");
pub const IID_IBDA_SignalStatistics = &IID_IBDA_SignalStatistics_Value;
pub const IBDA_SignalStatistics = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalStrength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                lDbStrength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                lDbStrength: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalStrength: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                plDbStrength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                plDbStrength: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalQuality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                lPercentQuality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                lPercentQuality: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalQuality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                plPercentQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                plPercentQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalPresent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                fPresent: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                fPresent: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalPresent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                pfPresent: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                pfPresent: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalLocked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                fLocked: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                fLocked: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalLocked: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                pfLocked: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                pfLocked: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SampleTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                lmsSampleTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                lmsSampleTime: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SampleTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_SignalStatistics,
                plmsSampleTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_SignalStatistics,
                plmsSampleTime: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalStrength(self: *const T, lDbStrength: i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalStrength(@as(*const IBDA_SignalStatistics, @ptrCast(self)), lDbStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalStrength(self: *const T, plDbStrength: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalStrength(@as(*const IBDA_SignalStatistics, @ptrCast(self)), plDbStrength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalQuality(self: *const T, lPercentQuality: i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalQuality(@as(*const IBDA_SignalStatistics, @ptrCast(self)), lPercentQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalQuality(self: *const T, plPercentQuality: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalQuality(@as(*const IBDA_SignalStatistics, @ptrCast(self)), plPercentQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalPresent(self: *const T, fPresent: BOOLEAN) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalPresent(@as(*const IBDA_SignalStatistics, @ptrCast(self)), fPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalPresent(self: *const T, pfPresent: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalPresent(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pfPresent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SignalLocked(self: *const T, fLocked: BOOLEAN) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SignalLocked(@as(*const IBDA_SignalStatistics, @ptrCast(self)), fLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SignalLocked(self: *const T, pfLocked: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SignalLocked(@as(*const IBDA_SignalStatistics, @ptrCast(self)), pfLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_put_SampleTime(self: *const T, lmsSampleTime: i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).put_SampleTime(@as(*const IBDA_SignalStatistics, @ptrCast(self)), lmsSampleTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_SignalStatistics_get_SampleTime(self: *const T, plmsSampleTime: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_SignalStatistics.VTable, @ptrCast(self.vtable)).get_SampleTime(@as(*const IBDA_SignalStatistics, @ptrCast(self)), plmsSampleTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_Topology_Value = Guid.initString("79b56888-7fea-4690-b45d-38fd3c7849be");
pub const IID_IBDA_Topology = &IID_IBDA_Topology_Value;
pub const IBDA_Topology = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNodeTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                pulcNodeTypes: ?*u32,
                ulcNodeTypesMax: u32,
                rgulNodeTypes: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                pulcNodeTypes: ?*u32,
                ulcNodeTypesMax: u32,
                rgulNodeTypes: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNodeDescriptors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulcNodeDescriptors: ?*u32,
                ulcNodeDescriptorsMax: u32,
                rgNodeDescriptors: [*]BDANODE_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulcNodeDescriptors: ?*u32,
                ulcNodeDescriptorsMax: u32,
                rgNodeDescriptors: [*]BDANODE_DESCRIPTOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNodeInterfaces: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulNodeType: u32,
                pulcInterfaces: ?*u32,
                ulcInterfacesMax: u32,
                rgguidInterfaces: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulNodeType: u32,
                pulcInterfaces: ?*u32,
                ulcInterfacesMax: u32,
                rgguidInterfaces: [*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPinTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                pulcPinTypes: ?*u32,
                ulcPinTypesMax: u32,
                rgulPinTypes: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                pulcPinTypes: ?*u32,
                ulcPinTypesMax: u32,
                rgulPinTypes: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTemplateConnections: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                pulcConnections: ?*u32,
                ulcConnectionsMax: u32,
                rgConnections: [*]BDA_TEMPLATE_CONNECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                pulcConnections: ?*u32,
                ulcConnectionsMax: u32,
                rgConnections: [*]BDA_TEMPLATE_CONNECTION,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreatePin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulPinType: u32,
                pulPinId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulPinType: u32,
                pulPinId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeletePin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMedium: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
                pMedium: ?*REGPINMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulPinId: u32,
                pMedium: ?*REGPINMEDIUM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTopology: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulInputPinId: u32,
                ulOutputPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulInputPinId: u32,
                ulOutputPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetControlNode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Topology,
                ulInputPinId: u32,
                ulOutputPinId: u32,
                ulNodeType: u32,
                ppControlNode: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Topology,
                ulInputPinId: u32,
                ulOutputPinId: u32,
                ulNodeType: u32,
                ppControlNode: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeTypes(self: *const T, pulcNodeTypes: ?*u32, ulcNodeTypesMax: u32, rgulNodeTypes: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeTypes(@as(*const IBDA_Topology, @ptrCast(self)), pulcNodeTypes, ulcNodeTypesMax, rgulNodeTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeDescriptors(self: *const T, ulcNodeDescriptors: ?*u32, ulcNodeDescriptorsMax: u32, rgNodeDescriptors: [*]BDANODE_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeDescriptors(@as(*const IBDA_Topology, @ptrCast(self)), ulcNodeDescriptors, ulcNodeDescriptorsMax, rgNodeDescriptors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetNodeInterfaces(self: *const T, ulNodeType: u32, pulcInterfaces: ?*u32, ulcInterfacesMax: u32, rgguidInterfaces: [*]Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetNodeInterfaces(@as(*const IBDA_Topology, @ptrCast(self)), ulNodeType, pulcInterfaces, ulcInterfacesMax, rgguidInterfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetPinTypes(self: *const T, pulcPinTypes: ?*u32, ulcPinTypesMax: u32, rgulPinTypes: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetPinTypes(@as(*const IBDA_Topology, @ptrCast(self)), pulcPinTypes, ulcPinTypesMax, rgulPinTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetTemplateConnections(self: *const T, pulcConnections: ?*u32, ulcConnectionsMax: u32, rgConnections: [*]BDA_TEMPLATE_CONNECTION) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetTemplateConnections(@as(*const IBDA_Topology, @ptrCast(self)), pulcConnections, ulcConnectionsMax, rgConnections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_CreatePin(self: *const T, ulPinType: u32, pulPinId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).CreatePin(@as(*const IBDA_Topology, @ptrCast(self)), ulPinType, pulPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_DeletePin(self: *const T, ulPinId: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).DeletePin(@as(*const IBDA_Topology, @ptrCast(self)), ulPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_SetMediaType(self: *const T, ulPinId: u32, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IBDA_Topology, @ptrCast(self)), ulPinId, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_SetMedium(self: *const T, ulPinId: u32, pMedium: ?*REGPINMEDIUM) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).SetMedium(@as(*const IBDA_Topology, @ptrCast(self)), ulPinId, pMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_CreateTopology(self: *const T, ulInputPinId: u32, ulOutputPinId: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).CreateTopology(@as(*const IBDA_Topology, @ptrCast(self)), ulInputPinId, ulOutputPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Topology_GetControlNode(self: *const T, ulInputPinId: u32, ulOutputPinId: u32, ulNodeType: u32, ppControlNode: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Topology.VTable, @ptrCast(self.vtable)).GetControlNode(@as(*const IBDA_Topology, @ptrCast(self)), ulInputPinId, ulOutputPinId, ulNodeType, ppControlNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_VoidTransform_Value = Guid.initString("71985f46-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_VoidTransform = &IID_IBDA_VoidTransform_Value;
pub const IBDA_VoidTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_VoidTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_VoidTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_VoidTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_VoidTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_VoidTransform_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_VoidTransform.VTable, @ptrCast(self.vtable)).Start(@as(*const IBDA_VoidTransform, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_VoidTransform_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_VoidTransform.VTable, @ptrCast(self.vtable)).Stop(@as(*const IBDA_VoidTransform, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NullTransform_Value = Guid.initString("ddf15b0d-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_NullTransform = &IID_IBDA_NullTransform_Value;
pub const IBDA_NullTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NullTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NullTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NullTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NullTransform,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NullTransform_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NullTransform.VTable, @ptrCast(self.vtable)).Start(@as(*const IBDA_NullTransform, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NullTransform_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NullTransform.VTable, @ptrCast(self.vtable)).Stop(@as(*const IBDA_NullTransform, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_FrequencyFilter_Value = Guid.initString("71985f47-1ca1-11d3-9cc8-00c04f7971e0");
pub const IID_IBDA_FrequencyFilter = &IID_IBDA_FrequencyFilter_Value;
pub const IBDA_FrequencyFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Autotune: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                ulTransponder: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                ulTransponder: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Autotune: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pulTransponder: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pulTransponder: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                ulFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                ulFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Frequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pulFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pulFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Polarity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                Polarity: Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                Polarity: Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Polarity: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pPolarity: ?*Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pPolarity: ?*Polarisation,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Range: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                ulRange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                ulRange: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Range: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pulRange: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pulRange: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Bandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                ulBandwidth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                ulBandwidth: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pulBandwidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pulBandwidth: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyMultiplier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                ulMultiplier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                ulMultiplier: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyMultiplier: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_FrequencyFilter,
                pulMultiplier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_FrequencyFilter,
                pulMultiplier: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Autotune(self: *const T, ulTransponder: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Autotune(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ulTransponder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Autotune(self: *const T, pulTransponder: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Autotune(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pulTransponder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Frequency(self: *const T, ulFrequency: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Frequency(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ulFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Frequency(self: *const T, pulFrequency: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Frequency(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pulFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Polarity(self: *const T, Polarity: Polarisation) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Polarity(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), Polarity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Polarity(self: *const T, pPolarity: ?*Polarisation) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Polarity(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pPolarity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Range(self: *const T, ulRange: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Range(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ulRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Range(self: *const T, pulRange: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Range(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pulRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_Bandwidth(self: *const T, ulBandwidth: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_Bandwidth(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ulBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_Bandwidth(self: *const T, pulBandwidth: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pulBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_put_FrequencyMultiplier(self: *const T, ulMultiplier: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).put_FrequencyMultiplier(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), ulMultiplier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FrequencyFilter_get_FrequencyMultiplier(self: *const T, pulMultiplier: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FrequencyFilter.VTable, @ptrCast(self.vtable)).get_FrequencyMultiplier(@as(*const IBDA_FrequencyFilter, @ptrCast(self)), pulMultiplier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_LNBInfo_Value = Guid.initString("992cf102-49f9-4719-a664-c4f23e2408f4");
pub const IID_IBDA_LNBInfo = &IID_IBDA_LNBInfo_Value;
pub const IBDA_LNBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyLowBand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                ulLOFLow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                ulLOFLow: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyLowBand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                pulLOFLow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                pulLOFLow: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_LocalOscilatorFrequencyHighBand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                ulLOFHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                ulLOFHigh: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LocalOscilatorFrequencyHighBand: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                pulLOFHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                pulLOFHigh: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HighLowSwitchFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                ulSwitchFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                ulSwitchFrequency: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HighLowSwitchFrequency: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_LNBInfo,
                pulSwitchFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_LNBInfo,
                pulSwitchFrequency: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_LocalOscilatorFrequencyLowBand(self: *const T, ulLOFLow: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_LocalOscilatorFrequencyLowBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), ulLOFLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_LocalOscilatorFrequencyLowBand(self: *const T, pulLOFLow: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_LocalOscilatorFrequencyLowBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), pulLOFLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_LocalOscilatorFrequencyHighBand(self: *const T, ulLOFHigh: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_LocalOscilatorFrequencyHighBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), ulLOFHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_LocalOscilatorFrequencyHighBand(self: *const T, pulLOFHigh: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_LocalOscilatorFrequencyHighBand(@as(*const IBDA_LNBInfo, @ptrCast(self)), pulLOFHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_put_HighLowSwitchFrequency(self: *const T, ulSwitchFrequency: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).put_HighLowSwitchFrequency(@as(*const IBDA_LNBInfo, @ptrCast(self)), ulSwitchFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_LNBInfo_get_HighLowSwitchFrequency(self: *const T, pulSwitchFrequency: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_LNBInfo.VTable, @ptrCast(self.vtable)).get_HighLowSwitchFrequency(@as(*const IBDA_LNBInfo, @ptrCast(self)), pulSwitchFrequency);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiseqCommand_Value = Guid.initString("f84e2ab0-3c6b-45e3-a0fc-8669d4b81f11");
pub const IID_IBDA_DiseqCommand = &IID_IBDA_DiseqCommand_Value;
pub const IBDA_DiseqCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableDiseqCommands: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                bEnable: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                bEnable: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqLNBSource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                ulLNBSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                ulLNBSource: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqUseToneBurst: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                bUseToneBurst: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                bUseToneBurst: BOOLEAN,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DiseqRepeats: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                ulRepeats: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                ulRepeats: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_DiseqSendCommand: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                ulRequestId: u32,
                ulcbCommandLen: u32,
                pbCommand: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                ulRequestId: u32,
                ulcbCommandLen: u32,
                pbCommand: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DiseqResponse: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DiseqCommand,
                ulRequestId: u32,
                pulcbResponseLen: ?*u32,
                pbResponse: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DiseqCommand,
                ulRequestId: u32,
                pulcbResponseLen: ?*u32,
                pbResponse: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_EnableDiseqCommands(self: *const T, bEnable: BOOLEAN) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_EnableDiseqCommands(@as(*const IBDA_DiseqCommand, @ptrCast(self)), bEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqLNBSource(self: *const T, ulLNBSource: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqLNBSource(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ulLNBSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqUseToneBurst(self: *const T, bUseToneBurst: BOOLEAN) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqUseToneBurst(@as(*const IBDA_DiseqCommand, @ptrCast(self)), bUseToneBurst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqRepeats(self: *const T, ulRepeats: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqRepeats(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ulRepeats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_put_DiseqSendCommand(self: *const T, ulRequestId: u32, ulcbCommandLen: u32, pbCommand: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).put_DiseqSendCommand(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ulRequestId, ulcbCommandLen, pbCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DiseqCommand_get_DiseqResponse(self: *const T, ulRequestId: u32, pulcbResponseLen: ?*u32, pbResponse: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DiseqCommand.VTable, @ptrCast(self.vtable)).get_DiseqResponse(@as(*const IBDA_DiseqCommand, @ptrCast(self)), ulRequestId, pulcbResponseLen, pbResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AutoDemodulate_Value = Guid.initString("ddf15b12-bd25-11d2-9ca0-00c04f7971e0");
pub const IID_IBDA_AutoDemodulate = &IID_IBDA_AutoDemodulate_Value;
pub const IBDA_AutoDemodulate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        put_AutoDemodulate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AutoDemodulate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AutoDemodulate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulate_put_AutoDemodulate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AutoDemodulate.VTable, @ptrCast(self.vtable)).put_AutoDemodulate(@as(*const IBDA_AutoDemodulate, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_AutoDemodulateEx_Value = Guid.initString("34518d13-1182-48e6-b28f-b24987787326");
pub const IID_IBDA_AutoDemodulateEx = &IID_IBDA_AutoDemodulateEx_Value;
pub const IBDA_AutoDemodulateEx = extern struct {
    pub const VTable = extern struct {
        base: IBDA_AutoDemodulate.VTable,
        get_SupportedDeviceNodeTypes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AutoDemodulateEx,
                ulcDeviceNodeTypesMax: u32,
                pulcDeviceNodeTypes: ?*u32,
                pguidDeviceNodeTypes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AutoDemodulateEx,
                ulcDeviceNodeTypesMax: u32,
                pulcDeviceNodeTypes: ?*u32,
                pguidDeviceNodeTypes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SupportedVideoFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AutoDemodulateEx,
                pulAMTunerModeType: ?*u32,
                pulAnalogVideoStandard: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AutoDemodulateEx,
                pulAMTunerModeType: ?*u32,
                pulAnalogVideoStandard: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_AuxInputCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AutoDemodulateEx,
                pulCompositeCount: ?*u32,
                pulSvideoCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AutoDemodulateEx,
                pulCompositeCount: ?*u32,
                pulSvideoCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_AutoDemodulate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_SupportedDeviceNodeTypes(self: *const T, ulcDeviceNodeTypesMax: u32, pulcDeviceNodeTypes: ?*u32, pguidDeviceNodeTypes: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_SupportedDeviceNodeTypes(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), ulcDeviceNodeTypesMax, pulcDeviceNodeTypes, pguidDeviceNodeTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_SupportedVideoFormats(self: *const T, pulAMTunerModeType: ?*u32, pulAnalogVideoStandard: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_SupportedVideoFormats(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), pulAMTunerModeType, pulAnalogVideoStandard);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AutoDemodulateEx_get_AuxInputCount(self: *const T, pulCompositeCount: ?*u32, pulSvideoCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AutoDemodulateEx.VTable, @ptrCast(self.vtable)).get_AuxInputCount(@as(*const IBDA_AutoDemodulateEx, @ptrCast(self)), pulCompositeCount, pulSvideoCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator_Value = Guid.initString("ef30f379-985b-4d10-b640-a79d5e04e1e0");
pub const IID_IBDA_DigitalDemodulator = &IID_IBDA_DigitalDemodulator_Value;
pub const IBDA_DigitalDemodulator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ModulationType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pModulationType: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pModulationType: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModulationType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pModulationType: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pModulationType: ?*ModulationType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECMethod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECMethod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_InnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_InnerFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECMethod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECMethod: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECMethod: ?*FECMethod,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_OuterFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_OuterFECRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pFECRate: ?*BinaryConvolutionCodeRate,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SymbolRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pSymbolRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pSymbolRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SymbolRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pSymbolRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pSymbolRate: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SpectralInversion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pSpectralInversion: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pSpectralInversion: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SpectralInversion: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator,
                pSpectralInversion: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator,
                pSpectralInversion: ?*SpectralInversion,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_ModulationType(self: *const T, pModulationType: ?*ModulationType) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_ModulationType(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pModulationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_ModulationType(self: *const T, pModulationType: ?*ModulationType) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_ModulationType(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pModulationType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_InnerFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_InnerFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_InnerFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_InnerFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_InnerFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_InnerFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_InnerFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_InnerFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_OuterFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_OuterFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_OuterFECMethod(self: *const T, pFECMethod: ?*FECMethod) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_OuterFECMethod(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECMethod);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_OuterFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_OuterFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_OuterFECRate(self: *const T, pFECRate: ?*BinaryConvolutionCodeRate) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_OuterFECRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pFECRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_SymbolRate(self: *const T, pSymbolRate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_SymbolRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pSymbolRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_SymbolRate(self: *const T, pSymbolRate: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_SymbolRate(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pSymbolRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_put_SpectralInversion(self: *const T, pSpectralInversion: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).put_SpectralInversion(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pSpectralInversion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator_get_SpectralInversion(self: *const T, pSpectralInversion: ?*SpectralInversion) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator.VTable, @ptrCast(self.vtable)).get_SpectralInversion(@as(*const IBDA_DigitalDemodulator, @ptrCast(self)), pSpectralInversion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator2_Value = Guid.initString("525ed3ee-5cf3-4e1e-9a06-5368a84f9a6e");
pub const IID_IBDA_DigitalDemodulator2 = &IID_IBDA_DigitalDemodulator2_Value;
pub const IBDA_DigitalDemodulator2 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_GuardInterval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pGuardInterval: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pGuardInterval: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_GuardInterval: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pGuardInterval: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pGuardInterval: ?*GuardInterval,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_TransmissionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pTransmissionMode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pTransmissionMode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_TransmissionMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pTransmissionMode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pTransmissionMode: ?*TransmissionMode,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_RollOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pRollOff: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pRollOff: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RollOff: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pRollOff: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pRollOff: ?*RollOff,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Pilot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pPilot: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pPilot: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pilot: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator2,
                pPilot: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator2,
                pPilot: ?*Pilot,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_DigitalDemodulator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_GuardInterval(self: *const T, pGuardInterval: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_GuardInterval(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pGuardInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_GuardInterval(self: *const T, pGuardInterval: ?*GuardInterval) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_GuardInterval(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pGuardInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_TransmissionMode(self: *const T, pTransmissionMode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_TransmissionMode(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pTransmissionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_TransmissionMode(self: *const T, pTransmissionMode: ?*TransmissionMode) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_TransmissionMode(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pTransmissionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_RollOff(self: *const T, pRollOff: ?*RollOff) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_RollOff(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pRollOff);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_RollOff(self: *const T, pRollOff: ?*RollOff) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_RollOff(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pRollOff);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_put_Pilot(self: *const T, pPilot: ?*Pilot) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).put_Pilot(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pPilot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator2_get_Pilot(self: *const T, pPilot: ?*Pilot) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator2.VTable, @ptrCast(self.vtable)).get_Pilot(@as(*const IBDA_DigitalDemodulator2, @ptrCast(self)), pPilot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DigitalDemodulator3_Value = Guid.initString("13f19604-7d32-4359-93a2-a05205d90ac9");
pub const IID_IBDA_DigitalDemodulator3 = &IID_IBDA_DigitalDemodulator3_Value;
pub const IBDA_DigitalDemodulator3 = extern struct {
    pub const VTable = extern struct {
        base: IBDA_DigitalDemodulator2.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SignalTimeouts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator3,
                pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator3,
                pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SignalTimeouts: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator3,
                pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator3,
                pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PLPNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator3,
                pPLPNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator3,
                pPLPNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PLPNumber: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_DigitalDemodulator3,
                pPLPNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_DigitalDemodulator3,
                pPLPNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBDA_DigitalDemodulator2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_put_SignalTimeouts(self: *const T, pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).put_SignalTimeouts(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), pSignalTimeouts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_get_SignalTimeouts(self: *const T, pSignalTimeouts: ?*BDA_SIGNAL_TIMEOUTS) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).get_SignalTimeouts(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), pSignalTimeouts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_put_PLPNumber(self: *const T, pPLPNumber: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).put_PLPNumber(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), pPLPNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DigitalDemodulator3_get_PLPNumber(self: *const T, pPLPNumber: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DigitalDemodulator3.VTable, @ptrCast(self.vtable)).get_PLPNumber(@as(*const IBDA_DigitalDemodulator3, @ptrCast(self)), pPLPNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const KSPROPERTY_IPSINK = enum(i32) {
    MULTICASTLIST = 0,
    ADAPTER_DESCRIPTION = 1,
    ADAPTER_ADDRESS = 2,
    _,
    pub fn initFlags(o: struct {
        MULTICASTLIST: u1 = 0,
        ADAPTER_DESCRIPTION: u1 = 0,
        ADAPTER_ADDRESS: u1 = 0,
    }) KSPROPERTY_IPSINK {
        return @as(KSPROPERTY_IPSINK, @enumFromInt(
              (if (o.MULTICASTLIST == 1) @intFromEnum(KSPROPERTY_IPSINK.MULTICASTLIST) else 0)
            | (if (o.ADAPTER_DESCRIPTION == 1) @intFromEnum(KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION) else 0)
            | (if (o.ADAPTER_ADDRESS == 1) @intFromEnum(KSPROPERTY_IPSINK.ADAPTER_ADDRESS) else 0)
        ));
    }
};
pub const KSPROPERTY_IPSINK_MULTICASTLIST = KSPROPERTY_IPSINK.MULTICASTLIST;
pub const KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION = KSPROPERTY_IPSINK.ADAPTER_DESCRIPTION;
pub const KSPROPERTY_IPSINK_ADAPTER_ADDRESS = KSPROPERTY_IPSINK.ADAPTER_ADDRESS;

const IID_ICCSubStreamFiltering_Value = Guid.initString("4b2bd7ea-8347-467b-8dbf-62f784929cc3");
pub const IID_ICCSubStreamFiltering = &IID_ICCSubStreamFiltering_Value;
pub const ICCSubStreamFiltering = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SubstreamTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICCSubStreamFiltering,
                pTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICCSubStreamFiltering,
                pTypes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SubstreamTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ICCSubStreamFiltering,
                Types: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ICCSubStreamFiltering,
                Types: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICCSubStreamFiltering_get_SubstreamTypes(self: *const T, pTypes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICCSubStreamFiltering.VTable, @ptrCast(self.vtable)).get_SubstreamTypes(@as(*const ICCSubStreamFiltering, @ptrCast(self)), pTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICCSubStreamFiltering_put_SubstreamTypes(self: *const T, Types: i32) callconv(.Inline) HRESULT {
            return @as(*const ICCSubStreamFiltering.VTable, @ptrCast(self.vtable)).put_SubstreamTypes(@as(*const ICCSubStreamFiltering, @ptrCast(self)), Types);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkControl_Value = Guid.initString("3f4dc8e2-4050-11d3-8f4b-00c04f7971e2");
pub const IID_IBDA_IPSinkControl = &IID_IBDA_IPSinkControl_Value;
pub const IBDA_IPSinkControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPSinkControl,
                pulcbSize: ?*u32,
                pbBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPSinkControl,
                pulcbSize: ?*u32,
                pbBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAdapterIPAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPSinkControl,
                pulcbSize: ?*u32,
                pbBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPSinkControl,
                pulcbSize: ?*u32,
                pbBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkControl_GetMulticastList(self: *const T, pulcbSize: ?*u32, pbBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPSinkControl.VTable, @ptrCast(self.vtable)).GetMulticastList(@as(*const IBDA_IPSinkControl, @ptrCast(self)), pulcbSize, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkControl_GetAdapterIPAddress(self: *const T, pulcbSize: ?*u32, pbBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPSinkControl.VTable, @ptrCast(self.vtable)).GetAdapterIPAddress(@as(*const IBDA_IPSinkControl, @ptrCast(self)), pulcbSize, pbBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_IPSinkInfo_Value = Guid.initString("a750108f-492e-4d51-95f7-649b23ff7ad7");
pub const IID_IBDA_IPSinkInfo = &IID_IBDA_IPSinkInfo_Value;
pub const IBDA_IPSinkInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_MulticastList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_IPSinkInfo,
                pulcbAddresses: ?*u32,
                ppbAddressList: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_IPSinkInfo,
                pulcbAddresses: ?*u32,
                ppbAddressList: [*]?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterIPAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_IPSinkInfo,
                pbstrBuffer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_IPSinkInfo,
                pbstrBuffer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AdapterDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_IPSinkInfo,
                pbstrBuffer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_IPSinkInfo,
                pbstrBuffer: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_MulticastList(self: *const T, pulcbAddresses: ?*u32, ppbAddressList: [*]?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_MulticastList(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pulcbAddresses, ppbAddressList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_AdapterIPAddress(self: *const T, pbstrBuffer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_AdapterIPAddress(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pbstrBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_IPSinkInfo_get_AdapterDescription(self: *const T, pbstrBuffer: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_IPSinkInfo.VTable, @ptrCast(self.vtable)).get_AdapterDescription(@as(*const IBDA_IPSinkInfo, @ptrCast(self)), pbstrBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IEnumPIDMap_Value = Guid.initString("afb6c2a2-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IEnumPIDMap = &IID_IEnumPIDMap_Value;
pub const IEnumPIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPIDMap,
                cRequest: u32,
                pPIDMap: [*]PID_MAP,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPIDMap,
                cRequest: u32,
                pPIDMap: [*]PID_MAP,
                pcReceived: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Skip: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPIDMap,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPIDMap,
                cRecords: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IEnumPIDMap,
                ppIEnumPIDMap: ?*?*IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IEnumPIDMap,
                ppIEnumPIDMap: ?*?*IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Next(self: *const T, cRequest: u32, pPIDMap: [*]PID_MAP, pcReceived: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Next(@as(*const IEnumPIDMap, @ptrCast(self)), cRequest, pPIDMap, pcReceived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Skip(self: *const T, cRecords: u32) callconv(.Inline) HRESULT {
            return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Skip(@as(*const IEnumPIDMap, @ptrCast(self)), cRecords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Reset(@as(*const IEnumPIDMap, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPIDMap_Clone(self: *const T, ppIEnumPIDMap: ?*?*IEnumPIDMap) callconv(.Inline) HRESULT {
            return @as(*const IEnumPIDMap.VTable, @ptrCast(self.vtable)).Clone(@as(*const IEnumPIDMap, @ptrCast(self)), ppIEnumPIDMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IMPEG2PIDMap_Value = Guid.initString("afb6c2a1-2c41-11d3-8a60-0000f81e0e4a");
pub const IID_IMPEG2PIDMap = &IID_IMPEG2PIDMap_Value;
pub const IMPEG2PIDMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2PIDMap,
                culPID: u32,
                pulPID: ?*u32,
                MediaSampleContent: MEDIA_SAMPLE_CONTENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2PIDMap,
                culPID: u32,
                pulPID: ?*u32,
                MediaSampleContent: MEDIA_SAMPLE_CONTENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnmapPID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2PIDMap,
                culPID: u32,
                pulPID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2PIDMap,
                culPID: u32,
                pulPID: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumPIDMap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMPEG2PIDMap,
                pIEnumPIDMap: ?*?*IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMPEG2PIDMap,
                pIEnumPIDMap: ?*?*IEnumPIDMap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_MapPID(self: *const T, culPID: u32, pulPID: ?*u32, MediaSampleContent: MEDIA_SAMPLE_CONTENT) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).MapPID(@as(*const IMPEG2PIDMap, @ptrCast(self)), culPID, pulPID, MediaSampleContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_UnmapPID(self: *const T, culPID: u32, pulPID: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).UnmapPID(@as(*const IMPEG2PIDMap, @ptrCast(self)), culPID, pulPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMPEG2PIDMap_EnumPIDMap(self: *const T, pIEnumPIDMap: ?*?*IEnumPIDMap) callconv(.Inline) HRESULT {
            return @as(*const IMPEG2PIDMap.VTable, @ptrCast(self.vtable)).EnumPIDMap(@as(*const IMPEG2PIDMap, @ptrCast(self)), pIEnumPIDMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFrequencyMap_Value = Guid.initString("06fb45c1-693c-4ea7-b79f-7a6a54d8def2");
pub const IID_IFrequencyMap = &IID_IFrequencyMap_Value;
pub const IFrequencyMap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_FrequencyMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFrequencyMap,
                ulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFrequencyMap,
                ulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_FrequencyMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFrequencyMap,
                ulCount: u32,
                pList: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFrequencyMap,
                ulCount: u32,
                pList: [*]u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFrequencyMap,
                pulCountryCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFrequencyMap,
                pulCountryCode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CountryCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFrequencyMap,
                ulCountryCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFrequencyMap,
                ulCountryCode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DefaultFrequencyMapping: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFrequencyMap,
                ulCountryCode: u32,
                pulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFrequencyMap,
                ulCountryCode: u32,
                pulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_CountryCodeList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFrequencyMap,
                pulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFrequencyMap,
                pulCount: ?*u32,
                ppulList: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_FrequencyMapping(self: *const T, ulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_FrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ulCount, ppulList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_put_FrequencyMapping(self: *const T, ulCount: u32, pList: [*]u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).put_FrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ulCount, pList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_CountryCode(self: *const T, pulCountryCode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_CountryCode(@as(*const IFrequencyMap, @ptrCast(self)), pulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_put_CountryCode(self: *const T, ulCountryCode: u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).put_CountryCode(@as(*const IFrequencyMap, @ptrCast(self)), ulCountryCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_DefaultFrequencyMapping(self: *const T, ulCountryCode: u32, pulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_DefaultFrequencyMapping(@as(*const IFrequencyMap, @ptrCast(self)), ulCountryCode, pulCount, ppulList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFrequencyMap_get_CountryCodeList(self: *const T, pulCount: ?*u32, ppulList: ?*?*u32) callconv(.Inline) HRESULT {
            return @as(*const IFrequencyMap.VTable, @ptrCast(self.vtable)).get_CountryCodeList(@as(*const IFrequencyMap, @ptrCast(self)), pulCount, ppulList);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_EasMessage_Value = Guid.initString("d806973d-3ebe-46de-8fbb-6358fe784208");
pub const IID_IBDA_EasMessage = &IID_IBDA_EasMessage_Value;
pub const IBDA_EasMessage = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_EasMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EasMessage,
                ulEventID: u32,
                ppEASObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EasMessage,
                ulEventID: u32,
                ppEASObject: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EasMessage_get_EasMessage(self: *const T, ulEventID: u32, ppEASObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EasMessage.VTable, @ptrCast(self.vtable)).get_EasMessage(@as(*const IBDA_EasMessage, @ptrCast(self)), ulEventID, ppEASObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamInfo_Value = Guid.initString("8e882535-5f86-47ab-86cf-c281a72a0549");
pub const IID_IBDA_TransportStreamInfo = &IID_IBDA_TransportStreamInfo_Value;
pub const IBDA_TransportStreamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PatTableTickCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBDA_TransportStreamInfo,
                pPatTickCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBDA_TransportStreamInfo,
                pPatTickCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamInfo_get_PatTableTickCount(self: *const T, pPatTickCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_TransportStreamInfo.VTable, @ptrCast(self.vtable)).get_PatTableTickCount(@as(*const IBDA_TransportStreamInfo, @ptrCast(self)), pPatTickCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_ConditionalAccess_Value = Guid.initString("cd51f1e0-7be9-4123-8482-a2a796c0a6b0");
pub const IID_IBDA_ConditionalAccess = &IID_IBDA_ConditionalAccess_Value;
pub const IBDA_ConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_SmartCardStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                pCardStatus: ?*SmartCardStatusType,
                pCardAssociation: ?*SmartCardAssociationType,
                pbstrCardError: ?*?BSTR,
                pfOOBLocked: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                pCardStatus: ?*SmartCardStatusType,
                pCardAssociation: ?*SmartCardAssociationType,
                pbstrCardError: ?*?BSTR,
                pfOOBLocked: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SmartCardInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                pbstrCardName: ?*?BSTR,
                pbstrCardManufacturer: ?*?BSTR,
                pfDaylightSavings: ?*VARIANT_BOOL,
                pbyRatingRegion: ?*u8,
                plTimeZoneOffsetMinutes: ?*i32,
                pbstrLanguage: ?*?BSTR,
                pEALocationCode: ?*EALocationCodeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                pbstrCardName: ?*?BSTR,
                pbstrCardManufacturer: ?*?BSTR,
                pfDaylightSavings: ?*VARIANT_BOOL,
                pbyRatingRegion: ?*u8,
                plTimeZoneOffsetMinutes: ?*i32,
                pbstrLanguage: ?*?BSTR,
                pEALocationCode: ?*EALocationCodeType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_SmartCardApplications: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                pulcApplications: ?*u32,
                ulcApplicationsMax: u32,
                rgApplications: [*]SmartCardApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                pulcApplications: ?*u32,
                ulcApplicationsMax: u32,
                rgApplications: [*]SmartCardApplication,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Entitlement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                usVirtualChannel: u16,
                pEntitlement: ?*EntitlementType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                usVirtualChannel: u16,
                pEntitlement: ?*EntitlementType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TuneByChannel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                usVirtualChannel: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                usVirtualChannel: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveProgram: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                usProgramNumber: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModuleUI: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                byDialogNumber: u8,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                byDialogNumber: u8,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InformUIClosed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccess,
                byDialogNumber: u8,
                CloseReason: UICloseReasonType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccess,
                byDialogNumber: u8,
                CloseReason: UICloseReasonType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardStatus(self: *const T, pCardStatus: ?*SmartCardStatusType, pCardAssociation: ?*SmartCardAssociationType, pbstrCardError: ?*?BSTR, pfOOBLocked: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardStatus(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), pCardStatus, pCardAssociation, pbstrCardError, pfOOBLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardInfo(self: *const T, pbstrCardName: ?*?BSTR, pbstrCardManufacturer: ?*?BSTR, pfDaylightSavings: ?*VARIANT_BOOL, pbyRatingRegion: ?*u8, plTimeZoneOffsetMinutes: ?*i32, pbstrLanguage: ?*?BSTR, pEALocationCode: ?*EALocationCodeType) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardInfo(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), pbstrCardName, pbstrCardManufacturer, pfDaylightSavings, pbyRatingRegion, plTimeZoneOffsetMinutes, pbstrLanguage, pEALocationCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_SmartCardApplications(self: *const T, pulcApplications: ?*u32, ulcApplicationsMax: u32, rgApplications: [*]SmartCardApplication) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_SmartCardApplications(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), pulcApplications, ulcApplicationsMax, rgApplications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_get_Entitlement(self: *const T, usVirtualChannel: u16, pEntitlement: ?*EntitlementType) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).get_Entitlement(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), usVirtualChannel, pEntitlement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_TuneByChannel(self: *const T, usVirtualChannel: u16) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).TuneByChannel(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), usVirtualChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_SetProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).SetProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_AddProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).AddProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_RemoveProgram(self: *const T, usProgramNumber: u16) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).RemoveProgram(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), usProgramNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_GetModuleUI(self: *const T, byDialogNumber: u8, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).GetModuleUI(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), byDialogNumber, pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccess_InformUIClosed(self: *const T, byDialogNumber: u8, CloseReason: UICloseReasonType) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccess.VTable, @ptrCast(self.vtable)).InformUIClosed(@as(*const IBDA_ConditionalAccess, @ptrCast(self)), byDialogNumber, CloseReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DiagnosticProperties_Value = Guid.initString("20e80cb5-c543-4c1b-8eb3-49e719eee7d4");
pub const IID_IBDA_DiagnosticProperties = &IID_IBDA_DiagnosticProperties_Value;
pub const IBDA_DiagnosticProperties = extern struct {
    pub const VTable = extern struct {
        base: IPropertyBag.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPropertyBag.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IBDA_DRM_Value = Guid.initString("f98d88b0-1992-4cd6-a6d9-b9afab99330d");
pub const IID_IBDA_DRM = &IID_IBDA_DRM_Value;
pub const IBDA_DRM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDRMPairingStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRM,
                pdwStatus: ?*u32,
                phError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRM,
                pdwStatus: ?*u32,
                phError: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PerformDRMPairing: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRM,
                fSync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRM,
                fSync: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRM_GetDRMPairingStatus(self: *const T, pdwStatus: ?*u32, phError: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRM.VTable, @ptrCast(self.vtable)).GetDRMPairingStatus(@as(*const IBDA_DRM, @ptrCast(self)), pdwStatus, phError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRM_PerformDRMPairing(self: *const T, fSync: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRM.VTable, @ptrCast(self.vtable)).PerformDRMPairing(@as(*const IBDA_DRM, @ptrCast(self)), fSync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_NameValueService_Value = Guid.initString("7f0b3150-7b81-4ad4-98e3-7e9097094301");
pub const IID_IBDA_NameValueService = &IID_IBDA_NameValueService_Value;
pub const IBDA_NameValueService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValueNameByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NameValueService,
                ulIndex: u32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NameValueService,
                ulIndex: u32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NameValueService,
                bstrName: ?BSTR,
                bstrLanguage: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NameValueService,
                bstrName: ?BSTR,
                bstrLanguage: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_NameValueService,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
                ulReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_NameValueService,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                bstrName: ?BSTR,
                bstrValue: ?BSTR,
                ulReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_GetValueNameByIndex(self: *const T, ulIndex: u32, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).GetValueNameByIndex(@as(*const IBDA_NameValueService, @ptrCast(self)), ulIndex, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_GetValue(self: *const T, bstrName: ?BSTR, bstrLanguage: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).GetValue(@as(*const IBDA_NameValueService, @ptrCast(self)), bstrName, bstrLanguage, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_NameValueService_SetValue(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, bstrName: ?BSTR, bstrValue: ?BSTR, ulReserved: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_NameValueService.VTable, @ptrCast(self.vtable)).SetValue(@as(*const IBDA_NameValueService, @ptrCast(self)), ulDialogRequest, bstrLanguage, bstrName, bstrValue, ulReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ConditionalAccessEx_Value = Guid.initString("497c3418-23cb-44ba-bb62-769f506fcea7");
pub const IID_IBDA_ConditionalAccessEx = &IID_IBDA_ConditionalAccessEx_Value;
pub const IBDA_ConditionalAccessEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckEntitlementToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                RequestType: BDA_CONDITIONALACCESS_REQUESTTYPE,
                ulcbEntitlementTokenLen: u32,
                pbEntitlementToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                RequestType: BDA_CONDITIONALACCESS_REQUESTTYPE,
                ulcbEntitlementTokenLen: u32,
                pbEntitlementToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCaptureToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccessEx,
                ulcbCaptureTokenLen: u32,
                pbCaptureToken: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccessEx,
                ulcbCaptureTokenLen: u32,
                pbCaptureToken: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenBroadcastMmi: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                EventId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseMmiDialog: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                ulDialogNumber: u32,
                ReasonCode: BDA_CONDITIONALACCESS_MMICLOSEREASON,
                pulSessionResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccessEx,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                ulDialogNumber: u32,
                ReasonCode: BDA_CONDITIONALACCESS_MMICLOSEREASON,
                pulSessionResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDialogRequestNumber: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ConditionalAccessEx,
                pulDialogRequestNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ConditionalAccessEx,
                pulDialogRequestNumber: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CheckEntitlementToken(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, RequestType: BDA_CONDITIONALACCESS_REQUESTTYPE, ulcbEntitlementTokenLen: u32, pbEntitlementToken: [*:0]u8, pulDescrambleStatus: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CheckEntitlementToken(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ulDialogRequest, bstrLanguage, RequestType, ulcbEntitlementTokenLen, pbEntitlementToken, pulDescrambleStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_SetCaptureToken(self: *const T, ulcbCaptureTokenLen: u32, pbCaptureToken: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).SetCaptureToken(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ulcbCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_OpenBroadcastMmi(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, EventId: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).OpenBroadcastMmi(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ulDialogRequest, bstrLanguage, EventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CloseMmiDialog(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, ulDialogNumber: u32, ReasonCode: BDA_CONDITIONALACCESS_MMICLOSEREASON, pulSessionResult: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CloseMmiDialog(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), ulDialogRequest, bstrLanguage, ulDialogNumber, ReasonCode, pulSessionResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ConditionalAccessEx_CreateDialogRequestNumber(self: *const T, pulDialogRequestNumber: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ConditionalAccessEx.VTable, @ptrCast(self.vtable)).CreateDialogRequestNumber(@as(*const IBDA_ConditionalAccessEx, @ptrCast(self)), pulDialogRequestNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_ISDBConditionalAccess_Value = Guid.initString("5e68c627-16c2-4e6c-b1e2-d00170cdaa0f");
pub const IID_IBDA_ISDBConditionalAccess = &IID_IBDA_ISDBConditionalAccess_Value;
pub const IBDA_ISDBConditionalAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIsdbCasRequest: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_ISDBConditionalAccess,
                ulRequestId: u32,
                ulcbRequestBufferLen: u32,
                pbRequestBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_ISDBConditionalAccess,
                ulRequestId: u32,
                ulcbRequestBufferLen: u32,
                pbRequestBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_ISDBConditionalAccess_SetIsdbCasRequest(self: *const T, ulRequestId: u32, ulcbRequestBufferLen: u32, pbRequestBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_ISDBConditionalAccess.VTable, @ptrCast(self.vtable)).SetIsdbCasRequest(@as(*const IBDA_ISDBConditionalAccess, @ptrCast(self)), ulRequestId, ulcbRequestBufferLen, pbRequestBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_EventingService_Value = Guid.initString("207c413f-00dc-4c61-bad6-6fee1ff07064");
pub const IID_IBDA_EventingService = &IID_IBDA_EventingService_Value;
pub const IBDA_EventingService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompleteEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_EventingService,
                ulEventID: u32,
                ulEventResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_EventingService,
                ulEventID: u32,
                ulEventResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_EventingService_CompleteEvent(self: *const T, ulEventID: u32, ulEventResult: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_EventingService.VTable, @ptrCast(self.vtable)).CompleteEvent(@as(*const IBDA_EventingService, @ptrCast(self)), ulEventID, ulEventResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_AUX_Value = Guid.initString("7def4c09-6e66-4567-a819-f0e17f4a81ab");
pub const IID_IBDA_AUX = &IID_IBDA_AUX_Value;
pub const IBDA_AUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AUX,
                pdwNumAuxInputsBSTR: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AUX,
                pdwNumAuxInputsBSTR: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_AUX,
                dwIndex: u32,
                dwInputID: ?*u32,
                pConnectorType: ?*Guid,
                ConnTypeNum: ?*u32,
                NumVideoStds: ?*u32,
                AnalogStds: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_AUX,
                dwIndex: u32,
                dwInputID: ?*u32,
                pConnectorType: ?*Guid,
                ConnTypeNum: ?*u32,
                NumVideoStds: ?*u32,
                AnalogStds: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AUX_QueryCapabilities(self: *const T, pdwNumAuxInputsBSTR: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AUX.VTable, @ptrCast(self.vtable)).QueryCapabilities(@as(*const IBDA_AUX, @ptrCast(self)), pdwNumAuxInputsBSTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_AUX_EnumCapability(self: *const T, dwIndex: u32, dwInputID: ?*u32, pConnectorType: ?*Guid, ConnTypeNum: ?*u32, NumVideoStds: ?*u32, AnalogStds: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const IBDA_AUX.VTable, @ptrCast(self.vtable)).EnumCapability(@as(*const IBDA_AUX, @ptrCast(self)), dwIndex, dwInputID, pConnectorType, ConnTypeNum, NumVideoStds, AnalogStds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_Encoder_Value = Guid.initString("3a8bad59-59fe-4559-a0ba-396cfaa98ae3");
pub const IID_IBDA_Encoder = &IID_IBDA_Encoder_Value;
pub const IBDA_Encoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryCapabilities: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Encoder,
                NumAudioFmts: ?*u32,
                NumVideoFmts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Encoder,
                NumAudioFmts: ?*u32,
                NumVideoFmts: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumAudioCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Encoder,
                FmtIndex: u32,
                MethodID: ?*u32,
                AlgorithmType: ?*u32,
                SamplingRate: ?*u32,
                BitDepth: ?*u32,
                NumChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Encoder,
                FmtIndex: u32,
                MethodID: ?*u32,
                AlgorithmType: ?*u32,
                SamplingRate: ?*u32,
                BitDepth: ?*u32,
                NumChannels: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumVideoCapability: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Encoder,
                FmtIndex: u32,
                MethodID: ?*u32,
                AlgorithmType: ?*u32,
                VerticalSize: ?*u32,
                HorizontalSize: ?*u32,
                AspectRatio: ?*u32,
                FrameRateCode: ?*u32,
                ProgressiveSequence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Encoder,
                FmtIndex: u32,
                MethodID: ?*u32,
                AlgorithmType: ?*u32,
                VerticalSize: ?*u32,
                HorizontalSize: ?*u32,
                AspectRatio: ?*u32,
                FrameRateCode: ?*u32,
                ProgressiveSequence: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Encoder,
                AudioBitrateMode: u32,
                AudioBitrate: u32,
                AudioMethodID: u32,
                AudioProgram: u32,
                VideoBitrateMode: u32,
                VideoBitrate: u32,
                VideoMethodID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Encoder,
                AudioBitrateMode: u32,
                AudioBitrate: u32,
                AudioMethodID: u32,
                AudioProgram: u32,
                VideoBitrateMode: u32,
                VideoBitrate: u32,
                VideoMethodID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_Encoder,
                AudioBitrateMax: ?*u32,
                AudioBitrateMin: ?*u32,
                AudioBitrateMode: ?*u32,
                AudioBitrateStepping: ?*u32,
                AudioBitrate: ?*u32,
                AudioMethodID: ?*u32,
                AvailableAudioPrograms: ?*u32,
                AudioProgram: ?*u32,
                VideoBitrateMax: ?*u32,
                VideoBitrateMin: ?*u32,
                VideoBitrateMode: ?*u32,
                VideoBitrate: ?*u32,
                VideoBitrateStepping: ?*u32,
                VideoMethodID: ?*u32,
                SignalSourceID: ?*u32,
                SignalFormat: ?*u64,
                SignalLock: ?*BOOL,
                SignalLevel: ?*i32,
                SignalToNoiseRatio: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_Encoder,
                AudioBitrateMax: ?*u32,
                AudioBitrateMin: ?*u32,
                AudioBitrateMode: ?*u32,
                AudioBitrateStepping: ?*u32,
                AudioBitrate: ?*u32,
                AudioMethodID: ?*u32,
                AvailableAudioPrograms: ?*u32,
                AudioProgram: ?*u32,
                VideoBitrateMax: ?*u32,
                VideoBitrateMin: ?*u32,
                VideoBitrateMode: ?*u32,
                VideoBitrate: ?*u32,
                VideoBitrateStepping: ?*u32,
                VideoMethodID: ?*u32,
                SignalSourceID: ?*u32,
                SignalFormat: ?*u64,
                SignalLock: ?*BOOL,
                SignalLevel: ?*i32,
                SignalToNoiseRatio: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_QueryCapabilities(self: *const T, NumAudioFmts: ?*u32, NumVideoFmts: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).QueryCapabilities(@as(*const IBDA_Encoder, @ptrCast(self)), NumAudioFmts, NumVideoFmts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_EnumAudioCapability(self: *const T, FmtIndex: u32, MethodID: ?*u32, AlgorithmType: ?*u32, SamplingRate: ?*u32, BitDepth: ?*u32, NumChannels: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).EnumAudioCapability(@as(*const IBDA_Encoder, @ptrCast(self)), FmtIndex, MethodID, AlgorithmType, SamplingRate, BitDepth, NumChannels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_EnumVideoCapability(self: *const T, FmtIndex: u32, MethodID: ?*u32, AlgorithmType: ?*u32, VerticalSize: ?*u32, HorizontalSize: ?*u32, AspectRatio: ?*u32, FrameRateCode: ?*u32, ProgressiveSequence: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).EnumVideoCapability(@as(*const IBDA_Encoder, @ptrCast(self)), FmtIndex, MethodID, AlgorithmType, VerticalSize, HorizontalSize, AspectRatio, FrameRateCode, ProgressiveSequence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_SetParameters(self: *const T, AudioBitrateMode: u32, AudioBitrate: u32, AudioMethodID: u32, AudioProgram: u32, VideoBitrateMode: u32, VideoBitrate: u32, VideoMethodID: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).SetParameters(@as(*const IBDA_Encoder, @ptrCast(self)), AudioBitrateMode, AudioBitrate, AudioMethodID, AudioProgram, VideoBitrateMode, VideoBitrate, VideoMethodID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_Encoder_GetState(self: *const T, AudioBitrateMax: ?*u32, AudioBitrateMin: ?*u32, AudioBitrateMode: ?*u32, AudioBitrateStepping: ?*u32, AudioBitrate: ?*u32, AudioMethodID: ?*u32, AvailableAudioPrograms: ?*u32, AudioProgram: ?*u32, VideoBitrateMax: ?*u32, VideoBitrateMin: ?*u32, VideoBitrateMode: ?*u32, VideoBitrate: ?*u32, VideoBitrateStepping: ?*u32, VideoMethodID: ?*u32, SignalSourceID: ?*u32, SignalFormat: ?*u64, SignalLock: ?*BOOL, SignalLevel: ?*i32, SignalToNoiseRatio: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_Encoder.VTable, @ptrCast(self.vtable)).GetState(@as(*const IBDA_Encoder, @ptrCast(self)), AudioBitrateMax, AudioBitrateMin, AudioBitrateMode, AudioBitrateStepping, AudioBitrate, AudioMethodID, AvailableAudioPrograms, AudioProgram, VideoBitrateMax, VideoBitrateMin, VideoBitrateMode, VideoBitrate, VideoBitrateStepping, VideoMethodID, SignalSourceID, SignalFormat, SignalLock, SignalLevel, SignalToNoiseRatio);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_FDC_Value = Guid.initString("138adc7e-58ae-437f-b0b4-c9fe19d5b4ac");
pub const IID_IBDA_FDC = &IID_IBDA_FDC_Value;
pub const IBDA_FDC = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                CurrentBitrate: ?*u32,
                CarrierLock: ?*BOOL,
                CurrentFrequency: ?*u32,
                CurrentSpectrumInversion: ?*BOOL,
                CurrentPIDList: ?*?BSTR,
                CurrentTIDList: ?*?BSTR,
                Overflow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                CurrentBitrate: ?*u32,
                CarrierLock: ?*BOOL,
                CurrentFrequency: ?*u32,
                CurrentSpectrumInversion: ?*BOOL,
                CurrentPIDList: ?*?BSTR,
                CurrentTIDList: ?*?BSTR,
                Overflow: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestTables: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                TableIDs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                TableIDs: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                PidsToAdd: ?BSTR,
                RemainingFilterEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                PidsToAdd: ?BSTR,
                RemainingFilterEntries: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemovePid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                PidsToRemove: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                PidsToRemove: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddTid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                TidsToAdd: ?BSTR,
                CurrentTidList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                TidsToAdd: ?BSTR,
                CurrentTidList: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RemoveTid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                TidsToRemove: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                TidsToRemove: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTableSection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_FDC,
                Pid: ?*u32,
                MaxBufferSize: u32,
                ActualSize: ?*u32,
                SecBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_FDC,
                Pid: ?*u32,
                MaxBufferSize: u32,
                ActualSize: ?*u32,
                SecBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_GetStatus(self: *const T, CurrentBitrate: ?*u32, CarrierLock: ?*BOOL, CurrentFrequency: ?*u32, CurrentSpectrumInversion: ?*BOOL, CurrentPIDList: ?*?BSTR, CurrentTIDList: ?*?BSTR, Overflow: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IBDA_FDC, @ptrCast(self)), CurrentBitrate, CarrierLock, CurrentFrequency, CurrentSpectrumInversion, CurrentPIDList, CurrentTIDList, Overflow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RequestTables(self: *const T, TableIDs: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RequestTables(@as(*const IBDA_FDC, @ptrCast(self)), TableIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_AddPid(self: *const T, PidsToAdd: ?BSTR, RemainingFilterEntries: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).AddPid(@as(*const IBDA_FDC, @ptrCast(self)), PidsToAdd, RemainingFilterEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RemovePid(self: *const T, PidsToRemove: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RemovePid(@as(*const IBDA_FDC, @ptrCast(self)), PidsToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_AddTid(self: *const T, TidsToAdd: ?BSTR, CurrentTidList: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).AddTid(@as(*const IBDA_FDC, @ptrCast(self)), TidsToAdd, CurrentTidList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_RemoveTid(self: *const T, TidsToRemove: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).RemoveTid(@as(*const IBDA_FDC, @ptrCast(self)), TidsToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_FDC_GetTableSection(self: *const T, Pid: ?*u32, MaxBufferSize: u32, ActualSize: ?*u32, SecBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_FDC.VTable, @ptrCast(self.vtable)).GetTableSection(@as(*const IBDA_FDC, @ptrCast(self)), Pid, MaxBufferSize, ActualSize, SecBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_GuideDataDeliveryService_Value = Guid.initString("c0afcb73-23e7-4bc6-bafa-fdc167b4719f");
pub const IID_IBDA_GuideDataDeliveryService = &IID_IBDA_GuideDataDeliveryService_Value;
pub const IBDA_GuideDataDeliveryService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGuideDataType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
                pguidDataType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
                pguidDataType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetGuideData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
                pulcbBufferLen: ?*u32,
                pbBuffer: ?*u8,
                pulGuideDataPercentageProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
                pulcbBufferLen: ?*u32,
                pbBuffer: ?*u8,
                pulGuideDataPercentageProgress: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestGuideDataUpdate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTuneXmlFromServiceIdx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
                ul64ServiceIdx: u64,
                pbstrTuneXml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
                ul64ServiceIdx: u64,
                pbstrTuneXml: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServices: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
                pulcbBufferLen: ?*u32,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
                pulcbBufferLen: ?*u32,
                pbBuffer: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceInfoFromTuneXml: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_GuideDataDeliveryService,
                bstrTuneXml: ?BSTR,
                pbstrServiceDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_GuideDataDeliveryService,
                bstrTuneXml: ?BSTR,
                pbstrServiceDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetGuideDataType(self: *const T, pguidDataType: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetGuideDataType(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pguidDataType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetGuideData(self: *const T, pulcbBufferLen: ?*u32, pbBuffer: ?*u8, pulGuideDataPercentageProgress: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetGuideData(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pulcbBufferLen, pbBuffer, pulGuideDataPercentageProgress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_RequestGuideDataUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).RequestGuideDataUpdate(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetTuneXmlFromServiceIdx(self: *const T, ul64ServiceIdx: u64, pbstrTuneXml: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetTuneXmlFromServiceIdx(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), ul64ServiceIdx, pbstrTuneXml);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetServices(self: *const T, pulcbBufferLen: ?*u32, pbBuffer: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetServices(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), pulcbBufferLen, pbBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_GuideDataDeliveryService_GetServiceInfoFromTuneXml(self: *const T, bstrTuneXml: ?BSTR, pbstrServiceDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_GuideDataDeliveryService.VTable, @ptrCast(self.vtable)).GetServiceInfoFromTuneXml(@as(*const IBDA_GuideDataDeliveryService, @ptrCast(self)), bstrTuneXml, pbstrServiceDescription);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRMService_Value = Guid.initString("bff6b5bb-b0ae-484c-9dca-73528fb0b46e");
pub const IID_IBDA_DRMService = &IID_IBDA_DRMService_Value;
pub const IBDA_DRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRMService,
                puuidNewDrm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRMService,
                puuidNewDrm: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDRMStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRMService,
                pbstrDrmUuidList: ?*?BSTR,
                DrmUuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRMService,
                pbstrDrmUuidList: ?*?BSTR,
                DrmUuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRMService_SetDRM(self: *const T, puuidNewDrm: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRMService.VTable, @ptrCast(self.vtable)).SetDRM(@as(*const IBDA_DRMService, @ptrCast(self)), puuidNewDrm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRMService_GetDRMStatus(self: *const T, pbstrDrmUuidList: ?*?BSTR, DrmUuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRMService.VTable, @ptrCast(self.vtable)).GetDRMStatus(@as(*const IBDA_DRMService, @ptrCast(self)), pbstrDrmUuidList, DrmUuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMSession_Value = Guid.initString("4be6fa3d-07cd-4139-8b80-8c18ba3aec88");
pub const IID_IBDA_WMDRMSession = &IID_IBDA_WMDRMSession_Value;
pub const IBDA_WMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                MaxCaptureToken: ?*u32,
                MaxStreamingPid: ?*u32,
                MaxLicense: ?*u32,
                MinSecurityLevel: ?*u32,
                RevInfoSequenceNumber: ?*u32,
                RevInfoIssuedTime: ?*u64,
                RevInfoTTL: ?*u32,
                RevListVersion: ?*u32,
                ulState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                MaxCaptureToken: ?*u32,
                MaxStreamingPid: ?*u32,
                MaxLicense: ?*u32,
                MinSecurityLevel: ?*u32,
                RevInfoSequenceNumber: ?*u32,
                RevInfoIssuedTime: ?*u64,
                RevInfoTTL: ?*u32,
                RevListVersion: ?*u32,
                ulState: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRevInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                ulRevInfoLen: u32,
                pbRevInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                ulRevInfoLen: u32,
                pbRevInfo: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                ulCrlLen: u32,
                pbCrlLen: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                ulCrlLen: u32,
                pbCrlLen: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TransactMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                ulcbRequest: u32,
                pbRequest: [*:0]u8,
                pulcbResponse: ?*u32,
                pbResponse: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                ulcbRequest: u32,
                pbRequest: [*:0]u8,
                pulcbResponse: ?*u32,
                pbResponse: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                uuidKey: ?*Guid,
                pulPackageLen: ?*u32,
                pbPackage: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                uuidKey: ?*Guid,
                pulPackageLen: ?*u32,
                pbPackage: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReissueLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenewLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                ulInXmrLicenseLen: u32,
                pbInXmrLicense: [*:0]u8,
                ulEntitlementTokenLen: u32,
                pbEntitlementToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
                pulOutXmrLicenseLen: ?*u32,
                pbOutXmrLicense: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                ulInXmrLicenseLen: u32,
                pbInXmrLicense: [*:0]u8,
                ulEntitlementTokenLen: u32,
                pbEntitlementToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
                pulOutXmrLicenseLen: ?*u32,
                pbOutXmrLicense: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetKeyInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMSession,
                pulKeyInfoLen: ?*u32,
                pbKeyInfo: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMSession,
                pulKeyInfoLen: ?*u32,
                pbKeyInfo: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetStatus(self: *const T, MaxCaptureToken: ?*u32, MaxStreamingPid: ?*u32, MaxLicense: ?*u32, MinSecurityLevel: ?*u32, RevInfoSequenceNumber: ?*u32, RevInfoIssuedTime: ?*u64, RevInfoTTL: ?*u32, RevListVersion: ?*u32, ulState: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IBDA_WMDRMSession, @ptrCast(self)), MaxCaptureToken, MaxStreamingPid, MaxLicense, MinSecurityLevel, RevInfoSequenceNumber, RevInfoIssuedTime, RevInfoTTL, RevListVersion, ulState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_SetRevInfo(self: *const T, ulRevInfoLen: u32, pbRevInfo: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).SetRevInfo(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ulRevInfoLen, pbRevInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_SetCrl(self: *const T, ulCrlLen: u32, pbCrlLen: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).SetCrl(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ulCrlLen, pbCrlLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_TransactMessage(self: *const T, ulcbRequest: u32, pbRequest: [*:0]u8, pulcbResponse: ?*u32, pbResponse: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).TransactMessage(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ulcbRequest, pbRequest, pulcbResponse, pbResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetLicense(self: *const T, uuidKey: ?*Guid, pulPackageLen: ?*u32, pbPackage: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), uuidKey, pulPackageLen, pbPackage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_ReissueLicense(self: *const T, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).ReissueLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_RenewLicense(self: *const T, ulInXmrLicenseLen: u32, pbInXmrLicense: [*:0]u8, ulEntitlementTokenLen: u32, pbEntitlementToken: [*:0]u8, pulDescrambleStatus: ?*u32, pulOutXmrLicenseLen: ?*u32, pbOutXmrLicense: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).RenewLicense(@as(*const IBDA_WMDRMSession, @ptrCast(self)), ulInXmrLicenseLen, pbInXmrLicense, ulEntitlementTokenLen, pbEntitlementToken, pulDescrambleStatus, pulOutXmrLicenseLen, pbOutXmrLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMSession_GetKeyInfo(self: *const T, pulKeyInfoLen: ?*u32, pbKeyInfo: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMSession.VTable, @ptrCast(self.vtable)).GetKeyInfo(@as(*const IBDA_WMDRMSession, @ptrCast(self)), pulKeyInfoLen, pbKeyInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_WMDRMTuner_Value = Guid.initString("86d979cf-a8a7-4f94-b5fb-14c0aca68fe6");
pub const IID_IBDA_WMDRMTuner = &IID_IBDA_WMDRMTuner_Value;
pub const IBDA_WMDRMTuner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PurchaseEntitlement: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                ulPurchaseTokenLen: u32,
                pbPurchaseToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
                pulCaptureTokenLen: ?*u32,
                pbCaptureToken: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                ulDialogRequest: u32,
                bstrLanguage: ?BSTR,
                ulPurchaseTokenLen: u32,
                pbPurchaseToken: [*:0]u8,
                pulDescrambleStatus: ?*u32,
                pulCaptureTokenLen: ?*u32,
                pbCaptureToken: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelCaptureToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                ulCaptureTokenLen: u32,
                pbCaptureToken: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                ulCaptureTokenLen: u32,
                pbCaptureToken: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPidProtection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                ulPid: u32,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                ulPid: u32,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPidProtection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                pulPid: u32,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                pulPid: u32,
                uuidKey: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                ulSyncValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                ulSyncValue: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStartCodeProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_WMDRMTuner,
                pulStartCodeProfileLen: ?*u32,
                pbStartCodeProfile: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_WMDRMTuner,
                pulStartCodeProfileLen: ?*u32,
                pbStartCodeProfile: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_PurchaseEntitlement(self: *const T, ulDialogRequest: u32, bstrLanguage: ?BSTR, ulPurchaseTokenLen: u32, pbPurchaseToken: [*:0]u8, pulDescrambleStatus: ?*u32, pulCaptureTokenLen: ?*u32, pbCaptureToken: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).PurchaseEntitlement(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ulDialogRequest, bstrLanguage, ulPurchaseTokenLen, pbPurchaseToken, pulDescrambleStatus, pulCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_CancelCaptureToken(self: *const T, ulCaptureTokenLen: u32, pbCaptureToken: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).CancelCaptureToken(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ulCaptureTokenLen, pbCaptureToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_SetPidProtection(self: *const T, ulPid: u32, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).SetPidProtection(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ulPid, uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_GetPidProtection(self: *const T, pulPid: u32, uuidKey: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).GetPidProtection(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), pulPid, uuidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_SetSyncValue(self: *const T, ulSyncValue: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).SetSyncValue(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), ulSyncValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_WMDRMTuner_GetStartCodeProfile(self: *const T, pulStartCodeProfileLen: ?*u32, pbStartCodeProfile: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_WMDRMTuner.VTable, @ptrCast(self.vtable)).GetStartCodeProfile(@as(*const IBDA_WMDRMTuner, @ptrCast(self)), pulStartCodeProfileLen, pbStartCodeProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_DRIDRMService_Value = Guid.initString("1f9bc2a5-44a3-4c52-aab1-0bbce5a1381d");
pub const IID_IBDA_DRIDRMService = &IID_IBDA_DRIDRMService_Value;
pub const IBDA_DRIDRMService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDRM: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIDRMService,
                bstrNewDrm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIDRMService,
                bstrNewDrm: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDRMStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIDRMService,
                pbstrDrmUuidList: ?*?BSTR,
                DrmUuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIDRMService,
                pbstrDrmUuidList: ?*?BSTR,
                DrmUuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPairingStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIDRMService,
                penumPairingStatus: ?*BDA_DrmPairingError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIDRMService,
                penumPairingStatus: ?*BDA_DrmPairingError,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_SetDRM(self: *const T, bstrNewDrm: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).SetDRM(@as(*const IBDA_DRIDRMService, @ptrCast(self)), bstrNewDrm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_GetDRMStatus(self: *const T, pbstrDrmUuidList: ?*?BSTR, DrmUuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).GetDRMStatus(@as(*const IBDA_DRIDRMService, @ptrCast(self)), pbstrDrmUuidList, DrmUuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIDRMService_GetPairingStatus(self: *const T, penumPairingStatus: ?*BDA_DrmPairingError) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIDRMService.VTable, @ptrCast(self.vtable)).GetPairingStatus(@as(*const IBDA_DRIDRMService, @ptrCast(self)), penumPairingStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_DRIWMDRMSession_Value = Guid.initString("05c690f8-56db-4bb2-b053-79c12098bb26");
pub const IID_IBDA_DRIWMDRMSession = &IID_IBDA_DRIWMDRMSession_Value;
pub const IBDA_DRIWMDRMSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcknowledgeLicense: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                hrLicenseAck: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                hrLicenseAck: HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessLicenseChallenge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                dwcbLicenseMessage: u32,
                pbLicenseMessage: [*:0]u8,
                pdwcbLicenseResponse: ?*u32,
                ppbLicenseResponse: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                dwcbLicenseMessage: u32,
                pbLicenseMessage: [*:0]u8,
                pdwcbLicenseResponse: ?*u32,
                ppbLicenseResponse: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProcessRegistrationChallenge: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                dwcbRegistrationMessage: u32,
                pbRegistrationMessage: [*:0]u8,
                pdwcbRegistrationResponse: ?*u32,
                ppbRegistrationResponse: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                dwcbRegistrationMessage: u32,
                pbRegistrationMessage: [*:0]u8,
                pdwcbRegistrationResponse: ?*u32,
                ppbRegistrationResponse: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRevInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                dwRevInfoLen: u32,
                pbRevInfo: [*:0]u8,
                pdwResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                dwRevInfoLen: u32,
                pbRevInfo: [*:0]u8,
                pdwResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCrl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                dwCrlLen: u32,
                pbCrlLen: [*:0]u8,
                pdwResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                dwCrlLen: u32,
                pbCrlLen: [*:0]u8,
                pdwResponse: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHMSAssociationData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLastCardeaError: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_DRIWMDRMSession,
                pdwError: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_DRIWMDRMSession,
                pdwError: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_AcknowledgeLicense(self: *const T, hrLicenseAck: HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).AcknowledgeLicense(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), hrLicenseAck);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_ProcessLicenseChallenge(self: *const T, dwcbLicenseMessage: u32, pbLicenseMessage: [*:0]u8, pdwcbLicenseResponse: ?*u32, ppbLicenseResponse: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).ProcessLicenseChallenge(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwcbLicenseMessage, pbLicenseMessage, pdwcbLicenseResponse, ppbLicenseResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_ProcessRegistrationChallenge(self: *const T, dwcbRegistrationMessage: u32, pbRegistrationMessage: [*:0]u8, pdwcbRegistrationResponse: ?*u32, ppbRegistrationResponse: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).ProcessRegistrationChallenge(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwcbRegistrationMessage, pbRegistrationMessage, pdwcbRegistrationResponse, ppbRegistrationResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_SetRevInfo(self: *const T, dwRevInfoLen: u32, pbRevInfo: [*:0]u8, pdwResponse: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).SetRevInfo(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwRevInfoLen, pbRevInfo, pdwResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_SetCrl(self: *const T, dwCrlLen: u32, pbCrlLen: [*:0]u8, pdwResponse: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).SetCrl(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), dwCrlLen, pbCrlLen, pdwResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_GetHMSAssociationData(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).GetHMSAssociationData(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_DRIWMDRMSession_GetLastCardeaError(self: *const T, pdwError: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_DRIWMDRMSession.VTable, @ptrCast(self.vtable)).GetLastCardeaError(@as(*const IBDA_DRIWMDRMSession, @ptrCast(self)), pdwError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_MUX_Value = Guid.initString("942aafec-4c05-4c74-b8eb-8706c2a4943f");
pub const IID_IBDA_MUX = &IID_IBDA_MUX_Value;
pub const IBDA_MUX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPidList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_MUX,
                ulPidListCount: u32,
                pbPidListBuffer: [*]BDA_MUX_PIDLISTITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_MUX,
                ulPidListCount: u32,
                pbPidListBuffer: [*]BDA_MUX_PIDLISTITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPidList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_MUX,
                pulPidListCount: ?*u32,
                pbPidListBuffer: ?*BDA_MUX_PIDLISTITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_MUX,
                pulPidListCount: ?*u32,
                pbPidListBuffer: ?*BDA_MUX_PIDLISTITEM,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_MUX_SetPidList(self: *const T, ulPidListCount: u32, pbPidListBuffer: [*]BDA_MUX_PIDLISTITEM) callconv(.Inline) HRESULT {
            return @as(*const IBDA_MUX.VTable, @ptrCast(self.vtable)).SetPidList(@as(*const IBDA_MUX, @ptrCast(self)), ulPidListCount, pbPidListBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_MUX_GetPidList(self: *const T, pulPidListCount: ?*u32, pbPidListBuffer: ?*BDA_MUX_PIDLISTITEM) callconv(.Inline) HRESULT {
            return @as(*const IBDA_MUX.VTable, @ptrCast(self.vtable)).GetPidList(@as(*const IBDA_MUX, @ptrCast(self)), pulPidListCount, pbPidListBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBDA_TransportStreamSelector_Value = Guid.initString("1dcfafe9-b45e-41b3-bb2a-561eb129ae98");
pub const IID_IBDA_TransportStreamSelector = &IID_IBDA_TransportStreamSelector_Value;
pub const IBDA_TransportStreamSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTSID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_TransportStreamSelector,
                usTSID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_TransportStreamSelector,
                usTSID: u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTSInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_TransportStreamSelector,
                pulTSInformationBufferLen: ?*u32,
                pbTSInformationBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_TransportStreamSelector,
                pulTSInformationBufferLen: ?*u32,
                pbTSInformationBuffer: [*:0]u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamSelector_SetTSID(self: *const T, usTSID: u16) callconv(.Inline) HRESULT {
            return @as(*const IBDA_TransportStreamSelector.VTable, @ptrCast(self.vtable)).SetTSID(@as(*const IBDA_TransportStreamSelector, @ptrCast(self)), usTSID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_TransportStreamSelector_GetTSInformation(self: *const T, pulTSInformationBufferLen: ?*u32, pbTSInformationBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @as(*const IBDA_TransportStreamSelector.VTable, @ptrCast(self.vtable)).GetTSInformation(@as(*const IBDA_TransportStreamSelector, @ptrCast(self)), pulTSInformationBufferLen, pbTSInformationBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IBDA_UserActivityService_Value = Guid.initString("53b14189-e478-4b7a-a1ff-506db4b99dfe");
pub const IID_IBDA_UserActivityService = &IID_IBDA_UserActivityService_Value;
pub const IBDA_UserActivityService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCurrentTunerUseReason: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_UserActivityService,
                dwUseReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_UserActivityService,
                dwUseReason: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUserActivityInterval: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_UserActivityService,
                pdwActivityInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_UserActivityService,
                pdwActivityInterval: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UserActivityDetected: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBDA_UserActivityService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBDA_UserActivityService,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_SetCurrentTunerUseReason(self: *const T, dwUseReason: u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).SetCurrentTunerUseReason(@as(*const IBDA_UserActivityService, @ptrCast(self)), dwUseReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_GetUserActivityInterval(self: *const T, pdwActivityInterval: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).GetUserActivityInterval(@as(*const IBDA_UserActivityService, @ptrCast(self)), pdwActivityInterval);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBDA_UserActivityService_UserActivityDetected(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBDA_UserActivityService.VTable, @ptrCast(self.vtable)).UserActivityDetected(@as(*const IBDA_UserActivityService, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvent_Value = Guid.initString("1f0e5357-af43-44e6-8547-654c645145d2");
pub const IID_IESEvent = &IID_IESEvent_Value;
pub const IESEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvent,
                pdwEventId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvent,
                pdwEventId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEventType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvent,
                pguidEventType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvent,
                pguidEventType: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCompletionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvent,
                dwResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvent,
                dwResult: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvent,
                pbData: ?*?*SAFEARRAY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStringData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvent,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvent,
                pbstrData: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetEventId(self: *const T, pdwEventId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetEventId(@as(*const IESEvent, @ptrCast(self)), pdwEventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetEventType(self: *const T, pguidEventType: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetEventType(@as(*const IESEvent, @ptrCast(self)), pguidEventType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_SetCompletionStatus(self: *const T, dwResult: u32) callconv(.Inline) HRESULT {
            return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).SetCompletionStatus(@as(*const IESEvent, @ptrCast(self)), dwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetData(self: *const T, pbData: ?*?*SAFEARRAY) callconv(.Inline) HRESULT {
            return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetData(@as(*const IESEvent, @ptrCast(self)), pbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvent_GetStringData(self: *const T, pbstrData: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IESEvent.VTable, @ptrCast(self.vtable)).GetStringData(@as(*const IESEvent, @ptrCast(self)), pbstrData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.1'
const IID_IESEvents_Value = Guid.initString("abd414bf-cfe5-4e5e-af5b-4b4e49c5bfeb");
pub const IID_IESEvents = &IID_IESEvents_Value;
pub const IESEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnESEventReceived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IESEvents,
                guidEventType: Guid,
                pESEvent: ?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IESEvents,
                guidEventType: Guid,
                pESEvent: ?*IESEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IESEvents_OnESEventReceived(self: *const T, guidEventType: Guid, pESEvent: ?*IESEvent) callconv(.Inline) HRESULT {
            return @as(*const IESEvents.VTable, @ptrCast(self.vtable)).OnESEventReceived(@as(*const IESEvents, @ptrCast(self)), guidEventType, pESEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IBroadcastEvent_Value = Guid.initString("3b21263f-26e8-489d-aac4-924f7efd9511");
pub const IID_IBroadcastEvent = &IID_IBroadcastEvent_Value;
pub const IBroadcastEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Fire: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBroadcastEvent,
                EventID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBroadcastEvent,
                EventID: Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBroadcastEvent_Fire(self: *const T, EventID: Guid) callconv(.Inline) HRESULT {
            return @as(*const IBroadcastEvent.VTable, @ptrCast(self.vtable)).Fire(@as(*const IBroadcastEvent, @ptrCast(self)), EventID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBroadcastEventEx_Value = Guid.initString("3d9e3887-1929-423f-8021-43682de95448");
pub const IID_IBroadcastEventEx = &IID_IBroadcastEventEx_Value;
pub const IBroadcastEventEx = extern struct {
    pub const VTable = extern struct {
        base: IBroadcastEvent.VTable,
        FireEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBroadcastEventEx,
                EventID: Guid,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBroadcastEventEx,
                EventID: Guid,
                Param1: u32,
                Param2: u32,
                Param3: u32,
                Param4: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBroadcastEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBroadcastEventEx_FireEx(self: *const T, EventID: Guid, Param1: u32, Param2: u32, Param3: u32, Param4: u32) callconv(.Inline) HRESULT {
            return @as(*const IBroadcastEventEx.VTable, @ptrCast(self.vtable)).FireEx(@as(*const IBroadcastEventEx, @ptrCast(self)), EventID, Param1, Param2, Param3, Param4);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowConfig_Value = Guid.initString("fa2aa8f1-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowConfig = &IID_IAMNetShowConfig_Value;
pub const IAMNetShowConfig = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pBufferingTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pBufferingTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BufferingTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                BufferingTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                BufferingTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseFixedUDPPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pUseFixedUDPPort: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pUseFixedUDPPort: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseFixedUDPPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                UseFixedUDPPort: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                UseFixedUDPPort: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FixedUDPPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pFixedUDPPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pFixedUDPPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FixedUDPPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                FixedUDPPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                FixedUDPPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UseHTTPProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pUseHTTPProxy: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pUseHTTPProxy: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_UseHTTPProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                UseHTTPProxy: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                UseHTTPProxy: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableAutoProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pEnableAutoProxy: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pEnableAutoProxy: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableAutoProxy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                EnableAutoProxy: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                EnableAutoProxy: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyHost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pbstrHTTPProxyHost: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pbstrHTTPProxyHost: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyHost: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                bstrHTTPProxyHost: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                bstrHTTPProxyHost: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HTTPProxyPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pHTTPProxyPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pHTTPProxyPort: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HTTPProxyPort: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                HTTPProxyPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                HTTPProxyPort: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableMulticast: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pEnableMulticast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pEnableMulticast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableMulticast: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                EnableMulticast: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                EnableMulticast: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableUDP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pEnableUDP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pEnableUDP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableUDP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                EnableUDP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                EnableUDP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableTCP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pEnableTCP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pEnableTCP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableTCP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                EnableTCP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                EnableTCP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_EnableHTTP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                pEnableHTTP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                pEnableHTTP: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_EnableHTTP: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowConfig,
                EnableHTTP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowConfig,
                EnableHTTP: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_BufferingTime(self: *const T, pBufferingTime: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_BufferingTime(@as(*const IAMNetShowConfig, @ptrCast(self)), pBufferingTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_BufferingTime(self: *const T, BufferingTime: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_BufferingTime(@as(*const IAMNetShowConfig, @ptrCast(self)), BufferingTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_UseFixedUDPPort(self: *const T, pUseFixedUDPPort: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_UseFixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), pUseFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_UseFixedUDPPort(self: *const T, UseFixedUDPPort: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_UseFixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), UseFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_FixedUDPPort(self: *const T, pFixedUDPPort: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_FixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), pFixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_FixedUDPPort(self: *const T, FixedUDPPort: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_FixedUDPPort(@as(*const IAMNetShowConfig, @ptrCast(self)), FixedUDPPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_UseHTTPProxy(self: *const T, pUseHTTPProxy: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_UseHTTPProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), pUseHTTPProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_UseHTTPProxy(self: *const T, UseHTTPProxy: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_UseHTTPProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), UseHTTPProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableAutoProxy(self: *const T, pEnableAutoProxy: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableAutoProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), pEnableAutoProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableAutoProxy(self: *const T, EnableAutoProxy: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableAutoProxy(@as(*const IAMNetShowConfig, @ptrCast(self)), EnableAutoProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_HTTPProxyHost(self: *const T, pbstrHTTPProxyHost: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_HTTPProxyHost(@as(*const IAMNetShowConfig, @ptrCast(self)), pbstrHTTPProxyHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_HTTPProxyHost(self: *const T, bstrHTTPProxyHost: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_HTTPProxyHost(@as(*const IAMNetShowConfig, @ptrCast(self)), bstrHTTPProxyHost);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_HTTPProxyPort(self: *const T, pHTTPProxyPort: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_HTTPProxyPort(@as(*const IAMNetShowConfig, @ptrCast(self)), pHTTPProxyPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_HTTPProxyPort(self: *const T, HTTPProxyPort: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_HTTPProxyPort(@as(*const IAMNetShowConfig, @ptrCast(self)), HTTPProxyPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableMulticast(self: *const T, pEnableMulticast: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableMulticast(@as(*const IAMNetShowConfig, @ptrCast(self)), pEnableMulticast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableMulticast(self: *const T, EnableMulticast: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableMulticast(@as(*const IAMNetShowConfig, @ptrCast(self)), EnableMulticast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableUDP(self: *const T, pEnableUDP: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableUDP(@as(*const IAMNetShowConfig, @ptrCast(self)), pEnableUDP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableUDP(self: *const T, EnableUDP: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableUDP(@as(*const IAMNetShowConfig, @ptrCast(self)), EnableUDP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableTCP(self: *const T, pEnableTCP: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableTCP(@as(*const IAMNetShowConfig, @ptrCast(self)), pEnableTCP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableTCP(self: *const T, EnableTCP: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableTCP(@as(*const IAMNetShowConfig, @ptrCast(self)), EnableTCP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_get_EnableHTTP(self: *const T, pEnableHTTP: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).get_EnableHTTP(@as(*const IAMNetShowConfig, @ptrCast(self)), pEnableHTTP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowConfig_put_EnableHTTP(self: *const T, EnableHTTP: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowConfig.VTable, @ptrCast(self.vtable)).put_EnableHTTP(@as(*const IAMNetShowConfig, @ptrCast(self)), EnableHTTP);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMChannelInfo_Value = Guid.initString("fa2aa8f2-8b62-11d0-a520-000000000000");
pub const IID_IAMChannelInfo = &IID_IAMChannelInfo_Value;
pub const IAMChannelInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrChannelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrChannelName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrChannelDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrChannelDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ChannelURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrChannelURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrChannelURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactAddress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrContactAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrContactAddress: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactPhone: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrContactPhone: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrContactPhone: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContactEmail: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMChannelInfo,
                pbstrContactEmail: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMChannelInfo,
                pbstrContactEmail: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelName(self: *const T, pbstrChannelName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelName(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrChannelName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelDescription(self: *const T, pbstrChannelDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelDescription(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrChannelDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ChannelURL(self: *const T, pbstrChannelURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ChannelURL(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrChannelURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactAddress(self: *const T, pbstrContactAddress: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactAddress(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrContactAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactPhone(self: *const T, pbstrContactPhone: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactPhone(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrContactPhone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMChannelInfo_get_ContactEmail(self: *const T, pbstrContactEmail: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMChannelInfo.VTable, @ptrCast(self.vtable)).get_ContactEmail(@as(*const IAMChannelInfo, @ptrCast(self)), pbstrContactEmail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetworkStatus_Value = Guid.initString("fa2aa8f3-8b62-11d0-a520-000000000000");
pub const IID_IAMNetworkStatus = &IID_IAMNetworkStatus_Value;
pub const IAMNetworkStatus = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceivedPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pReceivedPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pReceivedPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RecoveredPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pRecoveredPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pRecoveredPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LostPackets: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pLostPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pLostPackets: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ReceptionQuality: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pReceptionQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pReceptionQuality: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pBufferingCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pBufferingCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsBroadcast: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pIsBroadcast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pIsBroadcast: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BufferingProgress: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetworkStatus,
                pBufferingProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetworkStatus,
                pBufferingProgress: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_ReceivedPackets(self: *const T, pReceivedPackets: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_ReceivedPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), pReceivedPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_RecoveredPackets(self: *const T, pRecoveredPackets: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_RecoveredPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), pRecoveredPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_LostPackets(self: *const T, pLostPackets: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_LostPackets(@as(*const IAMNetworkStatus, @ptrCast(self)), pLostPackets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_ReceptionQuality(self: *const T, pReceptionQuality: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_ReceptionQuality(@as(*const IAMNetworkStatus, @ptrCast(self)), pReceptionQuality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_BufferingCount(self: *const T, pBufferingCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_BufferingCount(@as(*const IAMNetworkStatus, @ptrCast(self)), pBufferingCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_IsBroadcast(self: *const T, pIsBroadcast: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_IsBroadcast(@as(*const IAMNetworkStatus, @ptrCast(self)), pIsBroadcast);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetworkStatus_get_BufferingProgress(self: *const T, pBufferingProgress: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetworkStatus.VTable, @ptrCast(self.vtable)).get_BufferingProgress(@as(*const IAMNetworkStatus, @ptrCast(self)), pBufferingProgress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMExtendedSeekingCapabilities = enum(i32) {
    CANSEEK = 1,
    CANSCAN = 2,
    MARKERSEEK = 4,
    SCANWITHOUTCLOCK = 8,
    NOSTANDARDREPAINT = 16,
    BUFFERING = 32,
    SENDS_VIDEOFRAMEREADY = 64,
};
pub const AM_EXSEEK_CANSEEK = AMExtendedSeekingCapabilities.CANSEEK;
pub const AM_EXSEEK_CANSCAN = AMExtendedSeekingCapabilities.CANSCAN;
pub const AM_EXSEEK_MARKERSEEK = AMExtendedSeekingCapabilities.MARKERSEEK;
pub const AM_EXSEEK_SCANWITHOUTCLOCK = AMExtendedSeekingCapabilities.SCANWITHOUTCLOCK;
pub const AM_EXSEEK_NOSTANDARDREPAINT = AMExtendedSeekingCapabilities.NOSTANDARDREPAINT;
pub const AM_EXSEEK_BUFFERING = AMExtendedSeekingCapabilities.BUFFERING;
pub const AM_EXSEEK_SENDS_VIDEOFRAMEREADY = AMExtendedSeekingCapabilities.SENDS_VIDEOFRAMEREADY;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedSeeking_Value = Guid.initString("fa2aa8f9-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedSeeking = &IID_IAMExtendedSeeking_Value;
pub const IAMExtendedSeeking = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExSeekCapabilities: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                pExCapabilities: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedSeeking,
                pExCapabilities: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MarkerCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                pMarkerCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedSeeking,
                pMarkerCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentMarker: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                pCurrentMarker: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedSeeking,
                pCurrentMarker: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMarkerTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                MarkerNum: i32,
                pMarkerTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtendedSeeking,
                MarkerNum: i32,
                pMarkerTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMarkerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                MarkerNum: i32,
                pbstrMarkerName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMExtendedSeeking,
                MarkerNum: i32,
                pbstrMarkerName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PlaybackSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                Speed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedSeeking,
                Speed: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaybackSpeed: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedSeeking,
                pSpeed: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedSeeking,
                pSpeed: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_ExSeekCapabilities(self: *const T, pExCapabilities: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_ExSeekCapabilities(@as(*const IAMExtendedSeeking, @ptrCast(self)), pExCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_MarkerCount(self: *const T, pMarkerCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_MarkerCount(@as(*const IAMExtendedSeeking, @ptrCast(self)), pMarkerCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_CurrentMarker(self: *const T, pCurrentMarker: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_CurrentMarker(@as(*const IAMExtendedSeeking, @ptrCast(self)), pCurrentMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_GetMarkerTime(self: *const T, MarkerNum: i32, pMarkerTime: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).GetMarkerTime(@as(*const IAMExtendedSeeking, @ptrCast(self)), MarkerNum, pMarkerTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_GetMarkerName(self: *const T, MarkerNum: i32, pbstrMarkerName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).GetMarkerName(@as(*const IAMExtendedSeeking, @ptrCast(self)), MarkerNum, pbstrMarkerName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_put_PlaybackSpeed(self: *const T, Speed: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).put_PlaybackSpeed(@as(*const IAMExtendedSeeking, @ptrCast(self)), Speed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedSeeking_get_PlaybackSpeed(self: *const T, pSpeed: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedSeeking.VTable, @ptrCast(self.vtable)).get_PlaybackSpeed(@as(*const IAMExtendedSeeking, @ptrCast(self)), pSpeed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowExProps_Value = Guid.initString("fa2aa8f5-8b62-11d0-a520-000000000000");
pub const IID_IAMNetShowExProps = &IID_IAMNetShowExProps_Value;
pub const IAMNetShowExProps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceProtocol: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pSourceProtocol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pSourceProtocol: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Bandwidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pBandwidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCorrection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pbstrErrorCorrection: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pbstrErrorCorrection: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CodecCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pCodecCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pCodecCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecInstalled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pCodecInstalled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pCodecInstalled: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecDescription: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pbstrCodecDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pbstrCodecDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCodecURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pbstrCodecURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMNetShowExProps,
                CodecNum: i32,
                pbstrCodecURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CreationDate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pCreationDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pCreationDate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLink: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowExProps,
                pbstrSourceLink: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowExProps,
                pbstrSourceLink: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_SourceProtocol(self: *const T, pSourceProtocol: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_SourceProtocol(@as(*const IAMNetShowExProps, @ptrCast(self)), pSourceProtocol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_Bandwidth(self: *const T, pBandwidth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_Bandwidth(@as(*const IAMNetShowExProps, @ptrCast(self)), pBandwidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_ErrorCorrection(self: *const T, pbstrErrorCorrection: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_ErrorCorrection(@as(*const IAMNetShowExProps, @ptrCast(self)), pbstrErrorCorrection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_CodecCount(self: *const T, pCodecCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_CodecCount(@as(*const IAMNetShowExProps, @ptrCast(self)), pCodecCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecInstalled(self: *const T, CodecNum: i32, pCodecInstalled: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecInstalled(@as(*const IAMNetShowExProps, @ptrCast(self)), CodecNum, pCodecInstalled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecDescription(self: *const T, CodecNum: i32, pbstrCodecDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecDescription(@as(*const IAMNetShowExProps, @ptrCast(self)), CodecNum, pbstrCodecDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_GetCodecURL(self: *const T, CodecNum: i32, pbstrCodecURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).GetCodecURL(@as(*const IAMNetShowExProps, @ptrCast(self)), CodecNum, pbstrCodecURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_CreationDate(self: *const T, pCreationDate: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_CreationDate(@as(*const IAMNetShowExProps, @ptrCast(self)), pCreationDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowExProps_get_SourceLink(self: *const T, pbstrSourceLink: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowExProps.VTable, @ptrCast(self.vtable)).get_SourceLink(@as(*const IAMNetShowExProps, @ptrCast(self)), pbstrSourceLink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMExtendedErrorInfo_Value = Guid.initString("fa2aa8f6-8b62-11d0-a520-000000000000");
pub const IID_IAMExtendedErrorInfo = &IID_IAMExtendedErrorInfo_Value;
pub const IAMExtendedErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HasError: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedErrorInfo,
                pHasError: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedErrorInfo,
                pHasError: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorDescription: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedErrorInfo,
                pbstrErrorDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedErrorInfo,
                pbstrErrorDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorCode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMExtendedErrorInfo,
                pErrorCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMExtendedErrorInfo,
                pErrorCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_HasError(self: *const T, pHasError: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_HasError(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), pHasError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_ErrorDescription(self: *const T, pbstrErrorDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_ErrorDescription(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), pbstrErrorDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMExtendedErrorInfo_get_ErrorCode(self: *const T, pErrorCode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMExtendedErrorInfo.VTable, @ptrCast(self.vtable)).get_ErrorCode(@as(*const IAMExtendedErrorInfo, @ptrCast(self)), pErrorCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent_Value = Guid.initString("fa2aa8f4-8b62-11d0-a520-000000000000");
pub const IID_IAMMediaContent = &IID_IAMMediaContent_Value;
pub const IAMMediaContent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthorName: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrAuthorName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrAuthorName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Title: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrTitle: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rating: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrRating: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrRating: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Description: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrDescription: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Copyright: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrCopyright: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrCopyright: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BaseURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrBaseURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrLogoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrLogoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_LogoIconURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrLogoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrLogoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WatermarkURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrWatermarkURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrWatermarkURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerImage: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoBannerImage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoBannerImage: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoBannerURL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoBannerURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoBannerURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MoreInfoText: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent,
                pbstrMoreInfoText: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_AuthorName(self: *const T, pbstrAuthorName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_AuthorName(@as(*const IAMMediaContent, @ptrCast(self)), pbstrAuthorName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Title(self: *const T, pbstrTitle: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Title(@as(*const IAMMediaContent, @ptrCast(self)), pbstrTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Rating(self: *const T, pbstrRating: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Rating(@as(*const IAMMediaContent, @ptrCast(self)), pbstrRating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Description(self: *const T, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Description(@as(*const IAMMediaContent, @ptrCast(self)), pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_Copyright(self: *const T, pbstrCopyright: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_Copyright(@as(*const IAMMediaContent, @ptrCast(self)), pbstrCopyright);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_BaseURL(self: *const T, pbstrBaseURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_BaseURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrBaseURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_LogoURL(self: *const T, pbstrLogoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_LogoURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrLogoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_LogoIconURL(self: *const T, pbstrLogoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_LogoIconURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrLogoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_WatermarkURL(self: *const T, pbstrWatermarkURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_WatermarkURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrWatermarkURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoURL(self: *const T, pbstrMoreInfoURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrMoreInfoURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoBannerImage(self: *const T, pbstrMoreInfoBannerImage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoBannerImage(@as(*const IAMMediaContent, @ptrCast(self)), pbstrMoreInfoBannerImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoBannerURL(self: *const T, pbstrMoreInfoBannerURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoBannerURL(@as(*const IAMMediaContent, @ptrCast(self)), pbstrMoreInfoBannerURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent_get_MoreInfoText(self: *const T, pbstrMoreInfoText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent.VTable, @ptrCast(self.vtable)).get_MoreInfoText(@as(*const IAMMediaContent, @ptrCast(self)), pbstrMoreInfoText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMMediaContent2_Value = Guid.initString("ce8f78c1-74d9-11d2-b09d-00a0c9a81117");
pub const IID_IAMMediaContent2 = &IID_IAMMediaContent2_Value;
pub const IAMMediaContent2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_MediaParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaContent2,
                EntryNum: i32,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaContent2,
                EntryNum: i32,
                bstrName: ?BSTR,
                pbstrValue: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_MediaParameterName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaContent2,
                EntryNum: i32,
                Index: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaContent2,
                EntryNum: i32,
                Index: i32,
                pbstrName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PlaylistCount: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMMediaContent2,
                pNumberEntries: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMMediaContent2,
                pNumberEntries: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_MediaParameter(self: *const T, EntryNum: i32, bstrName: ?BSTR, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_MediaParameter(@as(*const IAMMediaContent2, @ptrCast(self)), EntryNum, bstrName, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_MediaParameterName(self: *const T, EntryNum: i32, Index: i32, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_MediaParameterName(@as(*const IAMMediaContent2, @ptrCast(self)), EntryNum, Index, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaContent2_get_PlaylistCount(self: *const T, pNumberEntries: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaContent2.VTable, @ptrCast(self.vtable)).get_PlaylistCount(@as(*const IAMMediaContent2, @ptrCast(self)), pNumberEntries);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMNetShowPreroll_Value = Guid.initString("aae7e4e2-6388-11d1-8d93-006097c9a2b2");
pub const IID_IAMNetShowPreroll = &IID_IAMNetShowPreroll_Value;
pub const IAMNetShowPreroll = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Preroll: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowPreroll,
                fPreroll: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowPreroll,
                fPreroll: VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Preroll: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMNetShowPreroll,
                pfPreroll: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMNetShowPreroll,
                pfPreroll: ?*VARIANT_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowPreroll_put_Preroll(self: *const T, fPreroll: VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowPreroll.VTable, @ptrCast(self.vtable)).put_Preroll(@as(*const IAMNetShowPreroll, @ptrCast(self)), fPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMNetShowPreroll_get_Preroll(self: *const T, pfPreroll: ?*VARIANT_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMNetShowPreroll.VTable, @ptrCast(self.vtable)).get_Preroll(@as(*const IAMNetShowPreroll, @ptrCast(self)), pfPreroll);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDShowPlugin_Value = Guid.initString("4746b7c8-700e-11d1-becc-00c04fb6e937");
pub const IID_IDShowPlugin = &IID_IDShowPlugin_Value;
pub const IDShowPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_URL: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDShowPlugin,
                pURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDShowPlugin,
                pURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_UserAgent: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IDShowPlugin,
                pUserAgent: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IDShowPlugin,
                pUserAgent: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDShowPlugin_get_URL(self: *const T, pURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDShowPlugin.VTable, @ptrCast(self.vtable)).get_URL(@as(*const IDShowPlugin, @ptrCast(self)), pURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDShowPlugin_get_UserAgent(self: *const T, pUserAgent: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IDShowPlugin.VTable, @ptrCast(self.vtable)).get_UserAgent(@as(*const IDShowPlugin, @ptrCast(self)), pUserAgent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMDirectSound_Value = Guid.initString("546f4260-d53e-11cf-b3f0-00aa003761c5");
pub const IID_IAMDirectSound = &IID_IAMDirectSound_Value;
pub const IAMDirectSound = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectSoundInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lplpds: ?*?*IDirectSound,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lplpds: ?*?*IDirectSound,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPrimaryBufferInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lplpdsb: ?*?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lplpdsb: ?*?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecondaryBufferInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lplpdsb: ?*?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lplpdsb: ?*?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseDirectSoundInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lpds: ?*IDirectSound,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lpds: ?*IDirectSound,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleasePrimaryBufferInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lpdsb: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lpdsb: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseSecondaryBufferInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                lpdsb: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                lpdsb: ?*IDirectSoundBuffer,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFocusWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                param0: ?HWND,
                param1: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                param0: ?HWND,
                param1: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFocusWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMDirectSound,
                param0: ?*?HWND,
                param1: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMDirectSound,
                param0: ?*?HWND,
                param1: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetDirectSoundInterface(self: *const T, lplpds: ?*?*IDirectSound) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetDirectSoundInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetPrimaryBufferInterface(self: *const T, lplpdsb: ?*?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetPrimaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetSecondaryBufferInterface(self: *const T, lplpdsb: ?*?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetSecondaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lplpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleaseDirectSoundInterface(self: *const T, lpds: ?*IDirectSound) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleaseDirectSoundInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleasePrimaryBufferInterface(self: *const T, lpdsb: ?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleasePrimaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_ReleaseSecondaryBufferInterface(self: *const T, lpdsb: ?*IDirectSoundBuffer) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).ReleaseSecondaryBufferInterface(@as(*const IAMDirectSound, @ptrCast(self)), lpdsb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_SetFocusWindow(self: *const T, param0: ?HWND, param1: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).SetFocusWindow(@as(*const IAMDirectSound, @ptrCast(self)), param0, param1);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMDirectSound_GetFocusWindow(self: *const T, param0: ?*?HWND, param1: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMDirectSound.VTable, @ptrCast(self.vtable)).GetFocusWindow(@as(*const IAMDirectSound, @ptrCast(self)), param0, param1);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_LINE21_CCLEVEL = enum(i32) {
    @"2" = 0,
};
pub const AM_L21_CCLEVEL_TC2 = AM_LINE21_CCLEVEL.@"2";

pub const AM_LINE21_CCSERVICE = enum(i32) {
    None = 0,
    Caption1 = 1,
    Caption2 = 2,
    Text1 = 3,
    Text2 = 4,
    XDS = 5,
    DefChannel = 10,
    Invalid = 11,
};
pub const AM_L21_CCSERVICE_None = AM_LINE21_CCSERVICE.None;
pub const AM_L21_CCSERVICE_Caption1 = AM_LINE21_CCSERVICE.Caption1;
pub const AM_L21_CCSERVICE_Caption2 = AM_LINE21_CCSERVICE.Caption2;
pub const AM_L21_CCSERVICE_Text1 = AM_LINE21_CCSERVICE.Text1;
pub const AM_L21_CCSERVICE_Text2 = AM_LINE21_CCSERVICE.Text2;
pub const AM_L21_CCSERVICE_XDS = AM_LINE21_CCSERVICE.XDS;
pub const AM_L21_CCSERVICE_DefChannel = AM_LINE21_CCSERVICE.DefChannel;
pub const AM_L21_CCSERVICE_Invalid = AM_LINE21_CCSERVICE.Invalid;

pub const AM_LINE21_CCSTATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_L21_CCSTATE_Off = AM_LINE21_CCSTATE.ff;
pub const AM_L21_CCSTATE_On = AM_LINE21_CCSTATE.n;

pub const AM_LINE21_CCSTYLE = enum(i32) {
    None = 0,
    PopOn = 1,
    PaintOn = 2,
    RollUp = 3,
};
pub const AM_L21_CCSTYLE_None = AM_LINE21_CCSTYLE.None;
pub const AM_L21_CCSTYLE_PopOn = AM_LINE21_CCSTYLE.PopOn;
pub const AM_L21_CCSTYLE_PaintOn = AM_LINE21_CCSTYLE.PaintOn;
pub const AM_L21_CCSTYLE_RollUp = AM_LINE21_CCSTYLE.RollUp;

pub const AM_LINE21_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_L21_DRAWBGMODE_Opaque = AM_LINE21_DRAWBGMODE.Opaque;
pub const AM_L21_DRAWBGMODE_Transparent = AM_LINE21_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMLine21Decoder_Value = Guid.initString("6e8d4a21-310c-11d0-b79a-00aa003767a7");
pub const IID_IAMLine21Decoder = &IID_IAMLine21Decoder_Value;
pub const IAMLine21Decoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpLevel: ?*AM_LINE21_CCLEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpLevel: ?*AM_LINE21_CCLEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpService: ?*AM_LINE21_CCSERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpService: ?*AM_LINE21_CCSERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                Service: AM_LINE21_CCSERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                Service: AM_LINE21_CCSERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpState: ?*AM_LINE21_CCSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpState: ?*AM_LINE21_CCSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServiceState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                State: AM_LINE21_CCSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                State: AM_LINE21_CCSTATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpbmih: ?*BITMAPINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpbmih: ?*BITMAPINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpbmi: ?*BITMAPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpbmi: ?*BITMAPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                pdwPhysColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                pdwPhysColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                dwPhysColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                dwPhysColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRedrawAlways: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpbOption: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpbOption: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRedrawAlways: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                bOption: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                bOption: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDrawBackgroundMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                lpMode: ?*AM_LINE21_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                lpMode: ?*AM_LINE21_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDrawBackgroundMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMLine21Decoder,
                Mode: AM_LINE21_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMLine21Decoder,
                Mode: AM_LINE21_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetDecoderLevel(self: *const T, lpLevel: ?*AM_LINE21_CCLEVEL) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetDecoderLevel(@as(*const IAMLine21Decoder, @ptrCast(self)), lpLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetCurrentService(self: *const T, lpService: ?*AM_LINE21_CCSERVICE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetCurrentService(@as(*const IAMLine21Decoder, @ptrCast(self)), lpService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetCurrentService(self: *const T, Service: AM_LINE21_CCSERVICE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetCurrentService(@as(*const IAMLine21Decoder, @ptrCast(self)), Service);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetServiceState(self: *const T, lpState: ?*AM_LINE21_CCSTATE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetServiceState(@as(*const IAMLine21Decoder, @ptrCast(self)), lpState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetServiceState(self: *const T, State: AM_LINE21_CCSTATE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetServiceState(@as(*const IAMLine21Decoder, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetOutputFormat(self: *const T, lpbmih: ?*BITMAPINFOHEADER) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IAMLine21Decoder, @ptrCast(self)), lpbmih);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetOutputFormat(self: *const T, lpbmi: ?*BITMAPINFO) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetOutputFormat(@as(*const IAMLine21Decoder, @ptrCast(self)), lpbmi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetBackgroundColor(self: *const T, pdwPhysColor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IAMLine21Decoder, @ptrCast(self)), pdwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetBackgroundColor(self: *const T, dwPhysColor: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IAMLine21Decoder, @ptrCast(self)), dwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetRedrawAlways(self: *const T, lpbOption: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetRedrawAlways(@as(*const IAMLine21Decoder, @ptrCast(self)), lpbOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetRedrawAlways(self: *const T, bOption: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetRedrawAlways(@as(*const IAMLine21Decoder, @ptrCast(self)), bOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_GetDrawBackgroundMode(self: *const T, lpMode: ?*AM_LINE21_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).GetDrawBackgroundMode(@as(*const IAMLine21Decoder, @ptrCast(self)), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMLine21Decoder_SetDrawBackgroundMode(self: *const T, Mode: AM_LINE21_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @as(*const IAMLine21Decoder.VTable, @ptrCast(self.vtable)).SetDrawBackgroundMode(@as(*const IAMLine21Decoder, @ptrCast(self)), Mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMParse_Value = Guid.initString("c47a3420-005c-11d2-9038-00a0c9697298");
pub const IID_IAMParse = &IID_IAMParse_Value;
pub const IAMParse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParseTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMParse,
                prtCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMParse,
                prtCurrent: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParseTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMParse,
                rtCurrent: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMParse,
                rtCurrent: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMParse,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMParse,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_GetParseTime(self: *const T, prtCurrent: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).GetParseTime(@as(*const IAMParse, @ptrCast(self)), prtCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_SetParseTime(self: *const T, rtCurrent: i64) callconv(.Inline) HRESULT {
            return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).SetParseTime(@as(*const IAMParse, @ptrCast(self)), rtCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMParse_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMParse.VTable, @ptrCast(self.vtable)).Flush(@as(*const IAMParse, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMCollection_Value = Guid.initString("56a868b9-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMCollection = &IID_IAMCollection_Value;
pub const IAMCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMCollection,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Item: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMCollection,
                lItem: i32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMCollection,
                lItem: i32,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMCollection,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IAMCollection, @ptrCast(self)), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_Item(self: *const T, lItem: i32, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).Item(@as(*const IAMCollection, @ptrCast(self)), lItem, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMCollection_get__NewEnum(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAMCollection.VTable, @ptrCast(self.vtable)).get__NewEnum(@as(*const IAMCollection, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaControl_Value = Guid.initString("56a868b1-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaControl = &IID_IMediaControl_Value;
pub const IMediaControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Run: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Pause: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
                msTimeout: i32,
                pfs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
                msTimeout: i32,
                pfs: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RenderFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
                strFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
                strFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSourceFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
                strFilename: ?BSTR,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
                strFilename: ?BSTR,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaControl,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaControl,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_RegFilterCollection: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaControl,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaControl,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopWhenReady: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Run(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Run(@as(*const IMediaControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Pause(@as(*const IMediaControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).Stop(@as(*const IMediaControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_GetState(self: *const T, msTimeout: i32, pfs: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMediaControl, @ptrCast(self)), msTimeout, pfs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_RenderFile(self: *const T, strFilename: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).RenderFile(@as(*const IMediaControl, @ptrCast(self)), strFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_AddSourceFilter(self: *const T, strFilename: ?BSTR, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).AddSourceFilter(@as(*const IMediaControl, @ptrCast(self)), strFilename, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_get_FilterCollection(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).get_FilterCollection(@as(*const IMediaControl, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_get_RegFilterCollection(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).get_RegFilterCollection(@as(*const IMediaControl, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaControl_StopWhenReady(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaControl.VTable, @ptrCast(self.vtable)).StopWhenReady(@as(*const IMediaControl, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEvent_Value = Guid.initString("56a868b6-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEvent = &IID_IMediaEvent_Value;
pub const IMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                hEvent: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                hEvent: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                lEventCode: ?*i32,
                lParam1: ?*isize,
                lParam2: ?*isize,
                msTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                lEventCode: ?*i32,
                lParam1: ?*isize,
                lParam2: ?*isize,
                msTimeout: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitForCompletion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                msTimeout: i32,
                pEvCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                msTimeout: i32,
                pEvCode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CancelDefaultHandling: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                lEvCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                lEvCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RestoreDefaultHandling: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                lEvCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                lEvCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FreeEventParams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEvent,
                lEvCode: i32,
                lParam1: isize,
                lParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEvent,
                lEvCode: i32,
                lParam1: isize,
                lParam2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_GetEventHandle(self: *const T, hEvent: ?*isize) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).GetEventHandle(@as(*const IMediaEvent, @ptrCast(self)), hEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_GetEvent(self: *const T, lEventCode: ?*i32, lParam1: ?*isize, lParam2: ?*isize, msTimeout: i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).GetEvent(@as(*const IMediaEvent, @ptrCast(self)), lEventCode, lParam1, lParam2, msTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_WaitForCompletion(self: *const T, msTimeout: i32, pEvCode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).WaitForCompletion(@as(*const IMediaEvent, @ptrCast(self)), msTimeout, pEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_CancelDefaultHandling(self: *const T, lEvCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).CancelDefaultHandling(@as(*const IMediaEvent, @ptrCast(self)), lEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_RestoreDefaultHandling(self: *const T, lEvCode: i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).RestoreDefaultHandling(@as(*const IMediaEvent, @ptrCast(self)), lEvCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEvent_FreeEventParams(self: *const T, lEvCode: i32, lParam1: isize, lParam2: isize) callconv(.Inline) HRESULT {
            return @as(*const IMediaEvent.VTable, @ptrCast(self.vtable)).FreeEventParams(@as(*const IMediaEvent, @ptrCast(self)), lEvCode, lParam1, lParam2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaEventEx_Value = Guid.initString("56a868c0-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaEventEx = &IID_IMediaEventEx_Value;
pub const IMediaEventEx = extern struct {
    pub const VTable = extern struct {
        base: IMediaEvent.VTable,
        SetNotifyWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEventEx,
                hwnd: isize,
                lMsg: i32,
                lInstanceData: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEventEx,
                hwnd: isize,
                lMsg: i32,
                lInstanceData: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNotifyFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEventEx,
                lNoNotifyFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEventEx,
                lNoNotifyFlags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNotifyFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaEventEx,
                lplNoNotifyFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaEventEx,
                lplNoNotifyFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaEvent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_SetNotifyWindow(self: *const T, hwnd: isize, lMsg: i32, lInstanceData: isize) callconv(.Inline) HRESULT {
            return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).SetNotifyWindow(@as(*const IMediaEventEx, @ptrCast(self)), hwnd, lMsg, lInstanceData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_SetNotifyFlags(self: *const T, lNoNotifyFlags: i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).SetNotifyFlags(@as(*const IMediaEventEx, @ptrCast(self)), lNoNotifyFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaEventEx_GetNotifyFlags(self: *const T, lplNoNotifyFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaEventEx.VTable, @ptrCast(self.vtable)).GetNotifyFlags(@as(*const IMediaEventEx, @ptrCast(self)), lplNoNotifyFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMediaPosition_Value = Guid.initString("56a868b2-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaPosition = &IID_IMediaPosition_Value;
pub const IMediaPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Duration: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                plength: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                plength: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_CurrentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CurrentPosition: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_StopTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PrerollTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                pllTime: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_PrerollTime: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                llTime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                dRate: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Rate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaPosition,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaPosition,
                pdRate: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanSeekForward: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaPosition,
                pCanSeekForward: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaPosition,
                pCanSeekForward: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanSeekBackward: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaPosition,
                pCanSeekBackward: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaPosition,
                pCanSeekBackward: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_Duration(self: *const T, plength: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_Duration(@as(*const IMediaPosition, @ptrCast(self)), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_CurrentPosition(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_CurrentPosition(@as(*const IMediaPosition, @ptrCast(self)), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_CurrentPosition(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_CurrentPosition(@as(*const IMediaPosition, @ptrCast(self)), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_StopTime(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_StopTime(@as(*const IMediaPosition, @ptrCast(self)), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_StopTime(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_StopTime(@as(*const IMediaPosition, @ptrCast(self)), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_PrerollTime(self: *const T, pllTime: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_PrerollTime(@as(*const IMediaPosition, @ptrCast(self)), pllTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_PrerollTime(self: *const T, llTime: f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_PrerollTime(@as(*const IMediaPosition, @ptrCast(self)), llTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_put_Rate(self: *const T, dRate: f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).put_Rate(@as(*const IMediaPosition, @ptrCast(self)), dRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_get_Rate(self: *const T, pdRate: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).get_Rate(@as(*const IMediaPosition, @ptrCast(self)), pdRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_CanSeekForward(self: *const T, pCanSeekForward: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).CanSeekForward(@as(*const IMediaPosition, @ptrCast(self)), pCanSeekForward);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaPosition_CanSeekBackward(self: *const T, pCanSeekBackward: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IMediaPosition.VTable, @ptrCast(self.vtable)).CanSeekBackward(@as(*const IMediaPosition, @ptrCast(self)), pCanSeekBackward);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicAudio_Value = Guid.initString("56a868b3-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicAudio = &IID_IBasicAudio_Value;
pub const IBasicAudio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicAudio,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicAudio,
                lVolume: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Volume: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicAudio,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicAudio,
                plVolume: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicAudio,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicAudio,
                lBalance: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Balance: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicAudio,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicAudio,
                plBalance: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_put_Volume(self: *const T, lVolume: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).put_Volume(@as(*const IBasicAudio, @ptrCast(self)), lVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_get_Volume(self: *const T, plVolume: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).get_Volume(@as(*const IBasicAudio, @ptrCast(self)), plVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_put_Balance(self: *const T, lBalance: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).put_Balance(@as(*const IBasicAudio, @ptrCast(self)), lBalance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicAudio_get_Balance(self: *const T, plBalance: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicAudio.VTable, @ptrCast(self.vtable)).get_Balance(@as(*const IBasicAudio, @ptrCast(self)), plBalance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVideoWindow_Value = Guid.initString("56a868b4-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IVideoWindow = &IID_IVideoWindow_Value;
pub const IVideoWindow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Caption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                strCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                strCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Caption: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                strCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                strCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowStyle: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowStyle: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyle: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowStyle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowStyle: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowStyleEx: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowStyleEx: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowStyleEx: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowStyleEx: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowStyleEx: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowStyleEx: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_AutoShow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                AutoShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                AutoShow: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AutoShow: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                AutoShow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                AutoShow: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_WindowState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowState: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_WindowState: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                WindowState: ?*SHOW_WINDOW_CMD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                WindowState: ?*SHOW_WINDOW_CMD,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BackgroundPalette: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                BackgroundPalette: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                BackgroundPalette: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BackgroundPalette: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pBackgroundPalette: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pBackgroundPalette: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Visible: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Visible: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Visible: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pVisible: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pVisible: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Left: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Left: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Width: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Width: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Top: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Top: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Height: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Owner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Owner: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Owner: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Owner: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Owner: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Owner: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_MessageDrain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Drain: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Drain: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MessageDrain: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Drain: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Drain: ?*isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BorderColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Color: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Color: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_BorderColor: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                Color: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                Color: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FullScreenMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                FullScreenMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                FullScreenMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FullScreenMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IVideoWindow,
                FullScreenMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IVideoWindow,
                FullScreenMode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowForeground: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                Focus: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                Focus: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyOwnerMessage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                hwnd: isize,
                uMsg: i32,
                wParam: isize,
                lParam: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                hwnd: isize,
                uMsg: i32,
                wParam: isize,
                lParam: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetWindowPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetWindowPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinIdealImageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxIdealImageSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRestorePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HideCursor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                HideCursor: OA_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                HideCursor: OA_BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsCursorHidden: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoWindow,
                CursorHidden: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoWindow,
                CursorHidden: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Caption(self: *const T, strCaption: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Caption(@as(*const IVideoWindow, @ptrCast(self)), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Caption(self: *const T, strCaption: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Caption(@as(*const IVideoWindow, @ptrCast(self)), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowStyle(self: *const T, WindowStyle: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowStyle(@as(*const IVideoWindow, @ptrCast(self)), WindowStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowStyle(self: *const T, WindowStyle: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowStyle(@as(*const IVideoWindow, @ptrCast(self)), WindowStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowStyleEx(self: *const T, WindowStyleEx: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowStyleEx(@as(*const IVideoWindow, @ptrCast(self)), WindowStyleEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowStyleEx(self: *const T, WindowStyleEx: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowStyleEx(@as(*const IVideoWindow, @ptrCast(self)), WindowStyleEx);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_AutoShow(self: *const T, AutoShow: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_AutoShow(@as(*const IVideoWindow, @ptrCast(self)), AutoShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_AutoShow(self: *const T, AutoShow: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_AutoShow(@as(*const IVideoWindow, @ptrCast(self)), AutoShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_WindowState(self: *const T, WindowState: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_WindowState(@as(*const IVideoWindow, @ptrCast(self)), WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_WindowState(self: *const T, WindowState: ?*SHOW_WINDOW_CMD) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_WindowState(@as(*const IVideoWindow, @ptrCast(self)), WindowState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_BackgroundPalette(self: *const T, BackgroundPalette: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_BackgroundPalette(@as(*const IVideoWindow, @ptrCast(self)), BackgroundPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_BackgroundPalette(self: *const T, pBackgroundPalette: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_BackgroundPalette(@as(*const IVideoWindow, @ptrCast(self)), pBackgroundPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Visible(self: *const T, Visible: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Visible(@as(*const IVideoWindow, @ptrCast(self)), Visible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Visible(self: *const T, pVisible: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Visible(@as(*const IVideoWindow, @ptrCast(self)), pVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Left(self: *const T, Left: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Left(@as(*const IVideoWindow, @ptrCast(self)), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Left(self: *const T, pLeft: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Left(@as(*const IVideoWindow, @ptrCast(self)), pLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Width(@as(*const IVideoWindow, @ptrCast(self)), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Width(self: *const T, pWidth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Width(@as(*const IVideoWindow, @ptrCast(self)), pWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Top(self: *const T, Top: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Top(@as(*const IVideoWindow, @ptrCast(self)), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Top(self: *const T, pTop: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Top(@as(*const IVideoWindow, @ptrCast(self)), pTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Height(self: *const T, Height: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Height(@as(*const IVideoWindow, @ptrCast(self)), Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Height(self: *const T, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Height(@as(*const IVideoWindow, @ptrCast(self)), pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_Owner(self: *const T, Owner: isize) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_Owner(@as(*const IVideoWindow, @ptrCast(self)), Owner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_Owner(self: *const T, Owner: ?*isize) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_Owner(@as(*const IVideoWindow, @ptrCast(self)), Owner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_MessageDrain(self: *const T, Drain: isize) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_MessageDrain(@as(*const IVideoWindow, @ptrCast(self)), Drain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_MessageDrain(self: *const T, Drain: ?*isize) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_MessageDrain(@as(*const IVideoWindow, @ptrCast(self)), Drain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_BorderColor(self: *const T, Color: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_BorderColor(@as(*const IVideoWindow, @ptrCast(self)), Color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_BorderColor(self: *const T, Color: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_BorderColor(@as(*const IVideoWindow, @ptrCast(self)), Color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_get_FullScreenMode(self: *const T, FullScreenMode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).get_FullScreenMode(@as(*const IVideoWindow, @ptrCast(self)), FullScreenMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_put_FullScreenMode(self: *const T, FullScreenMode: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).put_FullScreenMode(@as(*const IVideoWindow, @ptrCast(self)), FullScreenMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_SetWindowForeground(self: *const T, Focus: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).SetWindowForeground(@as(*const IVideoWindow, @ptrCast(self)), Focus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_NotifyOwnerMessage(self: *const T, hwnd: isize, uMsg: i32, wParam: isize, lParam: isize) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).NotifyOwnerMessage(@as(*const IVideoWindow, @ptrCast(self)), hwnd, uMsg, wParam, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_SetWindowPosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).SetWindowPosition(@as(*const IVideoWindow, @ptrCast(self)), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetWindowPosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetWindowPosition(@as(*const IVideoWindow, @ptrCast(self)), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetMinIdealImageSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetMinIdealImageSize(@as(*const IVideoWindow, @ptrCast(self)), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetMaxIdealImageSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetMaxIdealImageSize(@as(*const IVideoWindow, @ptrCast(self)), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_GetRestorePosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).GetRestorePosition(@as(*const IVideoWindow, @ptrCast(self)), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_HideCursor(self: *const T, HideCursor: OA_BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).HideCursor(@as(*const IVideoWindow, @ptrCast(self)), HideCursor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoWindow_IsCursorHidden(self: *const T, CursorHidden: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoWindow.VTable, @ptrCast(self.vtable)).IsCursorHidden(@as(*const IVideoWindow, @ptrCast(self)), CursorHidden);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo_Value = Guid.initString("56a868b5-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IBasicVideo = &IID_IBasicVideo_Value;
pub const IBasicVideo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgTimePerFrame: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pAvgTimePerFrame: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pAvgTimePerFrame: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pBitRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_BitErrorRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pBitErrorRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pBitErrorRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pVideoWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pVideoWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VideoHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pVideoHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pVideoHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceLeft: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                SourceLeft: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                SourceLeft: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceLeft: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pSourceLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pSourceLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                SourceWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                SourceWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pSourceWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pSourceWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceTop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                SourceTop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                SourceTop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceTop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pSourceTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pSourceTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                SourceHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                SourceHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pSourceHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pSourceHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationLeft: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                DestinationLeft: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                DestinationLeft: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationLeft: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pDestinationLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pDestinationLeft: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                DestinationWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                DestinationWidth: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationWidth: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pDestinationWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pDestinationWidth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationTop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                DestinationTop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                DestinationTop: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationTop: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pDestinationTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pDestinationTop: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DestinationHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                DestinationHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                DestinationHeight: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DestinationHeight: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IBasicVideo,
                pDestinationHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IBasicVideo,
                pDestinationHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultSourcePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDestinationPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                Left: i32,
                Top: i32,
                Width: i32,
                Height: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDestinationPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                pLeft: ?*i32,
                pTop: ?*i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultDestinationPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                pWidth: ?*i32,
                pHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPaletteEntries: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                StartIndex: i32,
                Entries: i32,
                pRetrieved: ?*i32,
                pPalette: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                StartIndex: i32,
                Entries: i32,
                pRetrieved: ?*i32,
                pPalette: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
                pBufferSize: ?*i32,
                pDIBImage: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
                pBufferSize: ?*i32,
                pDIBImage: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingDefaultSource: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingDefaultDestination: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_AvgTimePerFrame(self: *const T, pAvgTimePerFrame: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_AvgTimePerFrame(@as(*const IBasicVideo, @ptrCast(self)), pAvgTimePerFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_BitRate(self: *const T, pBitRate: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_BitRate(@as(*const IBasicVideo, @ptrCast(self)), pBitRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_BitErrorRate(self: *const T, pBitErrorRate: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_BitErrorRate(@as(*const IBasicVideo, @ptrCast(self)), pBitErrorRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_VideoWidth(self: *const T, pVideoWidth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_VideoWidth(@as(*const IBasicVideo, @ptrCast(self)), pVideoWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_VideoHeight(self: *const T, pVideoHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_VideoHeight(@as(*const IBasicVideo, @ptrCast(self)), pVideoHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceLeft(self: *const T, SourceLeft: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceLeft(@as(*const IBasicVideo, @ptrCast(self)), SourceLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceLeft(self: *const T, pSourceLeft: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceLeft(@as(*const IBasicVideo, @ptrCast(self)), pSourceLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceWidth(self: *const T, SourceWidth: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceWidth(@as(*const IBasicVideo, @ptrCast(self)), SourceWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceWidth(self: *const T, pSourceWidth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceWidth(@as(*const IBasicVideo, @ptrCast(self)), pSourceWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceTop(self: *const T, SourceTop: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceTop(@as(*const IBasicVideo, @ptrCast(self)), SourceTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceTop(self: *const T, pSourceTop: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceTop(@as(*const IBasicVideo, @ptrCast(self)), pSourceTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_SourceHeight(self: *const T, SourceHeight: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_SourceHeight(@as(*const IBasicVideo, @ptrCast(self)), SourceHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_SourceHeight(self: *const T, pSourceHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_SourceHeight(@as(*const IBasicVideo, @ptrCast(self)), pSourceHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationLeft(self: *const T, DestinationLeft: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationLeft(@as(*const IBasicVideo, @ptrCast(self)), DestinationLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationLeft(self: *const T, pDestinationLeft: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationLeft(@as(*const IBasicVideo, @ptrCast(self)), pDestinationLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationWidth(self: *const T, DestinationWidth: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationWidth(@as(*const IBasicVideo, @ptrCast(self)), DestinationWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationWidth(self: *const T, pDestinationWidth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationWidth(@as(*const IBasicVideo, @ptrCast(self)), pDestinationWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationTop(self: *const T, DestinationTop: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationTop(@as(*const IBasicVideo, @ptrCast(self)), DestinationTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationTop(self: *const T, pDestinationTop: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationTop(@as(*const IBasicVideo, @ptrCast(self)), pDestinationTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_put_DestinationHeight(self: *const T, DestinationHeight: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).put_DestinationHeight(@as(*const IBasicVideo, @ptrCast(self)), DestinationHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_get_DestinationHeight(self: *const T, pDestinationHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).get_DestinationHeight(@as(*const IBasicVideo, @ptrCast(self)), pDestinationHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetSourcePosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetSourcePosition(@as(*const IBasicVideo, @ptrCast(self)), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetSourcePosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetSourcePosition(@as(*const IBasicVideo, @ptrCast(self)), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDefaultSourcePosition(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDefaultSourcePosition(@as(*const IBasicVideo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDestinationPosition(self: *const T, Left: i32, Top: i32, Width: i32, Height: i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)), Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetDestinationPosition(self: *const T, pLeft: ?*i32, pTop: ?*i32, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)), pLeft, pTop, pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_SetDefaultDestinationPosition(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).SetDefaultDestinationPosition(@as(*const IBasicVideo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetVideoSize(self: *const T, pWidth: ?*i32, pHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetVideoSize(@as(*const IBasicVideo, @ptrCast(self)), pWidth, pHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetVideoPaletteEntries(self: *const T, StartIndex: i32, Entries: i32, pRetrieved: ?*i32, pPalette: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetVideoPaletteEntries(@as(*const IBasicVideo, @ptrCast(self)), StartIndex, Entries, pRetrieved, pPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_GetCurrentImage(self: *const T, pBufferSize: ?*i32, pDIBImage: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IBasicVideo, @ptrCast(self)), pBufferSize, pDIBImage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_IsUsingDefaultSource(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).IsUsingDefaultSource(@as(*const IBasicVideo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo_IsUsingDefaultDestination(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo.VTable, @ptrCast(self.vtable)).IsUsingDefaultDestination(@as(*const IBasicVideo, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IBasicVideo2_Value = Guid.initString("329bb360-f6ea-11d1-9038-00a0c9697298");
pub const IID_IBasicVideo2 = &IID_IBasicVideo2_Value;
pub const IBasicVideo2 = extern struct {
    pub const VTable = extern struct {
        base: IBasicVideo.VTable,
        GetPreferredAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBasicVideo2,
                plAspectX: ?*i32,
                plAspectY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBasicVideo2,
                plAspectX: ?*i32,
                plAspectY: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBasicVideo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBasicVideo2_GetPreferredAspectRatio(self: *const T, plAspectX: ?*i32, plAspectY: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBasicVideo2.VTable, @ptrCast(self.vtable)).GetPreferredAspectRatio(@as(*const IBasicVideo2, @ptrCast(self)), plAspectX, plAspectY);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDeferredCommand_Value = Guid.initString("56a868b8-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IDeferredCommand = &IID_IDeferredCommand_Value;
pub const IDeferredCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDeferredCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDeferredCommand,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Confidence: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDeferredCommand,
                pConfidence: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDeferredCommand,
                pConfidence: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Postpone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDeferredCommand,
                newtime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDeferredCommand,
                newtime: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHResult: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDeferredCommand,
                phrResult: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDeferredCommand,
                phrResult: ?*HRESULT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Cancel(@as(*const IDeferredCommand, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Confidence(self: *const T, pConfidence: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Confidence(@as(*const IDeferredCommand, @ptrCast(self)), pConfidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_Postpone(self: *const T, newtime: f64) callconv(.Inline) HRESULT {
            return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).Postpone(@as(*const IDeferredCommand, @ptrCast(self)), newtime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeferredCommand_GetHResult(self: *const T, phrResult: ?*HRESULT) callconv(.Inline) HRESULT {
            return @as(*const IDeferredCommand.VTable, @ptrCast(self.vtable)).GetHResult(@as(*const IDeferredCommand, @ptrCast(self)), phrResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQueueCommand_Value = Guid.initString("56a868b7-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IQueueCommand = &IID_IQueueCommand_Value;
pub const IQueueCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeAtStreamTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IQueueCommand,
                pCmd: ?*?*IDeferredCommand,
                time: f64,
                iid: ?*Guid,
                dispidMethod: i32,
                wFlags: i16,
                cArgs: i32,
                pDispParams: ?*VARIANT,
                pvarResult: ?*VARIANT,
                puArgErr: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IQueueCommand,
                pCmd: ?*?*IDeferredCommand,
                time: f64,
                iid: ?*Guid,
                dispidMethod: i32,
                wFlags: i16,
                cArgs: i32,
                pDispParams: ?*VARIANT,
                pvarResult: ?*VARIANT,
                puArgErr: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InvokeAtPresentationTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IQueueCommand,
                pCmd: ?*?*IDeferredCommand,
                time: f64,
                iid: ?*Guid,
                dispidMethod: i32,
                wFlags: i16,
                cArgs: i32,
                pDispParams: ?*VARIANT,
                pvarResult: ?*VARIANT,
                puArgErr: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IQueueCommand,
                pCmd: ?*?*IDeferredCommand,
                time: f64,
                iid: ?*Guid,
                dispidMethod: i32,
                wFlags: i16,
                cArgs: i32,
                pDispParams: ?*VARIANT,
                pvarResult: ?*VARIANT,
                puArgErr: ?*i16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueueCommand_InvokeAtStreamTime(self: *const T, pCmd: ?*?*IDeferredCommand, time: f64, iid: ?*Guid, dispidMethod: i32, wFlags: i16, cArgs: i32, pDispParams: ?*VARIANT, pvarResult: ?*VARIANT, puArgErr: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IQueueCommand.VTable, @ptrCast(self.vtable)).InvokeAtStreamTime(@as(*const IQueueCommand, @ptrCast(self)), pCmd, time, iid, dispidMethod, wFlags, cArgs, pDispParams, pvarResult, puArgErr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueueCommand_InvokeAtPresentationTime(self: *const T, pCmd: ?*?*IDeferredCommand, time: f64, iid: ?*Guid, dispidMethod: i32, wFlags: i16, cArgs: i32, pDispParams: ?*VARIANT, pvarResult: ?*VARIANT, puArgErr: ?*i16) callconv(.Inline) HRESULT {
            return @as(*const IQueueCommand.VTable, @ptrCast(self.vtable)).InvokeAtPresentationTime(@as(*const IQueueCommand, @ptrCast(self)), pCmd, time, iid, dispidMethod, wFlags, cArgs, pDispParams, pvarResult, puArgErr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_FilgraphManager_Value = Guid.initString("e436ebb3-524f-11ce-9f53-0020af0ba770");
pub const CLSID_FilgraphManager = &CLSID_FilgraphManager_Value;

const IID_IFilterInfo_Value = Guid.initString("56a868ba-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IFilterInfo = &IID_IFilterInfo_Value;
pub const IFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        FindPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFilterInfo,
                strPinID: ?BSTR,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFilterInfo,
                strPinID: ?BSTR,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_VendorInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                strVendorInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                strVendorInfo: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pins: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IsFileSource: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                pbIsSource: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                pbIsSource: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Filename: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                pstrFilename: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                pstrFilename: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Filename: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IFilterInfo,
                strFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IFilterInfo,
                strFilename: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_FindPin(self: *const T, strPinID: ?BSTR, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).FindPin(@as(*const IFilterInfo, @ptrCast(self)), strPinID, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Name(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IFilterInfo, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_VendorInfo(self: *const T, strVendorInfo: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_VendorInfo(@as(*const IFilterInfo, @ptrCast(self)), strVendorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Filter(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Filter(@as(*const IFilterInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Pins(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Pins(@as(*const IFilterInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_IsFileSource(self: *const T, pbIsSource: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_IsFileSource(@as(*const IFilterInfo, @ptrCast(self)), pbIsSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_get_Filename(self: *const T, pstrFilename: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).get_Filename(@as(*const IFilterInfo, @ptrCast(self)), pstrFilename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFilterInfo_put_Filename(self: *const T, strFilename: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFilterInfo.VTable, @ptrCast(self.vtable)).put_Filename(@as(*const IFilterInfo, @ptrCast(self)), strFilename);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegFilterInfo_Value = Guid.initString("56a868bb-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IRegFilterInfo = &IID_IRegFilterInfo_Value;
pub const IRegFilterInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IRegFilterInfo,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IRegFilterInfo,
                strName: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Filter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IRegFilterInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IRegFilterInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegFilterInfo_get_Name(self: *const T, strName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IRegFilterInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IRegFilterInfo, @ptrCast(self)), strName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegFilterInfo_Filter(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IRegFilterInfo.VTable, @ptrCast(self.vtable)).Filter(@as(*const IRegFilterInfo, @ptrCast(self)), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaTypeInfo_Value = Guid.initString("56a868bc-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IMediaTypeInfo = &IID_IMediaTypeInfo_Value;
pub const IMediaTypeInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaTypeInfo,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaTypeInfo,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Subtype: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMediaTypeInfo,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMediaTypeInfo,
                strType: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaTypeInfo_get_Type(self: *const T, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMediaTypeInfo.VTable, @ptrCast(self.vtable)).get_Type(@as(*const IMediaTypeInfo, @ptrCast(self)), strType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaTypeInfo_get_Subtype(self: *const T, strType: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IMediaTypeInfo.VTable, @ptrCast(self.vtable)).get_Subtype(@as(*const IMediaTypeInfo, @ptrCast(self)), strType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPinInfo_Value = Guid.initString("56a868bd-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IPinInfo = &IID_IPinInfo_Value;
pub const IPinInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Pin: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectedTo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ConnectionMediaType: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FilterInfo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Name: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Direction: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppDirection: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppDirection: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_PinID: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                strPinID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                strPinID: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MediaTypes: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IPinInfo,
                ppUnk: ?*?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Connect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectDirect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConnectWithType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
                pMediaType: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinInfo,
                pPin: ?*IUnknown,
                pMediaType: ?*IDispatch,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Disconnect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IPinInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IPinInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Pin(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Pin(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_ConnectedTo(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_ConnectedTo(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_ConnectionMediaType(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_ConnectionMediaType(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_FilterInfo(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_FilterInfo(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Name(self: *const T, ppUnk: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Name(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_Direction(self: *const T, ppDirection: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_Direction(@as(*const IPinInfo, @ptrCast(self)), ppDirection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_PinID(self: *const T, strPinID: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_PinID(@as(*const IPinInfo, @ptrCast(self)), strPinID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_get_MediaTypes(self: *const T, ppUnk: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).get_MediaTypes(@as(*const IPinInfo, @ptrCast(self)), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Connect(self: *const T, pPin: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Connect(@as(*const IPinInfo, @ptrCast(self)), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_ConnectDirect(self: *const T, pPin: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).ConnectDirect(@as(*const IPinInfo, @ptrCast(self)), pPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_ConnectWithType(self: *const T, pPin: ?*IUnknown, pMediaType: ?*IDispatch) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).ConnectWithType(@as(*const IPinInfo, @ptrCast(self)), pPin, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Disconnect(@as(*const IPinInfo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPinInfo_Render(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IPinInfo.VTable, @ptrCast(self.vtable)).Render(@as(*const IPinInfo, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMStats_Value = Guid.initString("bc9bcf80-dcd2-11d2-abf6-00a0c905f375");
pub const IID_IAMStats = &IID_IAMStats_Value;
pub const IAMStats = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStats,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IAMStats,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IAMStats,
                plCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueByIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStats,
                lIndex: i32,
                szName: ?*?BSTR,
                lCount: ?*i32,
                dLast: ?*f64,
                dAverage: ?*f64,
                dStdDev: ?*f64,
                dMin: ?*f64,
                dMax: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStats,
                lIndex: i32,
                szName: ?*?BSTR,
                lCount: ?*i32,
                dLast: ?*f64,
                dAverage: ?*f64,
                dStdDev: ?*f64,
                dMin: ?*f64,
                dMax: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetValueByName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStats,
                szName: ?BSTR,
                lIndex: ?*i32,
                lCount: ?*i32,
                dLast: ?*f64,
                dAverage: ?*f64,
                dStdDev: ?*f64,
                dMin: ?*f64,
                dMax: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStats,
                szName: ?BSTR,
                lIndex: ?*i32,
                lCount: ?*i32,
                dLast: ?*f64,
                dAverage: ?*f64,
                dStdDev: ?*f64,
                dMin: ?*f64,
                dMax: ?*f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndex: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStats,
                szName: ?BSTR,
                lCreate: i32,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStats,
                szName: ?BSTR,
                lCreate: i32,
                plIndex: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddValue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMStats,
                lIndex: i32,
                dValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMStats,
                lIndex: i32,
                dValue: f64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).Reset(@as(*const IAMStats, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_get_Count(self: *const T, plCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).get_Count(@as(*const IAMStats, @ptrCast(self)), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetValueByIndex(self: *const T, lIndex: i32, szName: ?*?BSTR, lCount: ?*i32, dLast: ?*f64, dAverage: ?*f64, dStdDev: ?*f64, dMin: ?*f64, dMax: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetValueByIndex(@as(*const IAMStats, @ptrCast(self)), lIndex, szName, lCount, dLast, dAverage, dStdDev, dMin, dMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetValueByName(self: *const T, szName: ?BSTR, lIndex: ?*i32, lCount: ?*i32, dLast: ?*f64, dAverage: ?*f64, dStdDev: ?*f64, dMin: ?*f64, dMax: ?*f64) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetValueByName(@as(*const IAMStats, @ptrCast(self)), szName, lIndex, lCount, dLast, dAverage, dStdDev, dMin, dMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_GetIndex(self: *const T, szName: ?BSTR, lCreate: i32, plIndex: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).GetIndex(@as(*const IAMStats, @ptrCast(self)), szName, lCreate, plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMStats_AddValue(self: *const T, lIndex: i32, dValue: f64) callconv(.Inline) HRESULT {
            return @as(*const IAMStats.VTable, @ptrCast(self.vtable)).AddValue(@as(*const IAMStats, @ptrCast(self)), lIndex, dValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMVAUncompBufferInfo = extern struct {
    dwMinNumSurfaces: u32,
    dwMaxNumSurfaces: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAUncompDataInfo = extern struct {
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
};

pub const AMVAInternalMemInfo = extern struct {
    dwScratchMemAlloc: u32,
};

pub const AMVACompBufferInfo = extern struct {
    dwNumCompBuffers: u32,
    dwWidthToCreate: u32,
    dwHeightToCreate: u32,
    dwBytesToAllocate: u32,
    ddCompCaps: DDSCAPS2,
    ddPixelFormat: DDPIXELFORMAT,
};

pub const AMVABeginFrameInfo = extern struct {
    dwDestSurfaceIndex: u32,
    pInputData: ?*anyopaque,
    dwSizeInputData: u32,
    pOutputData: ?*anyopaque,
    dwSizeOutputData: u32,
};

pub const AMVAEndFrameInfo = extern struct {
    dwSizeMiscData: u32,
    pMiscData: ?*anyopaque,
};

pub const AMVABUFFERINFO = extern struct {
    dwTypeIndex: u32,
    dwBufferIndex: u32,
    dwDataOffset: u32,
    dwDataSize: u32,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAcceleratorNotify_Value = Guid.initString("256a6a21-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAcceleratorNotify = &IID_IAMVideoAcceleratorNotify_Value;
pub const IAMVideoAcceleratorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUncompSurfacesInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAcceleratorNotify,
                pGuid: ?*const Guid,
                pUncompBufferInfo: ?*AMVAUncompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAcceleratorNotify,
                pGuid: ?*const Guid,
                pUncompBufferInfo: ?*AMVAUncompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUncompSurfacesInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAcceleratorNotify,
                dwActualUncompSurfacesAllocated: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAcceleratorNotify,
                dwActualUncompSurfacesAllocated: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCreateVideoAcceleratorData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAcceleratorNotify,
                pGuid: ?*const Guid,
                pdwSizeMiscData: ?*u32,
                ppMiscData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAcceleratorNotify,
                pGuid: ?*const Guid,
                pdwSizeMiscData: ?*u32,
                ppMiscData: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_GetUncompSurfacesInfo(self: *const T, pGuid: ?*const Guid, pUncompBufferInfo: ?*AMVAUncompBufferInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).GetUncompSurfacesInfo(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), pGuid, pUncompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_SetUncompSurfacesInfo(self: *const T, dwActualUncompSurfacesAllocated: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).SetUncompSurfacesInfo(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), dwActualUncompSurfacesAllocated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAcceleratorNotify_GetCreateVideoAcceleratorData(self: *const T, pGuid: ?*const Guid, pdwSizeMiscData: ?*u32, ppMiscData: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAcceleratorNotify.VTable, @ptrCast(self.vtable)).GetCreateVideoAcceleratorData(@as(*const IAMVideoAcceleratorNotify, @ptrCast(self)), pGuid, pdwSizeMiscData, ppMiscData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IAMVideoAccelerator_Value = Guid.initString("256a6a22-fbad-11d1-82bf-00a0c9696c8f");
pub const IID_IAMVideoAccelerator = &IID_IAMVideoAccelerator_Value;
pub const IAMVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoAcceleratorGUIDs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pdwNumGuidsSupported: ?*u32,
                pGuidsSupported: ?[*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pdwNumGuidsSupported: ?*u32,
                pGuidsSupported: ?[*]Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetUncompFormatsSupported: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pdwNumFormatsSupported: ?*u32,
                pFormatsSupported: ?[*]DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pdwNumFormatsSupported: ?*u32,
                pFormatsSupported: ?[*]DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInternalMemInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
                pamvaInternalMemInfo: ?*AMVAInternalMemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
                pamvaInternalMemInfo: ?*AMVAInternalMemInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCompBufferInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
                pdwNumTypesCompBuffers: ?*u32,
                pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pGuid: ?*const Guid,
                pamvaUncompDataInfo: ?*const AMVAUncompDataInfo,
                pdwNumTypesCompBuffers: ?*u32,
                pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInternalCompBufferInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pdwNumTypesCompBuffers: ?*u32,
                pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pdwNumTypesCompBuffers: ?*u32,
                pamvaCompBufferInfo: ?[*]AMVACompBufferInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                amvaBeginFrameInfo: ?*const AMVABeginFrameInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                amvaBeginFrameInfo: ?*const AMVABeginFrameInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                pEndFrameInfo: ?*const AMVAEndFrameInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                pEndFrameInfo: ?*const AMVAEndFrameInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
                bReadOnly: BOOL,
                ppBuffer: ?*?*anyopaque,
                lpStride: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
                bReadOnly: BOOL,
                ppBuffer: ?*?*anyopaque,
                lpStride: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Execute: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                dwFunction: u32,
                lpPrivateInputData: ?*anyopaque,
                cbPrivateInputData: u32,
                lpPrivateOutputDat: ?*anyopaque,
                cbPrivateOutputData: u32,
                dwNumBuffers: u32,
                pamvaBufferInfo: [*]const AMVABUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                dwFunction: u32,
                lpPrivateInputData: ?*anyopaque,
                cbPrivateInputData: u32,
                lpPrivateOutputDat: ?*anyopaque,
                cbPrivateOutputData: u32,
                dwNumBuffers: u32,
                pamvaBufferInfo: [*]const AMVABUFFERINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryRenderStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                dwTypeIndex: u32,
                dwBufferIndex: u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMVideoAccelerator,
                dwFlipToIndex: u32,
                pMediaSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMVideoAccelerator,
                dwFlipToIndex: u32,
                pMediaSample: ?*IMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetVideoAcceleratorGUIDs(self: *const T, pdwNumGuidsSupported: ?*u32, pGuidsSupported: ?[*]Guid) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetVideoAcceleratorGUIDs(@as(*const IAMVideoAccelerator, @ptrCast(self)), pdwNumGuidsSupported, pGuidsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetUncompFormatsSupported(self: *const T, pGuid: ?*const Guid, pdwNumFormatsSupported: ?*u32, pFormatsSupported: ?[*]DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetUncompFormatsSupported(@as(*const IAMVideoAccelerator, @ptrCast(self)), pGuid, pdwNumFormatsSupported, pFormatsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetInternalMemInfo(self: *const T, pGuid: ?*const Guid, pamvaUncompDataInfo: ?*const AMVAUncompDataInfo, pamvaInternalMemInfo: ?*AMVAInternalMemInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetInternalMemInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), pGuid, pamvaUncompDataInfo, pamvaInternalMemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetCompBufferInfo(self: *const T, pGuid: ?*const Guid, pamvaUncompDataInfo: ?*const AMVAUncompDataInfo, pdwNumTypesCompBuffers: ?*u32, pamvaCompBufferInfo: ?[*]AMVACompBufferInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetCompBufferInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), pGuid, pamvaUncompDataInfo, pdwNumTypesCompBuffers, pamvaCompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetInternalCompBufferInfo(self: *const T, pdwNumTypesCompBuffers: ?*u32, pamvaCompBufferInfo: ?[*]AMVACompBufferInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetInternalCompBufferInfo(@as(*const IAMVideoAccelerator, @ptrCast(self)), pdwNumTypesCompBuffers, pamvaCompBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_BeginFrame(self: *const T, amvaBeginFrameInfo: ?*const AMVABeginFrameInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).BeginFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), amvaBeginFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_EndFrame(self: *const T, pEndFrameInfo: ?*const AMVAEndFrameInfo) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).EndFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), pEndFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_GetBuffer(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32, bReadOnly: BOOL, ppBuffer: ?*?*anyopaque, lpStride: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).GetBuffer(@as(*const IAMVideoAccelerator, @ptrCast(self)), dwTypeIndex, dwBufferIndex, bReadOnly, ppBuffer, lpStride);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_ReleaseBuffer(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).ReleaseBuffer(@as(*const IAMVideoAccelerator, @ptrCast(self)), dwTypeIndex, dwBufferIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_Execute(self: *const T, dwFunction: u32, lpPrivateInputData: ?*anyopaque, cbPrivateInputData: u32, lpPrivateOutputDat: ?*anyopaque, cbPrivateOutputData: u32, dwNumBuffers: u32, pamvaBufferInfo: [*]const AMVABUFFERINFO) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).Execute(@as(*const IAMVideoAccelerator, @ptrCast(self)), dwFunction, lpPrivateInputData, cbPrivateInputData, lpPrivateOutputDat, cbPrivateOutputData, dwNumBuffers, pamvaBufferInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_QueryRenderStatus(self: *const T, dwTypeIndex: u32, dwBufferIndex: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).QueryRenderStatus(@as(*const IAMVideoAccelerator, @ptrCast(self)), dwTypeIndex, dwBufferIndex, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMVideoAccelerator_DisplayFrame(self: *const T, dwFlipToIndex: u32, pMediaSample: ?*IMediaSample) callconv(.Inline) HRESULT {
            return @as(*const IAMVideoAccelerator.VTable, @ptrCast(self.vtable)).DisplayFrame(@as(*const IAMVideoAccelerator, @ptrCast(self)), dwFlipToIndex, pMediaSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_WST_PAGE = extern struct {
    dwPageNr: u32,
    dwSubPageNr: u32,
    pucPageData: ?*u8,
};

pub const AM_WST_LEVEL = enum(i32) {
    @"5" = 0,
};
pub const AM_WST_LEVEL_1_5 = AM_WST_LEVEL.@"5";

pub const AM_WST_SERVICE = enum(i32) {
    None = 0,
    Text = 1,
    IDS = 2,
    Invalid = 3,
};
pub const AM_WST_SERVICE_None = AM_WST_SERVICE.None;
pub const AM_WST_SERVICE_Text = AM_WST_SERVICE.Text;
pub const AM_WST_SERVICE_IDS = AM_WST_SERVICE.IDS;
pub const AM_WST_SERVICE_Invalid = AM_WST_SERVICE.Invalid;

pub const AM_WST_STATE = enum(i32) {
    ff = 0,
    n = 1,
};
pub const AM_WST_STATE_Off = AM_WST_STATE.ff;
pub const AM_WST_STATE_On = AM_WST_STATE.n;

pub const AM_WST_STYLE = enum(i32) {
    None = 0,
    Invers = 1,
};
pub const AM_WST_STYLE_None = AM_WST_STYLE.None;
pub const AM_WST_STYLE_Invers = AM_WST_STYLE.Invers;

pub const AM_WST_DRAWBGMODE = enum(i32) {
    Opaque = 0,
    Transparent = 1,
};
pub const AM_WST_DRAWBGMODE_Opaque = AM_WST_DRAWBGMODE.Opaque;
pub const AM_WST_DRAWBGMODE_Transparent = AM_WST_DRAWBGMODE.Transparent;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IAMWstDecoder_Value = Guid.initString("c056de21-75c2-11d3-a184-00105aef9f33");
pub const IID_IAMWstDecoder = &IID_IAMWstDecoder_Value;
pub const IAMWstDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecoderLevel: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpLevel: ?*AM_WST_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpLevel: ?*AM_WST_LEVEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentService: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpService: ?*AM_WST_SERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpService: ?*AM_WST_SERVICE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetServiceState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpState: ?*AM_WST_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpState: ?*AM_WST_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetServiceState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                State: AM_WST_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                State: AM_WST_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpbmih: ?*BITMAPINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpbmih: ?*BITMAPINFOHEADER,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpbmi: ?*BITMAPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpbmi: ?*BITMAPINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                pdwPhysColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                pdwPhysColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                dwPhysColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                dwPhysColor: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRedrawAlways: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpbOption: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpbOption: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRedrawAlways: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                bOption: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                bOption: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDrawBackgroundMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                lpMode: ?*AM_WST_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                lpMode: ?*AM_WST_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDrawBackgroundMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                Mode: AM_WST_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                Mode: AM_WST_DRAWBGMODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAnswerMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                bAnswer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                bAnswer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAnswerMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                pbAnswer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                pbAnswer: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHoldPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                bHoldPage: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                bHoldPage: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHoldPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                pbHoldPage: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                pbHoldPage: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                pWstPage: ?*AM_WST_PAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                pWstPage: ?*AM_WST_PAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCurrentPage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWstDecoder,
                WstPage: AM_WST_PAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWstDecoder,
                WstPage: AM_WST_PAGE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetDecoderLevel(self: *const T, lpLevel: ?*AM_WST_LEVEL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetDecoderLevel(@as(*const IAMWstDecoder, @ptrCast(self)), lpLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetCurrentService(self: *const T, lpService: ?*AM_WST_SERVICE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetCurrentService(@as(*const IAMWstDecoder, @ptrCast(self)), lpService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetServiceState(self: *const T, lpState: ?*AM_WST_STATE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetServiceState(@as(*const IAMWstDecoder, @ptrCast(self)), lpState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetServiceState(self: *const T, State: AM_WST_STATE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetServiceState(@as(*const IAMWstDecoder, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetOutputFormat(self: *const T, lpbmih: ?*BITMAPINFOHEADER) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetOutputFormat(@as(*const IAMWstDecoder, @ptrCast(self)), lpbmih);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetOutputFormat(self: *const T, lpbmi: ?*BITMAPINFO) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetOutputFormat(@as(*const IAMWstDecoder, @ptrCast(self)), lpbmi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetBackgroundColor(self: *const T, pdwPhysColor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetBackgroundColor(@as(*const IAMWstDecoder, @ptrCast(self)), pdwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetBackgroundColor(self: *const T, dwPhysColor: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetBackgroundColor(@as(*const IAMWstDecoder, @ptrCast(self)), dwPhysColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetRedrawAlways(self: *const T, lpbOption: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetRedrawAlways(@as(*const IAMWstDecoder, @ptrCast(self)), lpbOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetRedrawAlways(self: *const T, bOption: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetRedrawAlways(@as(*const IAMWstDecoder, @ptrCast(self)), bOption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetDrawBackgroundMode(self: *const T, lpMode: ?*AM_WST_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetDrawBackgroundMode(@as(*const IAMWstDecoder, @ptrCast(self)), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetDrawBackgroundMode(self: *const T, Mode: AM_WST_DRAWBGMODE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetDrawBackgroundMode(@as(*const IAMWstDecoder, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetAnswerMode(self: *const T, bAnswer: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetAnswerMode(@as(*const IAMWstDecoder, @ptrCast(self)), bAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetAnswerMode(self: *const T, pbAnswer: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetAnswerMode(@as(*const IAMWstDecoder, @ptrCast(self)), pbAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetHoldPage(self: *const T, bHoldPage: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetHoldPage(@as(*const IAMWstDecoder, @ptrCast(self)), bHoldPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetHoldPage(self: *const T, pbHoldPage: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetHoldPage(@as(*const IAMWstDecoder, @ptrCast(self)), pbHoldPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_GetCurrentPage(self: *const T, pWstPage: ?*AM_WST_PAGE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).GetCurrentPage(@as(*const IAMWstDecoder, @ptrCast(self)), pWstPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWstDecoder_SetCurrentPage(self: *const T, WstPage: AM_WST_PAGE) callconv(.Inline) HRESULT {
            return @as(*const IAMWstDecoder.VTable, @ptrCast(self.vtable)).SetCurrentPage(@as(*const IAMWstDecoder, @ptrCast(self)), WstPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISelector_Value = Guid.initString("1abdaeca-68b6-4f83-9371-b413907c7b9f");
pub const IID_ISelector = &IID_ISelector_Value;
pub const ISelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_NumSources: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelector,
                pdwNumSources: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelector,
                pdwNumSources: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_SourceNodeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelector,
                pdwPinId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelector,
                pdwPinId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_SourceNodeId: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const ISelector,
                dwPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const ISelector,
                dwPinId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_get_NumSources(self: *const T, pdwNumSources: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISelector.VTable, @ptrCast(self.vtable)).get_NumSources(@as(*const ISelector, @ptrCast(self)), pdwNumSources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_get_SourceNodeId(self: *const T, pdwPinId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ISelector.VTable, @ptrCast(self.vtable)).get_SourceNodeId(@as(*const ISelector, @ptrCast(self)), pdwPinId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelector_put_SourceNodeId(self: *const T, dwPinId: u32) callconv(.Inline) HRESULT {
            return @as(*const ISelector.VTable, @ptrCast(self.vtable)).put_SourceNodeId(@as(*const ISelector, @ptrCast(self)), dwPinId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ICameraControl_Value = Guid.initString("2ba1785d-4d1b-44ef-85e8-c7f1d3f20184");
pub const IID_ICameraControl = &IID_ICameraControl_Value;
pub const ICameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Exposure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Exposure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Exposure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Focus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Focus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Focus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Iris: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Iris: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Iris: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Zoom: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Zoom: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Zoom: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_FocalLengths: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                plOcularFocalLength: ?*i32,
                plObjectiveFocalLengthMin: ?*i32,
                plObjectiveFocalLengthMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                plOcularFocalLength: ?*i32,
                plObjectiveFocalLengthMin: ?*i32,
                plObjectiveFocalLengthMax: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Pan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Pan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Pan: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Tilt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Tilt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Tilt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_PanTilt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pPanValue: ?*i32,
                pTiltValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pPanValue: ?*i32,
                pTiltValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_PanTilt: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                PanValue: i32,
                TiltValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                PanValue: i32,
                TiltValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Roll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Roll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Roll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ExposureRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_ExposureRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_ExposureRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_FocusRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_FocusRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_FocusRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_IrisRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_IrisRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_IrisRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ZoomRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_ZoomRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_ZoomRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_PanRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_PanRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_TiltRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_TiltRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_TiltRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_PanTiltRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pPanValue: ?*i32,
                pTiltValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pPanValue: ?*i32,
                pTiltValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_PanTiltRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                PanValue: i32,
                TiltValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                PanValue: i32,
                TiltValue: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_PanRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_RollRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_RollRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_RollRelative: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ScanMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_ScanMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_PrivacyMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_PrivacyMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICameraControl,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Exposure(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Exposure(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Exposure(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Exposure(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Exposure(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Exposure(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Focus(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Focus(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Focus(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Focus(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Focus(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Focus(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Iris(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Iris(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Iris(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Iris(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Iris(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Iris(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Zoom(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Zoom(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Zoom(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Zoom(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Zoom(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Zoom(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_FocalLengths(self: *const T, plOcularFocalLength: ?*i32, plObjectiveFocalLengthMin: ?*i32, plObjectiveFocalLengthMax: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_FocalLengths(@as(*const ICameraControl, @ptrCast(self)), plOcularFocalLength, plObjectiveFocalLengthMin, plObjectiveFocalLengthMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Pan(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Pan(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Pan(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Pan(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Pan(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Pan(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Tilt(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Tilt(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Tilt(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Tilt(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Tilt(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Tilt(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanTilt(self: *const T, pPanValue: ?*i32, pTiltValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanTilt(@as(*const ICameraControl, @ptrCast(self)), pPanValue, pTiltValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanTilt(self: *const T, PanValue: i32, TiltValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanTilt(@as(*const ICameraControl, @ptrCast(self)), PanValue, TiltValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_Roll(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_Roll(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_Roll(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_Roll(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_Roll(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_Roll(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ExposureRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ExposureRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_ExposureRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_ExposureRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_FocusRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_FocusRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_FocusRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_FocusRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_IrisRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_IrisRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_IrisRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_IrisRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ZoomRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ZoomRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_ZoomRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_ZoomRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_TiltRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_TiltRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_TiltRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_TiltRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PanTiltRelative(self: *const T, pPanValue: ?*i32, pTiltValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PanTiltRelative(@as(*const ICameraControl, @ptrCast(self)), pPanValue, pTiltValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PanTiltRelative(self: *const T, PanValue: i32, TiltValue: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PanTiltRelative(@as(*const ICameraControl, @ptrCast(self)), PanValue, TiltValue, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_PanRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_PanRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_RollRelative(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_RollRelative(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_RollRelative(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_RollRelative(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_getRange_RollRelative(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).getRange_RollRelative(@as(*const ICameraControl, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_ScanMode(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_ScanMode(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_ScanMode(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_ScanMode(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_get_PrivacyMode(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).get_PrivacyMode(@as(*const ICameraControl, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraControl_put_PrivacyMode(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const ICameraControl.VTable, @ptrCast(self.vtable)).put_PrivacyMode(@as(*const ICameraControl, @ptrCast(self)), Value, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVideoProcAmp_Value = Guid.initString("4050560e-42a7-413a-85c2-09269a2d0f44");
pub const IID_IVideoProcAmp = &IID_IVideoProcAmp_Value;
pub const IVideoProcAmp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_BacklightCompensation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_BacklightCompensation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_BacklightCompensation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Brightness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Brightness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Brightness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_ColorEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_ColorEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_ColorEnable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Contrast: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Contrast: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Contrast: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Gamma: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Gamma: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Gamma: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Saturation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Saturation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Saturation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Sharpness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Sharpness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Sharpness: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_WhiteBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_WhiteBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_WhiteBalance: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Gain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Gain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Gain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_Hue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_Hue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_Hue: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_DigitalMultiplier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_DigitalMultiplier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_DigitalMultiplier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_PowerlineFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_PowerlineFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_PowerlineFrequency: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        get_WhiteBalanceComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pValue1: ?*i32,
                pValue2: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pValue1: ?*i32,
                pValue2: ?*i32,
                pFlags: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        put_WhiteBalanceComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                Value1: i32,
                Value2: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                Value1: i32,
                Value2: i32,
                Flags: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        getRange_WhiteBalanceComponent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVideoProcAmp,
                pMin: ?*i32,
                pMax: ?*i32,
                pSteppingDelta: ?*i32,
                pDefault: ?*i32,
                pCapsFlag: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_BacklightCompensation(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_BacklightCompensation(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_BacklightCompensation(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_BacklightCompensation(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Brightness(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Brightness(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Brightness(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Brightness(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_ColorEnable(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_ColorEnable(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_ColorEnable(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_ColorEnable(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Contrast(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Contrast(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Contrast(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Contrast(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Gamma(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Gamma(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Gamma(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Gamma(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Saturation(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Saturation(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Saturation(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Saturation(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Sharpness(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Sharpness(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Sharpness(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Sharpness(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_WhiteBalance(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_WhiteBalance(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_WhiteBalance(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_WhiteBalance(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Gain(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Gain(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Gain(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Gain(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_Hue(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_Hue(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_Hue(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_Hue(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_DigitalMultiplier(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_DigitalMultiplier(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_DigitalMultiplier(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_DigitalMultiplier(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_PowerlineFrequency(self: *const T, pValue: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), pValue, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_PowerlineFrequency(self: *const T, Value: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), Value, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_PowerlineFrequency(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_PowerlineFrequency(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_get_WhiteBalanceComponent(self: *const T, pValue1: ?*i32, pValue2: ?*i32, pFlags: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).get_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), pValue1, pValue2, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_put_WhiteBalanceComponent(self: *const T, Value1: i32, Value2: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).put_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), Value1, Value2, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVideoProcAmp_getRange_WhiteBalanceComponent(self: *const T, pMin: ?*i32, pMax: ?*i32, pSteppingDelta: ?*i32, pDefault: ?*i32, pCapsFlag: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVideoProcAmp.VTable, @ptrCast(self.vtable)).getRange_WhiteBalanceComponent(@as(*const IVideoProcAmp, @ptrCast(self)), pMin, pMax, pSteppingDelta, pDefault, pCapsFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMWMBufferPass_Value = Guid.initString("6dd816d7-e740-4123-9e24-2444412644d8");
pub const IID_IAMWMBufferPass = &IID_IAMWMBufferPass_Value;
pub const IAMWMBufferPass = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWMBufferPass,
                pCallback: ?*IAMWMBufferPassCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWMBufferPass,
                pCallback: ?*IAMWMBufferPassCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWMBufferPass_SetNotify(self: *const T, pCallback: ?*IAMWMBufferPassCallback) callconv(.Inline) HRESULT {
            return @as(*const IAMWMBufferPass.VTable, @ptrCast(self.vtable)).SetNotify(@as(*const IAMWMBufferPass, @ptrCast(self)), pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMWMBufferPassCallback_Value = Guid.initString("b25b8372-d2d2-44b2-8653-1b8dae332489");
pub const IID_IAMWMBufferPassCallback = &IID_IAMWMBufferPassCallback_Value;
pub const IAMWMBufferPassCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMWMBufferPassCallback,
                pNSSBuffer3: ?*INSSBuffer3,
                pPin: ?*IPin,
                prtStart: ?*i64,
                prtEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMWMBufferPassCallback,
                pNSSBuffer3: ?*INSSBuffer3,
                pPin: ?*IPin,
                prtStart: ?*i64,
                prtEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMWMBufferPassCallback_Notify(self: *const T, pNSSBuffer3: ?*INSSBuffer3, pPin: ?*IPin, prtStart: ?*i64, prtEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMWMBufferPassCallback.VTable, @ptrCast(self.vtable)).Notify(@as(*const IAMWMBufferPassCallback, @ptrCast(self)), pNSSBuffer3, pPin, prtStart, prtEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter_Value = Guid.initString("45086030-f7e4-486a-b504-826bb5792a3b");
pub const IID_IConfigAsfWriter = &IID_IConfigAsfWriter_Value;
pub const IConfigAsfWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ConfigureFilterUsingProfileId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                dwProfileId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                dwProfileId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProfileId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                pdwProfileId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                pdwProfileId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureFilterUsingProfileGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                guidProfile: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProfileGuid: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                pProfileGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                pProfileGuid: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ConfigureFilterUsingProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                pProfile: ?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                pProfile: ?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentProfile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                ppProfile: ?*?*IWMProfile,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetIndexMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                bIndexFile: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                bIndexFile: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetIndexMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter,
                pbIndexFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter,
                pbIndexFile: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfileId(self: *const T, dwProfileId: u32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfileId(@as(*const IConfigAsfWriter, @ptrCast(self)), dwProfileId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfileId(self: *const T, pdwProfileId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfileId(@as(*const IConfigAsfWriter, @ptrCast(self)), pdwProfileId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfileGuid(self: *const T, guidProfile: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfileGuid(@as(*const IConfigAsfWriter, @ptrCast(self)), guidProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfileGuid(self: *const T, pProfileGuid: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfileGuid(@as(*const IConfigAsfWriter, @ptrCast(self)), pProfileGuid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_ConfigureFilterUsingProfile(self: *const T, pProfile: ?*IWMProfile) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).ConfigureFilterUsingProfile(@as(*const IConfigAsfWriter, @ptrCast(self)), pProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetCurrentProfile(self: *const T, ppProfile: ?*?*IWMProfile) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetCurrentProfile(@as(*const IConfigAsfWriter, @ptrCast(self)), ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_SetIndexMode(self: *const T, bIndexFile: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).SetIndexMode(@as(*const IConfigAsfWriter, @ptrCast(self)), bIndexFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter_GetIndexMode(self: *const T, pbIndexFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter.VTable, @ptrCast(self.vtable)).GetIndexMode(@as(*const IConfigAsfWriter, @ptrCast(self)), pbIndexFile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IConfigAsfWriter2_Value = Guid.initString("7989ccaa-53f0-44f0-884a-f3b03f6ae066");
pub const IID_IConfigAsfWriter2 = &IID_IConfigAsfWriter2_Value;
pub const IConfigAsfWriter2 = extern struct {
    pub const VTable = extern struct {
        base: IConfigAsfWriter.VTable,
        StreamNumFromPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter2,
                pPin: ?*IPin,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter2,
                pPin: ?*IPin,
                pwStreamNum: ?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter2,
                dwParam: u32,
                dwParam1: u32,
                dwParam2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter2,
                dwParam: u32,
                dwParam1: u32,
                dwParam2: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter2,
                dwParam: u32,
                pdwParam1: ?*u32,
                pdwParam2: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter2,
                dwParam: u32,
                pdwParam1: ?*u32,
                pdwParam2: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ResetMultiPassState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IConfigAsfWriter2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IConfigAsfWriter2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConfigAsfWriter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_StreamNumFromPin(self: *const T, pPin: ?*IPin, pwStreamNum: ?*u16) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).StreamNumFromPin(@as(*const IConfigAsfWriter2, @ptrCast(self)), pPin, pwStreamNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_SetParam(self: *const T, dwParam: u32, dwParam1: u32, dwParam2: u32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).SetParam(@as(*const IConfigAsfWriter2, @ptrCast(self)), dwParam, dwParam1, dwParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_GetParam(self: *const T, dwParam: u32, pdwParam1: ?*u32, pdwParam2: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).GetParam(@as(*const IConfigAsfWriter2, @ptrCast(self)), dwParam, pdwParam1, pdwParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConfigAsfWriter2_ResetMultiPassState(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IConfigAsfWriter2.VTable, @ptrCast(self.vtable)).ResetMultiPassState(@as(*const IConfigAsfWriter2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const STREAM_TYPE = enum(i32) {
    READ = 0,
    WRITE = 1,
    TRANSFORM = 2,
};
pub const STREAMTYPE_READ = STREAM_TYPE.READ;
pub const STREAMTYPE_WRITE = STREAM_TYPE.WRITE;
pub const STREAMTYPE_TRANSFORM = STREAM_TYPE.TRANSFORM;

pub const STREAM_STATE = enum(i32) {
    STOP = 0,
    RUN = 1,
};
pub const STREAMSTATE_STOP = STREAM_STATE.STOP;
pub const STREAMSTATE_RUN = STREAM_STATE.RUN;

pub const COMPLETION_STATUS_FLAGS = enum(i32) {
    NOUPDATEOK = 1,
    WAIT = 2,
    ABORT = 4,
};
pub const COMPSTAT_NOUPDATEOK = COMPLETION_STATUS_FLAGS.NOUPDATEOK;
pub const COMPSTAT_WAIT = COMPLETION_STATUS_FLAGS.WAIT;
pub const COMPSTAT_ABORT = COMPLETION_STATUS_FLAGS.ABORT;

pub const MMSSF_GET_INFORMATION_FLAGS = enum(i32) {
    HASCLOCK = 1,
    SUPPORTSEEK = 2,
    ASYNCHRONOUS = 4,
    _,
    pub fn initFlags(o: struct {
        HASCLOCK: u1 = 0,
        SUPPORTSEEK: u1 = 0,
        ASYNCHRONOUS: u1 = 0,
    }) MMSSF_GET_INFORMATION_FLAGS {
        return @as(MMSSF_GET_INFORMATION_FLAGS, @enumFromInt(
              (if (o.HASCLOCK == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.HASCLOCK) else 0)
            | (if (o.SUPPORTSEEK == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK) else 0)
            | (if (o.ASYNCHRONOUS == 1) @intFromEnum(MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS) else 0)
        ));
    }
};
pub const MMSSF_HASCLOCK = MMSSF_GET_INFORMATION_FLAGS.HASCLOCK;
pub const MMSSF_SUPPORTSEEK = MMSSF_GET_INFORMATION_FLAGS.SUPPORTSEEK;
pub const MMSSF_ASYNCHRONOUS = MMSSF_GET_INFORMATION_FLAGS.ASYNCHRONOUS;

pub const SSUPDATE_TYPE = enum(i32) {
    ASYNC = 1,
    CONTINUOUS = 2,
};
pub const SSUPDATE_ASYNC = SSUPDATE_TYPE.ASYNC;
pub const SSUPDATE_CONTINUOUS = SSUPDATE_TYPE.CONTINUOUS;

const IID_IMultiMediaStream_Value = Guid.initString("b502d1bc-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMultiMediaStream = &IID_IMultiMediaStream_Value;
pub const IMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                pdwFlags: ?*MMSSF_GET_INFORMATION_FLAGS,
                pStreamType: ?*STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                pdwFlags: ?*MMSSF_GET_INFORMATION_FLAGS,
                pStreamType: ?*STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                idPurpose: ?*Guid,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                idPurpose: ?*Guid,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMediaStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                Index: i32,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                Index: i32,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                pCurrentState: ?*STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                pCurrentState: ?*STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                NewState: STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                NewState: STREAM_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                pCurrentTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                pCurrentTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                pDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                pDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Seek: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                SeekTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                SeekTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEndOfStreamEventHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMultiMediaStream,
                phEOS: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMultiMediaStream,
                phEOS: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetInformation(self: *const T, pdwFlags: ?*MMSSF_GET_INFORMATION_FLAGS, pStreamType: ?*STREAM_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetInformation(@as(*const IMultiMediaStream, @ptrCast(self)), pdwFlags, pStreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetMediaStream(self: *const T, idPurpose: ?*Guid, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IMultiMediaStream, @ptrCast(self)), idPurpose, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_EnumMediaStreams(self: *const T, Index: i32, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).EnumMediaStreams(@as(*const IMultiMediaStream, @ptrCast(self)), Index, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetState(self: *const T, pCurrentState: ?*STREAM_STATE) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetState(@as(*const IMultiMediaStream, @ptrCast(self)), pCurrentState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_SetState(self: *const T, NewState: STREAM_STATE) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).SetState(@as(*const IMultiMediaStream, @ptrCast(self)), NewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetTime(self: *const T, pCurrentTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IMultiMediaStream, @ptrCast(self)), pCurrentTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetDuration(self: *const T, pDuration: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetDuration(@as(*const IMultiMediaStream, @ptrCast(self)), pDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_Seek(self: *const T, SeekTime: i64) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).Seek(@as(*const IMultiMediaStream, @ptrCast(self)), SeekTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultiMediaStream_GetEndOfStreamEventHandle(self: *const T, phEOS: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IMultiMediaStream.VTable, @ptrCast(self.vtable)).GetEndOfStreamEventHandle(@as(*const IMultiMediaStream, @ptrCast(self)), phEOS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStream_Value = Guid.initString("b502d1bd-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStream = &IID_IMediaStream_Value;
pub const IMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMultiMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                ppMultiMediaStream: ?*?*IMultiMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                ppMultiMediaStream: ?*?*IMultiMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInformation: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                pPurposeId: ?*Guid,
                pType: ?*STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                pPurposeId: ?*Guid,
                pType: ?*STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSameFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                pStreamThatHasDesiredFormat: ?*IMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                pStreamThatHasDesiredFormat: ?*IMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                dwFlags: u32,
                ppSample: ?*?*IStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                dwFlags: u32,
                ppSample: ?*?*IStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSharedSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                pExistingSample: ?*IStreamSample,
                dwFlags: u32,
                ppNewSample: ?*?*IStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                pExistingSample: ?*IStreamSample,
                dwFlags: u32,
                ppNewSample: ?*?*IStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SendEndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_GetMultiMediaStream(self: *const T, ppMultiMediaStream: ?*?*IMultiMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).GetMultiMediaStream(@as(*const IMediaStream, @ptrCast(self)), ppMultiMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_GetInformation(self: *const T, pPurposeId: ?*Guid, pType: ?*STREAM_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).GetInformation(@as(*const IMediaStream, @ptrCast(self)), pPurposeId, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_SetSameFormat(self: *const T, pStreamThatHasDesiredFormat: ?*IMediaStream, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).SetSameFormat(@as(*const IMediaStream, @ptrCast(self)), pStreamThatHasDesiredFormat, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_AllocateSample(self: *const T, dwFlags: u32, ppSample: ?*?*IStreamSample) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).AllocateSample(@as(*const IMediaStream, @ptrCast(self)), dwFlags, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_CreateSharedSample(self: *const T, pExistingSample: ?*IStreamSample, dwFlags: u32, ppNewSample: ?*?*IStreamSample) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).CreateSharedSample(@as(*const IMediaStream, @ptrCast(self)), pExistingSample, dwFlags, ppNewSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStream_SendEndOfStream(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaStream.VTable, @ptrCast(self.vtable)).SendEndOfStream(@as(*const IMediaStream, @ptrCast(self)), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStreamSample_Value = Guid.initString("b502d1be-9a57-11d0-8fde-00c04fd9189d");
pub const IID_IStreamSample = &IID_IStreamSample_Value;
pub const IStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamSample,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamSample,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSampleTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamSample,
                pStartTime: ?*i64,
                pEndTime: ?*i64,
                pCurrentTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamSample,
                pStartTime: ?*i64,
                pEndTime: ?*i64,
                pCurrentTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSampleTimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamSample,
                pStartTime: ?*const i64,
                pEndTime: ?*const i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamSample,
                pStartTime: ?*const i64,
                pEndTime: ?*const i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Update: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamSample,
                dwFlags: u32,
                hEvent: ?HANDLE,
                pfnAPC: ?PAPCFUNC,
                dwAPCData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamSample,
                dwFlags: u32,
                hEvent: ?HANDLE,
                pfnAPC: ?PAPCFUNC,
                dwAPCData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompletionStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IStreamSample,
                dwFlags: u32,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IStreamSample,
                dwFlags: u32,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_GetMediaStream(self: *const T, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IStreamSample, @ptrCast(self)), ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_GetSampleTimes(self: *const T, pStartTime: ?*i64, pEndTime: ?*i64, pCurrentTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).GetSampleTimes(@as(*const IStreamSample, @ptrCast(self)), pStartTime, pEndTime, pCurrentTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_SetSampleTimes(self: *const T, pStartTime: ?*const i64, pEndTime: ?*const i64) callconv(.Inline) HRESULT {
            return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).SetSampleTimes(@as(*const IStreamSample, @ptrCast(self)), pStartTime, pEndTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_Update(self: *const T, dwFlags: u32, hEvent: ?HANDLE, pfnAPC: ?PAPCFUNC, dwAPCData: usize) callconv(.Inline) HRESULT {
            return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).Update(@as(*const IStreamSample, @ptrCast(self)), dwFlags, hEvent, pfnAPC, dwAPCData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStreamSample_CompletionStatus(self: *const T, dwFlags: u32, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IStreamSample.VTable, @ptrCast(self.vtable)).CompletionStatus(@as(*const IStreamSample, @ptrCast(self)), dwFlags, dwMilliseconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DDSFF_FLAGS = enum(i32) {
    R = 1,
    _,
    pub fn initFlags(o: struct {
        R: u1 = 0,
    }) DDSFF_FLAGS {
        return @as(DDSFF_FLAGS, @enumFromInt(
              (if (o.R == 1) @intFromEnum(DDSFF_FLAGS.R) else 0)
        ));
    }
};
pub const DDSFF_PROGRESSIVERENDER = DDSFF_FLAGS.R;

const IID_IDirectDrawMediaStream_Value = Guid.initString("f4104fce-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawMediaStream = &IID_IDirectDrawMediaStream_Value;
pub const IDirectDrawMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                pDDSDCurrent: ?*DDSURFACEDESC,
                ppDirectDrawPalette: ?*?*IDirectDrawPalette,
                pDDSDDesired: ?*DDSURFACEDESC,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                pDDSDCurrent: ?*DDSURFACEDESC,
                ppDirectDrawPalette: ?*?*IDirectDrawPalette,
                pDDSDDesired: ?*DDSURFACEDESC,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                pDDSurfaceDesc: ?*const DDSURFACEDESC,
                pDirectDrawPalette: ?*IDirectDrawPalette,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                pDDSurfaceDesc: ?*const DDSURFACEDESC,
                pDirectDrawPalette: ?*IDirectDrawPalette,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDirectDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                pDirectDraw: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                pDirectDraw: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                pSurface: ?*IDirectDrawSurface,
                pRect: ?*const RECT,
                dwFlags: u32,
                ppSample: ?*?*IDirectDrawStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                pSurface: ?*IDirectDrawSurface,
                pRect: ?*const RECT,
                dwFlags: u32,
                ppSample: ?*?*IDirectDrawStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTimePerFrame: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaStream,
                pFrameTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaStream,
                pFrameTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetFormat(self: *const T, pDDSDCurrent: ?*DDSURFACEDESC, ppDirectDrawPalette: ?*?*IDirectDrawPalette, pDDSDDesired: ?*DDSURFACEDESC, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_SetFormat(self: *const T, pDDSurfaceDesc: ?*const DDSURFACEDESC, pDirectDrawPalette: ?*IDirectDrawPalette) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pDDSurfaceDesc, pDirectDrawPalette);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawMediaStream, @ptrCast(self)), ppDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_SetDirectDraw(self: *const T, pDirectDraw: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).SetDirectDraw(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_CreateSample(self: *const T, pSurface: ?*IDirectDrawSurface, pRect: ?*const RECT, dwFlags: u32, ppSample: ?*?*IDirectDrawStreamSample) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pSurface, pRect, dwFlags, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaStream_GetTimePerFrame(self: *const T, pFrameTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaStream.VTable, @ptrCast(self.vtable)).GetTimePerFrame(@as(*const IDirectDrawMediaStream, @ptrCast(self)), pFrameTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectDrawStreamSample_Value = Guid.initString("f4104fcf-9a70-11d0-8fde-00c04fd9189d");
pub const IID_IDirectDrawStreamSample = &IID_IDirectDrawStreamSample_Value;
pub const IDirectDrawStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawStreamSample,
                ppDirectDrawSurface: ?*?*IDirectDrawSurface,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawStreamSample,
                ppDirectDrawSurface: ?*?*IDirectDrawSurface,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawStreamSample,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawStreamSample,
                pRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawStreamSample_GetSurface(self: *const T, ppDirectDrawSurface: ?*?*IDirectDrawSurface, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawStreamSample.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IDirectDrawStreamSample, @ptrCast(self)), ppDirectDrawSurface, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawStreamSample_SetRect(self: *const T, pRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawStreamSample.VTable, @ptrCast(self.vtable)).SetRect(@as(*const IDirectDrawStreamSample, @ptrCast(self)), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioMediaStream_Value = Guid.initString("f7537560-a3be-11d0-8212-00c04fc32c45");
pub const IID_IAudioMediaStream = &IID_IAudioMediaStream_Value;
pub const IAudioMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaStream,
                pWaveFormatCurrent: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaStream,
                pWaveFormatCurrent: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaStream,
                lpWaveFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaStream,
                lpWaveFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioMediaStream,
                pAudioData: ?*IAudioData,
                dwFlags: u32,
                ppSample: ?*?*IAudioStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioMediaStream,
                pAudioData: ?*IAudioData,
                dwFlags: u32,
                ppSample: ?*?*IAudioStreamSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_GetFormat(self: *const T, pWaveFormatCurrent: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioMediaStream, @ptrCast(self)), pWaveFormatCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_SetFormat(self: *const T, lpWaveFormat: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAudioMediaStream, @ptrCast(self)), lpWaveFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioMediaStream_CreateSample(self: *const T, pAudioData: ?*IAudioData, dwFlags: u32, ppSample: ?*?*IAudioStreamSample) callconv(.Inline) HRESULT {
            return @as(*const IAudioMediaStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IAudioMediaStream, @ptrCast(self)), pAudioData, dwFlags, ppSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioStreamSample_Value = Guid.initString("345fee00-aba5-11d0-8212-00c04fc32c45");
pub const IID_IAudioStreamSample = &IID_IAudioStreamSample_Value;
pub const IAudioStreamSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        GetAudioData: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioStreamSample,
                ppAudio: ?*?*IAudioData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioStreamSample,
                ppAudio: ?*?*IAudioData,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioStreamSample_GetAudioData(self: *const T, ppAudio: ?*?*IAudioData) callconv(.Inline) HRESULT {
            return @as(*const IAudioStreamSample.VTable, @ptrCast(self.vtable)).GetAudioData(@as(*const IAudioStreamSample, @ptrCast(self)), ppAudio);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMemoryData_Value = Guid.initString("327fc560-af60-11d0-8212-00c04fc32c45");
pub const IID_IMemoryData = &IID_IMemoryData_Value;
pub const IMemoryData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemoryData,
                cbSize: u32,
                pbData: ?*u8,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemoryData,
                cbSize: u32,
                pbData: ?*u8,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemoryData,
                pdwLength: ?*u32,
                ppbData: ?*?*u8,
                pcbActualData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemoryData,
                pdwLength: ?*u32,
                ppbData: ?*?*u8,
                pcbActualData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActual: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMemoryData,
                cbDataValid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMemoryData,
                cbDataValid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_SetBuffer(self: *const T, cbSize: u32, pbData: ?*u8, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).SetBuffer(@as(*const IMemoryData, @ptrCast(self)), cbSize, pbData, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_GetInfo(self: *const T, pdwLength: ?*u32, ppbData: ?*?*u8, pcbActualData: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).GetInfo(@as(*const IMemoryData, @ptrCast(self)), pdwLength, ppbData, pcbActualData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMemoryData_SetActual(self: *const T, cbDataValid: u32) callconv(.Inline) HRESULT {
            return @as(*const IMemoryData.VTable, @ptrCast(self.vtable)).SetActual(@as(*const IMemoryData, @ptrCast(self)), cbDataValid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioData_Value = Guid.initString("54c719c0-af60-11d0-8212-00c04fc32c45");
pub const IID_IAudioData = &IID_IAudioData_Value;
pub const IAudioData = extern struct {
    pub const VTable = extern struct {
        base: IMemoryData.VTable,
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioData,
                pWaveFormatCurrent: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioData,
                pWaveFormatCurrent: ?*WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAudioData,
                lpWaveFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAudioData,
                lpWaveFormat: ?*const WAVEFORMATEX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMemoryData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioData_GetFormat(self: *const T, pWaveFormatCurrent: ?*WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IAudioData.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAudioData, @ptrCast(self)), pWaveFormatCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioData_SetFormat(self: *const T, lpWaveFormat: ?*const WAVEFORMATEX) callconv(.Inline) HRESULT {
            return @as(*const IAudioData.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAudioData, @ptrCast(self)), lpWaveFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMMSF_MMS_INIT_FLAGS = enum(i32) {
    D = 1,
    _,
    pub fn initFlags(o: struct {
        D: u1 = 0,
    }) AMMSF_MMS_INIT_FLAGS {
        return @as(AMMSF_MMS_INIT_FLAGS, @enumFromInt(
              (if (o.D == 1) @intFromEnum(AMMSF_MMS_INIT_FLAGS.D) else 0)
        ));
    }
};
pub const AMMSF_NOGRAPHTHREAD = AMMSF_MMS_INIT_FLAGS.D;

pub const AMMSF_MS_FLAGS = enum(i32) {
    ADDDEFAULTRENDERER = 1,
    CREATEPEER = 2,
    STOPIFNOSAMPLES = 4,
    NOSTALL = 8,
    _,
    pub fn initFlags(o: struct {
        ADDDEFAULTRENDERER: u1 = 0,
        CREATEPEER: u1 = 0,
        STOPIFNOSAMPLES: u1 = 0,
        NOSTALL: u1 = 0,
    }) AMMSF_MS_FLAGS {
        return @as(AMMSF_MS_FLAGS, @enumFromInt(
              (if (o.ADDDEFAULTRENDERER == 1) @intFromEnum(AMMSF_MS_FLAGS.ADDDEFAULTRENDERER) else 0)
            | (if (o.CREATEPEER == 1) @intFromEnum(AMMSF_MS_FLAGS.CREATEPEER) else 0)
            | (if (o.STOPIFNOSAMPLES == 1) @intFromEnum(AMMSF_MS_FLAGS.STOPIFNOSAMPLES) else 0)
            | (if (o.NOSTALL == 1) @intFromEnum(AMMSF_MS_FLAGS.NOSTALL) else 0)
        ));
    }
};
pub const AMMSF_ADDDEFAULTRENDERER = AMMSF_MS_FLAGS.ADDDEFAULTRENDERER;
pub const AMMSF_CREATEPEER = AMMSF_MS_FLAGS.CREATEPEER;
pub const AMMSF_STOPIFNOSAMPLES = AMMSF_MS_FLAGS.STOPIFNOSAMPLES;
pub const AMMSF_NOSTALL = AMMSF_MS_FLAGS.NOSTALL;

pub const AMMSF_RENDER_FLAGS = enum(i32) {
    RENDERTYPEMASK = 3,
    RENDERTOEXISTING = 0,
    RENDERALLSTREAMS = 1,
    NORENDER = 2,
    NOCLOCK = 4,
    RUN = 8,
    _,
    pub fn initFlags(o: struct {
        RENDERTYPEMASK: u1 = 0,
        RENDERTOEXISTING: u1 = 0,
        RENDERALLSTREAMS: u1 = 0,
        NORENDER: u1 = 0,
        NOCLOCK: u1 = 0,
        RUN: u1 = 0,
    }) AMMSF_RENDER_FLAGS {
        return @as(AMMSF_RENDER_FLAGS, @enumFromInt(
              (if (o.RENDERTYPEMASK == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERTYPEMASK) else 0)
            | (if (o.RENDERTOEXISTING == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERTOEXISTING) else 0)
            | (if (o.RENDERALLSTREAMS == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RENDERALLSTREAMS) else 0)
            | (if (o.NORENDER == 1) @intFromEnum(AMMSF_RENDER_FLAGS.NORENDER) else 0)
            | (if (o.NOCLOCK == 1) @intFromEnum(AMMSF_RENDER_FLAGS.NOCLOCK) else 0)
            | (if (o.RUN == 1) @intFromEnum(AMMSF_RENDER_FLAGS.RUN) else 0)
        ));
    }
};
pub const AMMSF_RENDERTYPEMASK = AMMSF_RENDER_FLAGS.RENDERTYPEMASK;
pub const AMMSF_RENDERTOEXISTING = AMMSF_RENDER_FLAGS.RENDERTOEXISTING;
pub const AMMSF_RENDERALLSTREAMS = AMMSF_RENDER_FLAGS.RENDERALLSTREAMS;
pub const AMMSF_NORENDER = AMMSF_RENDER_FLAGS.NORENDER;
pub const AMMSF_NOCLOCK = AMMSF_RENDER_FLAGS.NOCLOCK;
pub const AMMSF_RUN = AMMSF_RENDER_FLAGS.RUN;

pub const OUTPUT_STATE = enum(i32) {
    Disabled = 0,
    ReadData = 1,
    RenderData = 2,
    _,
    pub fn initFlags(o: struct {
        Disabled: u1 = 0,
        ReadData: u1 = 0,
        RenderData: u1 = 0,
    }) OUTPUT_STATE {
        return @as(OUTPUT_STATE, @enumFromInt(
              (if (o.Disabled == 1) @intFromEnum(OUTPUT_STATE.Disabled) else 0)
            | (if (o.ReadData == 1) @intFromEnum(OUTPUT_STATE.ReadData) else 0)
            | (if (o.RenderData == 1) @intFromEnum(OUTPUT_STATE.RenderData) else 0)
        ));
    }
};
pub const Disabled = OUTPUT_STATE.Disabled;
pub const ReadData = OUTPUT_STATE.ReadData;
pub const RenderData = OUTPUT_STATE.RenderData;

const IID_IAMMultiMediaStream_Value = Guid.initString("bebe595c-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMultiMediaStream = &IID_IAMMultiMediaStream_Value;
pub const IAMMultiMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMultiMediaStream.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                StreamType: STREAM_TYPE,
                dwFlags: u32,
                pFilterGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                StreamType: STREAM_TYPE,
                dwFlags: u32,
                pFilterGraph: ?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilterGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                ppGraphBuilder: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                ppGraphBuilder: ?*?*IGraphBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                ppFilter: ?*?*IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                ppFilter: ?*?*IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                pStreamObject: ?*IUnknown,
                PurposeId: ?*const Guid,
                dwFlags: u32,
                ppNewStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                pStreamObject: ?*IUnknown,
                PurposeId: ?*const Guid,
                dwFlags: u32,
                ppNewStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                pszFileName: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                pszFileName: ?[*:0]align(1) const u16,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenMoniker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                pCtx: ?*IBindCtx,
                pMoniker: ?*IMoniker,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                pCtx: ?*IBindCtx,
                pMoniker: ?*IMoniker,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Render: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMultiMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMultiMediaStream,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMultiMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_Initialize(self: *const T, StreamType: STREAM_TYPE, dwFlags: u32, pFilterGraph: ?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAMMultiMediaStream, @ptrCast(self)), StreamType, dwFlags, pFilterGraph);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_GetFilterGraph(self: *const T, ppGraphBuilder: ?*?*IGraphBuilder) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).GetFilterGraph(@as(*const IAMMultiMediaStream, @ptrCast(self)), ppGraphBuilder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_GetFilter(self: *const T, ppFilter: ?*?*IMediaStreamFilter) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).GetFilter(@as(*const IAMMultiMediaStream, @ptrCast(self)), ppFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_AddMediaStream(self: *const T, pStreamObject: ?*IUnknown, PurposeId: ?*const Guid, dwFlags: u32, ppNewStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).AddMediaStream(@as(*const IAMMultiMediaStream, @ptrCast(self)), pStreamObject, PurposeId, dwFlags, ppNewStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_OpenFile(self: *const T, pszFileName: ?[*:0]align(1) const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).OpenFile(@as(*const IAMMultiMediaStream, @ptrCast(self)), pszFileName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_OpenMoniker(self: *const T, pCtx: ?*IBindCtx, pMoniker: ?*IMoniker, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).OpenMoniker(@as(*const IAMMultiMediaStream, @ptrCast(self)), pCtx, pMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMultiMediaStream_Render(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMMultiMediaStream.VTable, @ptrCast(self.vtable)).Render(@as(*const IAMMultiMediaStream, @ptrCast(self)), dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaStream_Value = Guid.initString("bebe595d-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IAMMediaStream = &IID_IAMMediaStream_Value;
pub const IAMMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        Initialize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaStream,
                pSourceObject: ?*IUnknown,
                dwFlags: u32,
                PurposeId: ?*Guid,
                StreamType: STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaStream,
                pSourceObject: ?*IUnknown,
                dwFlags: u32,
                PurposeId: ?*Guid,
                StreamType: STREAM_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaStream,
                State: FILTER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaStream,
                State: FILTER_STATE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JoinAMMultiMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaStream,
                pAMMultiMediaStream: ?*IAMMultiMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaStream,
                pAMMultiMediaStream: ?*IAMMultiMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JoinFilter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaStream,
                pMediaStreamFilter: ?*IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaStream,
                pMediaStreamFilter: ?*IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        JoinFilterGraph: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaStream,
                pFilterGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaStream,
                pFilterGraph: ?*IFilterGraph,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_Initialize(self: *const T, pSourceObject: ?*IUnknown, dwFlags: u32, PurposeId: ?*Guid, StreamType: STREAM_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).Initialize(@as(*const IAMMediaStream, @ptrCast(self)), pSourceObject, dwFlags, PurposeId, StreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_SetState(self: *const T, State: FILTER_STATE) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).SetState(@as(*const IAMMediaStream, @ptrCast(self)), State);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinAMMultiMediaStream(self: *const T, pAMMultiMediaStream: ?*IAMMultiMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinAMMultiMediaStream(@as(*const IAMMediaStream, @ptrCast(self)), pAMMultiMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinFilter(self: *const T, pMediaStreamFilter: ?*IMediaStreamFilter) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinFilter(@as(*const IAMMediaStream, @ptrCast(self)), pMediaStreamFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaStream_JoinFilterGraph(self: *const T, pFilterGraph: ?*IFilterGraph) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaStream.VTable, @ptrCast(self.vtable)).JoinFilterGraph(@as(*const IAMMediaStream, @ptrCast(self)), pFilterGraph);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaStreamFilter_Value = Guid.initString("bebe595e-9a6f-11d0-8fde-00c04fd9189d");
pub const IID_IMediaStreamFilter = &IID_IMediaStreamFilter_Value;
pub const IMediaStreamFilter = extern struct {
    pub const VTable = extern struct {
        base: IBaseFilter.VTable,
        AddMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                pAMMediaStream: ?*IAMMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                pAMMediaStream: ?*IAMMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                idPurpose: ?*Guid,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                idPurpose: ?*Guid,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumMediaStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                Index: i32,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                Index: i32,
                ppMediaStream: ?*?*IMediaStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SupportSeeking: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                bRenderer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                bRenderer: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReferenceTimeToStreamTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                pTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                pTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentStreamTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                pCurrentStreamTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                pCurrentStreamTime: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WaitUntil: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                WaitStreamTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                WaitStreamTime: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Flush: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
                bCancelEOS: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
                bCancelEOS: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndOfStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaStreamFilter,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBaseFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_AddMediaStream(self: *const T, pAMMediaStream: ?*IAMMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).AddMediaStream(@as(*const IMediaStreamFilter, @ptrCast(self)), pAMMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_GetMediaStream(self: *const T, idPurpose: ?*Guid, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).GetMediaStream(@as(*const IMediaStreamFilter, @ptrCast(self)), idPurpose, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_EnumMediaStreams(self: *const T, Index: i32, ppMediaStream: ?*?*IMediaStream) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).EnumMediaStreams(@as(*const IMediaStreamFilter, @ptrCast(self)), Index, ppMediaStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_SupportSeeking(self: *const T, bRenderer: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).SupportSeeking(@as(*const IMediaStreamFilter, @ptrCast(self)), bRenderer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_ReferenceTimeToStreamTime(self: *const T, pTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).ReferenceTimeToStreamTime(@as(*const IMediaStreamFilter, @ptrCast(self)), pTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_GetCurrentStreamTime(self: *const T, pCurrentStreamTime: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).GetCurrentStreamTime(@as(*const IMediaStreamFilter, @ptrCast(self)), pCurrentStreamTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_WaitUntil(self: *const T, WaitStreamTime: i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).WaitUntil(@as(*const IMediaStreamFilter, @ptrCast(self)), WaitStreamTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_Flush(self: *const T, bCancelEOS: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).Flush(@as(*const IMediaStreamFilter, @ptrCast(self)), bCancelEOS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaStreamFilter_EndOfStream(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMediaStreamFilter.VTable, @ptrCast(self.vtable)).EndOfStream(@as(*const IMediaStreamFilter, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSampleAllocator_Value = Guid.initString("ab6b4afc-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSampleAllocator = &IID_IDirectDrawMediaSampleAllocator_Value;
pub const IDirectDrawMediaSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaSampleAllocator,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaSampleAllocator,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSampleAllocator_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaSampleAllocator.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawMediaSampleAllocator, @ptrCast(self)), ppDirectDraw);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawMediaSample_Value = Guid.initString("ab6b4afe-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IDirectDrawMediaSample = &IID_IDirectDrawMediaSample_Value;
pub const IDirectDrawMediaSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSurfaceAndReleaseLock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaSample,
                ppDirectDrawSurface: ?*?*IDirectDrawSurface,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaSample,
                ppDirectDrawSurface: ?*?*IDirectDrawSurface,
                pRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockMediaSamplePointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawMediaSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSample_GetSurfaceAndReleaseLock(self: *const T, ppDirectDrawSurface: ?*?*IDirectDrawSurface, pRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaSample.VTable, @ptrCast(self.vtable)).GetSurfaceAndReleaseLock(@as(*const IDirectDrawMediaSample, @ptrCast(self)), ppDirectDrawSurface, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawMediaSample_LockMediaSamplePointer(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawMediaSample.VTable, @ptrCast(self.vtable)).LockMediaSamplePointer(@as(*const IDirectDrawMediaSample, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeStream_Value = Guid.initString("ab6b4afa-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeStream = &IID_IAMMediaTypeStream_Value;
pub const IAMMediaTypeStream = extern struct {
    pub const VTable = extern struct {
        base: IMediaStream.VTable,
        GetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeStream,
                pMediaType: ?*AM_MEDIA_TYPE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeStream,
                pMediaType: ?*AM_MEDIA_TYPE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeStream,
                pMediaType: ?*AM_MEDIA_TYPE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeStream,
                pMediaType: ?*AM_MEDIA_TYPE,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSample: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeStream,
                lSampleSize: i32,
                pbBuffer: ?*u8,
                dwFlags: u32,
                pUnkOuter: ?*IUnknown,
                ppAMMediaTypeSample: ?*?*IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeStream,
                lSampleSize: i32,
                pbBuffer: ?*u8,
                dwFlags: u32,
                pUnkOuter: ?*IUnknown,
                ppAMMediaTypeSample: ?*?*IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamAllocatorRequirements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeStream,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeStream,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamAllocatorRequirements: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeStream,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeStream,
                pProps: ?*ALLOCATOR_PROPERTIES,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_GetFormat(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).GetFormat(@as(*const IAMMediaTypeStream, @ptrCast(self)), pMediaType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_SetFormat(self: *const T, pMediaType: ?*AM_MEDIA_TYPE, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).SetFormat(@as(*const IAMMediaTypeStream, @ptrCast(self)), pMediaType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_CreateSample(self: *const T, lSampleSize: i32, pbBuffer: ?*u8, dwFlags: u32, pUnkOuter: ?*IUnknown, ppAMMediaTypeSample: ?*?*IAMMediaTypeSample) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).CreateSample(@as(*const IAMMediaTypeStream, @ptrCast(self)), lSampleSize, pbBuffer, dwFlags, pUnkOuter, ppAMMediaTypeSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_GetStreamAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).GetStreamAllocatorRequirements(@as(*const IAMMediaTypeStream, @ptrCast(self)), pProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeStream_SetStreamAllocatorRequirements(self: *const T, pProps: ?*ALLOCATOR_PROPERTIES) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeStream.VTable, @ptrCast(self.vtable)).SetStreamAllocatorRequirements(@as(*const IAMMediaTypeStream, @ptrCast(self)), pProps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMMediaTypeSample_Value = Guid.initString("ab6b4afb-f6e4-11d0-900d-00c04fd9189d");
pub const IID_IAMMediaTypeSample = &IID_IAMMediaTypeSample_Value;
pub const IAMMediaTypeSample = extern struct {
    pub const VTable = extern struct {
        base: IStreamSample.VTable,
        SetPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pBuffer: [*:0]u8,
                lSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pBuffer: [*:0]u8,
                lSize: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                ppBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                ppBuffer: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        GetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsSyncPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSyncPoint: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                bIsSyncPoint: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                bIsSyncPoint: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPreroll: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                bIsPreroll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                bIsPreroll: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
            else => *const fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) i32,
        },
        SetActualDataLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                __MIDL__IAMMediaTypeSample0000: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                __MIDL__IAMMediaTypeSample0000: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                ppMediaType: ?*?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDiscontinuity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDiscontinuity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                bDiscontinuity: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                bDiscontinuity: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMediaTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMediaTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMMediaTypeSample,
                pTimeStart: ?*i64,
                pTimeEnd: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IStreamSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetPointer(self: *const T, pBuffer: [*:0]u8, lSize: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetPointer(@as(*const IAMMediaTypeSample, @ptrCast(self)), pBuffer, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetPointer(self: *const T, ppBuffer: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetPointer(@as(*const IAMMediaTypeSample, @ptrCast(self)), ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetSize(self: *const T) callconv(.Inline) i32 {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetSize(@as(*const IAMMediaTypeSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsSyncPoint(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsSyncPoint(@as(*const IAMMediaTypeSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetSyncPoint(self: *const T, bIsSyncPoint: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetSyncPoint(@as(*const IAMMediaTypeSample, @ptrCast(self)), bIsSyncPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsPreroll(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsPreroll(@as(*const IAMMediaTypeSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetPreroll(self: *const T, bIsPreroll: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetPreroll(@as(*const IAMMediaTypeSample, @ptrCast(self)), bIsPreroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetActualDataLength(self: *const T) callconv(.Inline) i32 {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetActualDataLength(@as(*const IAMMediaTypeSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetActualDataLength(self: *const T, __MIDL__IAMMediaTypeSample0000: i32) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetActualDataLength(@as(*const IAMMediaTypeSample, @ptrCast(self)), __MIDL__IAMMediaTypeSample0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetMediaType(self: *const T, ppMediaType: ?*?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetMediaType(@as(*const IAMMediaTypeSample, @ptrCast(self)), ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetMediaType(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetMediaType(@as(*const IAMMediaTypeSample, @ptrCast(self)), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_IsDiscontinuity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).IsDiscontinuity(@as(*const IAMMediaTypeSample, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetDiscontinuity(self: *const T, bDiscontinuity: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetDiscontinuity(@as(*const IAMMediaTypeSample, @ptrCast(self)), bDiscontinuity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_GetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).GetMediaTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMMediaTypeSample_SetMediaTime(self: *const T, pTimeStart: ?*i64, pTimeEnd: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMMediaTypeSample.VTable, @ptrCast(self.vtable)).SetMediaTime(@as(*const IAMMediaTypeSample, @ptrCast(self)), pTimeStart, pTimeEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IDirectDrawVideo_Value = Guid.initString("36d39eb0-dd75-11ce-bf0e-00aa0055595a");
pub const IID_IDirectDrawVideo = &IID_IDirectDrawVideo_Value;
pub const IDirectDrawVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSwitches: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pSwitches: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pSwitches: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSwitches: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                Switches: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                Switches: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pCaps: ?*DDCAPS_DX7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pCaps: ?*DDCAPS_DX7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetEmulatedCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pCaps: ?*DDCAPS_DX7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pCaps: ?*DDCAPS_DX7,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurfaceDesc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pSurfaceDesc: ?*DDSURFACEDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pSurfaceDesc: ?*DDSURFACEDESC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetFourCCCodes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pCount: ?*u32,
                pCodes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pCount: ?*u32,
                pCodes: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pDirectDraw: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pDirectDraw: ?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDirectDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                ppDirectDraw: ?*?*IDirectDraw,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurfaceType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                pSurfaceType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                pSurfaceType: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UseScanLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseScanLine: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseScanLine: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanUseScanLine: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseScanLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseScanLine: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UseOverlayStretch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseOverlayStretch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseOverlayStretch: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanUseOverlayStretch: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseOverlayStretch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseOverlayStretch: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UseWhenFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseWhenFullScreen: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseWhenFullScreen: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        WillUseFullScreen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDirectDrawVideo,
                UseWhenFullScreen: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDirectDrawVideo,
                UseWhenFullScreen: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSwitches(self: *const T, pSwitches: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSwitches(@as(*const IDirectDrawVideo, @ptrCast(self)), pSwitches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetSwitches(self: *const T, Switches: u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetSwitches(@as(*const IDirectDrawVideo, @ptrCast(self)), Switches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetCaps(self: *const T, pCaps: ?*DDCAPS_DX7) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetCaps(@as(*const IDirectDrawVideo, @ptrCast(self)), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetEmulatedCaps(self: *const T, pCaps: ?*DDCAPS_DX7) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetEmulatedCaps(@as(*const IDirectDrawVideo, @ptrCast(self)), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSurfaceDesc(self: *const T, pSurfaceDesc: ?*DDSURFACEDESC) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSurfaceDesc(@as(*const IDirectDrawVideo, @ptrCast(self)), pSurfaceDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetFourCCCodes(self: *const T, pCount: ?*u32, pCodes: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetFourCCCodes(@as(*const IDirectDrawVideo, @ptrCast(self)), pCount, pCodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetDirectDraw(self: *const T, pDirectDraw: ?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetDirectDraw(@as(*const IDirectDrawVideo, @ptrCast(self)), pDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetDirectDraw(self: *const T, ppDirectDraw: ?*?*IDirectDraw) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetDirectDraw(@as(*const IDirectDrawVideo, @ptrCast(self)), ppDirectDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_GetSurfaceType(self: *const T, pSurfaceType: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).GetSurfaceType(@as(*const IDirectDrawVideo, @ptrCast(self)), pSurfaceType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_SetDefault(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).SetDefault(@as(*const IDirectDrawVideo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseScanLine(self: *const T, UseScanLine: i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseScanLine(@as(*const IDirectDrawVideo, @ptrCast(self)), UseScanLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_CanUseScanLine(self: *const T, UseScanLine: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).CanUseScanLine(@as(*const IDirectDrawVideo, @ptrCast(self)), UseScanLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseOverlayStretch(self: *const T, UseOverlayStretch: i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseOverlayStretch(@as(*const IDirectDrawVideo, @ptrCast(self)), UseOverlayStretch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_CanUseOverlayStretch(self: *const T, UseOverlayStretch: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).CanUseOverlayStretch(@as(*const IDirectDrawVideo, @ptrCast(self)), UseOverlayStretch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_UseWhenFullScreen(self: *const T, UseWhenFullScreen: i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).UseWhenFullScreen(@as(*const IDirectDrawVideo, @ptrCast(self)), UseWhenFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectDrawVideo_WillUseFullScreen(self: *const T, UseWhenFullScreen: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IDirectDrawVideo.VTable, @ptrCast(self.vtable)).WillUseFullScreen(@as(*const IDirectDrawVideo, @ptrCast(self)), UseWhenFullScreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IQualProp_Value = Guid.initString("1bd0ecb0-f8e2-11ce-aac6-0020af0b99a3");
pub const IID_IQualProp = &IID_IQualProp_Value;
pub const IQualProp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDroppedInRenderer: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                pcFrames: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                pcFrames: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FramesDrawn: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                pcFramesDrawn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                pcFramesDrawn: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgFrameRate: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                piAvgFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                piAvgFrameRate: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Jitter: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                iJitter: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                iJitter: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AvgSyncOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                piAvg: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                piAvg: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DevSyncOffset: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IQualProp,
                piDev: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IQualProp,
                piDev: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_FramesDroppedInRenderer(self: *const T, pcFrames: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_FramesDroppedInRenderer(@as(*const IQualProp, @ptrCast(self)), pcFrames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_FramesDrawn(self: *const T, pcFramesDrawn: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_FramesDrawn(@as(*const IQualProp, @ptrCast(self)), pcFramesDrawn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_AvgFrameRate(self: *const T, piAvgFrameRate: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_AvgFrameRate(@as(*const IQualProp, @ptrCast(self)), piAvgFrameRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_Jitter(self: *const T, iJitter: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_Jitter(@as(*const IQualProp, @ptrCast(self)), iJitter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_AvgSyncOffset(self: *const T, piAvg: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_AvgSyncOffset(@as(*const IQualProp, @ptrCast(self)), piAvg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQualProp_get_DevSyncOffset(self: *const T, piDev: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IQualProp.VTable, @ptrCast(self.vtable)).get_DevSyncOffset(@as(*const IQualProp, @ptrCast(self)), piDev);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFullScreenVideo_Value = Guid.initString("dd1d7110-7836-11cf-bf47-00aa0055595a");
pub const IID_IFullScreenVideo = &IID_IFullScreenVideo_Value;
pub const IFullScreenVideo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CountModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                pModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                pModes: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModeInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Mode: i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
                pDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Mode: i32,
                pWidth: ?*i32,
                pHeight: ?*i32,
                pDepth: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                pMode: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsModeAvailable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsModeEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Mode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEnabled: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Mode: i32,
                bEnabled: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Mode: i32,
                bEnabled: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClipFactor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                pClipFactor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                pClipFactor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClipFactor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                ClipFactor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                ClipFactor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMessageDrain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMessageDrain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                hwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                hwnd: ?*?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Monitor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Monitor: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Monitor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Monitor: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        HideOnDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                Hide: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                Hide: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsHideOnDeactivate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCaption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                strCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                strCaption: ?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCaption: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
                pstrCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
                pstrCaption: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefault: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_CountModes(self: *const T, pModes: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).CountModes(@as(*const IFullScreenVideo, @ptrCast(self)), pModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetModeInfo(self: *const T, Mode: i32, pWidth: ?*i32, pHeight: ?*i32, pDepth: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetModeInfo(@as(*const IFullScreenVideo, @ptrCast(self)), Mode, pWidth, pHeight, pDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetCurrentMode(self: *const T, pMode: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetCurrentMode(@as(*const IFullScreenVideo, @ptrCast(self)), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsModeAvailable(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsModeAvailable(@as(*const IFullScreenVideo, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsModeEnabled(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsModeEnabled(@as(*const IFullScreenVideo, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetEnabled(self: *const T, Mode: i32, bEnabled: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetEnabled(@as(*const IFullScreenVideo, @ptrCast(self)), Mode, bEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetClipFactor(self: *const T, pClipFactor: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetClipFactor(@as(*const IFullScreenVideo, @ptrCast(self)), pClipFactor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetClipFactor(self: *const T, ClipFactor: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetClipFactor(@as(*const IFullScreenVideo, @ptrCast(self)), ClipFactor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetMessageDrain(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetMessageDrain(@as(*const IFullScreenVideo, @ptrCast(self)), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetMessageDrain(self: *const T, hwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetMessageDrain(@as(*const IFullScreenVideo, @ptrCast(self)), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetMonitor(self: *const T, Monitor: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IFullScreenVideo, @ptrCast(self)), Monitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetMonitor(self: *const T, Monitor: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IFullScreenVideo, @ptrCast(self)), Monitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_HideOnDeactivate(self: *const T, Hide: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).HideOnDeactivate(@as(*const IFullScreenVideo, @ptrCast(self)), Hide);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_IsHideOnDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).IsHideOnDeactivate(@as(*const IFullScreenVideo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetCaption(self: *const T, strCaption: ?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetCaption(@as(*const IFullScreenVideo, @ptrCast(self)), strCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_GetCaption(self: *const T, pstrCaption: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).GetCaption(@as(*const IFullScreenVideo, @ptrCast(self)), pstrCaption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideo_SetDefault(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideo.VTable, @ptrCast(self.vtable)).SetDefault(@as(*const IFullScreenVideo, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IFullScreenVideoEx_Value = Guid.initString("53479470-f1dd-11cf-bc42-00aa00ac74f6");
pub const IID_IFullScreenVideoEx = &IID_IFullScreenVideoEx_Value;
pub const IFullScreenVideoEx = extern struct {
    pub const VTable = extern struct {
        base: IFullScreenVideo.VTable,
        SetAcceleratorTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideoEx,
                hwnd: ?HWND,
                hAccel: ?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideoEx,
                hwnd: ?HWND,
                hAccel: ?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAcceleratorTable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideoEx,
                phwnd: ?*?HWND,
                phAccel: ?*?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideoEx,
                phwnd: ?*?HWND,
                phAccel: ?*?HACCEL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        KeepPixelAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideoEx,
                KeepAspect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideoEx,
                KeepAspect: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsKeepPixelAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IFullScreenVideoEx,
                pKeepAspect: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IFullScreenVideoEx,
                pKeepAspect: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IFullScreenVideo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_SetAcceleratorTable(self: *const T, hwnd: ?HWND, hAccel: ?HACCEL) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).SetAcceleratorTable(@as(*const IFullScreenVideoEx, @ptrCast(self)), hwnd, hAccel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_GetAcceleratorTable(self: *const T, phwnd: ?*?HWND, phAccel: ?*?HACCEL) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).GetAcceleratorTable(@as(*const IFullScreenVideoEx, @ptrCast(self)), phwnd, phAccel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_KeepPixelAspectRatio(self: *const T, KeepAspect: i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).KeepPixelAspectRatio(@as(*const IFullScreenVideoEx, @ptrCast(self)), KeepAspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFullScreenVideoEx_IsKeepPixelAspectRatio(self: *const T, pKeepAspect: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IFullScreenVideoEx.VTable, @ptrCast(self.vtable)).IsKeepPixelAspectRatio(@as(*const IFullScreenVideoEx, @ptrCast(self)), pKeepAspect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBaseVideoMixer_Value = Guid.initString("61ded640-e912-11ce-a099-00aa00479a58");
pub const IID_IBaseVideoMixer = &IID_IBaseVideoMixer_Value;
pub const IBaseVideoMixer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLeadPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                iPin: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                iPin: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLeadPin: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                piPin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                piPin: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInputPinCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                piPinCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                piPinCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsUsingClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                pbValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                pbValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUsingClock: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                bValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                bValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetClockPeriod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                pbValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                pbValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetClockPeriod: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBaseVideoMixer,
                bValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBaseVideoMixer,
                bValue: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetLeadPin(self: *const T, iPin: i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetLeadPin(@as(*const IBaseVideoMixer, @ptrCast(self)), iPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetLeadPin(self: *const T, piPin: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetLeadPin(@as(*const IBaseVideoMixer, @ptrCast(self)), piPin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetInputPinCount(self: *const T, piPinCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetInputPinCount(@as(*const IBaseVideoMixer, @ptrCast(self)), piPinCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_IsUsingClock(self: *const T, pbValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).IsUsingClock(@as(*const IBaseVideoMixer, @ptrCast(self)), pbValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetUsingClock(self: *const T, bValue: i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetUsingClock(@as(*const IBaseVideoMixer, @ptrCast(self)), bValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_GetClockPeriod(self: *const T, pbValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).GetClockPeriod(@as(*const IBaseVideoMixer, @ptrCast(self)), pbValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBaseVideoMixer_SetClockPeriod(self: *const T, bValue: i32) callconv(.Inline) HRESULT {
            return @as(*const IBaseVideoMixer.VTable, @ptrCast(self.vtable)).SetClockPeriod(@as(*const IBaseVideoMixer, @ptrCast(self)), bValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TRUECOLORINFO = extern struct {
    dwBitMasks: [3]u32,
    bmiColors: [256]RGBQUAD,
};

pub const VIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwBitRate: u32,
    dwBitErrorRate: u32,
    AvgTimePerFrame: i64,
    bmiHeader: BITMAPINFOHEADER,
    Anonymous: extern union {
        bmiColors: [256]RGBQUAD,
        dwBitMasks: [3]u32,
        TrueColorInfo: TRUECOLORINFO,
    },
};

pub const ANALOGVIDEOINFO = extern struct {
    rcSource: RECT,
    rcTarget: RECT,
    dwActiveWidth: u32,
    dwActiveHeight: u32,
    AvgTimePerFrame: i64,
};

pub const AM_PROPERTY_FRAMESTEP = enum(i32) {
    STEP = 1,
    CANCEL = 2,
    CANSTEP = 3,
    CANSTEPMULTIPLE = 4,
};
pub const AM_PROPERTY_FRAMESTEP_STEP = AM_PROPERTY_FRAMESTEP.STEP;
pub const AM_PROPERTY_FRAMESTEP_CANCEL = AM_PROPERTY_FRAMESTEP.CANCEL;
pub const AM_PROPERTY_FRAMESTEP_CANSTEP = AM_PROPERTY_FRAMESTEP.CANSTEP;
pub const AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = AM_PROPERTY_FRAMESTEP.CANSTEPMULTIPLE;

pub const AM_FRAMESTEP_STEP = extern struct {
    dwFramesToStep: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IDMOWrapperFilter_Value = Guid.initString("52d6f586-9f0f-4824-8fc8-e32ca04930c2");
pub const IID_IDMOWrapperFilter = &IID_IDMOWrapperFilter_Value;
pub const IDMOWrapperFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDMOWrapperFilter,
                clsidDMO: ?*const Guid,
                catDMO: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDMOWrapperFilter,
                clsidDMO: ?*const Guid,
                catDMO: ?*const Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDMOWrapperFilter_Init(self: *const T, clsidDMO: ?*const Guid, catDMO: ?*const Guid) callconv(.Inline) HRESULT {
            return @as(*const IDMOWrapperFilter.VTable, @ptrCast(self.vtable)).Init(@as(*const IDMOWrapperFilter, @ptrCast(self)), clsidDMO, catDMO);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCXNotify_Value = Guid.initString("81a3bd31-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCXNotify = &IID_IMixerOCXNotify_Value;
pub const IMixerOCXNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnInvalidateRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCXNotify,
                lpcRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCXNotify,
                lpcRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnStatusChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCXNotify,
                ulStatusFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCXNotify,
                ulStatusFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDataChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCXNotify,
                ulDataFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCXNotify,
                ulDataFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnInvalidateRect(self: *const T, lpcRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnInvalidateRect(@as(*const IMixerOCXNotify, @ptrCast(self)), lpcRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnStatusChange(self: *const T, ulStatusFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnStatusChange(@as(*const IMixerOCXNotify, @ptrCast(self)), ulStatusFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCXNotify_OnDataChange(self: *const T, ulDataFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCXNotify.VTable, @ptrCast(self.vtable)).OnDataChange(@as(*const IMixerOCXNotify, @ptrCast(self)), ulDataFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerOCX_Value = Guid.initString("81a3bd32-dee1-11d1-8508-00a0c91f9ca0");
pub const IID_IMixerOCX = &IID_IMixerOCX_Value;
pub const IMixerOCX = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDisplayChange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                ulBitsPerPixel: u32,
                ulScreenWidth: u32,
                ulScreenHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                ulBitsPerPixel: u32,
                ulScreenWidth: u32,
                ulScreenHeight: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatio: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                pdwPictAspectRatioX: ?*u32,
                pdwPictAspectRatioY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                pdwPictAspectRatioX: ?*u32,
                pdwPictAspectRatioY: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                pdwVideoWidth: ?*u32,
                pdwVideoHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                pdwVideoWidth: ?*u32,
                pdwVideoHeight: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStatus: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                pdwStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                pdwStatus: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnDraw: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                hdcDraw: ?HDC,
                prcDraw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                hdcDraw: ?HDC,
                prcDraw: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDrawRegion: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                lpptTopLeftSC: ?*POINT,
                prcDrawCC: ?*RECT,
                lprcClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                lpptTopLeftSC: ?*POINT,
                prcDrawCC: ?*RECT,
                lprcClip: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Advise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
                pmdns: ?*IMixerOCXNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
                pmdns: ?*IMixerOCXNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnAdvise: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerOCX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerOCX,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_OnDisplayChange(self: *const T, ulBitsPerPixel: u32, ulScreenWidth: u32, ulScreenHeight: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).OnDisplayChange(@as(*const IMixerOCX, @ptrCast(self)), ulBitsPerPixel, ulScreenWidth, ulScreenHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetAspectRatio(self: *const T, pdwPictAspectRatioX: ?*u32, pdwPictAspectRatioY: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetAspectRatio(@as(*const IMixerOCX, @ptrCast(self)), pdwPictAspectRatioX, pdwPictAspectRatioY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetVideoSize(self: *const T, pdwVideoWidth: ?*u32, pdwVideoHeight: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetVideoSize(@as(*const IMixerOCX, @ptrCast(self)), pdwVideoWidth, pdwVideoHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_GetStatus(self: *const T, pdwStatus: ?*?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).GetStatus(@as(*const IMixerOCX, @ptrCast(self)), pdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_OnDraw(self: *const T, hdcDraw: ?HDC, prcDraw: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).OnDraw(@as(*const IMixerOCX, @ptrCast(self)), hdcDraw, prcDraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_SetDrawRegion(self: *const T, lpptTopLeftSC: ?*POINT, prcDrawCC: ?*RECT, lprcClip: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).SetDrawRegion(@as(*const IMixerOCX, @ptrCast(self)), lpptTopLeftSC, prcDrawCC, lprcClip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_Advise(self: *const T, pmdns: ?*IMixerOCXNotify) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).Advise(@as(*const IMixerOCX, @ptrCast(self)), pmdns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerOCX_UnAdvise(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IMixerOCX.VTable, @ptrCast(self.vtable)).UnAdvise(@as(*const IMixerOCX, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_ASPECT_RATIO_MODE = enum(i32) {
    STRETCHED = 0,
    LETTER_BOX = 1,
    CROP = 2,
    STRETCHED_AS_PRIMARY = 3,
};
pub const AM_ARMODE_STRETCHED = AM_ASPECT_RATIO_MODE.STRETCHED;
pub const AM_ARMODE_LETTER_BOX = AM_ASPECT_RATIO_MODE.LETTER_BOX;
pub const AM_ARMODE_CROP = AM_ASPECT_RATIO_MODE.CROP;
pub const AM_ARMODE_STRETCHED_AS_PRIMARY = AM_ASPECT_RATIO_MODE.STRETCHED_AS_PRIMARY;

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerPinConfig_Value = Guid.initString("593cdde1-0759-11d1-9e69-00c04fd7c15b");
pub const IID_IMixerPinConfig = &IID_IMixerPinConfig_Value;
pub const IMixerPinConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRelativePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                dwLeft: u32,
                dwTop: u32,
                dwRight: u32,
                dwBottom: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                dwLeft: u32,
                dwTop: u32,
                dwRight: u32,
                dwBottom: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRelativePosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pdwLeft: ?*u32,
                pdwTop: ?*u32,
                pdwRight: ?*u32,
                pdwBottom: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pdwLeft: ?*u32,
                pdwTop: ?*u32,
                pdwRight: ?*u32,
                pdwBottom: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                dwZOrder: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                dwZOrder: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pdwZOrder: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pdwZOrder: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pColorKey: ?*COLORKEY,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetColorKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pColorKey: ?*COLORKEY,
                pColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pColorKey: ?*COLORKEY,
                pColor: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBlendingParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                dwBlendingParameter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                dwBlendingParameter: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBlendingParameter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pdwBlendingParameter: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pdwBlendingParameter: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                amAspectRatioMode: AM_ASPECT_RATIO_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                amAspectRatioMode: AM_ASPECT_RATIO_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pamAspectRatioMode: ?*AM_ASPECT_RATIO_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pamAspectRatioMode: ?*AM_ASPECT_RATIO_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamTransparent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                bStreamTransparent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                bStreamTransparent: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamTransparent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig,
                pbStreamTransparent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig,
                pbStreamTransparent: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetRelativePosition(self: *const T, dwLeft: u32, dwTop: u32, dwRight: u32, dwBottom: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetRelativePosition(@as(*const IMixerPinConfig, @ptrCast(self)), dwLeft, dwTop, dwRight, dwBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetRelativePosition(self: *const T, pdwLeft: ?*u32, pdwTop: ?*u32, pdwRight: ?*u32, pdwBottom: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetRelativePosition(@as(*const IMixerPinConfig, @ptrCast(self)), pdwLeft, pdwTop, pdwRight, pdwBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetZOrder(self: *const T, dwZOrder: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IMixerPinConfig, @ptrCast(self)), dwZOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetZOrder(self: *const T, pdwZOrder: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IMixerPinConfig, @ptrCast(self)), pdwZOrder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetColorKey(self: *const T, pColorKey: ?*COLORKEY) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetColorKey(@as(*const IMixerPinConfig, @ptrCast(self)), pColorKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetColorKey(self: *const T, pColorKey: ?*COLORKEY, pColor: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetColorKey(@as(*const IMixerPinConfig, @ptrCast(self)), pColorKey, pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetBlendingParameter(self: *const T, dwBlendingParameter: u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetBlendingParameter(@as(*const IMixerPinConfig, @ptrCast(self)), dwBlendingParameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetBlendingParameter(self: *const T, pdwBlendingParameter: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetBlendingParameter(@as(*const IMixerPinConfig, @ptrCast(self)), pdwBlendingParameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetAspectRatioMode(self: *const T, amAspectRatioMode: AM_ASPECT_RATIO_MODE) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IMixerPinConfig, @ptrCast(self)), amAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetAspectRatioMode(self: *const T, pamAspectRatioMode: ?*AM_ASPECT_RATIO_MODE) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IMixerPinConfig, @ptrCast(self)), pamAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_SetStreamTransparent(self: *const T, bStreamTransparent: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).SetStreamTransparent(@as(*const IMixerPinConfig, @ptrCast(self)), bStreamTransparent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig_GetStreamTransparent(self: *const T, pbStreamTransparent: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig.VTable, @ptrCast(self.vtable)).GetStreamTransparent(@as(*const IMixerPinConfig, @ptrCast(self)), pbStreamTransparent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMixerPinConfig2_Value = Guid.initString("ebf47182-8764-11d1-9e69-00c04fd7c15b");
pub const IID_IMixerPinConfig2 = &IID_IMixerPinConfig2_Value;
pub const IMixerPinConfig2 = extern struct {
    pub const VTable = extern struct {
        base: IMixerPinConfig.VTable,
        SetOverlaySurfaceColorControls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig2,
                pColorControl: ?*DDCOLORCONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig2,
                pColorControl: ?*DDCOLORCONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlaySurfaceColorControls: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMixerPinConfig2,
                pColorControl: ?*DDCOLORCONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMixerPinConfig2,
                pColorControl: ?*DDCOLORCONTROL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMixerPinConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig2_SetOverlaySurfaceColorControls(self: *const T, pColorControl: ?*DDCOLORCONTROL) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig2.VTable, @ptrCast(self.vtable)).SetOverlaySurfaceColorControls(@as(*const IMixerPinConfig2, @ptrCast(self)), pColorControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMixerPinConfig2_GetOverlaySurfaceColorControls(self: *const T, pColorControl: ?*DDCOLORCONTROL) callconv(.Inline) HRESULT {
            return @as(*const IMixerPinConfig2.VTable, @ptrCast(self.vtable)).GetOverlaySurfaceColorControls(@as(*const IMixerPinConfig2, @ptrCast(self)), pColorControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AM_MPEGSTREAMTYPE = extern struct {
    dwStreamId: u32,
    dwReserved: u32,
    mt: AM_MEDIA_TYPE,
    bFormat: [1]u8,
};

pub const AM_MPEGSYSTEMTYPE = extern struct {
    dwBitRate: u32,
    cStreams: u32,
    Streams: [1]AM_MPEGSTREAMTYPE,
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IMpegAudioDecoder_Value = Guid.initString("b45dd570-3c77-11d1-abe1-00a0c905f375");
pub const IID_IMpegAudioDecoder = &IID_IMpegAudioDecoder_Value;
pub const IMpegAudioDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_FrequencyDivider: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pDivider: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pDivider: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_FrequencyDivider: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                Divider: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                Divider: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderAccuracy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pAccuracy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pAccuracy: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderAccuracy: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                Accuracy: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                Accuracy: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Stereo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pStereo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pStereo: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Stereo: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                Stereo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                Stereo: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DecoderWordSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pWordSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pWordSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DecoderWordSize: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                WordSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                WordSize: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_IntegerDecode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pIntDecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pIntDecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_IntegerDecode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                IntDecode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                IntDecode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DualMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                pIntDecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                pIntDecode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_DualMode: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                IntDecode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                IntDecode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AudioFormat: switch (@import("builtin").zig_backend) {
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            .stage1 => fn(
                self: *const IMpegAudioDecoder,
                lpFmt: ?*MPEG1WAVEFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            // TODO: this function has a "SpecialName", should Zig do anything with this?
            else => *const fn(
                self: *const IMpegAudioDecoder,
                lpFmt: ?*MPEG1WAVEFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_FrequencyDivider(self: *const T, pDivider: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_FrequencyDivider(@as(*const IMpegAudioDecoder, @ptrCast(self)), pDivider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_FrequencyDivider(self: *const T, Divider: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_FrequencyDivider(@as(*const IMpegAudioDecoder, @ptrCast(self)), Divider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DecoderAccuracy(self: *const T, pAccuracy: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DecoderAccuracy(@as(*const IMpegAudioDecoder, @ptrCast(self)), pAccuracy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DecoderAccuracy(self: *const T, Accuracy: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DecoderAccuracy(@as(*const IMpegAudioDecoder, @ptrCast(self)), Accuracy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_Stereo(self: *const T, pStereo: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_Stereo(@as(*const IMpegAudioDecoder, @ptrCast(self)), pStereo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_Stereo(self: *const T, Stereo: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_Stereo(@as(*const IMpegAudioDecoder, @ptrCast(self)), Stereo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DecoderWordSize(self: *const T, pWordSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DecoderWordSize(@as(*const IMpegAudioDecoder, @ptrCast(self)), pWordSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DecoderWordSize(self: *const T, WordSize: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DecoderWordSize(@as(*const IMpegAudioDecoder, @ptrCast(self)), WordSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_IntegerDecode(self: *const T, pIntDecode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_IntegerDecode(@as(*const IMpegAudioDecoder, @ptrCast(self)), pIntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_IntegerDecode(self: *const T, IntDecode: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_IntegerDecode(@as(*const IMpegAudioDecoder, @ptrCast(self)), IntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_DualMode(self: *const T, pIntDecode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_DualMode(@as(*const IMpegAudioDecoder, @ptrCast(self)), pIntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_put_DualMode(self: *const T, IntDecode: u32) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).put_DualMode(@as(*const IMpegAudioDecoder, @ptrCast(self)), IntDecode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMpegAudioDecoder_get_AudioFormat(self: *const T, lpFmt: ?*MPEG1WAVEFORMAT) callconv(.Inline) HRESULT {
            return @as(*const IMpegAudioDecoder.VTable, @ptrCast(self.vtable)).get_AudioFormat(@as(*const IMpegAudioDecoder, @ptrCast(self)), lpFmt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9PresentationFlags = enum(i32) {
    SyncPoint = 1,
    Preroll = 2,
    Discontinuity = 4,
    TimeValid = 8,
    SrcDstRectsValid = 16,
};
pub const VMR9Sample_SyncPoint = VMR9PresentationFlags.SyncPoint;
pub const VMR9Sample_Preroll = VMR9PresentationFlags.Preroll;
pub const VMR9Sample_Discontinuity = VMR9PresentationFlags.Discontinuity;
pub const VMR9Sample_TimeValid = VMR9PresentationFlags.TimeValid;
pub const VMR9Sample_SrcDstRectsValid = VMR9PresentationFlags.SrcDstRectsValid;

pub const VMR9PresentationInfo = extern struct {
    dwFlags: u32,
    lpSurf: ?*IDirect3DSurface9,
    rtStart: i64,
    rtEnd: i64,
    szAspectRatio: SIZE,
    rcSrc: RECT,
    rcDst: RECT,
    dwReserved1: u32,
    dwReserved2: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenter9_Value = Guid.initString("69188c61-12a3-40f0-8ffc-342e7b433fd7");
pub const IID_IVMRImagePresenter9 = &IID_IVMRImagePresenter9_Value;
pub const IVMRImagePresenter9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartPresenting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StopPresenting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        PresentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
                lpPresInfo: ?*VMR9PresentationInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenter9,
                dwUserID: usize,
                lpPresInfo: ?*VMR9PresentationInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_StartPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).StartPresenting(@as(*const IVMRImagePresenter9, @ptrCast(self)), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_StopPresenting(self: *const T, dwUserID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).StopPresenting(@as(*const IVMRImagePresenter9, @ptrCast(self)), dwUserID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenter9_PresentImage(self: *const T, dwUserID: usize, lpPresInfo: ?*VMR9PresentationInfo) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenter9.VTable, @ptrCast(self.vtable)).PresentImage(@as(*const IVMRImagePresenter9, @ptrCast(self)), dwUserID, lpPresInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9SurfaceAllocationFlags = enum(i32) {
    @"3DRenderTarget" = 1,
    DXVATarget = 2,
    TextureSurface = 4,
    OffscreenSurface = 8,
    RGBDynamicSwitch = 16,
    UsageReserved = 224,
    UsageMask = 255,
};
pub const VMR9AllocFlag_3DRenderTarget = VMR9SurfaceAllocationFlags.@"3DRenderTarget";
pub const VMR9AllocFlag_DXVATarget = VMR9SurfaceAllocationFlags.DXVATarget;
pub const VMR9AllocFlag_TextureSurface = VMR9SurfaceAllocationFlags.TextureSurface;
pub const VMR9AllocFlag_OffscreenSurface = VMR9SurfaceAllocationFlags.OffscreenSurface;
pub const VMR9AllocFlag_RGBDynamicSwitch = VMR9SurfaceAllocationFlags.RGBDynamicSwitch;
pub const VMR9AllocFlag_UsageReserved = VMR9SurfaceAllocationFlags.UsageReserved;
pub const VMR9AllocFlag_UsageMask = VMR9SurfaceAllocationFlags.UsageMask;

pub const VMR9AllocationInfo = extern struct {
    dwFlags: u32,
    dwWidth: u32,
    dwHeight: u32,
    Format: D3DFORMAT,
    Pool: D3DPOOL,
    MinBuffers: u32,
    szAspectRatio: SIZE,
    szNativeSize: SIZE,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocator9_Value = Guid.initString("8d5148ea-3f5d-46cf-9df1-d1b896eedb1f");
pub const IID_IVMRSurfaceAllocator9 = &IID_IVMRSurfaceAllocator9_Value;
pub const IVMRSurfaceAllocator9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator9,
                dwUserID: usize,
                lpAllocInfo: ?*VMR9AllocationInfo,
                lpNumBuffers: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator9,
                dwUserID: usize,
                lpAllocInfo: ?*VMR9AllocationInfo,
                lpNumBuffers: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TerminateDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator9,
                dwID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator9,
                dwID: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator9,
                dwUserID: usize,
                SurfaceIndex: u32,
                SurfaceFlags: u32,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator9,
                dwUserID: usize,
                SurfaceIndex: u32,
                SurfaceFlags: u32,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AdviseNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocator9,
                lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocator9,
                lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_InitializeDevice(self: *const T, dwUserID: usize, lpAllocInfo: ?*VMR9AllocationInfo, lpNumBuffers: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).InitializeDevice(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dwUserID, lpAllocInfo, lpNumBuffers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_TerminateDevice(self: *const T, dwID: usize) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).TerminateDevice(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dwID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_GetSurface(self: *const T, dwUserID: usize, SurfaceIndex: u32, SurfaceFlags: u32, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), dwUserID, SurfaceIndex, SurfaceFlags, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocator9_AdviseNotify(self: *const T, lpIVMRSurfAllocNotify: ?*IVMRSurfaceAllocatorNotify9) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocator9.VTable, @ptrCast(self.vtable)).AdviseNotify(@as(*const IVMRSurfaceAllocator9, @ptrCast(self)), lpIVMRSurfAllocNotify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorEx9_Value = Guid.initString("6de9a68a-a928-4522-bf57-655ae3866456");
pub const IID_IVMRSurfaceAllocatorEx9 = &IID_IVMRSurfaceAllocatorEx9_Value;
pub const IVMRSurfaceAllocatorEx9 = extern struct {
    pub const VTable = extern struct {
        base: IVMRSurfaceAllocator9.VTable,
        GetSurfaceEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorEx9,
                dwUserID: usize,
                SurfaceIndex: u32,
                SurfaceFlags: u32,
                lplpSurface: ?*?*IDirect3DSurface9,
                lprcDst: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorEx9,
                dwUserID: usize,
                SurfaceIndex: u32,
                SurfaceFlags: u32,
                lplpSurface: ?*?*IDirect3DSurface9,
                lprcDst: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVMRSurfaceAllocator9.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorEx9_GetSurfaceEx(self: *const T, dwUserID: usize, SurfaceIndex: u32, SurfaceFlags: u32, lplpSurface: ?*?*IDirect3DSurface9, lprcDst: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorEx9.VTable, @ptrCast(self.vtable)).GetSurfaceEx(@as(*const IVMRSurfaceAllocatorEx9, @ptrCast(self)), dwUserID, SurfaceIndex, SurfaceFlags, lplpSurface, lprcDst);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurfaceAllocatorNotify9_Value = Guid.initString("dca3f5df-bb3a-4d03-bd81-84614bfbfa0c");
pub const IID_IVMRSurfaceAllocatorNotify9 = &IID_IVMRSurfaceAllocatorNotify9_Value;
pub const IVMRSurfaceAllocatorNotify9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseSurfaceAllocator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                dwUserID: usize,
                lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                dwUserID: usize,
                lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetD3DDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpD3DDevice: ?*IDirect3DDevice9,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpD3DDevice: ?*IDirect3DDevice9,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ChangeD3DDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpD3DDevice: ?*IDirect3DDevice9,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpD3DDevice: ?*IDirect3DDevice9,
                hMonitor: ?HMONITOR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AllocateSurfaceHelper: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpAllocInfo: ?*VMR9AllocationInfo,
                lpNumBuffers: ?*u32,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                lpAllocInfo: ?*VMR9AllocationInfo,
                lpNumBuffers: ?*u32,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotifyEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                EventCode: i32,
                Param1: isize,
                Param2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurfaceAllocatorNotify9,
                EventCode: i32,
                Param1: isize,
                Param2: isize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_AdviseSurfaceAllocator(self: *const T, dwUserID: usize, lpIVRMSurfaceAllocator: ?*IVMRSurfaceAllocator9) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).AdviseSurfaceAllocator(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), dwUserID, lpIVRMSurfaceAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_SetD3DDevice(self: *const T, lpD3DDevice: ?*IDirect3DDevice9, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).SetD3DDevice(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lpD3DDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_ChangeD3DDevice(self: *const T, lpD3DDevice: ?*IDirect3DDevice9, hMonitor: ?HMONITOR) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).ChangeD3DDevice(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lpD3DDevice, hMonitor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_AllocateSurfaceHelper(self: *const T, lpAllocInfo: ?*VMR9AllocationInfo, lpNumBuffers: ?*u32, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).AllocateSurfaceHelper(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), lpAllocInfo, lpNumBuffers, lplpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurfaceAllocatorNotify9_NotifyEvent(self: *const T, EventCode: i32, Param1: isize, Param2: isize) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurfaceAllocatorNotify9.VTable, @ptrCast(self.vtable)).NotifyEvent(@as(*const IVMRSurfaceAllocatorNotify9, @ptrCast(self)), EventCode, Param1, Param2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AspectRatioMode = enum(i32) {
    None = 0,
    LetterBox = 1,
};
pub const VMR9ARMode_None = VMR9AspectRatioMode.None;
pub const VMR9ARMode_LetterBox = VMR9AspectRatioMode.LetterBox;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRWindowlessControl9_Value = Guid.initString("8f537d09-f85e-4414-b23b-502e54c79927");
pub const IID_IVMRWindowlessControl9 = &IID_IVMRWindowlessControl9_Value;
pub const IVMRWindowlessControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
                lpARWidth: ?*i32,
                lpARHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
                lpARWidth: ?*i32,
                lpARHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxIdealVideoSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpWidth: ?*i32,
                lpHeight: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpSRCRect: ?*const RECT,
                lpDSTRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpSRCRect: ?*const RECT,
                lpDSTRect: ?*const RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoPosition: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpSRCRect: ?*RECT,
                lpDSTRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpSRCRect: ?*RECT,
                lpDSTRect: ?*RECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpAspectRatioMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                AspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                AspectRatioMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoClippingWindow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                hwnd: ?HWND,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RepaintVideo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                hwnd: ?HWND,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                hwnd: ?HWND,
                hdc: ?HDC,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DisplayModeChanged: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpDib: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpDib: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                Clr: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBorderColor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRWindowlessControl9,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRWindowlessControl9,
                lpClr: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetNativeVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32, lpARWidth: ?*i32, lpARHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetNativeVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpWidth, lpHeight, lpARWidth, lpARHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetMinIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetMinIdealVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetMaxIdealVideoSize(self: *const T, lpWidth: ?*i32, lpHeight: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetMaxIdealVideoSize(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpWidth, lpHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetVideoPosition(self: *const T, lpSRCRect: ?*const RECT, lpDSTRect: ?*const RECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetVideoPosition(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetVideoPosition(self: *const T, lpSRCRect: ?*RECT, lpDSTRect: ?*RECT) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetVideoPosition(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpSRCRect, lpDSTRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetAspectRatioMode(self: *const T, lpAspectRatioMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetAspectRatioMode(self: *const T, AspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRWindowlessControl9, @ptrCast(self)), AspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetVideoClippingWindow(self: *const T, hwnd: ?HWND) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetVideoClippingWindow(@as(*const IVMRWindowlessControl9, @ptrCast(self)), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_RepaintVideo(self: *const T, hwnd: ?HWND, hdc: ?HDC) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).RepaintVideo(@as(*const IVMRWindowlessControl9, @ptrCast(self)), hwnd, hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_DisplayModeChanged(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).DisplayModeChanged(@as(*const IVMRWindowlessControl9, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetCurrentImage(self: *const T, lpDib: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetCurrentImage(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpDib);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_SetBorderColor(self: *const T, Clr: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).SetBorderColor(@as(*const IVMRWindowlessControl9, @ptrCast(self)), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRWindowlessControl9_GetBorderColor(self: *const T, lpClr: ?*COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRWindowlessControl9.VTable, @ptrCast(self.vtable)).GetBorderColor(@as(*const IVMRWindowlessControl9, @ptrCast(self)), lpClr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MixerPrefs = enum(i32) {
    NoDecimation = 1,
    DecimateOutput = 2,
    ARAdjustXorY = 4,
    NonSquareMixing = 8,
    DecimateMask = 15,
    BiLinearFiltering = 16,
    PointFiltering = 32,
    AnisotropicFiltering = 64,
    PyramidalQuadFiltering = 128,
    GaussianQuadFiltering = 256,
    FilteringReserved = 3584,
    FilteringMask = 4080,
    RenderTargetRGB = 4096,
    RenderTargetYUV = 8192,
    RenderTargetReserved = 1032192,
    RenderTargetMask = 1044480,
    DynamicSwitchToBOB = 1048576,
    DynamicDecimateBy2 = 2097152,
    DynamicReserved = 12582912,
    DynamicMask = 15728640,
};
pub const MixerPref9_NoDecimation = VMR9MixerPrefs.NoDecimation;
pub const MixerPref9_DecimateOutput = VMR9MixerPrefs.DecimateOutput;
pub const MixerPref9_ARAdjustXorY = VMR9MixerPrefs.ARAdjustXorY;
pub const MixerPref9_NonSquareMixing = VMR9MixerPrefs.NonSquareMixing;
pub const MixerPref9_DecimateMask = VMR9MixerPrefs.DecimateMask;
pub const MixerPref9_BiLinearFiltering = VMR9MixerPrefs.BiLinearFiltering;
pub const MixerPref9_PointFiltering = VMR9MixerPrefs.PointFiltering;
pub const MixerPref9_AnisotropicFiltering = VMR9MixerPrefs.AnisotropicFiltering;
pub const MixerPref9_PyramidalQuadFiltering = VMR9MixerPrefs.PyramidalQuadFiltering;
pub const MixerPref9_GaussianQuadFiltering = VMR9MixerPrefs.GaussianQuadFiltering;
pub const MixerPref9_FilteringReserved = VMR9MixerPrefs.FilteringReserved;
pub const MixerPref9_FilteringMask = VMR9MixerPrefs.FilteringMask;
pub const MixerPref9_RenderTargetRGB = VMR9MixerPrefs.RenderTargetRGB;
pub const MixerPref9_RenderTargetYUV = VMR9MixerPrefs.RenderTargetYUV;
pub const MixerPref9_RenderTargetReserved = VMR9MixerPrefs.RenderTargetReserved;
pub const MixerPref9_RenderTargetMask = VMR9MixerPrefs.RenderTargetMask;
pub const MixerPref9_DynamicSwitchToBOB = VMR9MixerPrefs.DynamicSwitchToBOB;
pub const MixerPref9_DynamicDecimateBy2 = VMR9MixerPrefs.DynamicDecimateBy2;
pub const MixerPref9_DynamicReserved = VMR9MixerPrefs.DynamicReserved;
pub const MixerPref9_DynamicMask = VMR9MixerPrefs.DynamicMask;

pub const VMR9NormalizedRect = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

pub const VMR9ProcAmpControlFlags = enum(i32) {
    Brightness = 1,
    Contrast = 2,
    Hue = 4,
    Saturation = 8,
    Mask = 15,
};
pub const ProcAmpControl9_Brightness = VMR9ProcAmpControlFlags.Brightness;
pub const ProcAmpControl9_Contrast = VMR9ProcAmpControlFlags.Contrast;
pub const ProcAmpControl9_Hue = VMR9ProcAmpControlFlags.Hue;
pub const ProcAmpControl9_Saturation = VMR9ProcAmpControlFlags.Saturation;
pub const ProcAmpControl9_Mask = VMR9ProcAmpControlFlags.Mask;

pub const VMR9ProcAmpControl = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Brightness: f32,
    Contrast: f32,
    Hue: f32,
    Saturation: f32,
};

pub const VMR9ProcAmpControlRange = extern struct {
    dwSize: u32,
    dwProperty: VMR9ProcAmpControlFlags,
    MinValue: f32,
    MaxValue: f32,
    DefaultValue: f32,
    StepSize: f32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerControl9_Value = Guid.initString("1a777eaa-47c8-4930-b2c9-8fee1c1b0f3b");
pub const IID_IVMRMixerControl9 = &IID_IVMRMixerControl9_Value;
pub const IVMRMixerControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                Alpha: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                Alpha: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlpha: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pAlpha: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pAlpha: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                dwZ: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetZOrder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pZ: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pRect: ?*const VMR9NormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pRect: ?*const VMR9NormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOutputRect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pRect: ?*VMR9NormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                pRect: ?*VMR9NormalizedRect,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBackgroundClr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                ClrBkg: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                ClrBkg: COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBackgroundClr: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                lpClrBkg: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                lpClrBkg: ?*COLORREF,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwMixerPrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwMixerPrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMixingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                pdwMixerPrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                pdwMixerPrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetProcAmpControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAmpControlRange: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControlRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerControl9,
                dwStreamID: u32,
                lpClrControl: ?*VMR9ProcAmpControlRange,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetAlpha(self: *const T, dwStreamID: u32, Alpha: f32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetAlpha(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetAlpha(self: *const T, dwStreamID: u32, pAlpha: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetAlpha(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, pAlpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetZOrder(self: *const T, dwStreamID: u32, dwZ: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetZOrder(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, dwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetZOrder(self: *const T, dwStreamID: u32, pZ: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetZOrder(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, pZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*const VMR9NormalizedRect) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetOutputRect(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetOutputRect(self: *const T, dwStreamID: u32, pRect: ?*VMR9NormalizedRect) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetOutputRect(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetBackgroundClr(self: *const T, ClrBkg: COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetBackgroundClr(@as(*const IVMRMixerControl9, @ptrCast(self)), ClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetBackgroundClr(self: *const T, lpClrBkg: ?*COLORREF) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetBackgroundClr(@as(*const IVMRMixerControl9, @ptrCast(self)), lpClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetMixingPrefs(self: *const T, dwMixerPrefs: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetMixingPrefs(@as(*const IVMRMixerControl9, @ptrCast(self)), dwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetMixingPrefs(self: *const T, pdwMixerPrefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetMixingPrefs(@as(*const IVMRMixerControl9, @ptrCast(self)), pdwMixerPrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_SetProcAmpControl(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControl) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).SetProcAmpControl(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, lpClrControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetProcAmpControl(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControl) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetProcAmpControl(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, lpClrControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerControl9_GetProcAmpControlRange(self: *const T, dwStreamID: u32, lpClrControl: ?*VMR9ProcAmpControlRange) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerControl9.VTable, @ptrCast(self.vtable)).GetProcAmpControlRange(@as(*const IVMRMixerControl9, @ptrCast(self)), dwStreamID, lpClrControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9AlphaBitmap = extern struct {
    dwFlags: u32,
    hdc: ?HDC,
    pDDS: ?*IDirect3DSurface9,
    rSrc: RECT,
    rDest: VMR9NormalizedRect,
    fAlpha: f32,
    clrSrcKey: COLORREF,
    dwFilterMode: u32,
};

pub const VMR9AlphaBitmapFlags = enum(i32) {
    Disable = 1,
    hDC = 2,
    EntireDDS = 4,
    SrcColorKey = 8,
    SrcRect = 16,
    FilterMode = 32,
};
pub const VMR9AlphaBitmap_Disable = VMR9AlphaBitmapFlags.Disable;
pub const VMR9AlphaBitmap_hDC = VMR9AlphaBitmapFlags.hDC;
pub const VMR9AlphaBitmap_EntireDDS = VMR9AlphaBitmapFlags.EntireDDS;
pub const VMR9AlphaBitmap_SrcColorKey = VMR9AlphaBitmapFlags.SrcColorKey;
pub const VMR9AlphaBitmap_SrcRect = VMR9AlphaBitmapFlags.SrcRect;
pub const VMR9AlphaBitmap_FilterMode = VMR9AlphaBitmapFlags.FilterMode;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMixerBitmap9_Value = Guid.initString("ced175e5-1935-4820-81bd-ff6ad00c9108");
pub const IID_IVMRMixerBitmap9 = &IID_IVMRMixerBitmap9_Value;
pub const IVMRMixerBitmap9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*const VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*const VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UpdateAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*const VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*const VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAlphaBitmapParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMixerBitmap9,
                pBmpParms: ?*VMR9AlphaBitmap,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_SetAlphaBitmap(self: *const T, pBmpParms: ?*const VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).SetAlphaBitmap(@as(*const IVMRMixerBitmap9, @ptrCast(self)), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: ?*const VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).UpdateAlphaBitmapParameters(@as(*const IVMRMixerBitmap9, @ptrCast(self)), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMixerBitmap9_GetAlphaBitmapParameters(self: *const T, pBmpParms: ?*VMR9AlphaBitmap) callconv(.Inline) HRESULT {
            return @as(*const IVMRMixerBitmap9.VTable, @ptrCast(self.vtable)).GetAlphaBitmapParameters(@as(*const IVMRMixerBitmap9, @ptrCast(self)), pBmpParms);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRSurface9_Value = Guid.initString("dfc581a1-6e1f-4c3a-8d0a-5e9792ea2afc");
pub const IID_IVMRSurface9 = &IID_IVMRSurface9_Value;
pub const IVMRSurface9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSurfaceLocked: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LockSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface9,
                lpSurface: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface9,
                lpSurface: ?*?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnlockSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRSurface9,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRSurface9,
                lplpSurface: ?*?*IDirect3DSurface9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_IsSurfaceLocked(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).IsSurfaceLocked(@as(*const IVMRSurface9, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_LockSurface(self: *const T, lpSurface: ?*?*u8) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).LockSurface(@as(*const IVMRSurface9, @ptrCast(self)), lpSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_UnlockSurface(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).UnlockSurface(@as(*const IVMRSurface9, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRSurface9_GetSurface(self: *const T, lplpSurface: ?*?*IDirect3DSurface9) callconv(.Inline) HRESULT {
            return @as(*const IVMRSurface9.VTable, @ptrCast(self.vtable)).GetSurface(@as(*const IVMRSurface9, @ptrCast(self)), lplpSurface);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9RenderPrefs = enum(i32) {
    DoNotRenderBorder = 1,
    // Mask = 1, this enum value conflicts with DoNotRenderBorder
};
pub const RenderPrefs9_DoNotRenderBorder = VMR9RenderPrefs.DoNotRenderBorder;
pub const RenderPrefs9_Mask = VMR9RenderPrefs.DoNotRenderBorder;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImagePresenterConfig9_Value = Guid.initString("45c15cab-6e22-420a-8043-ae1f0ac02c7d");
pub const IID_IVMRImagePresenterConfig9 = &IID_IVMRImagePresenterConfig9_Value;
pub const IVMRImagePresenterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterConfig9,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterConfig9,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImagePresenterConfig9,
                dwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImagePresenterConfig9,
                dwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig9_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRImagePresenterConfig9, @ptrCast(self)), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImagePresenterConfig9_GetRenderingPrefs(self: *const T, dwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImagePresenterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRImagePresenterConfig9, @ptrCast(self)), dwRenderFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRVideoStreamControl9_Value = Guid.initString("d0cfe38b-93e7-4772-8957-0400c49a4485");
pub const IID_IVMRVideoStreamControl9 = &IID_IVMRVideoStreamControl9_Value;
pub const IVMRVideoStreamControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl9,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl9,
                fActive: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStreamActiveState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRVideoStreamControl9,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRVideoStreamControl9,
                lpfActive: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl9_SetStreamActiveState(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl9.VTable, @ptrCast(self.vtable)).SetStreamActiveState(@as(*const IVMRVideoStreamControl9, @ptrCast(self)), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRVideoStreamControl9_GetStreamActiveState(self: *const T, lpfActive: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRVideoStreamControl9.VTable, @ptrCast(self.vtable)).GetStreamActiveState(@as(*const IVMRVideoStreamControl9, @ptrCast(self)), lpfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9Mode = enum(i32) {
    Windowed = 1,
    Windowless = 2,
    Renderless = 4,
    Mask = 7,
};
pub const VMR9Mode_Windowed = VMR9Mode.Windowed;
pub const VMR9Mode_Windowless = VMR9Mode.Windowless;
pub const VMR9Mode_Renderless = VMR9Mode.Renderless;
pub const VMR9Mode_Mask = VMR9Mode.Mask;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRFilterConfig9_Value = Guid.initString("5a804648-4f66-4867-9c43-4f5c822cf1b8");
pub const IID_IVMRFilterConfig9 = &IID_IVMRFilterConfig9_Value;
pub const IVMRFilterConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetImageCompositor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                lpVMRImgCompositor: ?*IVMRImageCompositor9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                lpVMRImgCompositor: ?*IVMRImageCompositor9,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                dwMaxStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumberOfStreams: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                pdwMaxStreams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                dwRenderFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingPrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                pdwRenderFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetRenderingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                Mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                Mode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRenderingMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRFilterConfig9,
                pMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRFilterConfig9,
                pMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetImageCompositor(self: *const T, lpVMRImgCompositor: ?*IVMRImageCompositor9) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetImageCompositor(@as(*const IVMRFilterConfig9, @ptrCast(self)), lpVMRImgCompositor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetNumberOfStreams(@as(*const IVMRFilterConfig9, @ptrCast(self)), dwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetNumberOfStreams(self: *const T, pdwMaxStreams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetNumberOfStreams(@as(*const IVMRFilterConfig9, @ptrCast(self)), pdwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingPrefs(@as(*const IVMRFilterConfig9, @ptrCast(self)), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetRenderingPrefs(self: *const T, pdwRenderFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingPrefs(@as(*const IVMRFilterConfig9, @ptrCast(self)), pdwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_SetRenderingMode(self: *const T, Mode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).SetRenderingMode(@as(*const IVMRFilterConfig9, @ptrCast(self)), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRFilterConfig9_GetRenderingMode(self: *const T, pMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRFilterConfig9.VTable, @ptrCast(self.vtable)).GetRenderingMode(@as(*const IVMRFilterConfig9, @ptrCast(self)), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRAspectRatioControl9_Value = Guid.initString("00d96c29-bbde-4efc-9901-bb5036392146");
pub const IID_IVMRAspectRatioControl9 = &IID_IVMRAspectRatioControl9_Value;
pub const IVMRAspectRatioControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRAspectRatioControl9,
                lpdwARMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRAspectRatioControl9,
                lpdwARMode: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAspectRatioMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRAspectRatioControl9,
                dwARMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRAspectRatioControl9,
                dwARMode: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl9_GetAspectRatioMode(self: *const T, lpdwARMode: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRAspectRatioControl9.VTable, @ptrCast(self.vtable)).GetAspectRatioMode(@as(*const IVMRAspectRatioControl9, @ptrCast(self)), lpdwARMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRAspectRatioControl9_SetAspectRatioMode(self: *const T, dwARMode: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRAspectRatioControl9.VTable, @ptrCast(self.vtable)).SetAspectRatioMode(@as(*const IVMRAspectRatioControl9, @ptrCast(self)), dwARMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9MonitorInfo = extern struct {
    uDevID: u32,
    rcMonitor: RECT,
    hMon: ?HMONITOR,
    dwFlags: u32,
    szDevice: [32]u16,
    szDescription: [512]u16,
    liDriverVersion: i64,
    dwVendorId: u32,
    dwDeviceId: u32,
    dwSubSysId: u32,
    dwRevision: u32,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRMonitorConfig9_Value = Guid.initString("46c2e457-8ba0-4eef-b80b-0680f0978749");
pub const IID_IVMRMonitorConfig9 = &IID_IVMRMonitorConfig9_Value;
pub const IVMRMonitorConfig9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig9,
                uDev: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig9,
                uDev: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig9,
                puDev: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig9,
                puDev: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig9,
                uDev: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig9,
                uDev: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultMonitor: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig9,
                puDev: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig9,
                puDev: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableMonitors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRMonitorConfig9,
                pInfo: [*]VMR9MonitorInfo,
                dwMaxInfoArraySize: u32,
                pdwNumDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRMonitorConfig9,
                pInfo: [*]VMR9MonitorInfo,
                dwMaxInfoArraySize: u32,
                pdwNumDevices: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_SetMonitor(self: *const T, uDev: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).SetMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), uDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetMonitor(self: *const T, puDev: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), puDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_SetDefaultMonitor(self: *const T, uDev: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).SetDefaultMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), uDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetDefaultMonitor(self: *const T, puDev: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetDefaultMonitor(@as(*const IVMRMonitorConfig9, @ptrCast(self)), puDev);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRMonitorConfig9_GetAvailableMonitors(self: *const T, pInfo: [*]VMR9MonitorInfo, dwMaxInfoArraySize: u32, pdwNumDevices: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRMonitorConfig9.VTable, @ptrCast(self.vtable)).GetAvailableMonitors(@as(*const IVMRMonitorConfig9, @ptrCast(self)), pInfo, dwMaxInfoArraySize, pdwNumDevices);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9DeinterlacePrefs = enum(i32) {
    NextBest = 1,
    BOB = 2,
    Weave = 4,
    Mask = 7,
};
pub const DeinterlacePref9_NextBest = VMR9DeinterlacePrefs.NextBest;
pub const DeinterlacePref9_BOB = VMR9DeinterlacePrefs.BOB;
pub const DeinterlacePref9_Weave = VMR9DeinterlacePrefs.Weave;
pub const DeinterlacePref9_Mask = VMR9DeinterlacePrefs.Mask;

pub const VMR9DeinterlaceTech = enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DeinterlaceTech9_Unknown = VMR9DeinterlaceTech.Unknown;
pub const DeinterlaceTech9_BOBLineReplicate = VMR9DeinterlaceTech.BOBLineReplicate;
pub const DeinterlaceTech9_BOBVerticalStretch = VMR9DeinterlaceTech.BOBVerticalStretch;
pub const DeinterlaceTech9_MedianFiltering = VMR9DeinterlaceTech.MedianFiltering;
pub const DeinterlaceTech9_EdgeFiltering = VMR9DeinterlaceTech.EdgeFiltering;
pub const DeinterlaceTech9_FieldAdaptive = VMR9DeinterlaceTech.FieldAdaptive;
pub const DeinterlaceTech9_PixelAdaptive = VMR9DeinterlaceTech.PixelAdaptive;
pub const DeinterlaceTech9_MotionVectorSteered = VMR9DeinterlaceTech.MotionVectorSteered;

pub const VMR9Frequency = extern struct {
    dwNumerator: u32,
    dwDenominator: u32,
};

pub const VMR9_SampleFormat = enum(i32) {
    Reserved = 1,
    ProgressiveFrame = 2,
    FieldInterleavedEvenFirst = 3,
    FieldInterleavedOddFirst = 4,
    FieldSingleEven = 5,
    FieldSingleOdd = 6,
};
pub const VMR9_SampleReserved = VMR9_SampleFormat.Reserved;
pub const VMR9_SampleProgressiveFrame = VMR9_SampleFormat.ProgressiveFrame;
pub const VMR9_SampleFieldInterleavedEvenFirst = VMR9_SampleFormat.FieldInterleavedEvenFirst;
pub const VMR9_SampleFieldInterleavedOddFirst = VMR9_SampleFormat.FieldInterleavedOddFirst;
pub const VMR9_SampleFieldSingleEven = VMR9_SampleFormat.FieldSingleEven;
pub const VMR9_SampleFieldSingleOdd = VMR9_SampleFormat.FieldSingleOdd;

pub const VMR9VideoDesc = extern struct {
    dwSize: u32,
    dwSampleWidth: u32,
    dwSampleHeight: u32,
    SampleFormat: VMR9_SampleFormat,
    dwFourCC: u32,
    InputSampleFreq: VMR9Frequency,
    OutputFrameFreq: VMR9Frequency,
};

pub const VMR9DeinterlaceCaps = extern struct {
    dwSize: u32,
    dwNumPreviousOutputFrames: u32,
    dwNumForwardRefSamples: u32,
    dwNumBackwardRefSamples: u32,
    DeinterlaceTechnology: VMR9DeinterlaceTech,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRDeinterlaceControl9_Value = Guid.initString("a215fb8d-13c2-4f7f-993c-003d6271a459");
pub const IID_IVMRDeinterlaceControl9 = &IID_IVMRDeinterlaceControl9_Value;
pub const IVMRDeinterlaceControl9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfDeinterlaceModes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                lpVideoDescription: ?*VMR9VideoDesc,
                lpdwNumDeinterlaceModes: ?*u32,
                lpDeinterlaceModes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                lpVideoDescription: ?*VMR9VideoDesc,
                lpdwNumDeinterlaceModes: ?*u32,
                lpDeinterlaceModes: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlaceModeCaps: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                lpDeinterlaceMode: ?*Guid,
                lpVideoDescription: ?*VMR9VideoDesc,
                lpDeinterlaceCaps: ?*VMR9DeinterlaceCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                lpDeinterlaceMode: ?*Guid,
                lpVideoDescription: ?*VMR9VideoDesc,
                lpDeinterlaceCaps: ?*VMR9DeinterlaceCaps,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlacePrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                lpdwDeinterlacePrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                lpdwDeinterlacePrefs: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDeinterlacePrefs: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                dwDeinterlacePrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                dwDeinterlacePrefs: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetActualDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRDeinterlaceControl9,
                dwStreamID: u32,
                lpDeinterlaceMode: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetNumberOfDeinterlaceModes(self: *const T, lpVideoDescription: ?*VMR9VideoDesc, lpdwNumDeinterlaceModes: ?*u32, lpDeinterlaceModes: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetNumberOfDeinterlaceModes(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lpVideoDescription, lpdwNumDeinterlaceModes, lpDeinterlaceModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlaceModeCaps(self: *const T, lpDeinterlaceMode: ?*Guid, lpVideoDescription: ?*VMR9VideoDesc, lpDeinterlaceCaps: ?*VMR9DeinterlaceCaps) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlaceModeCaps(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lpDeinterlaceMode, lpVideoDescription, lpDeinterlaceCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_SetDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetDeinterlacePrefs(self: *const T, lpdwDeinterlacePrefs: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), lpdwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_SetDeinterlacePrefs(self: *const T, dwDeinterlacePrefs: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).SetDeinterlacePrefs(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dwDeinterlacePrefs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRDeinterlaceControl9_GetActualDeinterlaceMode(self: *const T, dwStreamID: u32, lpDeinterlaceMode: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IVMRDeinterlaceControl9.VTable, @ptrCast(self.vtable)).GetActualDeinterlaceMode(@as(*const IVMRDeinterlaceControl9, @ptrCast(self)), dwStreamID, lpDeinterlaceMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMR9VideoStreamInfo = extern struct {
    pddsVideoSurface: ?*IDirect3DSurface9,
    dwWidth: u32,
    dwHeight: u32,
    dwStrmID: u32,
    fAlpha: f32,
    rNormal: VMR9NormalizedRect,
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: VMR9_SampleFormat,
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_IVMRImageCompositor9_Value = Guid.initString("4a5c89eb-df51-4654-ac2a-e48e02bbabf6");
pub const IID_IVMRImageCompositor9 = &IID_IVMRImageCompositor9_Value;
pub const IVMRImageCompositor9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitCompositionDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TermCompositionDevice: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStreamMediaType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor9,
                dwStrmID: u32,
                pmt: ?*AM_MEDIA_TYPE,
                fTexture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor9,
                dwStrmID: u32,
                pmt: ?*AM_MEDIA_TYPE,
                fTexture: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CompositeImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirect3DSurface9,
                pmtRenderTarget: ?*AM_MEDIA_TYPE,
                rtStart: i64,
                rtEnd: i64,
                dwClrBkGnd: u32,
                pVideoStreamInfo: ?*VMR9VideoStreamInfo,
                cStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVMRImageCompositor9,
                pD3DDevice: ?*IUnknown,
                pddsRenderTarget: ?*IDirect3DSurface9,
                pmtRenderTarget: ?*AM_MEDIA_TYPE,
                rtStart: i64,
                rtEnd: i64,
                dwClrBkGnd: u32,
                pVideoStreamInfo: ?*VMR9VideoStreamInfo,
                cStreams: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_InitCompositionDevice(self: *const T, pD3DDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).InitCompositionDevice(@as(*const IVMRImageCompositor9, @ptrCast(self)), pD3DDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_TermCompositionDevice(self: *const T, pD3DDevice: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).TermCompositionDevice(@as(*const IVMRImageCompositor9, @ptrCast(self)), pD3DDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_SetStreamMediaType(self: *const T, dwStrmID: u32, pmt: ?*AM_MEDIA_TYPE, fTexture: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).SetStreamMediaType(@as(*const IVMRImageCompositor9, @ptrCast(self)), dwStrmID, pmt, fTexture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVMRImageCompositor9_CompositeImage(self: *const T, pD3DDevice: ?*IUnknown, pddsRenderTarget: ?*IDirect3DSurface9, pmtRenderTarget: ?*AM_MEDIA_TYPE, rtStart: i64, rtEnd: i64, dwClrBkGnd: u32, pVideoStreamInfo: ?*VMR9VideoStreamInfo, cStreams: u32) callconv(.Inline) HRESULT {
            return @as(*const IVMRImageCompositor9.VTable, @ptrCast(self.vtable)).CompositeImage(@as(*const IVMRImageCompositor9, @ptrCast(self)), pD3DDevice, pddsRenderTarget, pmtRenderTarget, rtStart, rtEnd, dwClrBkGnd, pVideoStreamInfo, cStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConnectInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                pdwNumConnectInfo: ?*u32,
                pddVPConnectInfo: ?[*]DDVIDEOPORTCONNECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                pdwNumConnectInfo: ?*u32,
                pddVPConnectInfo: ?[*]DDVIDEOPORTCONNECT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConnectInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwChosenEntry: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwChosenEntry: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVPDataInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                pamvpDataInfo: ?*AMVPDATAINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                pamvpDataInfo: ?*AMVPDATAINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxPixelRate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                pamvpSize: ?*AMVPSIZE,
                pdwMaxPixelsPerSecond: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                pamvpSize: ?*AMVPSIZE,
                pdwMaxPixelsPerSecond: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InformVPInputFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwNumFormats: u32,
                pDDPixelFormats: ?*DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwNumFormats: u32,
                pDDPixelFormats: ?*DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVideoFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                pdwNumFormats: ?*u32,
                pddPixelFormats: ?[*]DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                pdwNumFormats: ?*u32,
                pddPixelFormats: ?[*]DDPIXELFORMAT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwChosenEntry: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwChosenEntry: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetInvertPolarity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetOverlaySurface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                ppddOverlaySurface: ?*?*IDirectDrawSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                ppddOverlaySurface: ?*?*IDirectDrawSurface,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDirectDrawKernelHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwDDKernelHandle: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwDDKernelHandle: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVideoPortID: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwVideoPortID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwVideoPortID: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDDSurfaceKernelHandles: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                cHandles: u32,
                rgDDKernelHandles: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                cHandles: u32,
                rgDDKernelHandles: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSurfaceParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseConfig,
                dwPitch: u32,
                dwXOrigin: u32,
                dwYOrigin: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseConfig,
                dwPitch: u32,
                dwXOrigin: u32,
                dwYOrigin: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetConnectInfo(self: *const T, pdwNumConnectInfo: ?*u32, pddVPConnectInfo: ?[*]DDVIDEOPORTCONNECT) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetConnectInfo(@as(*const IVPBaseConfig, @ptrCast(self)), pdwNumConnectInfo, pddVPConnectInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetConnectInfo(self: *const T, dwChosenEntry: u32) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetConnectInfo(@as(*const IVPBaseConfig, @ptrCast(self)), dwChosenEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetVPDataInfo(self: *const T, pamvpDataInfo: ?*AMVPDATAINFO) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetVPDataInfo(@as(*const IVPBaseConfig, @ptrCast(self)), pamvpDataInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetMaxPixelRate(self: *const T, pamvpSize: ?*AMVPSIZE, pdwMaxPixelsPerSecond: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetMaxPixelRate(@as(*const IVPBaseConfig, @ptrCast(self)), pamvpSize, pdwMaxPixelsPerSecond);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_InformVPInputFormats(self: *const T, dwNumFormats: u32, pDDPixelFormats: ?*DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).InformVPInputFormats(@as(*const IVPBaseConfig, @ptrCast(self)), dwNumFormats, pDDPixelFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetVideoFormats(self: *const T, pdwNumFormats: ?*u32, pddPixelFormats: ?[*]DDPIXELFORMAT) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetVideoFormats(@as(*const IVPBaseConfig, @ptrCast(self)), pdwNumFormats, pddPixelFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetVideoFormat(self: *const T, dwChosenEntry: u32) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetVideoFormat(@as(*const IVPBaseConfig, @ptrCast(self)), dwChosenEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetInvertPolarity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetInvertPolarity(@as(*const IVPBaseConfig, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_GetOverlaySurface(self: *const T, ppddOverlaySurface: ?*?*IDirectDrawSurface) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).GetOverlaySurface(@as(*const IVPBaseConfig, @ptrCast(self)), ppddOverlaySurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetDirectDrawKernelHandle(self: *const T, dwDDKernelHandle: usize) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetDirectDrawKernelHandle(@as(*const IVPBaseConfig, @ptrCast(self)), dwDDKernelHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetVideoPortID(self: *const T, dwVideoPortID: u32) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetVideoPortID(@as(*const IVPBaseConfig, @ptrCast(self)), dwVideoPortID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetDDSurfaceKernelHandles(self: *const T, cHandles: u32, rgDDKernelHandles: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetDDSurfaceKernelHandles(@as(*const IVPBaseConfig, @ptrCast(self)), cHandles, rgDDKernelHandles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseConfig_SetSurfaceParameters(self: *const T, dwPitch: u32, dwXOrigin: u32, dwYOrigin: u32) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseConfig.VTable, @ptrCast(self.vtable)).SetSurfaceParameters(@as(*const IVPBaseConfig, @ptrCast(self)), dwPitch, dwXOrigin, dwYOrigin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVPConfig_Value = Guid.initString("bc29a660-30e3-11d0-9e69-00c04fd7c15b");
pub const IID_IVPConfig = &IID_IVPConfig_Value;
pub const IVPConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
        IsVPDecimationAllowed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPConfig,
                pbIsDecimationAllowed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPConfig,
                pbIsDecimationAllowed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetScalingFactors: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPConfig,
                pamvpSize: ?*AMVPSIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPConfig,
                pamvpSize: ?*AMVPSIZE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPConfig_IsVPDecimationAllowed(self: *const T, pbIsDecimationAllowed: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVPConfig.VTable, @ptrCast(self.vtable)).IsVPDecimationAllowed(@as(*const IVPConfig, @ptrCast(self)), pbIsDecimationAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPConfig_SetScalingFactors(self: *const T, pamvpSize: ?*AMVPSIZE) callconv(.Inline) HRESULT {
            return @as(*const IVPConfig.VTable, @ptrCast(self.vtable)).SetScalingFactors(@as(*const IVPConfig, @ptrCast(self)), pamvpSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVPVBIConfig_Value = Guid.initString("ec529b00-1a1f-11d1-bad9-00609744111a");
pub const IID_IVPVBIConfig = &IID_IVPVBIConfig_Value;
pub const IVPVBIConfig = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseConfig.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseConfig.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
pub const IVPBaseNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RenegotiateVPParameters: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPBaseNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPBaseNotify,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPBaseNotify_RenegotiateVPParameters(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IVPBaseNotify.VTable, @ptrCast(self.vtable)).RenegotiateVPParameters(@as(*const IVPBaseNotify, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVPNotify_Value = Guid.initString("c76794a1-d6c5-11d0-9e69-00c04fd7c15b");
pub const IID_IVPNotify = &IID_IVPNotify_Value;
pub const IVPNotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
        SetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPNotify,
                mode: AMVP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPNotify,
                mode: AMVP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDeinterlaceMode: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPNotify,
                pMode: ?*AMVP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPNotify,
                pMode: ?*AMVP_MODE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify_SetDeinterlaceMode(self: *const T, mode: AMVP_MODE) callconv(.Inline) HRESULT {
            return @as(*const IVPNotify.VTable, @ptrCast(self.vtable)).SetDeinterlaceMode(@as(*const IVPNotify, @ptrCast(self)), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify_GetDeinterlaceMode(self: *const T, pMode: ?*AMVP_MODE) callconv(.Inline) HRESULT {
            return @as(*const IVPNotify.VTable, @ptrCast(self.vtable)).GetDeinterlaceMode(@as(*const IVPNotify, @ptrCast(self)), pMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.0'
const IID_IVPNotify2_Value = Guid.initString("ebf47183-8764-11d1-9e69-00c04fd7c15b");
pub const IID_IVPNotify2 = &IID_IVPNotify2_Value;
pub const IVPNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IVPNotify.VTable,
        SetVPSyncMaster: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPNotify2,
                bVPSyncMaster: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPNotify2,
                bVPSyncMaster: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVPSyncMaster: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IVPNotify2,
                pbVPSyncMaster: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IVPNotify2,
                pbVPSyncMaster: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify2_SetVPSyncMaster(self: *const T, bVPSyncMaster: BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVPNotify2.VTable, @ptrCast(self.vtable)).SetVPSyncMaster(@as(*const IVPNotify2, @ptrCast(self)), bVPSyncMaster);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVPNotify2_GetVPSyncMaster(self: *const T, pbVPSyncMaster: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IVPNotify2.VTable, @ptrCast(self.vtable)).GetVPSyncMaster(@as(*const IVPNotify2, @ptrCast(self)), pbVPSyncMaster);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVPVBINotify_Value = Guid.initString("ec529b01-1a1f-11d1-bad9-00609744111a");
pub const IID_IVPVBINotify = &IID_IVPVBINotify_Value;
pub const IVPVBINotify = extern struct {
    pub const VTable = extern struct {
        base: IVPBaseNotify.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVPBaseNotify.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RIFFCHUNK = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
};

pub const RIFFLIST = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    fccListType: u32 align(2),
};

pub const AVIMAINHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    dwMicroSecPerFrame: u32 align(2),
    dwMaxBytesPerSec: u32 align(2),
    dwPaddingGranularity: u32 align(2),
    dwFlags: u32 align(2),
    dwTotalFrames: u32 align(2),
    dwInitialFrames: u32 align(2),
    dwStreams: u32 align(2),
    dwSuggestedBufferSize: u32 align(2),
    dwWidth: u32 align(2),
    dwHeight: u32 align(2),
    dwReserved: [4]u32 align(2),
};

pub const AVIEXTHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    dwGrandFrames: u32 align(2),
    dwFuture: [61]u32 align(2),
};

pub const AVISTREAMHEADER = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    fccType: u32 align(2),
    fccHandler: u32 align(2),
    dwFlags: u32 align(2),
    wPriority: u16 align(2),
    wLanguage: u16 align(2),
    dwInitialFrames: u32 align(2),
    dwScale: u32 align(2),
    dwRate: u32 align(2),
    dwStart: u32 align(2),
    dwLength: u32 align(2),
    dwSuggestedBufferSize: u32 align(2),
    dwQuality: u32 align(2),
    dwSampleSize: u32 align(2),
    rcFrame: extern struct {
        left: i16,
        top: i16,
        right: i16,
        bottom: i16,
    } align(2),
};

pub const AVIOLDINDEX = extern struct {
    pub const _avioldindex_entry = extern struct {
        dwChunkId: u32 align(2),
        dwFlags: u32 align(2),
        dwOffset: u32 align(2),
        dwSize: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    aIndex: [1]_avioldindex_entry align(2),
};

pub const TIMECODEDATA = extern struct {
    time: TIMECODE align(2),
    dwSMPTEflags: u32 align(2),
    dwUser: u32 align(2),
};

pub const AVIMETAINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    adwIndex: [1]u32 align(2),
};

pub const AVISUPERINDEX = extern struct {
    pub const _avisuperindex_entry = extern struct {
        qwOffset: u64 align(2),
        dwSize: u32 align(2),
        dwDuration: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [1022]_avisuperindex_entry align(2),
};

pub const AVISTDINDEX_ENTRY = extern struct {
    dwOffset: u32 align(2),
    dwSize: u32 align(2),
};

pub const AVISTDINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved_3: u32 align(2),
    aIndex: [2044]AVISTDINDEX_ENTRY align(2),
};

pub const AVITIMEDINDEX_ENTRY = extern struct {
    dwOffset: u32 align(2),
    dwSize: u32 align(2),
    dwDuration: u32 align(2),
};

pub const AVITIMEDINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved_3: u32 align(2),
    aIndex: [1362]AVITIMEDINDEX_ENTRY align(2),
    adwTrailingFill: [2734]u32 align(2),
};

pub const AVITIMECODEINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [1022]TIMECODEDATA align(2),
};

pub const AVITCDLINDEX_ENTRY = extern struct {
    dwTick: u32 align(2),
    time: TIMECODE align(2),
    dwSMPTEflags: u32 align(2),
    dwUser: u32 align(2),
    szReelId: [12]i8 align(2),
};

pub const AVITCDLINDEX = extern struct {
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    dwReserved: [3]u32 align(2),
    aIndex: [584]AVITCDLINDEX_ENTRY align(2),
    adwTrailingFill: [3512]u32 align(2),
};

pub const AVIFIELDINDEX = extern struct {
    pub const _avifieldindex_entry = extern struct {
        dwOffset: u32 align(2),
        dwSize: u32 align(2),
        dwOffsetField2: u32 align(2),
    };
    fcc: u32 align(2),
    cb: u32 align(2),
    wLongsPerEntry: u16 align(2),
    bIndexSubType: u8 align(2),
    bIndexType: u8 align(2),
    nEntriesInUse: u32 align(2),
    dwChunkId: u32 align(2),
    qwBaseOffset: u64 align(2),
    dwReserved3: u32 align(2),
    aIndex: [1]_avifieldindex_entry align(2),
};

pub const MainAVIHeader = extern struct {
    dwMicroSecPerFrame: u32,
    dwMaxBytesPerSec: u32,
    dwPaddingGranularity: u32,
    dwFlags: u32,
    dwTotalFrames: u32,
    dwInitialFrames: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwReserved: [4]u32,
};

pub const AVIStreamHeader = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    wPriority: u16,
    wLanguage: u16,
    dwInitialFrames: u32,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
};

pub const AVIINDEXENTRY = extern struct {
    ckid: u32,
    dwFlags: u32,
    dwChunkOffset: u32,
    dwChunkLength: u32,
};

pub const AVIPALCHANGE = extern struct {
    bFirstEntry: u8,
    bNumEntries: u8,
    wFlags: u16,
    peNew: [1]PALETTEENTRY,
};

pub const AM_PROPERTY_AC3 = enum(i32) {
    ERROR_CONCEALMENT = 1,
    ALTERNATE_AUDIO = 2,
    DOWNMIX = 3,
    BIT_STREAM_MODE = 4,
    DIALOGUE_LEVEL = 5,
    LANGUAGE_CODE = 6,
    ROOM_TYPE = 7,
};
pub const AM_PROPERTY_AC3_ERROR_CONCEALMENT = AM_PROPERTY_AC3.ERROR_CONCEALMENT;
pub const AM_PROPERTY_AC3_ALTERNATE_AUDIO = AM_PROPERTY_AC3.ALTERNATE_AUDIO;
pub const AM_PROPERTY_AC3_DOWNMIX = AM_PROPERTY_AC3.DOWNMIX;
pub const AM_PROPERTY_AC3_BIT_STREAM_MODE = AM_PROPERTY_AC3.BIT_STREAM_MODE;
pub const AM_PROPERTY_AC3_DIALOGUE_LEVEL = AM_PROPERTY_AC3.DIALOGUE_LEVEL;
pub const AM_PROPERTY_AC3_LANGUAGE_CODE = AM_PROPERTY_AC3.LANGUAGE_CODE;
pub const AM_PROPERTY_AC3_ROOM_TYPE = AM_PROPERTY_AC3.ROOM_TYPE;

pub const AM_AC3_ERROR_CONCEALMENT = extern struct {
    fRepeatPreviousBlock: BOOL,
    fErrorInCurrentBlock: BOOL,
};

pub const AM_AC3_ALTERNATE_AUDIO = extern struct {
    fStereo: BOOL,
    DualMode: u32,
};

pub const AM_AC3_DOWNMIX = extern struct {
    fDownMix: BOOL,
    fDolbySurround: BOOL,
};

pub const AM_AC3_BIT_STREAM_MODE = extern struct {
    BitStreamMode: i32,
};

pub const AM_AC3_DIALOGUE_LEVEL = extern struct {
    DialogueLevel: u32,
};

pub const AM_AC3_ROOM_TYPE = extern struct {
    fLargeRoom: BOOL,
};

pub const AM_PROPERTY_DVDSUBPIC = enum(i32) {
    PALETTE = 0,
    HLI = 1,
    COMPOSIT_ON = 2,
};
pub const AM_PROPERTY_DVDSUBPIC_PALETTE = AM_PROPERTY_DVDSUBPIC.PALETTE;
pub const AM_PROPERTY_DVDSUBPIC_HLI = AM_PROPERTY_DVDSUBPIC.HLI;
pub const AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = AM_PROPERTY_DVDSUBPIC.COMPOSIT_ON;

pub const AM_DVD_YUV = extern struct {
    Reserved: u8,
    Y: u8,
    U: u8,
    V: u8,
};

pub const AM_PROPERTY_SPPAL = extern struct {
    sppal: [16]AM_DVD_YUV,
};

pub const AM_COLCON = extern struct {
    _bitfield1: u8,
    _bitfield2: u8,
    _bitfield3: u8,
    _bitfield4: u8,
};

pub const AM_PROPERTY_SPHLI = extern struct {
    HLISS: u16,
    Reserved: u16,
    StartPTM: u32,
    EndPTM: u32,
    StartX: u16,
    StartY: u16,
    StopX: u16,
    StopY: u16,
    ColCon: AM_COLCON,
};

pub const AM_PROPERTY_DVDCOPYPROT = enum(i32) {
    DVDCOPY_CHLG_KEY = 1,
    DVDCOPY_DVD_KEY1 = 2,
    DVDCOPY_DEC_KEY2 = 3,
    DVDCOPY_TITLE_KEY = 4,
    COPY_MACROVISION = 5,
    DVDCOPY_REGION = 6,
    DVDCOPY_SET_COPY_STATE = 7,
    COPY_ANALOG_COMPONENT = 8,
    COPY_DIGITAL_CP = 9,
    COPY_DVD_SRM = 10,
    DVDCOPY_SUPPORTS_NEW_KEYCOUNT = 11,
    DVDCOPY_DISC_KEY = 128,
};
pub const AM_PROPERTY_DVDCOPY_CHLG_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_CHLG_KEY;
pub const AM_PROPERTY_DVDCOPY_DVD_KEY1 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DVD_KEY1;
pub const AM_PROPERTY_DVDCOPY_DEC_KEY2 = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DEC_KEY2;
pub const AM_PROPERTY_DVDCOPY_TITLE_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_TITLE_KEY;
pub const AM_PROPERTY_COPY_MACROVISION = AM_PROPERTY_DVDCOPYPROT.COPY_MACROVISION;
pub const AM_PROPERTY_DVDCOPY_REGION = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_REGION;
pub const AM_PROPERTY_DVDCOPY_SET_COPY_STATE = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SET_COPY_STATE;
pub const AM_PROPERTY_COPY_ANALOG_COMPONENT = AM_PROPERTY_DVDCOPYPROT.COPY_ANALOG_COMPONENT;
pub const AM_PROPERTY_COPY_DIGITAL_CP = AM_PROPERTY_DVDCOPYPROT.COPY_DIGITAL_CP;
pub const AM_PROPERTY_COPY_DVD_SRM = AM_PROPERTY_DVDCOPYPROT.COPY_DVD_SRM;
pub const AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_SUPPORTS_NEW_KEYCOUNT;
pub const AM_PROPERTY_DVDCOPY_DISC_KEY = AM_PROPERTY_DVDCOPYPROT.DVDCOPY_DISC_KEY;

pub const AM_DIGITAL_CP = enum(i32) {
    OFF = 0,
    ON = 1,
    DVD_COMPLIANT = 2,
};
pub const AM_DIGITAL_CP_OFF = AM_DIGITAL_CP.OFF;
pub const AM_DIGITAL_CP_ON = AM_DIGITAL_CP.ON;
pub const AM_DIGITAL_CP_DVD_COMPLIANT = AM_DIGITAL_CP.DVD_COMPLIANT;

pub const AM_DVDCOPY_CHLGKEY = extern struct {
    ChlgKey: [10]u8,
    Reserved: [2]u8,
};

pub const AM_DVDCOPY_BUSKEY = extern struct {
    BusKey: [5]u8,
    Reserved: [1]u8,
};

pub const AM_DVDCOPY_DISCKEY = extern struct {
    DiscKey: [2048]u8,
};

pub const AM_DVDCOPY_TITLEKEY = extern struct {
    KeyFlags: u32,
    Reserved1: [2]u32,
    TitleKey: [6]u8,
    Reserved2: [2]u8,
};

pub const AM_COPY_MACROVISION = extern struct {
    MACROVISIONLevel: u32,
};

pub const AM_DVDCOPY_SET_COPY_STATE = extern struct {
    DVDCopyState: u32,
};

pub const AM_DVDCOPYSTATE = enum(i32) {
    INITIALIZE = 0,
    INITIALIZE_TITLE = 1,
    AUTHENTICATION_NOT_REQUIRED = 2,
    AUTHENTICATION_REQUIRED = 3,
    DONE = 4,
};
pub const AM_DVDCOPYSTATE_INITIALIZE = AM_DVDCOPYSTATE.INITIALIZE;
pub const AM_DVDCOPYSTATE_INITIALIZE_TITLE = AM_DVDCOPYSTATE.INITIALIZE_TITLE;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_NOT_REQUIRED;
pub const AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = AM_DVDCOPYSTATE.AUTHENTICATION_REQUIRED;
pub const AM_DVDCOPYSTATE_DONE = AM_DVDCOPYSTATE.DONE;

pub const AM_COPY_MACROVISION_LEVEL = enum(i32) {
    DISABLED = 0,
    LEVEL1 = 1,
    LEVEL2 = 2,
    LEVEL3 = 3,
};
pub const AM_MACROVISION_DISABLED = AM_COPY_MACROVISION_LEVEL.DISABLED;
pub const AM_MACROVISION_LEVEL1 = AM_COPY_MACROVISION_LEVEL.LEVEL1;
pub const AM_MACROVISION_LEVEL2 = AM_COPY_MACROVISION_LEVEL.LEVEL2;
pub const AM_MACROVISION_LEVEL3 = AM_COPY_MACROVISION_LEVEL.LEVEL3;

pub const DVD_REGION = extern struct {
    CopySystem: u8,
    RegionData: u8,
    SystemRegion: u8,
    ResetCount: u8,
};

pub const AM_MPEG2Level = enum(i32) {
    Low = 1,
    Main = 2,
    High1440 = 3,
    High = 4,
};
pub const AM_MPEG2Level_Low = AM_MPEG2Level.Low;
pub const AM_MPEG2Level_Main = AM_MPEG2Level.Main;
pub const AM_MPEG2Level_High1440 = AM_MPEG2Level.High1440;
pub const AM_MPEG2Level_High = AM_MPEG2Level.High;

pub const AM_MPEG2Profile = enum(i32) {
    Simple = 1,
    Main = 2,
    SNRScalable = 3,
    SpatiallyScalable = 4,
    High = 5,
};
pub const AM_MPEG2Profile_Simple = AM_MPEG2Profile.Simple;
pub const AM_MPEG2Profile_Main = AM_MPEG2Profile.Main;
pub const AM_MPEG2Profile_SNRScalable = AM_MPEG2Profile.SNRScalable;
pub const AM_MPEG2Profile_SpatiallyScalable = AM_MPEG2Profile.SpatiallyScalable;
pub const AM_MPEG2Profile_High = AM_MPEG2Profile.High;

pub const AM_DvdKaraokeData = extern struct {
    dwDownmix: u32,
    dwSpeakerAssignment: u32,
};

pub const AM_PROPERTY_DVDKARAOKE = enum(i32) {
    ENABLE = 0,
    DATA = 1,
};
pub const AM_PROPERTY_DVDKARAOKE_ENABLE = AM_PROPERTY_DVDKARAOKE.ENABLE;
pub const AM_PROPERTY_DVDKARAOKE_DATA = AM_PROPERTY_DVDKARAOKE.DATA;

pub const AM_PROPERTY_TS_RATE_CHANGE = enum(i32) {
    SimpleRateChange = 1,
    ExactRateChange = 2,
    MaxFullDataRate = 3,
    Step = 4,
    UseRateVersion = 5,
    QueryFullFrameRate = 6,
    QueryLastRateSegPTS = 7,
    CorrectTS = 8,
    ReverseMaxFullDataRate = 9,
    ResetOnTimeDisc = 10,
    QueryMapping = 11,
};
pub const AM_RATE_SimpleRateChange = AM_PROPERTY_TS_RATE_CHANGE.SimpleRateChange;
pub const AM_RATE_ExactRateChange = AM_PROPERTY_TS_RATE_CHANGE.ExactRateChange;
pub const AM_RATE_MaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.MaxFullDataRate;
pub const AM_RATE_Step = AM_PROPERTY_TS_RATE_CHANGE.Step;
pub const AM_RATE_UseRateVersion = AM_PROPERTY_TS_RATE_CHANGE.UseRateVersion;
pub const AM_RATE_QueryFullFrameRate = AM_PROPERTY_TS_RATE_CHANGE.QueryFullFrameRate;
pub const AM_RATE_QueryLastRateSegPTS = AM_PROPERTY_TS_RATE_CHANGE.QueryLastRateSegPTS;
pub const AM_RATE_CorrectTS = AM_PROPERTY_TS_RATE_CHANGE.CorrectTS;
pub const AM_RATE_ReverseMaxFullDataRate = AM_PROPERTY_TS_RATE_CHANGE.ReverseMaxFullDataRate;
pub const AM_RATE_ResetOnTimeDisc = AM_PROPERTY_TS_RATE_CHANGE.ResetOnTimeDisc;
pub const AM_RATE_QueryMapping = AM_PROPERTY_TS_RATE_CHANGE.QueryMapping;

pub const AM_PROPERTY_DVD_RATE_CHANGE = enum(i32) {
    ChangeRate = 1,
    FullDataRateMax = 2,
    ReverseDecode = 3,
    DecoderPosition = 4,
    DecoderVersion = 5,
};
pub const AM_RATE_ChangeRate = AM_PROPERTY_DVD_RATE_CHANGE.ChangeRate;
pub const AM_RATE_FullDataRateMax = AM_PROPERTY_DVD_RATE_CHANGE.FullDataRateMax;
pub const AM_RATE_ReverseDecode = AM_PROPERTY_DVD_RATE_CHANGE.ReverseDecode;
pub const AM_RATE_DecoderPosition = AM_PROPERTY_DVD_RATE_CHANGE.DecoderPosition;
pub const AM_RATE_DecoderVersion = AM_PROPERTY_DVD_RATE_CHANGE.DecoderVersion;

pub const AM_SimpleRateChange = extern struct {
    StartTime: i64,
    Rate: i32,
};

pub const AM_QueryRate = extern struct {
    lMaxForwardFullFrame: i32,
    lMaxReverseFullFrame: i32,
};

pub const AM_ExactRateChange = extern struct {
    OutputZeroTime: i64,
    Rate: i32,
};

pub const AM_DVD_ChangeRate = extern struct {
    StartInTime: i64,
    StartOutTime: i64,
    Rate: i32,
};

pub const DVD_PLAY_DIRECTION = enum(i32) {
    FORWARD = 0,
    BACKWARD = 1,
};
pub const DVD_DIR_FORWARD = DVD_PLAY_DIRECTION.FORWARD;
pub const DVD_DIR_BACKWARD = DVD_PLAY_DIRECTION.BACKWARD;

pub const DVD_ERROR = enum(i32) {
    Unexpected = 1,
    CopyProtectFail = 2,
    InvalidDVD1_0Disc = 3,
    InvalidDiscRegion = 4,
    LowParentalLevel = 5,
    MacrovisionFail = 6,
    IncompatibleSystemAndDecoderRegions = 7,
    IncompatibleDiscAndDecoderRegions = 8,
    CopyProtectOutputFail = 9,
    CopyProtectOutputNotSupported = 10,
};
pub const DVD_ERROR_Unexpected = DVD_ERROR.Unexpected;
pub const DVD_ERROR_CopyProtectFail = DVD_ERROR.CopyProtectFail;
pub const DVD_ERROR_InvalidDVD1_0Disc = DVD_ERROR.InvalidDVD1_0Disc;
pub const DVD_ERROR_InvalidDiscRegion = DVD_ERROR.InvalidDiscRegion;
pub const DVD_ERROR_LowParentalLevel = DVD_ERROR.LowParentalLevel;
pub const DVD_ERROR_MacrovisionFail = DVD_ERROR.MacrovisionFail;
pub const DVD_ERROR_IncompatibleSystemAndDecoderRegions = DVD_ERROR.IncompatibleSystemAndDecoderRegions;
pub const DVD_ERROR_IncompatibleDiscAndDecoderRegions = DVD_ERROR.IncompatibleDiscAndDecoderRegions;
pub const DVD_ERROR_CopyProtectOutputFail = DVD_ERROR.CopyProtectOutputFail;
pub const DVD_ERROR_CopyProtectOutputNotSupported = DVD_ERROR.CopyProtectOutputNotSupported;

pub const DVD_WARNING = enum(i32) {
    InvalidDVD1_0Disc = 1,
    FormatNotSupported = 2,
    IllegalNavCommand = 3,
    Open = 4,
    Seek = 5,
    Read = 6,
};
pub const DVD_WARNING_InvalidDVD1_0Disc = DVD_WARNING.InvalidDVD1_0Disc;
pub const DVD_WARNING_FormatNotSupported = DVD_WARNING.FormatNotSupported;
pub const DVD_WARNING_IllegalNavCommand = DVD_WARNING.IllegalNavCommand;
pub const DVD_WARNING_Open = DVD_WARNING.Open;
pub const DVD_WARNING_Seek = DVD_WARNING.Seek;
pub const DVD_WARNING_Read = DVD_WARNING.Read;

pub const DVD_PB_STOPPED = enum(i32) {
    Other = 0,
    NoBranch = 1,
    NoFirstPlayDomain = 2,
    StopCommand = 3,
    Reset = 4,
    DiscEjected = 5,
    IllegalNavCommand = 6,
    PlayPeriodAutoStop = 7,
    PlayChapterAutoStop = 8,
    ParentalFailure = 9,
    RegionFailure = 10,
    MacrovisionFailure = 11,
    DiscReadError = 12,
    CopyProtectFailure = 13,
    CopyProtectOutputFailure = 14,
    CopyProtectOutputNotSupported = 15,
};
pub const DVD_PB_STOPPED_Other = DVD_PB_STOPPED.Other;
pub const DVD_PB_STOPPED_NoBranch = DVD_PB_STOPPED.NoBranch;
pub const DVD_PB_STOPPED_NoFirstPlayDomain = DVD_PB_STOPPED.NoFirstPlayDomain;
pub const DVD_PB_STOPPED_StopCommand = DVD_PB_STOPPED.StopCommand;
pub const DVD_PB_STOPPED_Reset = DVD_PB_STOPPED.Reset;
pub const DVD_PB_STOPPED_DiscEjected = DVD_PB_STOPPED.DiscEjected;
pub const DVD_PB_STOPPED_IllegalNavCommand = DVD_PB_STOPPED.IllegalNavCommand;
pub const DVD_PB_STOPPED_PlayPeriodAutoStop = DVD_PB_STOPPED.PlayPeriodAutoStop;
pub const DVD_PB_STOPPED_PlayChapterAutoStop = DVD_PB_STOPPED.PlayChapterAutoStop;
pub const DVD_PB_STOPPED_ParentalFailure = DVD_PB_STOPPED.ParentalFailure;
pub const DVD_PB_STOPPED_RegionFailure = DVD_PB_STOPPED.RegionFailure;
pub const DVD_PB_STOPPED_MacrovisionFailure = DVD_PB_STOPPED.MacrovisionFailure;
pub const DVD_PB_STOPPED_DiscReadError = DVD_PB_STOPPED.DiscReadError;
pub const DVD_PB_STOPPED_CopyProtectFailure = DVD_PB_STOPPED.CopyProtectFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputFailure = DVD_PB_STOPPED.CopyProtectOutputFailure;
pub const DVD_PB_STOPPED_CopyProtectOutputNotSupported = DVD_PB_STOPPED.CopyProtectOutputNotSupported;

pub const AMGETERRORTEXTPROCA = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: HRESULT,
        param1: ?PSTR,
        param2: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: HRESULT,
        param1: ?PSTR,
        param2: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const AMGETERRORTEXTPROCW = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        param0: HRESULT,
        param1: ?PWSTR,
        param2: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => *const fn(
        param0: HRESULT,
        param1: ?PWSTR,
        param2: u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
} ;

pub const SNDDEV_ERR = enum(i32) {
    Open = 1,
    Close = 2,
    GetCaps = 3,
    PrepareHeader = 4,
    UnprepareHeader = 5,
    Reset = 6,
    Restart = 7,
    GetPosition = 8,
    Write = 9,
    Pause = 10,
    Stop = 11,
    Start = 12,
    AddBuffer = 13,
    Query = 14,
};
pub const SNDDEV_ERROR_Open = SNDDEV_ERR.Open;
pub const SNDDEV_ERROR_Close = SNDDEV_ERR.Close;
pub const SNDDEV_ERROR_GetCaps = SNDDEV_ERR.GetCaps;
pub const SNDDEV_ERROR_PrepareHeader = SNDDEV_ERR.PrepareHeader;
pub const SNDDEV_ERROR_UnprepareHeader = SNDDEV_ERR.UnprepareHeader;
pub const SNDDEV_ERROR_Reset = SNDDEV_ERR.Reset;
pub const SNDDEV_ERROR_Restart = SNDDEV_ERR.Restart;
pub const SNDDEV_ERROR_GetPosition = SNDDEV_ERR.GetPosition;
pub const SNDDEV_ERROR_Write = SNDDEV_ERR.Write;
pub const SNDDEV_ERROR_Pause = SNDDEV_ERR.Pause;
pub const SNDDEV_ERROR_Stop = SNDDEV_ERR.Stop;
pub const SNDDEV_ERROR_Start = SNDDEV_ERR.Start;
pub const SNDDEV_ERROR_AddBuffer = SNDDEV_ERR.AddBuffer;
pub const SNDDEV_ERROR_Query = SNDDEV_ERR.Query;

pub const MP_TYPE = enum(i32) {
    INT = 0,
    FLOAT = 1,
    BOOL = 2,
    ENUM = 3,
    MAX = 4,
};
pub const MPT_INT = MP_TYPE.INT;
pub const MPT_FLOAT = MP_TYPE.FLOAT;
pub const MPT_BOOL = MP_TYPE.BOOL;
pub const MPT_ENUM = MP_TYPE.ENUM;
pub const MPT_MAX = MP_TYPE.MAX;

pub const MP_CURVE_TYPE = enum(i32) {
    JUMP = 1,
    LINEAR = 2,
    SQUARE = 4,
    INVSQUARE = 8,
    SINE = 16,
};
pub const MP_CURVE_JUMP = MP_CURVE_TYPE.JUMP;
pub const MP_CURVE_LINEAR = MP_CURVE_TYPE.LINEAR;
pub const MP_CURVE_SQUARE = MP_CURVE_TYPE.SQUARE;
pub const MP_CURVE_INVSQUARE = MP_CURVE_TYPE.INVSQUARE;
pub const MP_CURVE_SINE = MP_CURVE_TYPE.SINE;

pub const MP_PARAMINFO = extern struct {
    mpType: MP_TYPE,
    mopCaps: u32,
    mpdMinValue: f32,
    mpdMaxValue: f32,
    mpdNeutralValue: f32,
    szUnitText: [32]u16,
    szLabel: [32]u16,
};

pub const MP_ENVELOPE_SEGMENT = extern struct {
    rtStart: i64,
    rtEnd: i64,
    valStart: f32,
    valEnd: f32,
    iCurve: MP_CURVE_TYPE,
    flags: u32,
};

const IID_IMediaParamInfo_Value = Guid.initString("6d6cbb60-a223-44aa-842f-a2f06750be6d");
pub const IID_IMediaParamInfo = &IID_IMediaParamInfo_Value;
pub const IMediaParamInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParamCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                pdwParams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                pdwParams: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParamInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                dwParamIndex: u32,
                pInfo: ?*MP_PARAMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                dwParamIndex: u32,
                pInfo: ?*MP_PARAMINFO,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetParamText: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                dwParamIndex: u32,
                ppwchText: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                dwParamIndex: u32,
                ppwchText: ?*?*u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNumTimeFormats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                pdwNumTimeFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                pdwNumTimeFormats: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSupportedTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                dwFormatIndex: u32,
                pguidTimeFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                dwFormatIndex: u32,
                pguidTimeFormat: ?*Guid,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParamInfo,
                pguidTimeFormat: ?*Guid,
                pTimeData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParamInfo,
                pguidTimeFormat: ?*Guid,
                pTimeData: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamCount(self: *const T, pdwParams: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamCount(@as(*const IMediaParamInfo, @ptrCast(self)), pdwParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamInfo(self: *const T, dwParamIndex: u32, pInfo: ?*MP_PARAMINFO) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamInfo(@as(*const IMediaParamInfo, @ptrCast(self)), dwParamIndex, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetParamText(self: *const T, dwParamIndex: u32, ppwchText: ?*?*u16) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetParamText(@as(*const IMediaParamInfo, @ptrCast(self)), dwParamIndex, ppwchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetNumTimeFormats(self: *const T, pdwNumTimeFormats: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetNumTimeFormats(@as(*const IMediaParamInfo, @ptrCast(self)), pdwNumTimeFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetSupportedTimeFormat(self: *const T, dwFormatIndex: u32, pguidTimeFormat: ?*Guid) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetSupportedTimeFormat(@as(*const IMediaParamInfo, @ptrCast(self)), dwFormatIndex, pguidTimeFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParamInfo_GetCurrentTimeFormat(self: *const T, pguidTimeFormat: ?*Guid, pTimeData: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParamInfo.VTable, @ptrCast(self.vtable)).GetCurrentTimeFormat(@as(*const IMediaParamInfo, @ptrCast(self)), pguidTimeFormat, pTimeData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMediaParams_Value = Guid.initString("6d6cbb61-a223-44aa-842f-a2f06750be6e");
pub const IID_IMediaParams = &IID_IMediaParams_Value;
pub const IMediaParams = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                pValue: ?*f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetParam: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                value: f32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddEnvelope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                cSegments: u32,
                pEnvelopeSegments: ?*MP_ENVELOPE_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                cSegments: u32,
                pEnvelopeSegments: ?*MP_ENVELOPE_SEGMENT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        FlushEnvelope: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                refTimeStart: i64,
                refTimeEnd: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParams,
                dwParamIndex: u32,
                refTimeStart: i64,
                refTimeEnd: i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimeFormat: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IMediaParams,
                guidTimeFormat: Guid,
                mpTimeData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IMediaParams,
                guidTimeFormat: Guid,
                mpTimeData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_GetParam(self: *const T, dwParamIndex: u32, pValue: ?*f32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).GetParam(@as(*const IMediaParams, @ptrCast(self)), dwParamIndex, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_SetParam(self: *const T, dwParamIndex: u32, value: f32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).SetParam(@as(*const IMediaParams, @ptrCast(self)), dwParamIndex, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_AddEnvelope(self: *const T, dwParamIndex: u32, cSegments: u32, pEnvelopeSegments: ?*MP_ENVELOPE_SEGMENT) callconv(.Inline) HRESULT {
            return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).AddEnvelope(@as(*const IMediaParams, @ptrCast(self)), dwParamIndex, cSegments, pEnvelopeSegments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_FlushEnvelope(self: *const T, dwParamIndex: u32, refTimeStart: i64, refTimeEnd: i64) callconv(.Inline) HRESULT {
            return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).FlushEnvelope(@as(*const IMediaParams, @ptrCast(self)), dwParamIndex, refTimeStart, refTimeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMediaParams_SetTimeFormat(self: *const T, guidTimeFormat: Guid, mpTimeData: u32) callconv(.Inline) HRESULT {
            return @as(*const IMediaParams.VTable, @ptrCast(self.vtable)).SetTimeFormat(@as(*const IMediaParams, @ptrCast(self)), guidTimeFormat, mpTimeData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VFW_FILTERLIST = extern struct {
    cFilters: u32,
    aClsId: [1]Guid,
};

pub const DXVA2_SampleFlags = enum(i32) {
    _Palette_Changed = 1,
    _SrcRect_Changed = 2,
    _DstRect_Changed = 4,
    _ColorData_Changed = 8,
    _PlanarAlpha_Changed = 16,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    sMask = -65505,
};
pub const DXVA2_SampleFlag_Palette_Changed = DXVA2_SampleFlags._Palette_Changed;
pub const DXVA2_SampleFlag_SrcRect_Changed = DXVA2_SampleFlags._SrcRect_Changed;
pub const DXVA2_SampleFlag_DstRect_Changed = DXVA2_SampleFlags._DstRect_Changed;
pub const DXVA2_SampleFlag_ColorData_Changed = DXVA2_SampleFlags._ColorData_Changed;
pub const DXVA2_SampleFlag_PlanarAlpha_Changed = DXVA2_SampleFlags._PlanarAlpha_Changed;
pub const DXVA2_SampleFlag_RFF = DXVA2_SampleFlags._RFF;
pub const DXVA2_SampleFlag_TFF = DXVA2_SampleFlags._TFF;
pub const DXVA2_SampleFlag_RFF_TFF_Present = DXVA2_SampleFlags._RFF_TFF_Present;
pub const DXVA2_SampleFlagsMask = DXVA2_SampleFlags.sMask;

pub const DXVA2_DestinationFlags = enum(i32) {
    _Background_Changed = 1,
    _TargetRect_Changed = 2,
    _ColorData_Changed = 4,
    _Alpha_Changed = 8,
    _RFF = 65536,
    _TFF = 131072,
    _RFF_TFF_Present = 262144,
    Mask = -65521,
};
pub const DXVA2_DestinationFlag_Background_Changed = DXVA2_DestinationFlags._Background_Changed;
pub const DXVA2_DestinationFlag_TargetRect_Changed = DXVA2_DestinationFlags._TargetRect_Changed;
pub const DXVA2_DestinationFlag_ColorData_Changed = DXVA2_DestinationFlags._ColorData_Changed;
pub const DXVA2_DestinationFlag_Alpha_Changed = DXVA2_DestinationFlags._Alpha_Changed;
pub const DXVA2_DestinationFlag_RFF = DXVA2_DestinationFlags._RFF;
pub const DXVA2_DestinationFlag_TFF = DXVA2_DestinationFlags._TFF;
pub const DXVA2_DestinationFlag_RFF_TFF_Present = DXVA2_DestinationFlags._RFF_TFF_Present;
pub const DXVA2_DestinationFlagMask = DXVA2_DestinationFlags.Mask;

pub const DXVA2_VIDEOSAMPLE = extern struct {
    Start: i64,
    End: i64,
    SampleFormat: DXVA2_ExtendedFormat,
    SampleFlags: u32,
    SrcResource: ?*anyopaque,
    SrcRect: RECT,
    DstRect: RECT,
    Pal: [16]DXVA2_AYUVSample8,
    PlanarAlpha: DXVA2_Fixed32,
};

pub const DXVA2_VIDEOPROCESSBLT = extern struct {
    TargetFrame: i64,
    TargetRect: RECT,
    ConstrictionSize: SIZE,
    StreamingFlags: u32,
    BackgroundColor: DXVA2_AYUVSample16,
    DestFormat: DXVA2_ExtendedFormat,
    DestFlags: u32,
    ProcAmpValues: DXVA2_ProcAmpValues,
    Alpha: DXVA2_Fixed32,
    NoiseFilterLuma: DXVA2_FilterValues,
    NoiseFilterChroma: DXVA2_FilterValues,
    DetailFilterLuma: DXVA2_FilterValues,
    DetailFilterChroma: DXVA2_FilterValues,
    pSrcSurfaces: ?*DXVA2_VIDEOSAMPLE,
    NumSrcSurfaces: u32,
};

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        pCount: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        pCount: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETVIDEOPROCESSORCAPS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        pCaps: ?*DXVA2_VideoProcessorCaps,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        pCaps: ?*DXVA2_VideoProcessorCaps,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        pCount: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        pCount: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        Count: u32,
        pFormats: [*]D3DFORMAT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETPROCAMPRANGE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        ProcAmpCap: u32,
        pRange: ?*DXVA2_ValueRange,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        ProcAmpCap: u32,
        pRange: ?*DXVA2_ValueRange,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_GETFILTERPROPERTYRANGE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        FilterSetting: u32,
        pRange: ?*DXVA2_ValueRange,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        FilterSetting: u32,
        pRange: ?*DXVA2_ValueRange,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_CREATEVIDEOPROCESSDEVICE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pD3DD9: ?*IDirect3DDevice9,
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        MaxSubStreams: u32,
        phDevice: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        pD3DD9: ?*IDirect3DDevice9,
        pVideoDesc: ?*const DXVA2_VideoDesc,
        RenderTargetFormat: D3DFORMAT,
        MaxSubStreams: u32,
        phDevice: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_DESTROYVIDEOPROCESSDEVICE = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_VIDEOPROCESSBEGINFRAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hDevice: ?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_VIDEOPROCESSENDFRAME = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hDevice: ?HANDLE,
        pHandleComplete: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hDevice: ?HANDLE,
        pHandleComplete: ?*?HANDLE,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_VIDEOPROCESSSETRENDERTARGET = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hDevice: ?HANDLE,
        pRenderTarget: ?*IDirect3DSurface9,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hDevice: ?HANDLE,
        pRenderTarget: ?*IDirect3DSurface9,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const PDXVA2SW_VIDEOPROCESSBLT = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        hDevice: ?HANDLE,
        pBlt: ?*const DXVA2_VIDEOPROCESSBLT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        hDevice: ?HANDLE,
        pBlt: ?*const DXVA2_VIDEOPROCESSBLT,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const DXVA2SW_CALLBACKS = extern struct {
    Size: u32,
    GetVideoProcessorRenderTargetCount: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT,
    GetVideoProcessorRenderTargets: ?PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS,
    GetVideoProcessorCaps: ?PDXVA2SW_GETVIDEOPROCESSORCAPS,
    GetVideoProcessorSubStreamFormatCount: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT,
    GetVideoProcessorSubStreamFormats: ?PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS,
    GetProcAmpRange: ?PDXVA2SW_GETPROCAMPRANGE,
    GetFilterPropertyRange: ?PDXVA2SW_GETFILTERPROPERTYRANGE,
    CreateVideoProcessDevice: ?PDXVA2SW_CREATEVIDEOPROCESSDEVICE,
    DestroyVideoProcessDevice: ?PDXVA2SW_DESTROYVIDEOPROCESSDEVICE,
    VideoProcessBeginFrame: ?PDXVA2SW_VIDEOPROCESSBEGINFRAME,
    VideoProcessEndFrame: ?PDXVA2SW_VIDEOPROCESSENDFRAME,
    VideoProcessSetRenderTarget: ?PDXVA2SW_VIDEOPROCESSSETRENDERTARGET,
    VideoProcessBlt: ?PDXVA2SW_VIDEOPROCESSBLT,
};

pub const DXVA2Trace_DecodeDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevBeginFrameData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    Enter: BOOL,
};

pub const DXVA2Trace_DecodeDevGetBufferData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    BufferType: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDevCreatedData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pD3DDevice: u64,
    DeviceGuid: Guid,
    RTFourCC: u32,
    Width: u32,
    Height: u32,
    Enter: BOOL,
};

pub const DXVA2Trace_VideoProcessDeviceData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    Enter: BOOL,
};

pub const DXVA2TraceVideoProcessBltData = extern struct {
    wmiHeader: EVENT_TRACE_HEADER,
    pObject: u64,
    pRenderTarget: u64,
    TargetFrameTime: u64,
    TargetRect: RECT,
    Enter: BOOL,
};

pub const AMPlayListItemFlags = enum(i32) {
    SKIP = 1,
    BIND = 2,
};
pub const AMPLAYLISTITEM_CANSKIP = AMPlayListItemFlags.SKIP;
pub const AMPLAYLISTITEM_CANBIND = AMPlayListItemFlags.BIND;

const IID_IAMPlayListItem_Value = Guid.initString("56a868ff-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayListItem = &IID_IAMPlayListItem_Value;
pub const IAMPlayListItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                pdwSources: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                pdwSources: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceStart: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtStart: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceStartMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pdwMarker: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pdwMarker: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEndMarker: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pdwMarker: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pdwMarker: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceStartMarkerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrStartMarker: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrStartMarker: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSourceEndMarkerName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrEndMarker: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                pbstrEndMarker: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetLinkURL: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                pbstrURL: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetScanDuration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtScanDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayListItem,
                dwSourceIndex: u32,
                prtScanDuration: ?*i64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IAMPlayListItem, @ptrCast(self)), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceCount(self: *const T, pdwSources: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceCount(@as(*const IAMPlayListItem, @ptrCast(self)), pdwSources);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceURL(self: *const T, dwSourceIndex: u32, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceURL(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStart(self: *const T, dwSourceIndex: u32, prtStart: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStart(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, prtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceDuration(self: *const T, dwSourceIndex: u32, prtDuration: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceDuration(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, prtDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStartMarker(self: *const T, dwSourceIndex: u32, pdwMarker: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStartMarker(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, pdwMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceEndMarker(self: *const T, dwSourceIndex: u32, pdwMarker: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceEndMarker(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, pdwMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceStartMarkerName(self: *const T, dwSourceIndex: u32, pbstrStartMarker: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceStartMarkerName(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, pbstrStartMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetSourceEndMarkerName(self: *const T, dwSourceIndex: u32, pbstrEndMarker: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetSourceEndMarkerName(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, pbstrEndMarker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetLinkURL(self: *const T, pbstrURL: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetLinkURL(@as(*const IAMPlayListItem, @ptrCast(self)), pbstrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayListItem_GetScanDuration(self: *const T, dwSourceIndex: u32, prtScanDuration: ?*i64) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayListItem.VTable, @ptrCast(self.vtable)).GetScanDuration(@as(*const IAMPlayListItem, @ptrCast(self)), dwSourceIndex, prtScanDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AMPlayListFlags = enum(i32) {
    STARTINSCANMODE = 1,
    FORCEBANNER = 2,
};
pub const AMPLAYLIST_STARTINSCANMODE = AMPlayListFlags.STARTINSCANMODE;
pub const AMPLAYLIST_FORCEBANNER = AMPlayListFlags.FORCEBANNER;

pub const AMPlayListEventFlags = enum(i32) {
    RESUME = 0,
    BREAK = 1,
    NEXT = 2,
    MASK = 15,
    REFRESH = 16,
};
pub const AMPLAYLISTEVENT_RESUME = AMPlayListEventFlags.RESUME;
pub const AMPLAYLISTEVENT_BREAK = AMPlayListEventFlags.BREAK;
pub const AMPLAYLISTEVENT_NEXT = AMPlayListEventFlags.NEXT;
pub const AMPLAYLISTEVENT_MASK = AMPlayListEventFlags.MASK;
pub const AMPLAYLISTEVENT_REFRESH = AMPlayListEventFlags.REFRESH;

const IID_IAMPlayList_Value = Guid.initString("56a868fe-0ad4-11ce-b03a-0020af0ba770");
pub const IID_IAMPlayList = &IID_IAMPlayList_Value;
pub const IAMPlayList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayList,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayList,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItemCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayList,
                pdwItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayList,
                pdwItems: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayList,
                dwItemIndex: u32,
                ppItem: ?*?*IAMPlayListItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayList,
                dwItemIndex: u32,
                ppItem: ?*?*IAMPlayListItem,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNamedEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayList,
                pwszEventName: ?PWSTR,
                dwItemIndex: u32,
                ppItem: ?*?*IAMPlayListItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayList,
                pwszEventName: ?PWSTR,
                dwItemIndex: u32,
                ppItem: ?*?*IAMPlayListItem,
                pdwFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRepeatInfo: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMPlayList,
                pdwRepeatCount: ?*u32,
                pdwRepeatStart: ?*u32,
                pdwRepeatEnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMPlayList,
                pdwRepeatCount: ?*u32,
                pdwRepeatStart: ?*u32,
                pdwRepeatEnd: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetFlags(self: *const T, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetFlags(@as(*const IAMPlayList, @ptrCast(self)), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetItemCount(self: *const T, pdwItems: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetItemCount(@as(*const IAMPlayList, @ptrCast(self)), pdwItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetItem(self: *const T, dwItemIndex: u32, ppItem: ?*?*IAMPlayListItem) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetItem(@as(*const IAMPlayList, @ptrCast(self)), dwItemIndex, ppItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetNamedEvent(self: *const T, pwszEventName: ?PWSTR, dwItemIndex: u32, ppItem: ?*?*IAMPlayListItem, pdwFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetNamedEvent(@as(*const IAMPlayList, @ptrCast(self)), pwszEventName, dwItemIndex, ppItem, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMPlayList_GetRepeatInfo(self: *const T, pdwRepeatCount: ?*u32, pdwRepeatStart: ?*u32, pdwRepeatEnd: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IAMPlayList.VTable, @ptrCast(self.vtable)).GetRepeatInfo(@as(*const IAMPlayList, @ptrCast(self)), pdwRepeatCount, pdwRepeatStart, pdwRepeatEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpecifyParticularPages_Value = Guid.initString("4c437b91-6e9e-11d1-a704-006097c4e476");
pub const IID_ISpecifyParticularPages = &IID_ISpecifyParticularPages_Value;
pub const ISpecifyParticularPages = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPages: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ISpecifyParticularPages,
                guidWhatPages: ?*const Guid,
                pPages: ?*CAUUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ISpecifyParticularPages,
                guidWhatPages: ?*const Guid,
                pPages: ?*CAUUID,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpecifyParticularPages_GetPages(self: *const T, guidWhatPages: ?*const Guid, pPages: ?*CAUUID) callconv(.Inline) HRESULT {
            return @as(*const ISpecifyParticularPages.VTable, @ptrCast(self.vtable)).GetPages(@as(*const ISpecifyParticularPages, @ptrCast(self)), guidWhatPages, pPages);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAMRebuild_Value = Guid.initString("02ef04dd-7580-11d1-bece-00c04fb6e937");
pub const IID_IAMRebuild = &IID_IAMRebuild_Value;
pub const IAMRebuild = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RebuildNow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAMRebuild,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAMRebuild,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAMRebuild_RebuildNow(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IAMRebuild.VTable, @ptrCast(self.vtable)).RebuildNow(@as(*const IAMRebuild, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBufferingTime_Value = Guid.initString("1e00486a-78dd-11d2-8dd3-006097c9a2b2");
pub const IID_IBufferingTime = &IID_IBufferingTime_Value;
pub const IBufferingTime = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferingTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBufferingTime,
                pdwMilliseconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBufferingTime,
                pdwMilliseconds: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetBufferingTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IBufferingTime,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IBufferingTime,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferingTime_GetBufferingTime(self: *const T, pdwMilliseconds: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IBufferingTime.VTable, @ptrCast(self.vtable)).GetBufferingTime(@as(*const IBufferingTime, @ptrCast(self)), pdwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBufferingTime_SetBufferingTime(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @as(*const IBufferingTime.VTable, @ptrCast(self.vtable)).SetBufferingTime(@as(*const IBufferingTime, @ptrCast(self)), dwMilliseconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MPEG1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX align(1),
    fwHeadLayer: u16 align(1),
    dwHeadBitrate: u32 align(1),
    fwHeadMode: u16 align(1),
    fwHeadModeExt: u16 align(1),
    wHeadEmphasis: u16 align(1),
    fwHeadFlags: u16 align(1),
    dwPTSLow: u32 align(1),
    dwPTSHigh: u32 align(1),
};

pub const MPEGLAYER3WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX align(1),
    wID: u16 align(1),
    fdwFlags: MPEGLAYER3WAVEFORMAT_FLAGS align(1),
    nBlockSize: u16 align(1),
    nFramesPerBlock: u16 align(1),
    nCodecDelay: u16 align(1),
};

pub const HEAACWAVEINFO = extern struct {
    wfx: WAVEFORMATEX align(1),
    wPayloadType: u16 align(1),
    wAudioProfileLevelIndication: u16 align(1),
    wStructType: u16 align(1),
    wReserved1: u16 align(1),
    dwReserved2: u32 align(1),
};

pub const HEAACWAVEFORMAT = extern struct {
    wfInfo: HEAACWAVEINFO,
    pbAudioSpecificConfig: [1]u8,
};

const IID_IWMCodecAMVideoAccelerator_Value = Guid.initString("d98ee251-34e0-4a2d-9312-9b4c788d9fa1");
pub const IID_IWMCodecAMVideoAccelerator = &IID_IWMCodecAMVideoAccelerator_Value;
pub const IWMCodecAMVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAcceleratorInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWMCodecAMVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWMCodecAMVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NegotiateConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWMCodecAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWMCodecAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayerNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWMCodecAMVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWMCodecAMVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecAMVideoAccelerator_SetAcceleratorInterface(self: *const T, pIAMVA: ?*IAMVideoAccelerator) callconv(.Inline) HRESULT {
            return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).SetAcceleratorInterface(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pIAMVA);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecAMVideoAccelerator_NegotiateConnection(self: *const T, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).NegotiateConnection(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecAMVideoAccelerator_SetPlayerNotify(self: *const T, pHook: ?*IWMPlayerTimestampHook) callconv(.Inline) HRESULT {
            return @as(*const IWMCodecAMVideoAccelerator.VTable, @ptrCast(self.vtable)).SetPlayerNotify(@as(*const IWMCodecAMVideoAccelerator, @ptrCast(self)), pHook);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecVideoAccelerator_Value = Guid.initString("990641b0-739f-4e94-a808-9888da8f75af");
pub const IID_IWMCodecVideoAccelerator = &IID_IWMCodecVideoAccelerator_Value;
pub const IWMCodecVideoAccelerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NegotiateConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWMCodecVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWMCodecVideoAccelerator,
                pIAMVA: ?*IAMVideoAccelerator,
                pMediaType: ?*AM_MEDIA_TYPE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPlayerNotify: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IWMCodecVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IWMCodecVideoAccelerator,
                pHook: ?*IWMPlayerTimestampHook,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecVideoAccelerator_NegotiateConnection(self: *const T, pIAMVA: ?*IAMVideoAccelerator, pMediaType: ?*AM_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @as(*const IWMCodecVideoAccelerator.VTable, @ptrCast(self.vtable)).NegotiateConnection(@as(*const IWMCodecVideoAccelerator, @ptrCast(self)), pIAMVA, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecVideoAccelerator_SetPlayerNotify(self: *const T, pHook: ?*IWMPlayerTimestampHook) callconv(.Inline) HRESULT {
            return @as(*const IWMCodecVideoAccelerator.VTable, @ptrCast(self.vtable)).SetPlayerNotify(@as(*const IWMCodecVideoAccelerator, @ptrCast(self)), pHook);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VIDEOENCODER_BITRATE_MODE = enum(i32) {
    ConstantBitRate = 0,
    VariableBitRateAverage = 1,
    VariableBitRatePeak = 2,
};
pub const ConstantBitRate = VIDEOENCODER_BITRATE_MODE.ConstantBitRate;
pub const VariableBitRateAverage = VIDEOENCODER_BITRATE_MODE.VariableBitRateAverage;
pub const VariableBitRatePeak = VIDEOENCODER_BITRATE_MODE.VariableBitRatePeak;

pub const DXVA_COPPSetProtectionLevelCmdData = extern struct {
    ProtType: u32,
    ProtLevel: u32,
    ExtendedInfoChangeMask: u32,
    ExtendedInfoData: u32,
};

pub const COPP_HDCP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    // LevelMax = 1, this enum value conflicts with Level1
    ForceDWORD = 2147483647,
};
pub const COPP_HDCP_Level0 = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_LevelMin = COPP_HDCP_Protection_Level.Level0;
pub const COPP_HDCP_Level1 = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_LevelMax = COPP_HDCP_Protection_Level.Level1;
pub const COPP_HDCP_ForceDWORD = COPP_HDCP_Protection_Level.ForceDWORD;

pub const COPP_CGMSA_Protection_Level = enum(i32) {
    Disabled = 0,
    // LevelMin = 0, this enum value conflicts with Disabled
    CopyFreely = 1,
    CopyNoMore = 2,
    CopyOneGeneration = 3,
    CopyNever = 4,
    RedistributionControlRequired = 8,
    LevelMax = 12,
    ForceDWORD = 2147483647,
};
pub const COPP_CGMSA_Disabled = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_LevelMin = COPP_CGMSA_Protection_Level.Disabled;
pub const COPP_CGMSA_CopyFreely = COPP_CGMSA_Protection_Level.CopyFreely;
pub const COPP_CGMSA_CopyNoMore = COPP_CGMSA_Protection_Level.CopyNoMore;
pub const COPP_CGMSA_CopyOneGeneration = COPP_CGMSA_Protection_Level.CopyOneGeneration;
pub const COPP_CGMSA_CopyNever = COPP_CGMSA_Protection_Level.CopyNever;
pub const COPP_CGMSA_RedistributionControlRequired = COPP_CGMSA_Protection_Level.RedistributionControlRequired;
pub const COPP_CGMSA_LevelMax = COPP_CGMSA_Protection_Level.LevelMax;
pub const COPP_CGMSA_ForceDWORD = COPP_CGMSA_Protection_Level.ForceDWORD;

pub const COPP_ACP_Protection_Level = enum(i32) {
    Level0 = 0,
    // LevelMin = 0, this enum value conflicts with Level0
    Level1 = 1,
    Level2 = 2,
    Level3 = 3,
    // LevelMax = 3, this enum value conflicts with Level3
    ForceDWORD = 2147483647,
};
pub const COPP_ACP_Level0 = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_LevelMin = COPP_ACP_Protection_Level.Level0;
pub const COPP_ACP_Level1 = COPP_ACP_Protection_Level.Level1;
pub const COPP_ACP_Level2 = COPP_ACP_Protection_Level.Level2;
pub const COPP_ACP_Level3 = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_LevelMax = COPP_ACP_Protection_Level.Level3;
pub const COPP_ACP_ForceDWORD = COPP_ACP_Protection_Level.ForceDWORD;

pub const DXVA_COPPSetSignalingCmdData = extern struct {
    ActiveTVProtectionStandard: u32,
    AspectRatioChangeMask1: u32,
    AspectRatioData1: u32,
    AspectRatioChangeMask2: u32,
    AspectRatioData2: u32,
    AspectRatioChangeMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoChangeMask: [4]u32,
    ExtendedInfoData: [4]u32,
    Reserved: u32,
};

pub const COPP_TVProtectionStandard = enum(i32) {
    Unknown = -2147483648,
    None = 0,
    IEC61880_525i = 1,
    IEC61880_2_525i = 2,
    IEC62375_625p = 4,
    EIA608B_525 = 8,
    EN300294_625i = 16,
    CEA805A_TypeA_525p = 32,
    CEA805A_TypeA_750p = 64,
    CEA805A_TypeA_1125i = 128,
    CEA805A_TypeB_525p = 256,
    CEA805A_TypeB_750p = 512,
    CEA805A_TypeB_1125i = 1024,
    ARIBTRB15_525i = 2048,
    ARIBTRB15_525p = 4096,
    ARIBTRB15_750p = 8192,
    ARIBTRB15_1125i = 16384,
    Mask = -2147450881,
    Reserved = 2147450880,
};
pub const COPP_ProtectionStandard_Unknown = COPP_TVProtectionStandard.Unknown;
pub const COPP_ProtectionStandard_None = COPP_TVProtectionStandard.None;
pub const COPP_ProtectionStandard_IEC61880_525i = COPP_TVProtectionStandard.IEC61880_525i;
pub const COPP_ProtectionStandard_IEC61880_2_525i = COPP_TVProtectionStandard.IEC61880_2_525i;
pub const COPP_ProtectionStandard_IEC62375_625p = COPP_TVProtectionStandard.IEC62375_625p;
pub const COPP_ProtectionStandard_EIA608B_525 = COPP_TVProtectionStandard.EIA608B_525;
pub const COPP_ProtectionStandard_EN300294_625i = COPP_TVProtectionStandard.EN300294_625i;
pub const COPP_ProtectionStandard_CEA805A_TypeA_525p = COPP_TVProtectionStandard.CEA805A_TypeA_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_750p = COPP_TVProtectionStandard.CEA805A_TypeA_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeA_1125i = COPP_TVProtectionStandard.CEA805A_TypeA_1125i;
pub const COPP_ProtectionStandard_CEA805A_TypeB_525p = COPP_TVProtectionStandard.CEA805A_TypeB_525p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_750p = COPP_TVProtectionStandard.CEA805A_TypeB_750p;
pub const COPP_ProtectionStandard_CEA805A_TypeB_1125i = COPP_TVProtectionStandard.CEA805A_TypeB_1125i;
pub const COPP_ProtectionStandard_ARIBTRB15_525i = COPP_TVProtectionStandard.ARIBTRB15_525i;
pub const COPP_ProtectionStandard_ARIBTRB15_525p = COPP_TVProtectionStandard.ARIBTRB15_525p;
pub const COPP_ProtectionStandard_ARIBTRB15_750p = COPP_TVProtectionStandard.ARIBTRB15_750p;
pub const COPP_ProtectionStandard_ARIBTRB15_1125i = COPP_TVProtectionStandard.ARIBTRB15_1125i;
pub const COPP_ProtectionStandard_Mask = COPP_TVProtectionStandard.Mask;
pub const COPP_ProtectionStandard_Reserved = COPP_TVProtectionStandard.Reserved;

pub const COPP_ImageAspectRatio_EN300294 = enum(i32) {
    EN300294_FullFormat4by3 = 0,
    EN300294_Box14by9Center = 1,
    EN300294_Box14by9Top = 2,
    EN300294_Box16by9Center = 3,
    EN300294_Box16by9Top = 4,
    EN300294_BoxGT16by9Center = 5,
    EN300294_FullFormat4by3ProtectedCenter = 6,
    EN300294_FullFormat16by9Anamorphic = 7,
    ForceDWORD = 2147483647,
};
pub const COPP_AspectRatio_EN300294_FullFormat4by3 = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3;
pub const COPP_AspectRatio_EN300294_Box14by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Center;
pub const COPP_AspectRatio_EN300294_Box14by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box14by9Top;
pub const COPP_AspectRatio_EN300294_Box16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Center;
pub const COPP_AspectRatio_EN300294_Box16by9Top = COPP_ImageAspectRatio_EN300294.EN300294_Box16by9Top;
pub const COPP_AspectRatio_EN300294_BoxGT16by9Center = COPP_ImageAspectRatio_EN300294.EN300294_BoxGT16by9Center;
pub const COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat4by3ProtectedCenter;
pub const COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic = COPP_ImageAspectRatio_EN300294.EN300294_FullFormat16by9Anamorphic;
pub const COPP_AspectRatio_ForceDWORD = COPP_ImageAspectRatio_EN300294.ForceDWORD;

pub const COPP_StatusFlags = enum(i32) {
    StatusNormal = 0,
    LinkLost = 1,
    RenegotiationRequired = 2,
    StatusFlagsReserved = -4,
};
pub const COPP_StatusNormal = COPP_StatusFlags.StatusNormal;
pub const COPP_LinkLost = COPP_StatusFlags.LinkLost;
pub const COPP_RenegotiationRequired = COPP_StatusFlags.RenegotiationRequired;
pub const COPP_StatusFlagsReserved = COPP_StatusFlags.StatusFlagsReserved;

pub const DXVA_COPPStatusData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwData: u32,
    ExtendedInfoValidMask: u32,
    ExtendedInfoData: u32,
};

pub const DXVA_COPPStatusDisplayData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    DisplayWidth: u32,
    DisplayHeight: u32,
    Format: u32,
    d3dFormat: u32,
    FreqNumerator: u32,
    FreqDenominator: u32,
};

pub const COPP_StatusHDCPFlags = enum(i32) {
    Repeater = 1,
    FlagsReserved = -2,
};
pub const COPP_HDCPRepeater = COPP_StatusHDCPFlags.Repeater;
pub const COPP_HDCPFlagsReserved = COPP_StatusHDCPFlags.FlagsReserved;

pub const DXVA_COPPStatusHDCPKeyData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    dwHDCPFlags: u32,
    BKey: Guid,
    Reserved1: Guid,
    Reserved2: Guid,
};

pub const COPP_ConnectorType = enum(i32) {
    Unknown = -1,
    VGA = 0,
    SVideo = 1,
    CompositeVideo = 2,
    ComponentVideo = 3,
    DVI = 4,
    HDMI = 5,
    LVDS = 6,
    TMDS = 7,
    D_JPN = 8,
    Internal = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_ConnectorType_Unknown = COPP_ConnectorType.Unknown;
pub const COPP_ConnectorType_VGA = COPP_ConnectorType.VGA;
pub const COPP_ConnectorType_SVideo = COPP_ConnectorType.SVideo;
pub const COPP_ConnectorType_CompositeVideo = COPP_ConnectorType.CompositeVideo;
pub const COPP_ConnectorType_ComponentVideo = COPP_ConnectorType.ComponentVideo;
pub const COPP_ConnectorType_DVI = COPP_ConnectorType.DVI;
pub const COPP_ConnectorType_HDMI = COPP_ConnectorType.HDMI;
pub const COPP_ConnectorType_LVDS = COPP_ConnectorType.LVDS;
pub const COPP_ConnectorType_TMDS = COPP_ConnectorType.TMDS;
pub const COPP_ConnectorType_D_JPN = COPP_ConnectorType.D_JPN;
pub const COPP_ConnectorType_Internal = COPP_ConnectorType.Internal;
pub const COPP_ConnectorType_ForceDWORD = COPP_ConnectorType.ForceDWORD;

pub const COPP_BusType = enum(i32) {
    Unknown = 0,
    PCI = 1,
    PCIX = 2,
    PCIExpress = 3,
    AGP = 4,
    Integrated = -2147483648,
    ForceDWORD = 2147483647,
};
pub const COPP_BusType_Unknown = COPP_BusType.Unknown;
pub const COPP_BusType_PCI = COPP_BusType.PCI;
pub const COPP_BusType_PCIX = COPP_BusType.PCIX;
pub const COPP_BusType_PCIExpress = COPP_BusType.PCIExpress;
pub const COPP_BusType_AGP = COPP_BusType.AGP;
pub const COPP_BusType_Integrated = COPP_BusType.Integrated;
pub const COPP_BusType_ForceDWORD = COPP_BusType.ForceDWORD;

pub const DXVA_COPPStatusSignalingCmdData = extern struct {
    rApp: Guid,
    dwFlags: u32,
    AvailableTVProtectionStandards: u32,
    ActiveTVProtectionStandard: u32,
    TVType: u32,
    AspectRatioValidMask1: u32,
    AspectRatioData1: u32,
    AspectRatioValidMask2: u32,
    AspectRatioData2: u32,
    AspectRatioValidMask3: u32,
    AspectRatioData3: u32,
    ExtendedInfoValidMask: [4]u32,
    ExtendedInfoData: [4]u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (2)
//--------------------------------------------------------------------------------
pub extern "quartz" fn AMGetErrorTextA(
    hr: HRESULT,
    pbuffer: [*:0]u8,
    MaxLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "quartz" fn AMGetErrorTextW(
    hr: HRESULT,
    pbuffer: [*:0]u16,
    MaxLen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (2)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCA;
        pub const AMGetErrorText = thismodule.AMGetErrorTextA;
    },
    .wide => struct {
        pub const AMGETERRORTEXTPROC = thismodule.AMGETERRORTEXTPROCW;
        pub const AMGetErrorText = thismodule.AMGetErrorTextW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const AMGETERRORTEXTPROC = *opaque{};
        pub const AMGetErrorText = *opaque{};
    } else struct {
        pub const AMGETERRORTEXTPROC = @compileError("'AMGETERRORTEXTPROC' requires that UNICODE be set to true or false in the root module");
        pub const AMGetErrorText = @compileError("'AMGetErrorText' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (72)
//--------------------------------------------------------------------------------
const Guid = @import("../../../zig.zig").Guid;
const AM_MEDIA_TYPE = @import("../../../windows/win32/media/media_foundation.zig").AM_MEDIA_TYPE;
const BITMAPINFO = @import("../../../windows/win32/graphics/gdi.zig").BITMAPINFO;
const BITMAPINFOHEADER = @import("../../../windows/win32/graphics/gdi.zig").BITMAPINFOHEADER;
const BOOL = @import("../../../windows/win32/foundation.zig").BOOL;
const BOOLEAN = @import("../../../windows/win32/foundation.zig").BOOLEAN;
const BSTR = @import("../../../windows/win32/foundation.zig").BSTR;
const CAUUID = @import("../../../windows/win32/system/ole.zig").CAUUID;
const COLORREF = @import("../../../windows/win32/foundation.zig").COLORREF;
const D3DFORMAT = @import("../../../windows/win32/graphics/direct3d9.zig").D3DFORMAT;
const D3DPOOL = @import("../../../windows/win32/graphics/direct3d9.zig").D3DPOOL;
const DDCAPS_DX7 = @import("../../../windows/win32/graphics/direct_draw.zig").DDCAPS_DX7;
const DDCOLORCONTROL = @import("../../../windows/win32/graphics/direct_draw.zig").DDCOLORCONTROL;
const DDCOLORKEY = @import("../../../windows/win32/graphics/direct_draw.zig").DDCOLORKEY;
const DDPIXELFORMAT = @import("../../../windows/win32/graphics/direct_draw.zig").DDPIXELFORMAT;
const DDSCAPS2 = @import("../../../windows/win32/graphics/direct_draw.zig").DDSCAPS2;
const DDSURFACEDESC = @import("../../../windows/win32/graphics/direct_draw.zig").DDSURFACEDESC;
const DDVIDEOPORTCONNECT = @import("../../../windows/win32/graphics/direct_draw.zig").DDVIDEOPORTCONNECT;
const DXVA2_AYUVSample16 = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_AYUVSample16;
const DXVA2_AYUVSample8 = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_AYUVSample8;
const DXVA2_ExtendedFormat = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_ExtendedFormat;
const DXVA2_FilterValues = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_FilterValues;
const DXVA2_Fixed32 = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_Fixed32;
const DXVA2_ProcAmpValues = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_ProcAmpValues;
const DXVA2_ValueRange = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_ValueRange;
const DXVA2_VideoDesc = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_VideoDesc;
const DXVA2_VideoProcessorCaps = @import("../../../windows/win32/media/media_foundation.zig").DXVA2_VideoProcessorCaps;
const EVENT_TRACE_HEADER = @import("../../../windows/win32/system/diagnostics/etw.zig").EVENT_TRACE_HEADER;
const HACCEL = @import("../../../windows/win32/ui/windows_and_messaging.zig").HACCEL;
const HANDLE = @import("../../../windows/win32/foundation.zig").HANDLE;
const HDC = @import("../../../windows/win32/graphics/gdi.zig").HDC;
const HKEY = @import("../../../windows/win32/system/registry.zig").HKEY;
const HMONITOR = @import("../../../windows/win32/graphics/gdi.zig").HMONITOR;
const HRESULT = @import("../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../windows/win32/foundation.zig").HWND;
const IBindCtx = @import("../../../windows/win32/system/com.zig").IBindCtx;
const IDirect3DDevice9 = @import("../../../windows/win32/graphics/direct3d9.zig").IDirect3DDevice9;
const IDirect3DSurface9 = @import("../../../windows/win32/graphics/direct3d9.zig").IDirect3DSurface9;
const IDirectDraw = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDraw;
const IDirectDraw7 = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDraw7;
const IDirectDrawPalette = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDrawPalette;
const IDirectDrawSurface = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDrawSurface;
const IDirectDrawSurface7 = @import("../../../windows/win32/graphics/direct_draw.zig").IDirectDrawSurface7;
const IDirectSound = @import("../../../windows/win32/media/audio/direct_sound.zig").IDirectSound;
const IDirectSoundBuffer = @import("../../../windows/win32/media/audio/direct_sound.zig").IDirectSoundBuffer;
const IDispatch = @import("../../../windows/win32/system/com.zig").IDispatch;
const IEnumMoniker = @import("../../../windows/win32/system/com.zig").IEnumMoniker;
const IErrorLog = @import("../../../windows/win32/system/com.zig").IErrorLog;
const IMoniker = @import("../../../windows/win32/system/com.zig").IMoniker;
const INSSBuffer3 = @import("../../../windows/win32/media/windows_media_format.zig").INSSBuffer3;
const IPersist = @import("../../../windows/win32/system/com.zig").IPersist;
const IPropertyBag = @import("../../../windows/win32/system/com/structured_storage.zig").IPropertyBag;
const IReferenceClock = @import("../../../windows/win32/media.zig").IReferenceClock;
const IUnknown = @import("../../../windows/win32/system/com.zig").IUnknown;
const IWMPlayerTimestampHook = @import("../../../windows/win32/media/windows_media_format.zig").IWMPlayerTimestampHook;
const IWMProfile = @import("../../../windows/win32/media/windows_media_format.zig").IWMProfile;
const PALETTEENTRY = @import("../../../windows/win32/graphics/gdi.zig").PALETTEENTRY;
const PAPCFUNC = @import("../../../windows/win32/foundation.zig").PAPCFUNC;
const POINT = @import("../../../windows/win32/foundation.zig").POINT;
const PSTR = @import("../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../windows/win32/foundation.zig").PWSTR;
const RECT = @import("../../../windows/win32/foundation.zig").RECT;
const RGBQUAD = @import("../../../windows/win32/graphics/gdi.zig").RGBQUAD;
const RGNDATA = @import("../../../windows/win32/graphics/gdi.zig").RGNDATA;
const SAFEARRAY = @import("../../../windows/win32/system/com.zig").SAFEARRAY;
const SHOW_WINDOW_CMD = @import("../../../windows/win32/ui/windows_and_messaging.zig").SHOW_WINDOW_CMD;
const SIZE = @import("../../../windows/win32/foundation.zig").SIZE;
const TIMECODE = @import("../../../windows/win32/media.zig").TIMECODE;
const TIMECODE_SAMPLE = @import("../../../windows/win32/media.zig").TIMECODE_SAMPLE;
const VARIANT = @import("../../../windows/win32/system/variant.zig").VARIANT;
const VARIANT_BOOL = @import("../../../windows/win32/foundation.zig").VARIANT_BOOL;
const WAVEFORMATEX = @import("../../../windows/win32/media/audio.zig").WAVEFORMATEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCA")) { _ = AMGETERRORTEXTPROCA; }
    if (@hasDecl(@This(), "AMGETERRORTEXTPROCW")) { _ = AMGETERRORTEXTPROCW; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT")) { _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS")) { _ = PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORCAPS")) { _ = PDXVA2SW_GETVIDEOPROCESSORCAPS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT")) { _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT; }
    if (@hasDecl(@This(), "PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS")) { _ = PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS; }
    if (@hasDecl(@This(), "PDXVA2SW_GETPROCAMPRANGE")) { _ = PDXVA2SW_GETPROCAMPRANGE; }
    if (@hasDecl(@This(), "PDXVA2SW_GETFILTERPROPERTYRANGE")) { _ = PDXVA2SW_GETFILTERPROPERTYRANGE; }
    if (@hasDecl(@This(), "PDXVA2SW_CREATEVIDEOPROCESSDEVICE")) { _ = PDXVA2SW_CREATEVIDEOPROCESSDEVICE; }
    if (@hasDecl(@This(), "PDXVA2SW_DESTROYVIDEOPROCESSDEVICE")) { _ = PDXVA2SW_DESTROYVIDEOPROCESSDEVICE; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBEGINFRAME")) { _ = PDXVA2SW_VIDEOPROCESSBEGINFRAME; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSENDFRAME")) { _ = PDXVA2SW_VIDEOPROCESSENDFRAME; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSSETRENDERTARGET")) { _ = PDXVA2SW_VIDEOPROCESSSETRENDERTARGET; }
    if (@hasDecl(@This(), "PDXVA2SW_VIDEOPROCESSBLT")) { _ = PDXVA2SW_VIDEOPROCESSBLT; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (2)
//--------------------------------------------------------------------------------
pub const tv = @import("direct_show/tv.zig");
pub const xml = @import("direct_show/xml.zig");
