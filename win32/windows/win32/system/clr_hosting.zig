//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (16)
//--------------------------------------------------------------------------------
pub const DEPRECATED_CLR_API_MESG = "This API has been deprecated. Refer to https://go.microsoft.com/fwlink/?LinkId=143720 for more details.";
pub const CLR_MAJOR_VERSION = @as(u32, 4);
pub const CLR_MINOR_VERSION = @as(u32, 0);
pub const CLR_BUILD_VERSION = @as(u32, 22220);
pub const CLR_ASSEMBLY_MAJOR_VERSION = @as(u32, 4);
pub const CLR_ASSEMBLY_MINOR_VERSION = @as(u32, 0);
pub const CLR_ASSEMBLY_BUILD_VERSION = @as(u32, 0);
pub const BucketParamsCount = @as(u32, 10);
pub const BucketParamLength = @as(u32, 255);
pub const LIBID_mscoree = Guid.initString("5477469e-83b1-11d2-8b49-00a0c9b7c9c4");
pub const CLSID_CLRStrongName = Guid.initString("b79b0acd-f5cd-409b-b5a5-a16244610b92");
pub const CLSID_CLRMetaHost = Guid.initString("9280188d-0e8e-4867-b30c-7fa83884e8de");
pub const CLSID_CLRMetaHostPolicy = Guid.initString("2ebcd49a-1b47-4a61-b13a-4a03701e594b");
pub const CLSID_CLRDebugging = Guid.initString("bacc578d-fbdd-48a4-969f-02d932b74634");
pub const CLSID_CLRDebuggingLegacy = Guid.initString("df8395b5-a4ba-450b-a77c-a9a47762c520");
pub const CLSID_CLRProfiling = Guid.initString("bd097ed8-733e-43fe-8ed7-a95ff9a8448c");

//--------------------------------------------------------------------------------
// Section: Types (121)
//--------------------------------------------------------------------------------
pub const COR_GC_STAT_TYPES = enum(i32) {
    COUNTS = 1,
    MEMORYUSAGE = 2,
};
pub const COR_GC_COUNTS = COR_GC_STAT_TYPES.COUNTS;
pub const COR_GC_MEMORYUSAGE = COR_GC_STAT_TYPES.MEMORYUSAGE;

pub const COR_GC_THREAD_STATS_TYPES = enum(i32) {
    S = 1,
};
pub const COR_GC_THREAD_HAS_PROMOTED_BYTES = COR_GC_THREAD_STATS_TYPES.S;

pub const COR_GC_STATS = extern struct {
    Flags: u32,
    ExplicitGCCount: usize,
    GenCollectionsTaken: [3]usize,
    CommittedKBytes: usize,
    ReservedKBytes: usize,
    Gen0HeapSizeKBytes: usize,
    Gen1HeapSizeKBytes: usize,
    Gen2HeapSizeKBytes: usize,
    LargeObjectHeapSizeKBytes: usize,
    KBytesPromotedFromGen0: usize,
    KBytesPromotedFromGen1: usize,
};

pub const COR_GC_THREAD_STATS = extern struct {
    PerThreadAllocation: u64,
    Flags: u32,
};

const IID_IGCHost_Value = Guid.initString("fac34f6e-0dcd-47b5-8021-531bc5ecca63");
pub const IID_IGCHost = &IID_IGCHost_Value;
pub const IGCHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGCStartupLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost,
                SegmentSize: u32,
                MaxGen0Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost,
                SegmentSize: u32,
                MaxGen0Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Collect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost,
                Generation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost,
                Generation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost,
                pStats: ?*COR_GC_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost,
                pStats: ?*COR_GC_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetThreadStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost,
                pFiberCookie: ?*u32,
                pStats: ?*COR_GC_THREAD_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost,
                pFiberCookie: ?*u32,
                pStats: ?*COR_GC_THREAD_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetVirtualMemLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost,
                sztMaxVirtualMemMB: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost,
                sztMaxVirtualMemMB: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost_SetGCStartupLimits(self: *const T, SegmentSize: u32, MaxGen0Size: u32) callconv(.Inline) HRESULT {
            return @as(*const IGCHost.VTable, @ptrCast(self.vtable)).SetGCStartupLimits(@as(*const IGCHost, @ptrCast(self)), SegmentSize, MaxGen0Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost_Collect(self: *const T, Generation: i32) callconv(.Inline) HRESULT {
            return @as(*const IGCHost.VTable, @ptrCast(self.vtable)).Collect(@as(*const IGCHost, @ptrCast(self)), Generation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost_GetStats(self: *const T, pStats: ?*COR_GC_STATS) callconv(.Inline) HRESULT {
            return @as(*const IGCHost.VTable, @ptrCast(self.vtable)).GetStats(@as(*const IGCHost, @ptrCast(self)), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost_GetThreadStats(self: *const T, pFiberCookie: ?*u32, pStats: ?*COR_GC_THREAD_STATS) callconv(.Inline) HRESULT {
            return @as(*const IGCHost.VTable, @ptrCast(self.vtable)).GetThreadStats(@as(*const IGCHost, @ptrCast(self)), pFiberCookie, pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost_SetVirtualMemLimit(self: *const T, sztMaxVirtualMemMB: usize) callconv(.Inline) HRESULT {
            return @as(*const IGCHost.VTable, @ptrCast(self.vtable)).SetVirtualMemLimit(@as(*const IGCHost, @ptrCast(self)), sztMaxVirtualMemMB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGCHost2_Value = Guid.initString("a1d70cec-2dbe-4e2f-9291-fdf81438a1df");
pub const IID_IGCHost2 = &IID_IGCHost2_Value;
pub const IGCHost2 = extern struct {
    pub const VTable = extern struct {
        base: IGCHost.VTable,
        SetGCStartupLimitsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHost2,
                SegmentSize: usize,
                MaxGen0Size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHost2,
                SegmentSize: usize,
                MaxGen0Size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IGCHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHost2_SetGCStartupLimitsEx(self: *const T, SegmentSize: usize, MaxGen0Size: usize) callconv(.Inline) HRESULT {
            return @as(*const IGCHost2.VTable, @ptrCast(self.vtable)).SetGCStartupLimitsEx(@as(*const IGCHost2, @ptrCast(self)), SegmentSize, MaxGen0Size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FLockClrVersionCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const HOST_TYPE = enum(i32) {
    DEFAULT = 0,
    APPLAUNCH = 1,
    CORFLAG = 2,
};
pub const HOST_TYPE_DEFAULT = HOST_TYPE.DEFAULT;
pub const HOST_TYPE_APPLAUNCH = HOST_TYPE.APPLAUNCH;
pub const HOST_TYPE_CORFLAG = HOST_TYPE.CORFLAG;

pub const FExecuteInAppDomainCallback = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        cookie: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        cookie: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const STARTUP_FLAGS = enum(i32) {
    CONCURRENT_GC = 1,
    LOADER_OPTIMIZATION_MASK = 6,
    LOADER_OPTIMIZATION_SINGLE_DOMAIN = 2,
    LOADER_OPTIMIZATION_MULTI_DOMAIN = 4,
    // LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST = 6, this enum value conflicts with LOADER_OPTIMIZATION_MASK
    LOADER_SAFEMODE = 16,
    LOADER_SETPREFERENCE = 256,
    SERVER_GC = 4096,
    HOARD_GC_VM = 8192,
    SINGLE_VERSION_HOSTING_INTERFACE = 16384,
    LEGACY_IMPERSONATION = 65536,
    DISABLE_COMMITTHREADSTACK = 131072,
    ALWAYSFLOW_IMPERSONATION = 262144,
    TRIM_GC_COMMIT = 524288,
    ETW = 1048576,
    ARM = 4194304,
};
pub const STARTUP_CONCURRENT_GC = STARTUP_FLAGS.CONCURRENT_GC;
pub const STARTUP_LOADER_OPTIMIZATION_MASK = STARTUP_FLAGS.LOADER_OPTIMIZATION_MASK;
pub const STARTUP_LOADER_OPTIMIZATION_SINGLE_DOMAIN = STARTUP_FLAGS.LOADER_OPTIMIZATION_SINGLE_DOMAIN;
pub const STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN = STARTUP_FLAGS.LOADER_OPTIMIZATION_MULTI_DOMAIN;
pub const STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST = STARTUP_FLAGS.LOADER_OPTIMIZATION_MASK;
pub const STARTUP_LOADER_SAFEMODE = STARTUP_FLAGS.LOADER_SAFEMODE;
pub const STARTUP_LOADER_SETPREFERENCE = STARTUP_FLAGS.LOADER_SETPREFERENCE;
pub const STARTUP_SERVER_GC = STARTUP_FLAGS.SERVER_GC;
pub const STARTUP_HOARD_GC_VM = STARTUP_FLAGS.HOARD_GC_VM;
pub const STARTUP_SINGLE_VERSION_HOSTING_INTERFACE = STARTUP_FLAGS.SINGLE_VERSION_HOSTING_INTERFACE;
pub const STARTUP_LEGACY_IMPERSONATION = STARTUP_FLAGS.LEGACY_IMPERSONATION;
pub const STARTUP_DISABLE_COMMITTHREADSTACK = STARTUP_FLAGS.DISABLE_COMMITTHREADSTACK;
pub const STARTUP_ALWAYSFLOW_IMPERSONATION = STARTUP_FLAGS.ALWAYSFLOW_IMPERSONATION;
pub const STARTUP_TRIM_GC_COMMIT = STARTUP_FLAGS.TRIM_GC_COMMIT;
pub const STARTUP_ETW = STARTUP_FLAGS.ETW;
pub const STARTUP_ARM = STARTUP_FLAGS.ARM;

pub const CLSID_RESOLUTION_FLAGS = enum(i32) {
    DEFAULT = 0,
    REGISTERED = 1,
};
pub const CLSID_RESOLUTION_DEFAULT = CLSID_RESOLUTION_FLAGS.DEFAULT;
pub const CLSID_RESOLUTION_REGISTERED = CLSID_RESOLUTION_FLAGS.REGISTERED;

pub const RUNTIME_INFO_FLAGS = enum(i32) {
    UPGRADE_VERSION = 1,
    REQUEST_IA64 = 2,
    REQUEST_AMD64 = 4,
    REQUEST_X86 = 8,
    DONT_RETURN_DIRECTORY = 16,
    DONT_RETURN_VERSION = 32,
    DONT_SHOW_ERROR_DIALOG = 64,
    IGNORE_ERROR_MODE = 4096,
    REQUEST_ARM64 = 8192,
};
pub const RUNTIME_INFO_UPGRADE_VERSION = RUNTIME_INFO_FLAGS.UPGRADE_VERSION;
pub const RUNTIME_INFO_REQUEST_IA64 = RUNTIME_INFO_FLAGS.REQUEST_IA64;
pub const RUNTIME_INFO_REQUEST_AMD64 = RUNTIME_INFO_FLAGS.REQUEST_AMD64;
pub const RUNTIME_INFO_REQUEST_X86 = RUNTIME_INFO_FLAGS.REQUEST_X86;
pub const RUNTIME_INFO_DONT_RETURN_DIRECTORY = RUNTIME_INFO_FLAGS.DONT_RETURN_DIRECTORY;
pub const RUNTIME_INFO_DONT_RETURN_VERSION = RUNTIME_INFO_FLAGS.DONT_RETURN_VERSION;
pub const RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = RUNTIME_INFO_FLAGS.DONT_SHOW_ERROR_DIALOG;
pub const RUNTIME_INFO_IGNORE_ERROR_MODE = RUNTIME_INFO_FLAGS.IGNORE_ERROR_MODE;
pub const RUNTIME_INFO_REQUEST_ARM64 = RUNTIME_INFO_FLAGS.REQUEST_ARM64;

pub const APPDOMAIN_SECURITY_FLAGS = enum(i32) {
    SECURITY_DEFAULT = 0,
    SECURITY_SANDBOXED = 1,
    SECURITY_FORBID_CROSSAD_REVERSE_PINVOKE = 2,
    FORCE_TRIVIAL_WAIT_OPERATIONS = 8,
};
pub const APPDOMAIN_SECURITY_DEFAULT = APPDOMAIN_SECURITY_FLAGS.SECURITY_DEFAULT;
pub const APPDOMAIN_SECURITY_SANDBOXED = APPDOMAIN_SECURITY_FLAGS.SECURITY_SANDBOXED;
pub const APPDOMAIN_SECURITY_FORBID_CROSSAD_REVERSE_PINVOKE = APPDOMAIN_SECURITY_FLAGS.SECURITY_FORBID_CROSSAD_REVERSE_PINVOKE;
pub const APPDOMAIN_FORCE_TRIVIAL_WAIT_OPERATIONS = APPDOMAIN_SECURITY_FLAGS.FORCE_TRIVIAL_WAIT_OPERATIONS;

const IID_IObjectHandle_Value = Guid.initString("c460e2b4-e199-412a-8456-84dc3e4838c3");
pub const IID_IObjectHandle = &IID_IObjectHandle_Value;
pub const IObjectHandle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unwrap: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IObjectHandle,
                ppv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IObjectHandle,
                ppv: ?*VARIANT,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectHandle_Unwrap(self: *const T, ppv: ?*VARIANT) callconv(.Inline) HRESULT {
            return @as(*const IObjectHandle.VTable, @ptrCast(self.vtable)).Unwrap(@as(*const IObjectHandle, @ptrCast(self)), ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAppDomainBinding_Value = Guid.initString("5c2b07a7-1e98-11d3-872f-00c04f79ed0d");
pub const IID_IAppDomainBinding = &IID_IAppDomainBinding_Value;
pub const IAppDomainBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IAppDomainBinding,
                pAppdomain: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IAppDomainBinding,
                pAppdomain: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAppDomainBinding_OnAppDomain(self: *const T, pAppdomain: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IAppDomainBinding.VTable, @ptrCast(self.vtable)).OnAppDomain(@as(*const IAppDomainBinding, @ptrCast(self)), pAppdomain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGCThreadControl_Value = Guid.initString("f31d1788-c397-4725-87a5-6af3472c2791");
pub const IID_IGCThreadControl = &IID_IGCThreadControl_Value;
pub const IGCThreadControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadIsBlockingForSuspension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspensionStarting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspensionEnding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCThreadControl,
                Generation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCThreadControl,
                Generation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCThreadControl_ThreadIsBlockingForSuspension(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGCThreadControl.VTable, @ptrCast(self.vtable)).ThreadIsBlockingForSuspension(@as(*const IGCThreadControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCThreadControl_SuspensionStarting(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IGCThreadControl.VTable, @ptrCast(self.vtable)).SuspensionStarting(@as(*const IGCThreadControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCThreadControl_SuspensionEnding(self: *const T, Generation: u32) callconv(.Inline) HRESULT {
            return @as(*const IGCThreadControl.VTable, @ptrCast(self.vtable)).SuspensionEnding(@as(*const IGCThreadControl, @ptrCast(self)), Generation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGCHostControl_Value = Guid.initString("5513d564-8374-4cb9-aed9-0083f4160a1d");
pub const IID_IGCHostControl = &IID_IGCHostControl_Value;
pub const IGCHostControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestVirtualMemLimit: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IGCHostControl,
                sztMaxVirtualMemMB: usize,
                psztNewMaxVirtualMemMB: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IGCHostControl,
                sztMaxVirtualMemMB: usize,
                psztNewMaxVirtualMemMB: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGCHostControl_RequestVirtualMemLimit(self: *const T, sztMaxVirtualMemMB: usize, psztNewMaxVirtualMemMB: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IGCHostControl.VTable, @ptrCast(self.vtable)).RequestVirtualMemLimit(@as(*const IGCHostControl, @ptrCast(self)), sztMaxVirtualMemMB, psztNewMaxVirtualMemMB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PTLS_CALLBACK_FUNCTION = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        __MIDL____MIDL_itf_mscoree_0000_00040005: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        __MIDL____MIDL_itf_mscoree_0000_00040005: ?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

const IID_ICorThreadpool_Value = Guid.initString("84680d3a-b2c1-46e8-acc2-dbc0a359159a");
pub const IID_ICorThreadpool = &IID_ICorThreadpool_Value;
pub const ICorThreadpool = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CorRegisterWaitForSingleObject: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                phNewWaitObject: ?*?HANDLE,
                hWaitObject: ?HANDLE,
                Callback: ?WAITORTIMERCALLBACK,
                Context: ?*anyopaque,
                timeout: u32,
                executeOnlyOnce: BOOL,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                phNewWaitObject: ?*?HANDLE,
                hWaitObject: ?HANDLE,
                Callback: ?WAITORTIMERCALLBACK,
                Context: ?*anyopaque,
                timeout: u32,
                executeOnlyOnce: BOOL,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorUnregisterWait: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                hWaitObject: ?HANDLE,
                CompletionEvent: ?HANDLE,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                hWaitObject: ?HANDLE,
                CompletionEvent: ?HANDLE,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorQueueUserWorkItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                executeOnlyOnce: BOOL,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                executeOnlyOnce: BOOL,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorCreateTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                phNewTimer: ?*?HANDLE,
                Callback: ?WAITORTIMERCALLBACK,
                Parameter: ?*anyopaque,
                DueTime: u32,
                Period: u32,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                phNewTimer: ?*?HANDLE,
                Callback: ?WAITORTIMERCALLBACK,
                Parameter: ?*anyopaque,
                DueTime: u32,
                Period: u32,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorChangeTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                Timer: ?HANDLE,
                DueTime: u32,
                Period: u32,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                Timer: ?HANDLE,
                DueTime: u32,
                Period: u32,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorDeleteTimer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                Timer: ?HANDLE,
                CompletionEvent: ?HANDLE,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                Timer: ?HANDLE,
                CompletionEvent: ?HANDLE,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorBindIoCompletionCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                fileHandle: ?HANDLE,
                callback: ?LPOVERLAPPED_COMPLETION_ROUTINE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                fileHandle: ?HANDLE,
                callback: ?LPOVERLAPPED_COMPLETION_ROUTINE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorCallOrQueueUserWorkItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                result: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorSetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                MaxWorkerThreads: u32,
                MaxIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                MaxWorkerThreads: u32,
                MaxIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorGetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                MaxWorkerThreads: ?*u32,
                MaxIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                MaxWorkerThreads: ?*u32,
                MaxIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CorGetAvailableThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorThreadpool,
                AvailableWorkerThreads: ?*u32,
                AvailableIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorThreadpool,
                AvailableWorkerThreads: ?*u32,
                AvailableIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorRegisterWaitForSingleObject(self: *const T, phNewWaitObject: ?*?HANDLE, hWaitObject: ?HANDLE, Callback: ?WAITORTIMERCALLBACK, Context: ?*anyopaque, timeout: u32, executeOnlyOnce: BOOL, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorRegisterWaitForSingleObject(@as(*const ICorThreadpool, @ptrCast(self)), phNewWaitObject, hWaitObject, Callback, Context, timeout, executeOnlyOnce, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorUnregisterWait(self: *const T, hWaitObject: ?HANDLE, CompletionEvent: ?HANDLE, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorUnregisterWait(@as(*const ICorThreadpool, @ptrCast(self)), hWaitObject, CompletionEvent, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorQueueUserWorkItem(self: *const T, Function: ?LPTHREAD_START_ROUTINE, Context: ?*anyopaque, executeOnlyOnce: BOOL, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorQueueUserWorkItem(@as(*const ICorThreadpool, @ptrCast(self)), Function, Context, executeOnlyOnce, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorCreateTimer(self: *const T, phNewTimer: ?*?HANDLE, Callback: ?WAITORTIMERCALLBACK, Parameter: ?*anyopaque, DueTime: u32, Period: u32, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorCreateTimer(@as(*const ICorThreadpool, @ptrCast(self)), phNewTimer, Callback, Parameter, DueTime, Period, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorChangeTimer(self: *const T, Timer: ?HANDLE, DueTime: u32, Period: u32, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorChangeTimer(@as(*const ICorThreadpool, @ptrCast(self)), Timer, DueTime, Period, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorDeleteTimer(self: *const T, Timer: ?HANDLE, CompletionEvent: ?HANDLE, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorDeleteTimer(@as(*const ICorThreadpool, @ptrCast(self)), Timer, CompletionEvent, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorBindIoCompletionCallback(self: *const T, fileHandle: ?HANDLE, callback: ?LPOVERLAPPED_COMPLETION_ROUTINE) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorBindIoCompletionCallback(@as(*const ICorThreadpool, @ptrCast(self)), fileHandle, callback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorCallOrQueueUserWorkItem(self: *const T, Function: ?LPTHREAD_START_ROUTINE, Context: ?*anyopaque, result: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorCallOrQueueUserWorkItem(@as(*const ICorThreadpool, @ptrCast(self)), Function, Context, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorSetMaxThreads(self: *const T, MaxWorkerThreads: u32, MaxIOCompletionThreads: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorSetMaxThreads(@as(*const ICorThreadpool, @ptrCast(self)), MaxWorkerThreads, MaxIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorGetMaxThreads(self: *const T, MaxWorkerThreads: ?*u32, MaxIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorGetMaxThreads(@as(*const ICorThreadpool, @ptrCast(self)), MaxWorkerThreads, MaxIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorThreadpool_CorGetAvailableThreads(self: *const T, AvailableWorkerThreads: ?*u32, AvailableIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorThreadpool.VTable, @ptrCast(self.vtable)).CorGetAvailableThreads(@as(*const ICorThreadpool, @ptrCast(self)), AvailableWorkerThreads, AvailableIOCompletionThreads);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebuggerThreadControl_Value = Guid.initString("23d86786-0bb5-4774-8fb5-e3522add6246");
pub const IID_IDebuggerThreadControl = &IID_IDebuggerThreadControl_Value;
pub const IDebuggerThreadControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadIsBlockingForDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseAllRuntimeThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StartBlockingForDebugger: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebuggerThreadControl,
                dwUnused: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebuggerThreadControl,
                dwUnused: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebuggerThreadControl_ThreadIsBlockingForDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebuggerThreadControl.VTable, @ptrCast(self.vtable)).ThreadIsBlockingForDebugger(@as(*const IDebuggerThreadControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebuggerThreadControl_ReleaseAllRuntimeThreads(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IDebuggerThreadControl.VTable, @ptrCast(self.vtable)).ReleaseAllRuntimeThreads(@as(*const IDebuggerThreadControl, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebuggerThreadControl_StartBlockingForDebugger(self: *const T, dwUnused: u32) callconv(.Inline) HRESULT {
            return @as(*const IDebuggerThreadControl.VTable, @ptrCast(self.vtable)).StartBlockingForDebugger(@as(*const IDebuggerThreadControl, @ptrCast(self)), dwUnused);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebuggerInfo_Value = Guid.initString("bf24142d-a47d-4d24-a66d-8c2141944e44");
pub const IID_IDebuggerInfo = &IID_IDebuggerInfo_Value;
pub const IDebuggerInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsDebuggerAttached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IDebuggerInfo,
                pbAttached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IDebuggerInfo,
                pbAttached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebuggerInfo_IsDebuggerAttached(self: *const T, pbAttached: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IDebuggerInfo.VTable, @ptrCast(self.vtable)).IsDebuggerAttached(@as(*const IDebuggerInfo, @ptrCast(self)), pbAttached);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorConfiguration_Value = Guid.initString("5c2b07a5-1e98-11d3-872f-00c04f79ed0d");
pub const IID_ICorConfiguration = &IID_ICorConfiguration_Value;
pub const ICorConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGCThreadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorConfiguration,
                pGCThreadControl: ?*IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorConfiguration,
                pGCThreadControl: ?*IGCThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGCHostControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorConfiguration,
                pGCHostControl: ?*IGCHostControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorConfiguration,
                pGCHostControl: ?*IGCHostControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDebuggerThreadControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorConfiguration,
                pDebuggerThreadControl: ?*IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorConfiguration,
                pDebuggerThreadControl: ?*IDebuggerThreadControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddDebuggerSpecialThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorConfiguration,
                dwSpecialThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorConfiguration,
                dwSpecialThreadId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorConfiguration_SetGCThreadControl(self: *const T, pGCThreadControl: ?*IGCThreadControl) callconv(.Inline) HRESULT {
            return @as(*const ICorConfiguration.VTable, @ptrCast(self.vtable)).SetGCThreadControl(@as(*const ICorConfiguration, @ptrCast(self)), pGCThreadControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorConfiguration_SetGCHostControl(self: *const T, pGCHostControl: ?*IGCHostControl) callconv(.Inline) HRESULT {
            return @as(*const ICorConfiguration.VTable, @ptrCast(self.vtable)).SetGCHostControl(@as(*const ICorConfiguration, @ptrCast(self)), pGCHostControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorConfiguration_SetDebuggerThreadControl(self: *const T, pDebuggerThreadControl: ?*IDebuggerThreadControl) callconv(.Inline) HRESULT {
            return @as(*const ICorConfiguration.VTable, @ptrCast(self.vtable)).SetDebuggerThreadControl(@as(*const ICorConfiguration, @ptrCast(self)), pDebuggerThreadControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorConfiguration_AddDebuggerSpecialThread(self: *const T, dwSpecialThreadId: u32) callconv(.Inline) HRESULT {
            return @as(*const ICorConfiguration.VTable, @ptrCast(self.vtable)).AddDebuggerSpecialThread(@as(*const ICorConfiguration, @ptrCast(self)), dwSpecialThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICorRuntimeHost_Value = Guid.initString("cb2f6722-ab3a-11d2-9c40-00c04fa30a3e");
pub const IID_ICorRuntimeHost = &IID_ICorRuntimeHost_Value;
pub const ICorRuntimeHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateLogicalThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteLogicalThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchInLogicalThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pFiberCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pFiberCookie: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchOutLogicalThreadState: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pFiberCookie: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pFiberCookie: ?*?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocksHeldByLogicalThread: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        MapFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                hFile: ?HANDLE,
                hMapAddress: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                hFile: ?HANDLE,
                hMapAddress: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetConfiguration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pConfiguration: ?*?*ICorConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pConfiguration: ?*?*ICorConfiguration,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pwzFriendlyName: ?[*:0]align(1) const u16,
                pIdentityArray: ?*IUnknown,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pwzFriendlyName: ?[*:0]align(1) const u16,
                pIdentityArray: ?*IUnknown,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumDomains: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NextDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*anyopaque,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*anyopaque,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseEnum: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                hEnum: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDomainEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pwzFriendlyName: ?[*:0]align(1) const u16,
                pSetup: ?*IUnknown,
                pEvidence: ?*IUnknown,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pwzFriendlyName: ?[*:0]align(1) const u16,
                pSetup: ?*IUnknown,
                pEvidence: ?*IUnknown,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateDomainSetup: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pAppDomainSetup: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pAppDomainSetup: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateEvidence: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pEvidence: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pEvidence: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CurrentDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICorRuntimeHost,
                pAppDomain: ?*?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CreateLogicalThreadState(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CreateLogicalThreadState(@as(*const ICorRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_DeleteLogicalThreadState(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).DeleteLogicalThreadState(@as(*const ICorRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_SwitchInLogicalThreadState(self: *const T, pFiberCookie: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).SwitchInLogicalThreadState(@as(*const ICorRuntimeHost, @ptrCast(self)), pFiberCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_SwitchOutLogicalThreadState(self: *const T, pFiberCookie: ?*?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).SwitchOutLogicalThreadState(@as(*const ICorRuntimeHost, @ptrCast(self)), pFiberCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_LocksHeldByLogicalThread(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).LocksHeldByLogicalThread(@as(*const ICorRuntimeHost, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_MapFile(self: *const T, hFile: ?HANDLE, hMapAddress: ?*HMODULE) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).MapFile(@as(*const ICorRuntimeHost, @ptrCast(self)), hFile, hMapAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_GetConfiguration(self: *const T, pConfiguration: ?*?*ICorConfiguration) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).GetConfiguration(@as(*const ICorRuntimeHost, @ptrCast(self)), pConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).Start(@as(*const ICorRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).Stop(@as(*const ICorRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CreateDomain(self: *const T, pwzFriendlyName: ?[*:0]align(1) const u16, pIdentityArray: ?*IUnknown, pAppDomain: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CreateDomain(@as(*const ICorRuntimeHost, @ptrCast(self)), pwzFriendlyName, pIdentityArray, pAppDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_GetDefaultDomain(self: *const T, pAppDomain: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).GetDefaultDomain(@as(*const ICorRuntimeHost, @ptrCast(self)), pAppDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_EnumDomains(self: *const T, hEnum: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).EnumDomains(@as(*const ICorRuntimeHost, @ptrCast(self)), hEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_NextDomain(self: *const T, hEnum: ?*anyopaque, pAppDomain: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).NextDomain(@as(*const ICorRuntimeHost, @ptrCast(self)), hEnum, pAppDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CloseEnum(self: *const T, hEnum: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CloseEnum(@as(*const ICorRuntimeHost, @ptrCast(self)), hEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CreateDomainEx(self: *const T, pwzFriendlyName: ?[*:0]align(1) const u16, pSetup: ?*IUnknown, pEvidence: ?*IUnknown, pAppDomain: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CreateDomainEx(@as(*const ICorRuntimeHost, @ptrCast(self)), pwzFriendlyName, pSetup, pEvidence, pAppDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CreateDomainSetup(self: *const T, pAppDomainSetup: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CreateDomainSetup(@as(*const ICorRuntimeHost, @ptrCast(self)), pAppDomainSetup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CreateEvidence(self: *const T, pEvidence: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CreateEvidence(@as(*const ICorRuntimeHost, @ptrCast(self)), pEvidence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_UnloadDomain(self: *const T, pAppDomain: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).UnloadDomain(@as(*const ICorRuntimeHost, @ptrCast(self)), pAppDomain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICorRuntimeHost_CurrentDomain(self: *const T, pAppDomain: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICorRuntimeHost.VTable, @ptrCast(self.vtable)).CurrentDomain(@as(*const ICorRuntimeHost, @ptrCast(self)), pAppDomain);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EMemoryAvailable = enum(i32) {
    Low = 1,
    Neutral = 2,
    High = 3,
};
pub const eMemoryAvailableLow = EMemoryAvailable.Low;
pub const eMemoryAvailableNeutral = EMemoryAvailable.Neutral;
pub const eMemoryAvailableHigh = EMemoryAvailable.High;

pub const EMemoryCriticalLevel = enum(i32) {
    TaskCritical = 0,
    AppDomainCritical = 1,
    ProcessCritical = 2,
};
pub const eTaskCritical = EMemoryCriticalLevel.TaskCritical;
pub const eAppDomainCritical = EMemoryCriticalLevel.AppDomainCritical;
pub const eProcessCritical = EMemoryCriticalLevel.ProcessCritical;

pub const WAIT_OPTION = enum(i32) {
    MSGPUMP = 1,
    ALERTABLE = 2,
    NOTINDEADLOCK = 4,
};
pub const WAIT_MSGPUMP = WAIT_OPTION.MSGPUMP;
pub const WAIT_ALERTABLE = WAIT_OPTION.ALERTABLE;
pub const WAIT_NOTINDEADLOCK = WAIT_OPTION.NOTINDEADLOCK;

const IID_ICLRMemoryNotificationCallback_Value = Guid.initString("47eb8e57-0846-4546-af76-6f42fcfc2649");
pub const IID_ICLRMemoryNotificationCallback = &IID_ICLRMemoryNotificationCallback_Value;
pub const ICLRMemoryNotificationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMemoryNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMemoryNotificationCallback,
                eMemoryAvailable: EMemoryAvailable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMemoryNotificationCallback,
                eMemoryAvailable: EMemoryAvailable,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMemoryNotificationCallback_OnMemoryNotification(self: *const T, eMemoryAvailable: EMemoryAvailable) callconv(.Inline) HRESULT {
            return @as(*const ICLRMemoryNotificationCallback.VTable, @ptrCast(self.vtable)).OnMemoryNotification(@as(*const ICLRMemoryNotificationCallback, @ptrCast(self)), eMemoryAvailable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostMalloc_Value = Guid.initString("1831991c-cc53-4a31-b218-04e910446479");
pub const IID_IHostMalloc = &IID_IHostMalloc_Value;
pub const IHostMalloc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Alloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMalloc,
                cbSize: usize,
                eCriticalLevel: EMemoryCriticalLevel,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMalloc,
                cbSize: usize,
                eCriticalLevel: EMemoryCriticalLevel,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DebugAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMalloc,
                cbSize: usize,
                eCriticalLevel: EMemoryCriticalLevel,
                pszFileName: ?*u8,
                iLineNo: i32,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMalloc,
                cbSize: usize,
                eCriticalLevel: EMemoryCriticalLevel,
                pszFileName: ?*u8,
                iLineNo: i32,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Free: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMalloc,
                pMem: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMalloc,
                pMem: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMalloc_Alloc(self: *const T, cbSize: usize, eCriticalLevel: EMemoryCriticalLevel, ppMem: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostMalloc.VTable, @ptrCast(self.vtable)).Alloc(@as(*const IHostMalloc, @ptrCast(self)), cbSize, eCriticalLevel, ppMem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMalloc_DebugAlloc(self: *const T, cbSize: usize, eCriticalLevel: EMemoryCriticalLevel, pszFileName: ?*u8, iLineNo: i32, ppMem: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostMalloc.VTable, @ptrCast(self.vtable)).DebugAlloc(@as(*const IHostMalloc, @ptrCast(self)), cbSize, eCriticalLevel, pszFileName, iLineNo, ppMem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMalloc_Free(self: *const T, pMem: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostMalloc.VTable, @ptrCast(self.vtable)).Free(@as(*const IHostMalloc, @ptrCast(self)), pMem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MALLOC_TYPE = enum(i32) {
    THREADSAFE = 1,
    EXECUTABLE = 2,
};
pub const MALLOC_THREADSAFE = MALLOC_TYPE.THREADSAFE;
pub const MALLOC_EXECUTABLE = MALLOC_TYPE.EXECUTABLE;

const IID_IHostMemoryManager_Value = Guid.initString("7bc698d1-f9e3-4460-9cde-d04248e9fa25");
pub const IID_IHostMemoryManager = &IID_IHostMemoryManager_Value;
pub const IHostMemoryManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMalloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                dwMallocType: u32,
                ppMalloc: ?*?*IHostMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                dwMallocType: u32,
                ppMalloc: ?*?*IHostMalloc,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualAlloc: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                pAddress: ?*anyopaque,
                dwSize: usize,
                flAllocationType: u32,
                flProtect: u32,
                eCriticalLevel: EMemoryCriticalLevel,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                pAddress: ?*anyopaque,
                dwSize: usize,
                flAllocationType: u32,
                flProtect: u32,
                eCriticalLevel: EMemoryCriticalLevel,
                ppMem: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualFree: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                dwSize: usize,
                dwFreeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                dwSize: usize,
                dwFreeType: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualQuery: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                lpBuffer: ?*anyopaque,
                dwLength: usize,
                pResult: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                lpBuffer: ?*anyopaque,
                dwLength: usize,
                pResult: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        VirtualProtect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                dwSize: usize,
                flNewProtect: u32,
                pflOldProtect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                lpAddress: ?*anyopaque,
                dwSize: usize,
                flNewProtect: u32,
                pflOldProtect: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemoryLoad: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                pMemoryLoad: ?*u32,
                pAvailableBytes: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                pMemoryLoad: ?*u32,
                pAvailableBytes: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RegisterMemoryNotificationCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                pCallback: ?*ICLRMemoryNotificationCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                pCallback: ?*ICLRMemoryNotificationCallback,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NeedsVirtualAddressSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
                size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
                size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AcquiredVirtualAddressSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
                size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
                size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleasedVirtualAddressSpace: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostMemoryManager,
                startAddress: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_CreateMalloc(self: *const T, dwMallocType: u32, ppMalloc: ?*?*IHostMalloc) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).CreateMalloc(@as(*const IHostMemoryManager, @ptrCast(self)), dwMallocType, ppMalloc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_VirtualAlloc(self: *const T, pAddress: ?*anyopaque, dwSize: usize, flAllocationType: u32, flProtect: u32, eCriticalLevel: EMemoryCriticalLevel, ppMem: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).VirtualAlloc(@as(*const IHostMemoryManager, @ptrCast(self)), pAddress, dwSize, flAllocationType, flProtect, eCriticalLevel, ppMem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_VirtualFree(self: *const T, lpAddress: ?*anyopaque, dwSize: usize, dwFreeType: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).VirtualFree(@as(*const IHostMemoryManager, @ptrCast(self)), lpAddress, dwSize, dwFreeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_VirtualQuery(self: *const T, lpAddress: ?*anyopaque, lpBuffer: ?*anyopaque, dwLength: usize, pResult: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).VirtualQuery(@as(*const IHostMemoryManager, @ptrCast(self)), lpAddress, lpBuffer, dwLength, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_VirtualProtect(self: *const T, lpAddress: ?*anyopaque, dwSize: usize, flNewProtect: u32, pflOldProtect: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).VirtualProtect(@as(*const IHostMemoryManager, @ptrCast(self)), lpAddress, dwSize, flNewProtect, pflOldProtect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_GetMemoryLoad(self: *const T, pMemoryLoad: ?*u32, pAvailableBytes: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).GetMemoryLoad(@as(*const IHostMemoryManager, @ptrCast(self)), pMemoryLoad, pAvailableBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_RegisterMemoryNotificationCallback(self: *const T, pCallback: ?*ICLRMemoryNotificationCallback) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).RegisterMemoryNotificationCallback(@as(*const IHostMemoryManager, @ptrCast(self)), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_NeedsVirtualAddressSpace(self: *const T, startAddress: ?*anyopaque, size: usize) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).NeedsVirtualAddressSpace(@as(*const IHostMemoryManager, @ptrCast(self)), startAddress, size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_AcquiredVirtualAddressSpace(self: *const T, startAddress: ?*anyopaque, size: usize) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).AcquiredVirtualAddressSpace(@as(*const IHostMemoryManager, @ptrCast(self)), startAddress, size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostMemoryManager_ReleasedVirtualAddressSpace(self: *const T, startAddress: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostMemoryManager.VTable, @ptrCast(self.vtable)).ReleasedVirtualAddressSpace(@as(*const IHostMemoryManager, @ptrCast(self)), startAddress);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRTask_Value = Guid.initString("28e66a4a-9906-4225-b231-9187c3eb8611");
pub const IID_ICLRTask = &IID_ICLRTask_Value;
pub const ICLRTask = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SwitchIn: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                threadHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                threadHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchOut: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMemStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                memUsage: ?*COR_GC_THREAD_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                memUsage: ?*COR_GC_THREAD_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                fFull: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                fFull: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Abort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RudeAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NeedsPriorityScheduling: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                pbNeedsPriorityScheduling: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                pbNeedsPriorityScheduling: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        YieldTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LocksHeld: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                pLockCount: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                pLockCount: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTaskIdentifier: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask,
                asked: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask,
                asked: u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_SwitchIn(self: *const T, threadHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).SwitchIn(@as(*const ICLRTask, @ptrCast(self)), threadHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_SwitchOut(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).SwitchOut(@as(*const ICLRTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_GetMemStats(self: *const T, memUsage: ?*COR_GC_THREAD_STATS) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).GetMemStats(@as(*const ICLRTask, @ptrCast(self)), memUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_Reset(self: *const T, fFull: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).Reset(@as(*const ICLRTask, @ptrCast(self)), fFull);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_ExitTask(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).ExitTask(@as(*const ICLRTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).Abort(@as(*const ICLRTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_RudeAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).RudeAbort(@as(*const ICLRTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_NeedsPriorityScheduling(self: *const T, pbNeedsPriorityScheduling: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).NeedsPriorityScheduling(@as(*const ICLRTask, @ptrCast(self)), pbNeedsPriorityScheduling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_YieldTask(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).YieldTask(@as(*const ICLRTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_LocksHeld(self: *const T, pLockCount: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).LocksHeld(@as(*const ICLRTask, @ptrCast(self)), pLockCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask_SetTaskIdentifier(self: *const T, asked: u64) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask.VTable, @ptrCast(self.vtable)).SetTaskIdentifier(@as(*const ICLRTask, @ptrCast(self)), asked);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRTask2_Value = Guid.initString("28e66a4a-9906-4225-b231-9187c3eb8612");
pub const IID_ICLRTask2 = &IID_ICLRTask2_Value;
pub const ICLRTask2 = extern struct {
    pub const VTable = extern struct {
        base: ICLRTask.VTable,
        BeginPreventAsyncAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndPreventAsyncAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTask2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTask2,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICLRTask.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask2_BeginPreventAsyncAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask2.VTable, @ptrCast(self.vtable)).BeginPreventAsyncAbort(@as(*const ICLRTask2, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTask2_EndPreventAsyncAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRTask2.VTable, @ptrCast(self.vtable)).EndPreventAsyncAbort(@as(*const ICLRTask2, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostTask_Value = Guid.initString("c2275828-c4b1-4b55-82c9-92135f74df1a");
pub const IID_IHostTask = &IID_IHostTask_Value;
pub const IHostTask = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Alert: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Join: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
                newPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
                newPriority: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetPriority: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
                pPriority: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCLRTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTask,
                pCLRTask: ?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTask,
                pCLRTask: ?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).Start(@as(*const IHostTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_Alert(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).Alert(@as(*const IHostTask, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_Join(self: *const T, dwMilliseconds: u32, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).Join(@as(*const IHostTask, @ptrCast(self)), dwMilliseconds, option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_SetPriority(self: *const T, newPriority: i32) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).SetPriority(@as(*const IHostTask, @ptrCast(self)), newPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_GetPriority(self: *const T, pPriority: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).GetPriority(@as(*const IHostTask, @ptrCast(self)), pPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTask_SetCLRTask(self: *const T, pCLRTask: ?*ICLRTask) callconv(.Inline) HRESULT {
            return @as(*const IHostTask.VTable, @ptrCast(self.vtable)).SetCLRTask(@as(*const IHostTask, @ptrCast(self)), pCLRTask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ETaskType = enum(i32) {
    DEBUGGERHELPER = 1,
    GC = 2,
    FINALIZER = 4,
    THREADPOOL_TIMER = 8,
    THREADPOOL_GATE = 16,
    THREADPOOL_WORKER = 32,
    THREADPOOL_IOCOMPLETION = 64,
    ADUNLOAD = 128,
    USER = 256,
    THREADPOOL_WAIT = 512,
    UNKNOWN = -2147483648,
};
pub const TT_DEBUGGERHELPER = ETaskType.DEBUGGERHELPER;
pub const TT_GC = ETaskType.GC;
pub const TT_FINALIZER = ETaskType.FINALIZER;
pub const TT_THREADPOOL_TIMER = ETaskType.THREADPOOL_TIMER;
pub const TT_THREADPOOL_GATE = ETaskType.THREADPOOL_GATE;
pub const TT_THREADPOOL_WORKER = ETaskType.THREADPOOL_WORKER;
pub const TT_THREADPOOL_IOCOMPLETION = ETaskType.THREADPOOL_IOCOMPLETION;
pub const TT_ADUNLOAD = ETaskType.ADUNLOAD;
pub const TT_USER = ETaskType.USER;
pub const TT_THREADPOOL_WAIT = ETaskType.THREADPOOL_WAIT;
pub const TT_UNKNOWN = ETaskType.UNKNOWN;

const IID_ICLRTaskManager_Value = Guid.initString("4862efbe-3ae5-44f8-8feb-346190ee8a34");
pub const IID_ICLRTaskManager = &IID_ICLRTaskManager_Value;
pub const ICLRTaskManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTaskManager,
                pTask: ?*?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTaskManager,
                pTask: ?*?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTaskManager,
                pTask: ?*?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTaskManager,
                pTask: ?*?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUILocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentTaskType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRTaskManager,
                pTaskType: ?*ETaskType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRTaskManager,
                pTaskType: ?*ETaskType,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTaskManager_CreateTask(self: *const T, pTask: ?*?*ICLRTask) callconv(.Inline) HRESULT {
            return @as(*const ICLRTaskManager.VTable, @ptrCast(self.vtable)).CreateTask(@as(*const ICLRTaskManager, @ptrCast(self)), pTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTaskManager_GetCurrentTask(self: *const T, pTask: ?*?*ICLRTask) callconv(.Inline) HRESULT {
            return @as(*const ICLRTaskManager.VTable, @ptrCast(self.vtable)).GetCurrentTask(@as(*const ICLRTaskManager, @ptrCast(self)), pTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTaskManager_SetUILocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRTaskManager.VTable, @ptrCast(self.vtable)).SetUILocale(@as(*const ICLRTaskManager, @ptrCast(self)), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTaskManager_SetLocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRTaskManager.VTable, @ptrCast(self.vtable)).SetLocale(@as(*const ICLRTaskManager, @ptrCast(self)), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRTaskManager_GetCurrentTaskType(self: *const T, pTaskType: ?*ETaskType) callconv(.Inline) HRESULT {
            return @as(*const ICLRTaskManager.VTable, @ptrCast(self.vtable)).GetCurrentTaskType(@as(*const ICLRTaskManager, @ptrCast(self)), pTaskType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostTaskManager_Value = Guid.initString("997ff24c-43b7-4352-8667-0dc04fafd354");
pub const IID_IHostTaskManager = &IID_IHostTaskManager_Value;
pub const IHostTaskManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                pTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                pTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                dwStackSize: u32,
                pStartAddress: ?LPTHREAD_START_ROUTINE,
                pParameter: ?*anyopaque,
                ppTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                dwStackSize: u32,
                pStartAddress: ?LPTHREAD_START_ROUTINE,
                pParameter: ?*anyopaque,
                ppTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Sleep: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SwitchToTask: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUILocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetLocale: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                lcid: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CallNeedsHostHook: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                target: usize,
                pbCallNeedsHostHook: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                target: usize,
                pbCallNeedsHostHook: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LeaveRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                target: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                target: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnterRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReverseLeaveRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReverseEnterRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginDelayAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndDelayAbort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginThreadAffinity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndThreadAffinity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetStackGuarantee: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                guarantee: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                guarantee: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStackGuarantee: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                pGuarantee: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                pGuarantee: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCLRTaskManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostTaskManager,
                ppManager: ?*ICLRTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostTaskManager,
                ppManager: ?*ICLRTaskManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_GetCurrentTask(self: *const T, pTask: ?*?*IHostTask) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).GetCurrentTask(@as(*const IHostTaskManager, @ptrCast(self)), pTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_CreateTask(self: *const T, dwStackSize: u32, pStartAddress: ?LPTHREAD_START_ROUTINE, pParameter: ?*anyopaque, ppTask: ?*?*IHostTask) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).CreateTask(@as(*const IHostTaskManager, @ptrCast(self)), dwStackSize, pStartAddress, pParameter, ppTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_Sleep(self: *const T, dwMilliseconds: u32, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).Sleep(@as(*const IHostTaskManager, @ptrCast(self)), dwMilliseconds, option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_SwitchToTask(self: *const T, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).SwitchToTask(@as(*const IHostTaskManager, @ptrCast(self)), option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_SetUILocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).SetUILocale(@as(*const IHostTaskManager, @ptrCast(self)), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_SetLocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).SetLocale(@as(*const IHostTaskManager, @ptrCast(self)), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_CallNeedsHostHook(self: *const T, target: usize, pbCallNeedsHostHook: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).CallNeedsHostHook(@as(*const IHostTaskManager, @ptrCast(self)), target, pbCallNeedsHostHook);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_LeaveRuntime(self: *const T, target: usize) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).LeaveRuntime(@as(*const IHostTaskManager, @ptrCast(self)), target);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_EnterRuntime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).EnterRuntime(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_ReverseLeaveRuntime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).ReverseLeaveRuntime(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_ReverseEnterRuntime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).ReverseEnterRuntime(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_BeginDelayAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).BeginDelayAbort(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_EndDelayAbort(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).EndDelayAbort(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_BeginThreadAffinity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).BeginThreadAffinity(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_EndThreadAffinity(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).EndThreadAffinity(@as(*const IHostTaskManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_SetStackGuarantee(self: *const T, guarantee: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).SetStackGuarantee(@as(*const IHostTaskManager, @ptrCast(self)), guarantee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_GetStackGuarantee(self: *const T, pGuarantee: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).GetStackGuarantee(@as(*const IHostTaskManager, @ptrCast(self)), pGuarantee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostTaskManager_SetCLRTaskManager(self: *const T, ppManager: ?*ICLRTaskManager) callconv(.Inline) HRESULT {
            return @as(*const IHostTaskManager.VTable, @ptrCast(self.vtable)).SetCLRTaskManager(@as(*const IHostTaskManager, @ptrCast(self)), ppManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostThreadpoolManager_Value = Guid.initString("983d50e2-cb15-466b-80fc-845dc6e8c5fd");
pub const IID_IHostThreadpoolManager = &IID_IHostThreadpoolManager_Value;
pub const IHostThreadpoolManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueueUserWorkItem: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                Function: ?LPTHREAD_START_ROUTINE,
                Context: ?*anyopaque,
                Flags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                dwMaxWorkerThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                dwMaxWorkerThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                pdwMaxWorkerThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                pdwMaxWorkerThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                pdwAvailableWorkerThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                pdwAvailableWorkerThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMinThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                dwMinIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                dwMinIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostThreadpoolManager,
                pdwMinIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostThreadpoolManager,
                pdwMinIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_QueueUserWorkItem(self: *const T, Function: ?LPTHREAD_START_ROUTINE, Context: ?*anyopaque, Flags: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).QueueUserWorkItem(@as(*const IHostThreadpoolManager, @ptrCast(self)), Function, Context, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_SetMaxThreads(self: *const T, dwMaxWorkerThreads: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).SetMaxThreads(@as(*const IHostThreadpoolManager, @ptrCast(self)), dwMaxWorkerThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_GetMaxThreads(self: *const T, pdwMaxWorkerThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).GetMaxThreads(@as(*const IHostThreadpoolManager, @ptrCast(self)), pdwMaxWorkerThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_GetAvailableThreads(self: *const T, pdwAvailableWorkerThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).GetAvailableThreads(@as(*const IHostThreadpoolManager, @ptrCast(self)), pdwAvailableWorkerThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_SetMinThreads(self: *const T, dwMinIOCompletionThreads: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).SetMinThreads(@as(*const IHostThreadpoolManager, @ptrCast(self)), dwMinIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostThreadpoolManager_GetMinThreads(self: *const T, pdwMinIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostThreadpoolManager.VTable, @ptrCast(self.vtable)).GetMinThreads(@as(*const IHostThreadpoolManager, @ptrCast(self)), pdwMinIOCompletionThreads);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRIoCompletionManager_Value = Guid.initString("2d74ce86-b8d6-4c84-b3a7-9768933b3c12");
pub const IID_ICLRIoCompletionManager = &IID_ICLRIoCompletionManager_Value;
pub const ICLRIoCompletionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnComplete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRIoCompletionManager,
                dwErrorCode: u32,
                NumberOfBytesTransferred: u32,
                pvOverlapped: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRIoCompletionManager,
                dwErrorCode: u32,
                NumberOfBytesTransferred: u32,
                pvOverlapped: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRIoCompletionManager_OnComplete(self: *const T, dwErrorCode: u32, NumberOfBytesTransferred: u32, pvOverlapped: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRIoCompletionManager.VTable, @ptrCast(self.vtable)).OnComplete(@as(*const ICLRIoCompletionManager, @ptrCast(self)), dwErrorCode, NumberOfBytesTransferred, pvOverlapped);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostIoCompletionManager_Value = Guid.initString("8bde9d80-ec06-41d6-83e6-22580effcc20");
pub const IID_IHostIoCompletionManager = &IID_IHostIoCompletionManager_Value;
pub const IHostIoCompletionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIoCompletionPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                phPort: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                phPort: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseIoCompletionPort: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                hPort: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                hPort: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                dwMaxIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                dwMaxIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMaxThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pdwMaxIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pdwMaxIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAvailableThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pdwAvailableIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pdwAvailableIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHostOverlappedSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetCLRIoCompletionManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pManager: ?*ICLRIoCompletionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pManager: ?*ICLRIoCompletionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        InitializeHostOverlapped: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pvOverlapped: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pvOverlapped: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Bind: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                hPort: ?HANDLE,
                hHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                hPort: ?HANDLE,
                hHandle: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetMinThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                dwMinIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                dwMinIOCompletionThreads: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetMinThreads: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostIoCompletionManager,
                pdwMinIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostIoCompletionManager,
                pdwMinIOCompletionThreads: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_CreateIoCompletionPort(self: *const T, phPort: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).CreateIoCompletionPort(@as(*const IHostIoCompletionManager, @ptrCast(self)), phPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_CloseIoCompletionPort(self: *const T, hPort: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).CloseIoCompletionPort(@as(*const IHostIoCompletionManager, @ptrCast(self)), hPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_SetMaxThreads(self: *const T, dwMaxIOCompletionThreads: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).SetMaxThreads(@as(*const IHostIoCompletionManager, @ptrCast(self)), dwMaxIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_GetMaxThreads(self: *const T, pdwMaxIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).GetMaxThreads(@as(*const IHostIoCompletionManager, @ptrCast(self)), pdwMaxIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_GetAvailableThreads(self: *const T, pdwAvailableIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).GetAvailableThreads(@as(*const IHostIoCompletionManager, @ptrCast(self)), pdwAvailableIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_GetHostOverlappedSize(self: *const T, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).GetHostOverlappedSize(@as(*const IHostIoCompletionManager, @ptrCast(self)), pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_SetCLRIoCompletionManager(self: *const T, pManager: ?*ICLRIoCompletionManager) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).SetCLRIoCompletionManager(@as(*const IHostIoCompletionManager, @ptrCast(self)), pManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_InitializeHostOverlapped(self: *const T, pvOverlapped: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).InitializeHostOverlapped(@as(*const IHostIoCompletionManager, @ptrCast(self)), pvOverlapped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_Bind(self: *const T, hPort: ?HANDLE, hHandle: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).Bind(@as(*const IHostIoCompletionManager, @ptrCast(self)), hPort, hHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_SetMinThreads(self: *const T, dwMinIOCompletionThreads: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).SetMinThreads(@as(*const IHostIoCompletionManager, @ptrCast(self)), dwMinIOCompletionThreads);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostIoCompletionManager_GetMinThreads(self: *const T, pdwMinIOCompletionThreads: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const IHostIoCompletionManager.VTable, @ptrCast(self.vtable)).GetMinThreads(@as(*const IHostIoCompletionManager, @ptrCast(self)), pdwMinIOCompletionThreads);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ESymbolReadingPolicy = enum(i32) {
    Never = 0,
    Always = 1,
    FullTrustOnly = 2,
};
pub const eSymbolReadingNever = ESymbolReadingPolicy.Never;
pub const eSymbolReadingAlways = ESymbolReadingPolicy.Always;
pub const eSymbolReadingFullTrustOnly = ESymbolReadingPolicy.FullTrustOnly;

const IID_ICLRDebugManager_Value = Guid.initString("00dcaec6-2ac0-43a9-acf9-1e36c139b10d");
pub const IID_ICLRDebugManager = &IID_ICLRDebugManager_Value;
pub const ICLRDebugManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                dwConnectionId: u32,
                szConnectionName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                dwConnectionId: u32,
                szConnectionName: ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetConnectionTasks: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                id: u32,
                dwCount: u32,
                ppCLRTask: [*]?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                id: u32,
                dwCount: u32,
                ppCLRTask: [*]?*ICLRTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndConnection: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                dwConnectionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                dwConnectionId: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDacl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                pacl: ?*ACL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                pacl: ?*ACL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDacl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                pacl: ?*?*ACL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                pacl: ?*?*ACL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsDebuggerAttached: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                pbAttached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                pbAttached: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSymbolReadingPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugManager,
                policy: ESymbolReadingPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugManager,
                policy: ESymbolReadingPolicy,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_BeginConnection(self: *const T, dwConnectionId: u32, szConnectionName: ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).BeginConnection(@as(*const ICLRDebugManager, @ptrCast(self)), dwConnectionId, szConnectionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_SetConnectionTasks(self: *const T, id: u32, dwCount: u32, ppCLRTask: [*]?*ICLRTask) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).SetConnectionTasks(@as(*const ICLRDebugManager, @ptrCast(self)), id, dwCount, ppCLRTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_EndConnection(self: *const T, dwConnectionId: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).EndConnection(@as(*const ICLRDebugManager, @ptrCast(self)), dwConnectionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_SetDacl(self: *const T, pacl: ?*ACL) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).SetDacl(@as(*const ICLRDebugManager, @ptrCast(self)), pacl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_GetDacl(self: *const T, pacl: ?*?*ACL) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).GetDacl(@as(*const ICLRDebugManager, @ptrCast(self)), pacl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_IsDebuggerAttached(self: *const T, pbAttached: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).IsDebuggerAttached(@as(*const ICLRDebugManager, @ptrCast(self)), pbAttached);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugManager_SetSymbolReadingPolicy(self: *const T, policy: ESymbolReadingPolicy) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugManager.VTable, @ptrCast(self.vtable)).SetSymbolReadingPolicy(@as(*const ICLRDebugManager, @ptrCast(self)), policy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ECustomDumpFlavor = enum(i32) {
    Mini = 0,
    CriticalCLRState = 1,
    NonHeapCLRState = 2,
    // Default = 0, this enum value conflicts with Mini
};
pub const DUMP_FLAVOR_Mini = ECustomDumpFlavor.Mini;
pub const DUMP_FLAVOR_CriticalCLRState = ECustomDumpFlavor.CriticalCLRState;
pub const DUMP_FLAVOR_NonHeapCLRState = ECustomDumpFlavor.NonHeapCLRState;
pub const DUMP_FLAVOR_Default = ECustomDumpFlavor.Mini;

pub const ECustomDumpItemKind = enum(i32) {
    e = 0,
};
pub const DUMP_ITEM_None = ECustomDumpItemKind.e;

pub const CustomDumpItem = extern struct {
    itemKind: ECustomDumpItemKind,
    Anonymous: extern union {
        pReserved: usize,
    },
};

pub const BucketParameterIndex = enum(i32) {
    Parameter1 = 0,
    Parameter2 = 1,
    Parameter3 = 2,
    Parameter4 = 3,
    Parameter5 = 4,
    Parameter6 = 5,
    Parameter7 = 6,
    Parameter8 = 7,
    Parameter9 = 8,
    InvalidBucketParamIndex = 9,
};
pub const Parameter1 = BucketParameterIndex.Parameter1;
pub const Parameter2 = BucketParameterIndex.Parameter2;
pub const Parameter3 = BucketParameterIndex.Parameter3;
pub const Parameter4 = BucketParameterIndex.Parameter4;
pub const Parameter5 = BucketParameterIndex.Parameter5;
pub const Parameter6 = BucketParameterIndex.Parameter6;
pub const Parameter7 = BucketParameterIndex.Parameter7;
pub const Parameter8 = BucketParameterIndex.Parameter8;
pub const Parameter9 = BucketParameterIndex.Parameter9;
pub const InvalidBucketParamIndex = BucketParameterIndex.InvalidBucketParamIndex;

pub const BucketParameters = extern struct {
    fInited: BOOL,
    pszEventTypeName: [255]u16,
    pszParams: [2550]u16,
};

const IID_ICLRErrorReportingManager_Value = Guid.initString("980d2f1a-bf79-4c08-812a-bb9778928f78");
pub const IID_ICLRErrorReportingManager = &IID_ICLRErrorReportingManager_Value;
pub const ICLRErrorReportingManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBucketParametersForCurrentException: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRErrorReportingManager,
                pParams: ?*BucketParameters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRErrorReportingManager,
                pParams: ?*BucketParameters,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BeginCustomDump: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRErrorReportingManager,
                dwFlavor: ECustomDumpFlavor,
                dwNumItems: u32,
                items: [*]CustomDumpItem,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRErrorReportingManager,
                dwFlavor: ECustomDumpFlavor,
                dwNumItems: u32,
                items: [*]CustomDumpItem,
                dwReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EndCustomDump: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRErrorReportingManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRErrorReportingManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRErrorReportingManager_GetBucketParametersForCurrentException(self: *const T, pParams: ?*BucketParameters) callconv(.Inline) HRESULT {
            return @as(*const ICLRErrorReportingManager.VTable, @ptrCast(self.vtable)).GetBucketParametersForCurrentException(@as(*const ICLRErrorReportingManager, @ptrCast(self)), pParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRErrorReportingManager_BeginCustomDump(self: *const T, dwFlavor: ECustomDumpFlavor, dwNumItems: u32, items: [*]CustomDumpItem, dwReserved: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRErrorReportingManager.VTable, @ptrCast(self.vtable)).BeginCustomDump(@as(*const ICLRErrorReportingManager, @ptrCast(self)), dwFlavor, dwNumItems, items, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRErrorReportingManager_EndCustomDump(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRErrorReportingManager.VTable, @ptrCast(self.vtable)).EndCustomDump(@as(*const ICLRErrorReportingManager, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostCrst_Value = Guid.initString("6df710a6-26a4-4a65-8cd5-7237b8bda8dc");
pub const IID_IHostCrst = &IID_IHostCrst_Value;
pub const IHostCrst = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Enter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostCrst,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostCrst,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Leave: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        TryEnter: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostCrst,
                option: u32,
                pbSucceeded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostCrst,
                option: u32,
                pbSucceeded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSpinCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostCrst,
                dwSpinCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostCrst,
                dwSpinCount: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostCrst_Enter(self: *const T, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostCrst.VTable, @ptrCast(self.vtable)).Enter(@as(*const IHostCrst, @ptrCast(self)), option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostCrst_Leave(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostCrst.VTable, @ptrCast(self.vtable)).Leave(@as(*const IHostCrst, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostCrst_TryEnter(self: *const T, option: u32, pbSucceeded: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const IHostCrst.VTable, @ptrCast(self.vtable)).TryEnter(@as(*const IHostCrst, @ptrCast(self)), option, pbSucceeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostCrst_SetSpinCount(self: *const T, dwSpinCount: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostCrst.VTable, @ptrCast(self.vtable)).SetSpinCount(@as(*const IHostCrst, @ptrCast(self)), dwSpinCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostAutoEvent_Value = Guid.initString("50b0cfce-4063-4278-9673-e5cb4ed0bdb8");
pub const IID_IHostAutoEvent = &IID_IHostAutoEvent_Value;
pub const IHostAutoEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAutoEvent,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAutoEvent,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAutoEvent_Wait(self: *const T, dwMilliseconds: u32, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostAutoEvent.VTable, @ptrCast(self.vtable)).Wait(@as(*const IHostAutoEvent, @ptrCast(self)), dwMilliseconds, option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAutoEvent_Set(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostAutoEvent.VTable, @ptrCast(self.vtable)).Set(@as(*const IHostAutoEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostManualEvent_Value = Guid.initString("1bf4ec38-affe-4fb9-85a6-525268f15b54");
pub const IID_IHostManualEvent = &IID_IHostManualEvent_Value;
pub const IHostManualEvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostManualEvent,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostManualEvent,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Reset: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Set: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostManualEvent_Wait(self: *const T, dwMilliseconds: u32, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostManualEvent.VTable, @ptrCast(self.vtable)).Wait(@as(*const IHostManualEvent, @ptrCast(self)), dwMilliseconds, option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostManualEvent_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostManualEvent.VTable, @ptrCast(self.vtable)).Reset(@as(*const IHostManualEvent, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostManualEvent_Set(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostManualEvent.VTable, @ptrCast(self.vtable)).Set(@as(*const IHostManualEvent, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostSemaphore_Value = Guid.initString("855efd47-cc09-463a-a97d-16acab882661");
pub const IID_IHostSemaphore = &IID_IHostSemaphore_Value;
pub const IHostSemaphore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Wait: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSemaphore,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSemaphore,
                dwMilliseconds: u32,
                option: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ReleaseSemaphore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSemaphore,
                lReleaseCount: i32,
                lpPreviousCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSemaphore,
                lReleaseCount: i32,
                lpPreviousCount: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSemaphore_Wait(self: *const T, dwMilliseconds: u32, option: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostSemaphore.VTable, @ptrCast(self.vtable)).Wait(@as(*const IHostSemaphore, @ptrCast(self)), dwMilliseconds, option);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSemaphore_ReleaseSemaphore(self: *const T, lReleaseCount: i32, lpPreviousCount: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IHostSemaphore.VTable, @ptrCast(self.vtable)).ReleaseSemaphore(@as(*const IHostSemaphore, @ptrCast(self)), lReleaseCount, lpPreviousCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRSyncManager_Value = Guid.initString("55ff199d-ad21-48f9-a16c-f24ebbb8727d");
pub const IID_ICLRSyncManager = &IID_ICLRSyncManager_Value;
pub const ICLRSyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMonitorOwner: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRSyncManager,
                Cookie: usize,
                ppOwnerHostTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRSyncManager,
                Cookie: usize,
                ppOwnerHostTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRWLockOwnerIterator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRSyncManager,
                Cookie: usize,
                pIterator: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRSyncManager,
                Cookie: usize,
                pIterator: ?*usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRWLockOwnerNext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRSyncManager,
                Iterator: usize,
                ppOwnerHostTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRSyncManager,
                Iterator: usize,
                ppOwnerHostTask: ?*?*IHostTask,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        DeleteRWLockOwnerIterator: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRSyncManager,
                Iterator: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRSyncManager,
                Iterator: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRSyncManager_GetMonitorOwner(self: *const T, Cookie: usize, ppOwnerHostTask: ?*?*IHostTask) callconv(.Inline) HRESULT {
            return @as(*const ICLRSyncManager.VTable, @ptrCast(self.vtable)).GetMonitorOwner(@as(*const ICLRSyncManager, @ptrCast(self)), Cookie, ppOwnerHostTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRSyncManager_CreateRWLockOwnerIterator(self: *const T, Cookie: usize, pIterator: ?*usize) callconv(.Inline) HRESULT {
            return @as(*const ICLRSyncManager.VTable, @ptrCast(self.vtable)).CreateRWLockOwnerIterator(@as(*const ICLRSyncManager, @ptrCast(self)), Cookie, pIterator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRSyncManager_GetRWLockOwnerNext(self: *const T, Iterator: usize, ppOwnerHostTask: ?*?*IHostTask) callconv(.Inline) HRESULT {
            return @as(*const ICLRSyncManager.VTable, @ptrCast(self.vtable)).GetRWLockOwnerNext(@as(*const ICLRSyncManager, @ptrCast(self)), Iterator, ppOwnerHostTask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRSyncManager_DeleteRWLockOwnerIterator(self: *const T, Iterator: usize) callconv(.Inline) HRESULT {
            return @as(*const ICLRSyncManager.VTable, @ptrCast(self.vtable)).DeleteRWLockOwnerIterator(@as(*const ICLRSyncManager, @ptrCast(self)), Iterator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostSyncManager_Value = Guid.initString("234330c7-5f10-4f20-9615-5122dab7a0ac");
pub const IID_IHostSyncManager = &IID_IHostSyncManager_Value;
pub const IHostSyncManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCLRSyncManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                pManager: ?*ICLRSyncManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                pManager: ?*ICLRSyncManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCrst: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                ppCrst: ?*?*IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                ppCrst: ?*?*IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateCrstWithSpinCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                dwSpinCount: u32,
                ppCrst: ?*?*IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                dwSpinCount: u32,
                ppCrst: ?*?*IHostCrst,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateAutoEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateManualEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                bInitialState: BOOL,
                ppEvent: ?*?*IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                bInitialState: BOOL,
                ppEvent: ?*?*IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateMonitorEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                Cookie: usize,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                Cookie: usize,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRWLockWriterEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                Cookie: usize,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                Cookie: usize,
                ppEvent: ?*?*IHostAutoEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateRWLockReaderEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                bInitialState: BOOL,
                Cookie: usize,
                ppEvent: ?*?*IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                bInitialState: BOOL,
                Cookie: usize,
                ppEvent: ?*?*IHostManualEvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CreateSemaphoreA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSyncManager,
                dwInitial: u32,
                dwMax: u32,
                ppSemaphore: ?*?*IHostSemaphore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSyncManager,
                dwInitial: u32,
                dwMax: u32,
                ppSemaphore: ?*?*IHostSemaphore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_SetCLRSyncManager(self: *const T, pManager: ?*ICLRSyncManager) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).SetCLRSyncManager(@as(*const IHostSyncManager, @ptrCast(self)), pManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateCrst(self: *const T, ppCrst: ?*?*IHostCrst) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateCrst(@as(*const IHostSyncManager, @ptrCast(self)), ppCrst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateCrstWithSpinCount(self: *const T, dwSpinCount: u32, ppCrst: ?*?*IHostCrst) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateCrstWithSpinCount(@as(*const IHostSyncManager, @ptrCast(self)), dwSpinCount, ppCrst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateAutoEvent(self: *const T, ppEvent: ?*?*IHostAutoEvent) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateAutoEvent(@as(*const IHostSyncManager, @ptrCast(self)), ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateManualEvent(self: *const T, bInitialState: BOOL, ppEvent: ?*?*IHostManualEvent) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateManualEvent(@as(*const IHostSyncManager, @ptrCast(self)), bInitialState, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateMonitorEvent(self: *const T, Cookie: usize, ppEvent: ?*?*IHostAutoEvent) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateMonitorEvent(@as(*const IHostSyncManager, @ptrCast(self)), Cookie, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateRWLockWriterEvent(self: *const T, Cookie: usize, ppEvent: ?*?*IHostAutoEvent) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateRWLockWriterEvent(@as(*const IHostSyncManager, @ptrCast(self)), Cookie, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateRWLockReaderEvent(self: *const T, bInitialState: BOOL, Cookie: usize, ppEvent: ?*?*IHostManualEvent) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateRWLockReaderEvent(@as(*const IHostSyncManager, @ptrCast(self)), bInitialState, Cookie, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSyncManager_CreateSemaphoreA(self: *const T, dwInitial: u32, dwMax: u32, ppSemaphore: ?*?*IHostSemaphore) callconv(.Inline) HRESULT {
            return @as(*const IHostSyncManager.VTable, @ptrCast(self.vtable)).CreateSemaphoreA(@as(*const IHostSyncManager, @ptrCast(self)), dwInitial, dwMax, ppSemaphore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EClrOperation = enum(i32) {
    OPR_ThreadAbort = 0,
    OPR_ThreadRudeAbortInNonCriticalRegion = 1,
    OPR_ThreadRudeAbortInCriticalRegion = 2,
    OPR_AppDomainUnload = 3,
    OPR_AppDomainRudeUnload = 4,
    OPR_ProcessExit = 5,
    OPR_FinalizerRun = 6,
    MaxClrOperation = 7,
};
pub const OPR_ThreadAbort = EClrOperation.OPR_ThreadAbort;
pub const OPR_ThreadRudeAbortInNonCriticalRegion = EClrOperation.OPR_ThreadRudeAbortInNonCriticalRegion;
pub const OPR_ThreadRudeAbortInCriticalRegion = EClrOperation.OPR_ThreadRudeAbortInCriticalRegion;
pub const OPR_AppDomainUnload = EClrOperation.OPR_AppDomainUnload;
pub const OPR_AppDomainRudeUnload = EClrOperation.OPR_AppDomainRudeUnload;
pub const OPR_ProcessExit = EClrOperation.OPR_ProcessExit;
pub const OPR_FinalizerRun = EClrOperation.OPR_FinalizerRun;
pub const MaxClrOperation = EClrOperation.MaxClrOperation;

pub const EClrFailure = enum(i32) {
    FAIL_NonCriticalResource = 0,
    FAIL_CriticalResource = 1,
    FAIL_FatalRuntime = 2,
    FAIL_OrphanedLock = 3,
    FAIL_StackOverflow = 4,
    FAIL_AccessViolation = 5,
    FAIL_CodeContract = 6,
    MaxClrFailure = 7,
};
pub const FAIL_NonCriticalResource = EClrFailure.FAIL_NonCriticalResource;
pub const FAIL_CriticalResource = EClrFailure.FAIL_CriticalResource;
pub const FAIL_FatalRuntime = EClrFailure.FAIL_FatalRuntime;
pub const FAIL_OrphanedLock = EClrFailure.FAIL_OrphanedLock;
pub const FAIL_StackOverflow = EClrFailure.FAIL_StackOverflow;
pub const FAIL_AccessViolation = EClrFailure.FAIL_AccessViolation;
pub const FAIL_CodeContract = EClrFailure.FAIL_CodeContract;
pub const MaxClrFailure = EClrFailure.MaxClrFailure;

pub const EClrUnhandledException = enum(i32) {
    RuntimeDeterminedPolicy = 0,
    HostDeterminedPolicy = 1,
};
pub const eRuntimeDeterminedPolicy = EClrUnhandledException.RuntimeDeterminedPolicy;
pub const eHostDeterminedPolicy = EClrUnhandledException.HostDeterminedPolicy;

pub const EPolicyAction = enum(i32) {
    eNoAction = 0,
    eThrowException = 1,
    eAbortThread = 2,
    eRudeAbortThread = 3,
    eUnloadAppDomain = 4,
    eRudeUnloadAppDomain = 5,
    eExitProcess = 6,
    eFastExitProcess = 7,
    eRudeExitProcess = 8,
    eDisableRuntime = 9,
    MaxPolicyAction = 10,
};
pub const eNoAction = EPolicyAction.eNoAction;
pub const eThrowException = EPolicyAction.eThrowException;
pub const eAbortThread = EPolicyAction.eAbortThread;
pub const eRudeAbortThread = EPolicyAction.eRudeAbortThread;
pub const eUnloadAppDomain = EPolicyAction.eUnloadAppDomain;
pub const eRudeUnloadAppDomain = EPolicyAction.eRudeUnloadAppDomain;
pub const eExitProcess = EPolicyAction.eExitProcess;
pub const eFastExitProcess = EPolicyAction.eFastExitProcess;
pub const eRudeExitProcess = EPolicyAction.eRudeExitProcess;
pub const eDisableRuntime = EPolicyAction.eDisableRuntime;
pub const MaxPolicyAction = EPolicyAction.MaxPolicyAction;

const IID_ICLRPolicyManager_Value = Guid.initString("7d290010-d781-45da-a6f8-aa5d711a730e");
pub const IID_ICLRPolicyManager = &IID_ICLRPolicyManager_Value;
pub const ICLRPolicyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDefaultAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                dwMilliseconds: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActionOnTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetTimeoutAndAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                dwMilliseconds: u32,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                operation: EClrOperation,
                dwMilliseconds: u32,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetActionOnFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                failure: EClrFailure,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                failure: EClrFailure,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetUnhandledExceptionPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRPolicyManager,
                policy: EClrUnhandledException,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRPolicyManager,
                policy: EClrUnhandledException,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetDefaultAction(self: *const T, operation: EClrOperation, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetDefaultAction(@as(*const ICLRPolicyManager, @ptrCast(self)), operation, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetTimeout(self: *const T, operation: EClrOperation, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetTimeout(@as(*const ICLRPolicyManager, @ptrCast(self)), operation, dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetActionOnTimeout(self: *const T, operation: EClrOperation, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetActionOnTimeout(@as(*const ICLRPolicyManager, @ptrCast(self)), operation, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetTimeoutAndAction(self: *const T, operation: EClrOperation, dwMilliseconds: u32, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetTimeoutAndAction(@as(*const ICLRPolicyManager, @ptrCast(self)), operation, dwMilliseconds, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetActionOnFailure(self: *const T, failure: EClrFailure, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetActionOnFailure(@as(*const ICLRPolicyManager, @ptrCast(self)), failure, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRPolicyManager_SetUnhandledExceptionPolicy(self: *const T, policy: EClrUnhandledException) callconv(.Inline) HRESULT {
            return @as(*const ICLRPolicyManager.VTable, @ptrCast(self.vtable)).SetUnhandledExceptionPolicy(@as(*const ICLRPolicyManager, @ptrCast(self)), policy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostPolicyManager_Value = Guid.initString("7ae49844-b1e3-4683-ba7c-1e8212ea3b79");
pub const IID_IHostPolicyManager = &IID_IHostPolicyManager_Value;
pub const IHostPolicyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDefaultAction: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnTimeout: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostPolicyManager,
                operation: EClrOperation,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OnFailure: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostPolicyManager,
                failure: EClrFailure,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostPolicyManager,
                failure: EClrFailure,
                action: EPolicyAction,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostPolicyManager_OnDefaultAction(self: *const T, operation: EClrOperation, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const IHostPolicyManager.VTable, @ptrCast(self.vtable)).OnDefaultAction(@as(*const IHostPolicyManager, @ptrCast(self)), operation, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostPolicyManager_OnTimeout(self: *const T, operation: EClrOperation, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const IHostPolicyManager.VTable, @ptrCast(self.vtable)).OnTimeout(@as(*const IHostPolicyManager, @ptrCast(self)), operation, action);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostPolicyManager_OnFailure(self: *const T, failure: EClrFailure, action: EPolicyAction) callconv(.Inline) HRESULT {
            return @as(*const IHostPolicyManager.VTable, @ptrCast(self.vtable)).OnFailure(@as(*const IHostPolicyManager, @ptrCast(self)), failure, action);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EClrEvent = enum(i32) {
    Event_DomainUnload = 0,
    Event_ClrDisabled = 1,
    Event_MDAFired = 2,
    Event_StackOverflow = 3,
    MaxClrEvent = 4,
};
pub const Event_DomainUnload = EClrEvent.Event_DomainUnload;
pub const Event_ClrDisabled = EClrEvent.Event_ClrDisabled;
pub const Event_MDAFired = EClrEvent.Event_MDAFired;
pub const Event_StackOverflow = EClrEvent.Event_StackOverflow;
pub const MaxClrEvent = EClrEvent.MaxClrEvent;

pub const MDAInfo = extern struct {
    lpMDACaption: ?[*:0]align(1) const u16,
    lpMDAMessage: ?[*:0]align(1) const u16,
    lpStackTrace: ?[*:0]align(1) const u16,
};

pub const StackOverflowType = enum(i32) {
    Managed = 0,
    ClrEngine = 1,
    Other = 2,
};
pub const SO_Managed = StackOverflowType.Managed;
pub const SO_ClrEngine = StackOverflowType.ClrEngine;
pub const SO_Other = StackOverflowType.Other;

pub const StackOverflowInfo = extern struct {
    soType: StackOverflowType,
    pExceptionInfo: ?*EXCEPTION_POINTERS,
};

const IID_IActionOnCLREvent_Value = Guid.initString("607be24b-d91b-4e28-a242-61871ce56e35");
pub const IID_IActionOnCLREvent = &IID_IActionOnCLREvent_Value;
pub const IActionOnCLREvent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IActionOnCLREvent,
                event: EClrEvent,
                data: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IActionOnCLREvent,
                event: EClrEvent,
                data: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActionOnCLREvent_OnEvent(self: *const T, event: EClrEvent, data: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IActionOnCLREvent.VTable, @ptrCast(self.vtable)).OnEvent(@as(*const IActionOnCLREvent, @ptrCast(self)), event, data);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLROnEventManager_Value = Guid.initString("1d0e0132-e64f-493d-9260-025c0e32c175");
pub const IID_ICLROnEventManager = &IID_ICLROnEventManager_Value;
pub const ICLROnEventManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterActionOnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLROnEventManager,
                event: EClrEvent,
                pAction: ?*IActionOnCLREvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLROnEventManager,
                event: EClrEvent,
                pAction: ?*IActionOnCLREvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnregisterActionOnEvent: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLROnEventManager,
                event: EClrEvent,
                pAction: ?*IActionOnCLREvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLROnEventManager,
                event: EClrEvent,
                pAction: ?*IActionOnCLREvent,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLROnEventManager_RegisterActionOnEvent(self: *const T, event: EClrEvent, pAction: ?*IActionOnCLREvent) callconv(.Inline) HRESULT {
            return @as(*const ICLROnEventManager.VTable, @ptrCast(self.vtable)).RegisterActionOnEvent(@as(*const ICLROnEventManager, @ptrCast(self)), event, pAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLROnEventManager_UnregisterActionOnEvent(self: *const T, event: EClrEvent, pAction: ?*IActionOnCLREvent) callconv(.Inline) HRESULT {
            return @as(*const ICLROnEventManager.VTable, @ptrCast(self.vtable)).UnregisterActionOnEvent(@as(*const ICLROnEventManager, @ptrCast(self)), event, pAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostGCManager_Value = Guid.initString("5d4ec34e-f248-457b-b603-255faaba0d21");
pub const IID_IHostGCManager = &IID_IHostGCManager_Value;
pub const IHostGCManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadIsBlockingForSuspension: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostGCManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostGCManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspensionStarting: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostGCManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostGCManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SuspensionEnding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostGCManager,
                Generation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostGCManager,
                Generation: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostGCManager_ThreadIsBlockingForSuspension(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostGCManager.VTable, @ptrCast(self.vtable)).ThreadIsBlockingForSuspension(@as(*const IHostGCManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostGCManager_SuspensionStarting(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostGCManager.VTable, @ptrCast(self.vtable)).SuspensionStarting(@as(*const IHostGCManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostGCManager_SuspensionEnding(self: *const T, Generation: u32) callconv(.Inline) HRESULT {
            return @as(*const IHostGCManager.VTable, @ptrCast(self.vtable)).SuspensionEnding(@as(*const IHostGCManager, @ptrCast(self)), Generation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRAssemblyReferenceList_Value = Guid.initString("1b2c9750-2e66-4bda-8b44-0a642c5cd733");
pub const IID_ICLRAssemblyReferenceList = &IID_ICLRAssemblyReferenceList_Value;
pub const ICLRAssemblyReferenceList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsStringAssemblyReferenceInList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyReferenceList,
                pwzAssemblyName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyReferenceList,
                pwzAssemblyName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsAssemblyReferenceInList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyReferenceList,
                pName: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyReferenceList,
                pName: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyReferenceList_IsStringAssemblyReferenceInList(self: *const T, pwzAssemblyName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyReferenceList.VTable, @ptrCast(self.vtable)).IsStringAssemblyReferenceInList(@as(*const ICLRAssemblyReferenceList, @ptrCast(self)), pwzAssemblyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyReferenceList_IsAssemblyReferenceInList(self: *const T, pName: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyReferenceList.VTable, @ptrCast(self.vtable)).IsAssemblyReferenceInList(@as(*const ICLRAssemblyReferenceList, @ptrCast(self)), pName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRReferenceAssemblyEnum_Value = Guid.initString("d509cb5d-cf32-4876-ae61-67770cf91973");
pub const IID_ICLRReferenceAssemblyEnum = &IID_ICLRReferenceAssemblyEnum_Value;
pub const ICLRReferenceAssemblyEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRReferenceAssemblyEnum,
                dwIndex: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRReferenceAssemblyEnum,
                dwIndex: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRReferenceAssemblyEnum_Get(self: *const T, dwIndex: u32, pwzBuffer: [*:0]u16, pcchBufferSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRReferenceAssemblyEnum.VTable, @ptrCast(self.vtable)).Get(@as(*const ICLRReferenceAssemblyEnum, @ptrCast(self)), dwIndex, pwzBuffer, pcchBufferSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRProbingAssemblyEnum_Value = Guid.initString("d0c5fb1f-416b-4f97-81f4-7ac7dc24dd5d");
pub const IID_ICLRProbingAssemblyEnum = &IID_ICLRProbingAssemblyEnum_Value;
pub const ICLRProbingAssemblyEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Get: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRProbingAssemblyEnum,
                dwIndex: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRProbingAssemblyEnum,
                dwIndex: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRProbingAssemblyEnum_Get(self: *const T, dwIndex: u32, pwzBuffer: [*:0]u16, pcchBufferSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRProbingAssemblyEnum.VTable, @ptrCast(self.vtable)).Get(@as(*const ICLRProbingAssemblyEnum, @ptrCast(self)), dwIndex, pwzBuffer, pcchBufferSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ECLRAssemblyIdentityFlags = enum(i32) {
    T = 0,
};
pub const CLR_ASSEMBLY_IDENTITY_FLAGS_DEFAULT = ECLRAssemblyIdentityFlags.T;

const IID_ICLRAssemblyIdentityManager_Value = Guid.initString("15f0a9da-3ff6-4393-9da9-fdfd284e6972");
pub const IID_ICLRAssemblyIdentityManager = &IID_ICLRAssemblyIdentityManager_Value;
pub const ICLRAssemblyIdentityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCLRAssemblyReferenceList: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                ppwzAssemblyReferences: ?*const ?PWSTR,
                dwNumOfReferences: u32,
                ppReferenceList: ?*?*ICLRAssemblyReferenceList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                ppwzAssemblyReferences: ?*const ?PWSTR,
                dwNumOfReferences: u32,
                ppReferenceList: ?*?*ICLRAssemblyReferenceList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindingIdentityFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetBindingIdentityFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                pStream: ?*IStream,
                dwFlags: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                pStream: ?*IStream,
                dwFlags: u32,
                pwzBuffer: [*:0]u16,
                pcchBufferSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferencedAssembliesFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pExcludeAssembliesList: ?*ICLRAssemblyReferenceList,
                ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwFlags: u32,
                pExcludeAssembliesList: ?*ICLRAssemblyReferenceList,
                ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetReferencedAssembliesFromStream: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                pStream: ?*IStream,
                dwFlags: u32,
                pExcludeAssembliesList: ?*ICLRAssemblyReferenceList,
                ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                pStream: ?*IStream,
                dwFlags: u32,
                pExcludeAssembliesList: ?*ICLRAssemblyReferenceList,
                ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProbingAssembliesFromReference: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                dwMachineType: u32,
                dwFlags: u32,
                pwzReferenceIdentity: ?[*:0]align(1) const u16,
                ppProbingAssemblyEnum: ?*?*ICLRProbingAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                dwMachineType: u32,
                dwFlags: u32,
                pwzReferenceIdentity: ?[*:0]align(1) const u16,
                ppProbingAssemblyEnum: ?*?*ICLRProbingAssemblyEnum,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsStronglyNamed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzAssemblyIdentity: ?[*:0]align(1) const u16,
                pbIsStronglyNamed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAssemblyIdentityManager,
                pwzAssemblyIdentity: ?[*:0]align(1) const u16,
                pbIsStronglyNamed: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetCLRAssemblyReferenceList(self: *const T, ppwzAssemblyReferences: ?*const ?PWSTR, dwNumOfReferences: u32, ppReferenceList: ?*?*ICLRAssemblyReferenceList) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetCLRAssemblyReferenceList(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), ppwzAssemblyReferences, dwNumOfReferences, ppReferenceList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetBindingIdentityFromFile(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, dwFlags: u32, pwzBuffer: [*:0]u16, pcchBufferSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetBindingIdentityFromFile(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), pwzFilePath, dwFlags, pwzBuffer, pcchBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetBindingIdentityFromStream(self: *const T, pStream: ?*IStream, dwFlags: u32, pwzBuffer: [*:0]u16, pcchBufferSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetBindingIdentityFromStream(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), pStream, dwFlags, pwzBuffer, pcchBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetReferencedAssembliesFromFile(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, dwFlags: u32, pExcludeAssembliesList: ?*ICLRAssemblyReferenceList, ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetReferencedAssembliesFromFile(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), pwzFilePath, dwFlags, pExcludeAssembliesList, ppReferenceEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetReferencedAssembliesFromStream(self: *const T, pStream: ?*IStream, dwFlags: u32, pExcludeAssembliesList: ?*ICLRAssemblyReferenceList, ppReferenceEnum: ?*?*ICLRReferenceAssemblyEnum) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetReferencedAssembliesFromStream(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), pStream, dwFlags, pExcludeAssembliesList, ppReferenceEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_GetProbingAssembliesFromReference(self: *const T, dwMachineType: u32, dwFlags: u32, pwzReferenceIdentity: ?[*:0]align(1) const u16, ppProbingAssemblyEnum: ?*?*ICLRProbingAssemblyEnum) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).GetProbingAssembliesFromReference(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), dwMachineType, dwFlags, pwzReferenceIdentity, ppProbingAssemblyEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAssemblyIdentityManager_IsStronglyNamed(self: *const T, pwzAssemblyIdentity: ?[*:0]align(1) const u16, pbIsStronglyNamed: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRAssemblyIdentityManager.VTable, @ptrCast(self.vtable)).IsStronglyNamed(@as(*const ICLRAssemblyIdentityManager, @ptrCast(self)), pwzAssemblyIdentity, pbIsStronglyNamed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EHostBindingPolicyModifyFlags = enum(i32) {
    DEFAULT = 0,
    CHAIN = 1,
    REMOVE = 2,
    MAX = 3,
};
pub const HOST_BINDING_POLICY_MODIFY_DEFAULT = EHostBindingPolicyModifyFlags.DEFAULT;
pub const HOST_BINDING_POLICY_MODIFY_CHAIN = EHostBindingPolicyModifyFlags.CHAIN;
pub const HOST_BINDING_POLICY_MODIFY_REMOVE = EHostBindingPolicyModifyFlags.REMOVE;
pub const HOST_BINDING_POLICY_MODIFY_MAX = EHostBindingPolicyModifyFlags.MAX;

const IID_ICLRHostBindingPolicyManager_Value = Guid.initString("4b3545e7-1856-48c9-a8ba-24b21a753c09");
pub const IID_ICLRHostBindingPolicyManager = &IID_ICLRHostBindingPolicyManager_Value;
pub const ICLRHostBindingPolicyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ModifyApplicationPolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRHostBindingPolicyManager,
                pwzSourceAssemblyIdentity: ?[*:0]align(1) const u16,
                pwzTargetAssemblyIdentity: ?[*:0]align(1) const u16,
                pbApplicationPolicy: ?*u8,
                cbAppPolicySize: u32,
                dwPolicyModifyFlags: u32,
                pbNewApplicationPolicy: [*:0]u8,
                pcbNewAppPolicySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRHostBindingPolicyManager,
                pwzSourceAssemblyIdentity: ?[*:0]align(1) const u16,
                pwzTargetAssemblyIdentity: ?[*:0]align(1) const u16,
                pbApplicationPolicy: ?*u8,
                cbAppPolicySize: u32,
                dwPolicyModifyFlags: u32,
                pbNewApplicationPolicy: [*:0]u8,
                pcbNewAppPolicySize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EvaluatePolicy: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRHostBindingPolicyManager,
                pwzReferenceIdentity: ?[*:0]align(1) const u16,
                pbApplicationPolicy: ?*u8,
                cbAppPolicySize: u32,
                pwzPostPolicyReferenceIdentity: [*:0]u16,
                pcchPostPolicyReferenceIdentity: ?*u32,
                pdwPoliciesApplied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRHostBindingPolicyManager,
                pwzReferenceIdentity: ?[*:0]align(1) const u16,
                pbApplicationPolicy: ?*u8,
                cbAppPolicySize: u32,
                pwzPostPolicyReferenceIdentity: [*:0]u16,
                pcchPostPolicyReferenceIdentity: ?*u32,
                pdwPoliciesApplied: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRHostBindingPolicyManager_ModifyApplicationPolicy(self: *const T, pwzSourceAssemblyIdentity: ?[*:0]align(1) const u16, pwzTargetAssemblyIdentity: ?[*:0]align(1) const u16, pbApplicationPolicy: ?*u8, cbAppPolicySize: u32, dwPolicyModifyFlags: u32, pbNewApplicationPolicy: [*:0]u8, pcbNewAppPolicySize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRHostBindingPolicyManager.VTable, @ptrCast(self.vtable)).ModifyApplicationPolicy(@as(*const ICLRHostBindingPolicyManager, @ptrCast(self)), pwzSourceAssemblyIdentity, pwzTargetAssemblyIdentity, pbApplicationPolicy, cbAppPolicySize, dwPolicyModifyFlags, pbNewApplicationPolicy, pcbNewAppPolicySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRHostBindingPolicyManager_EvaluatePolicy(self: *const T, pwzReferenceIdentity: ?[*:0]align(1) const u16, pbApplicationPolicy: ?*u8, cbAppPolicySize: u32, pwzPostPolicyReferenceIdentity: [*:0]u16, pcchPostPolicyReferenceIdentity: ?*u32, pdwPoliciesApplied: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRHostBindingPolicyManager.VTable, @ptrCast(self.vtable)).EvaluatePolicy(@as(*const ICLRHostBindingPolicyManager, @ptrCast(self)), pwzReferenceIdentity, pbApplicationPolicy, cbAppPolicySize, pwzPostPolicyReferenceIdentity, pcchPostPolicyReferenceIdentity, pdwPoliciesApplied);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRGCManager_Value = Guid.initString("54d9007e-a8e2-4885-b7bf-f998deee4f2a");
pub const IID_ICLRGCManager = &IID_ICLRGCManager_Value;
pub const ICLRGCManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Collect: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRGCManager,
                Generation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRGCManager,
                Generation: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetStats: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRGCManager,
                pStats: ?*COR_GC_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRGCManager,
                pStats: ?*COR_GC_STATS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetGCStartupLimits: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRGCManager,
                SegmentSize: u32,
                MaxGen0Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRGCManager,
                SegmentSize: u32,
                MaxGen0Size: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRGCManager_Collect(self: *const T, Generation: i32) callconv(.Inline) HRESULT {
            return @as(*const ICLRGCManager.VTable, @ptrCast(self.vtable)).Collect(@as(*const ICLRGCManager, @ptrCast(self)), Generation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRGCManager_GetStats(self: *const T, pStats: ?*COR_GC_STATS) callconv(.Inline) HRESULT {
            return @as(*const ICLRGCManager.VTable, @ptrCast(self.vtable)).GetStats(@as(*const ICLRGCManager, @ptrCast(self)), pStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRGCManager_SetGCStartupLimits(self: *const T, SegmentSize: u32, MaxGen0Size: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRGCManager.VTable, @ptrCast(self.vtable)).SetGCStartupLimits(@as(*const ICLRGCManager, @ptrCast(self)), SegmentSize, MaxGen0Size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRGCManager2_Value = Guid.initString("0603b793-a97a-4712-9cb4-0cd1c74c0f7c");
pub const IID_ICLRGCManager2 = &IID_ICLRGCManager2_Value;
pub const ICLRGCManager2 = extern struct {
    pub const VTable = extern struct {
        base: ICLRGCManager.VTable,
        SetGCStartupLimitsEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRGCManager2,
                SegmentSize: usize,
                MaxGen0Size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRGCManager2,
                SegmentSize: usize,
                MaxGen0Size: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICLRGCManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRGCManager2_SetGCStartupLimitsEx(self: *const T, SegmentSize: usize, MaxGen0Size: usize) callconv(.Inline) HRESULT {
            return @as(*const ICLRGCManager2.VTable, @ptrCast(self.vtable)).SetGCStartupLimitsEx(@as(*const ICLRGCManager2, @ptrCast(self)), SegmentSize, MaxGen0Size);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EBindPolicyLevels = enum(i32) {
    LevelNone = 0,
    LevelRetargetable = 1,
    UnifiedToCLR = 2,
    LevelApp = 4,
    LevelPublisher = 8,
    LevelHost = 16,
    LevelAdmin = 32,
    Portability = 64,
};
pub const ePolicyLevelNone = EBindPolicyLevels.LevelNone;
pub const ePolicyLevelRetargetable = EBindPolicyLevels.LevelRetargetable;
pub const ePolicyUnifiedToCLR = EBindPolicyLevels.UnifiedToCLR;
pub const ePolicyLevelApp = EBindPolicyLevels.LevelApp;
pub const ePolicyLevelPublisher = EBindPolicyLevels.LevelPublisher;
pub const ePolicyLevelHost = EBindPolicyLevels.LevelHost;
pub const ePolicyLevelAdmin = EBindPolicyLevels.LevelAdmin;
pub const ePolicyPortability = EBindPolicyLevels.Portability;

pub const AssemblyBindInfo = extern struct {
    dwAppDomainId: u32,
    lpReferencedIdentity: ?[*:0]align(1) const u16,
    lpPostPolicyIdentity: ?[*:0]align(1) const u16,
    ePolicyLevel: u32,
};

pub const ModuleBindInfo = extern struct {
    dwAppDomainId: u32,
    lpAssemblyIdentity: ?[*:0]align(1) const u16,
    lpModuleName: ?[*:0]align(1) const u16,
};

pub const EHostApplicationPolicy = enum(i32) {
    Y = 1,
};
pub const HOST_APPLICATION_BINDING_POLICY = EHostApplicationPolicy.Y;

const IID_IHostAssemblyStore_Value = Guid.initString("7b102a88-3f7f-496d-8fa2-c35374e01af3");
pub const IID_IHostAssemblyStore = &IID_IHostAssemblyStore_Value;
pub const IHostAssemblyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProvideAssembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAssemblyStore,
                pBindInfo: ?*AssemblyBindInfo,
                pAssemblyId: ?*u64,
                pContext: ?*u64,
                ppStmAssemblyImage: ?*?*IStream,
                ppStmPDB: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAssemblyStore,
                pBindInfo: ?*AssemblyBindInfo,
                pAssemblyId: ?*u64,
                pContext: ?*u64,
                ppStmAssemblyImage: ?*?*IStream,
                ppStmPDB: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ProvideModule: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAssemblyStore,
                pBindInfo: ?*ModuleBindInfo,
                pdwModuleId: ?*u32,
                ppStmModuleImage: ?*?*IStream,
                ppStmPDB: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAssemblyStore,
                pBindInfo: ?*ModuleBindInfo,
                pdwModuleId: ?*u32,
                ppStmModuleImage: ?*?*IStream,
                ppStmPDB: ?*?*IStream,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAssemblyStore_ProvideAssembly(self: *const T, pBindInfo: ?*AssemblyBindInfo, pAssemblyId: ?*u64, pContext: ?*u64, ppStmAssemblyImage: ?*?*IStream, ppStmPDB: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IHostAssemblyStore.VTable, @ptrCast(self.vtable)).ProvideAssembly(@as(*const IHostAssemblyStore, @ptrCast(self)), pBindInfo, pAssemblyId, pContext, ppStmAssemblyImage, ppStmPDB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAssemblyStore_ProvideModule(self: *const T, pBindInfo: ?*ModuleBindInfo, pdwModuleId: ?*u32, ppStmModuleImage: ?*?*IStream, ppStmPDB: ?*?*IStream) callconv(.Inline) HRESULT {
            return @as(*const IHostAssemblyStore.VTable, @ptrCast(self.vtable)).ProvideModule(@as(*const IHostAssemblyStore, @ptrCast(self)), pBindInfo, pdwModuleId, ppStmModuleImage, ppStmPDB);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostAssemblyManager_Value = Guid.initString("613dabd7-62b2-493e-9e65-c1e32a1e0c5e");
pub const IID_IHostAssemblyManager = &IID_IHostAssemblyManager_Value;
pub const IHostAssemblyManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNonHostStoreAssemblies: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAssemblyManager,
                ppReferenceList: ?*?*ICLRAssemblyReferenceList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAssemblyManager,
                ppReferenceList: ?*?*ICLRAssemblyReferenceList,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyStore: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostAssemblyManager,
                ppAssemblyStore: ?*?*IHostAssemblyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostAssemblyManager,
                ppAssemblyStore: ?*?*IHostAssemblyStore,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAssemblyManager_GetNonHostStoreAssemblies(self: *const T, ppReferenceList: ?*?*ICLRAssemblyReferenceList) callconv(.Inline) HRESULT {
            return @as(*const IHostAssemblyManager.VTable, @ptrCast(self.vtable)).GetNonHostStoreAssemblies(@as(*const IHostAssemblyManager, @ptrCast(self)), ppReferenceList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostAssemblyManager_GetAssemblyStore(self: *const T, ppAssemblyStore: ?*?*IHostAssemblyStore) callconv(.Inline) HRESULT {
            return @as(*const IHostAssemblyManager.VTable, @ptrCast(self.vtable)).GetAssemblyStore(@as(*const IHostAssemblyManager, @ptrCast(self)), ppAssemblyStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostControl_Value = Guid.initString("02ca073c-7079-4860-880a-c2f7a449c991");
pub const IID_IHostControl = &IID_IHostControl_Value;
pub const IHostControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHostManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostControl,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostControl,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAppDomainManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostControl,
                dwAppDomainID: u32,
                pUnkAppDomainManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostControl,
                dwAppDomainID: u32,
                pUnkAppDomainManager: ?*IUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostControl_GetHostManager(self: *const T, riid: ?*const Guid, ppObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const IHostControl.VTable, @ptrCast(self.vtable)).GetHostManager(@as(*const IHostControl, @ptrCast(self)), riid, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostControl_SetAppDomainManager(self: *const T, dwAppDomainID: u32, pUnkAppDomainManager: ?*IUnknown) callconv(.Inline) HRESULT {
            return @as(*const IHostControl.VTable, @ptrCast(self.vtable)).SetAppDomainManager(@as(*const IHostControl, @ptrCast(self)), dwAppDomainID, pUnkAppDomainManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRControl_Value = Guid.initString("9065597e-d1a1-4fb2-b6ba-7e1fce230f61");
pub const IID_ICLRControl = &IID_ICLRControl_Value;
pub const ICLRControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCLRManager: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRControl,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRControl,
                riid: ?*const Guid,
                ppObject: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetAppDomainManagerType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRControl,
                pwzAppDomainManagerAssembly: ?[*:0]align(1) const u16,
                pwzAppDomainManagerType: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRControl,
                pwzAppDomainManagerAssembly: ?[*:0]align(1) const u16,
                pwzAppDomainManagerType: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRControl_GetCLRManager(self: *const T, riid: ?*const Guid, ppObject: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRControl.VTable, @ptrCast(self.vtable)).GetCLRManager(@as(*const ICLRControl, @ptrCast(self)), riid, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRControl_SetAppDomainManagerType(self: *const T, pwzAppDomainManagerAssembly: ?[*:0]align(1) const u16, pwzAppDomainManagerType: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ICLRControl.VTable, @ptrCast(self.vtable)).SetAppDomainManagerType(@as(*const ICLRControl, @ptrCast(self)), pwzAppDomainManagerAssembly, pwzAppDomainManagerType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRRuntimeHost_Value = Guid.initString("90f1a06c-7712-4762-86b5-7a5eba6bdb02");
pub const IID_ICLRRuntimeHost = &IID_ICLRRuntimeHost_Value;
pub const ICLRRuntimeHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Stop: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetHostControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                pHostControl: ?*IHostControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                pHostControl: ?*IHostControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCLRControl: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                pCLRControl: ?*?*ICLRControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                pCLRControl: ?*?*ICLRControl,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        UnloadAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                dwAppDomainId: u32,
                fWaitUntilDone: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                dwAppDomainId: u32,
                fWaitUntilDone: BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteInAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                dwAppDomainId: u32,
                pCallback: ?FExecuteInAppDomainCallback,
                cookie: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                dwAppDomainId: u32,
                pCallback: ?FExecuteInAppDomainCallback,
                cookie: ?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentAppDomainId: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                pdwAppDomainId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                pdwAppDomainId: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteApplication: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                pwzAppFullName: ?[*:0]align(1) const u16,
                dwManifestPaths: u32,
                ppwzManifestPaths: ?*const ?PWSTR,
                dwActivationData: u32,
                ppwzActivationData: ?*const ?PWSTR,
                pReturnValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                pwzAppFullName: ?[*:0]align(1) const u16,
                dwManifestPaths: u32,
                ppwzManifestPaths: ?*const ?PWSTR,
                dwActivationData: u32,
                ppwzActivationData: ?*const ?PWSTR,
                pReturnValue: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExecuteInDefaultAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeHost,
                pwzAssemblyPath: ?[*:0]align(1) const u16,
                pwzTypeName: ?[*:0]align(1) const u16,
                pwzMethodName: ?[*:0]align(1) const u16,
                pwzArgument: ?[*:0]align(1) const u16,
                pReturnValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeHost,
                pwzAssemblyPath: ?[*:0]align(1) const u16,
                pwzTypeName: ?[*:0]align(1) const u16,
                pwzMethodName: ?[*:0]align(1) const u16,
                pwzArgument: ?[*:0]align(1) const u16,
                pReturnValue: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_Start(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).Start(@as(*const ICLRRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).Stop(@as(*const ICLRRuntimeHost, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_SetHostControl(self: *const T, pHostControl: ?*IHostControl) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).SetHostControl(@as(*const ICLRRuntimeHost, @ptrCast(self)), pHostControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_GetCLRControl(self: *const T, pCLRControl: ?*?*ICLRControl) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).GetCLRControl(@as(*const ICLRRuntimeHost, @ptrCast(self)), pCLRControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_UnloadAppDomain(self: *const T, dwAppDomainId: u32, fWaitUntilDone: BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).UnloadAppDomain(@as(*const ICLRRuntimeHost, @ptrCast(self)), dwAppDomainId, fWaitUntilDone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_ExecuteInAppDomain(self: *const T, dwAppDomainId: u32, pCallback: ?FExecuteInAppDomainCallback, cookie: ?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).ExecuteInAppDomain(@as(*const ICLRRuntimeHost, @ptrCast(self)), dwAppDomainId, pCallback, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_GetCurrentAppDomainId(self: *const T, pdwAppDomainId: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).GetCurrentAppDomainId(@as(*const ICLRRuntimeHost, @ptrCast(self)), pdwAppDomainId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_ExecuteApplication(self: *const T, pwzAppFullName: ?[*:0]align(1) const u16, dwManifestPaths: u32, ppwzManifestPaths: ?*const ?PWSTR, dwActivationData: u32, ppwzActivationData: ?*const ?PWSTR, pReturnValue: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).ExecuteApplication(@as(*const ICLRRuntimeHost, @ptrCast(self)), pwzAppFullName, dwManifestPaths, ppwzManifestPaths, dwActivationData, ppwzActivationData, pReturnValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeHost_ExecuteInDefaultAppDomain(self: *const T, pwzAssemblyPath: ?[*:0]align(1) const u16, pwzTypeName: ?[*:0]align(1) const u16, pwzMethodName: ?[*:0]align(1) const u16, pwzArgument: ?[*:0]align(1) const u16, pReturnValue: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeHost.VTable, @ptrCast(self.vtable)).ExecuteInDefaultAppDomain(@as(*const ICLRRuntimeHost, @ptrCast(self)), pwzAssemblyPath, pwzTypeName, pwzMethodName, pwzArgument, pReturnValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EApiCategories = enum(i32) {
    NoChecks = 0,
    Synchronization = 1,
    SharedState = 2,
    ExternalProcessMgmt = 4,
    SelfAffectingProcessMgmt = 8,
    ExternalThreading = 16,
    SelfAffectingThreading = 32,
    SecurityInfrastructure = 64,
    UI = 128,
    MayLeakOnAbort = 256,
    All = 511,
};
pub const eNoChecks = EApiCategories.NoChecks;
pub const eSynchronization = EApiCategories.Synchronization;
pub const eSharedState = EApiCategories.SharedState;
pub const eExternalProcessMgmt = EApiCategories.ExternalProcessMgmt;
pub const eSelfAffectingProcessMgmt = EApiCategories.SelfAffectingProcessMgmt;
pub const eExternalThreading = EApiCategories.ExternalThreading;
pub const eSelfAffectingThreading = EApiCategories.SelfAffectingThreading;
pub const eSecurityInfrastructure = EApiCategories.SecurityInfrastructure;
pub const eUI = EApiCategories.UI;
pub const eMayLeakOnAbort = EApiCategories.MayLeakOnAbort;
pub const eAll = EApiCategories.All;

const IID_ICLRHostProtectionManager_Value = Guid.initString("89f25f5c-ceef-43e1-9cfa-a68ce863aaac");
pub const IID_ICLRHostProtectionManager = &IID_ICLRHostProtectionManager_Value;
pub const ICLRHostProtectionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProtectedCategories: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRHostProtectionManager,
                categories: EApiCategories,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRHostProtectionManager,
                categories: EApiCategories,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetEagerSerializeGrantSets: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRHostProtectionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRHostProtectionManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRHostProtectionManager_SetProtectedCategories(self: *const T, categories: EApiCategories) callconv(.Inline) HRESULT {
            return @as(*const ICLRHostProtectionManager.VTable, @ptrCast(self.vtable)).SetProtectedCategories(@as(*const ICLRHostProtectionManager, @ptrCast(self)), categories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRHostProtectionManager_SetEagerSerializeGrantSets(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRHostProtectionManager.VTable, @ptrCast(self.vtable)).SetEagerSerializeGrantSets(@as(*const ICLRHostProtectionManager, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EInitializeNewDomainFlags = enum(i32) {
    ne = 0,
    SecurityChanges = 2,
};
pub const eInitializeNewDomainFlags_None = EInitializeNewDomainFlags.ne;
pub const eInitializeNewDomainFlags_NoSecurityChanges = EInitializeNewDomainFlags.SecurityChanges;

const IID_ICLRDomainManager_Value = Guid.initString("270d00a2-8e15-4d0b-adeb-37bc3e47df77");
pub const IID_ICLRDomainManager = &IID_ICLRDomainManager_Value;
pub const ICLRDomainManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAppDomainManagerType: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDomainManager,
                wszAppDomainManagerAssembly: ?[*:0]align(1) const u16,
                wszAppDomainManagerType: ?[*:0]align(1) const u16,
                dwInitializeDomainFlags: EInitializeNewDomainFlags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDomainManager,
                wszAppDomainManagerAssembly: ?[*:0]align(1) const u16,
                wszAppDomainManagerType: ?[*:0]align(1) const u16,
                dwInitializeDomainFlags: EInitializeNewDomainFlags,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetPropertiesForDefaultAppDomain: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDomainManager,
                nProperties: u32,
                pwszPropertyNames: ?*const ?PWSTR,
                pwszPropertyValues: ?*const ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDomainManager,
                nProperties: u32,
                pwszPropertyNames: ?*const ?PWSTR,
                pwszPropertyValues: ?*const ?PWSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDomainManager_SetAppDomainManagerType(self: *const T, wszAppDomainManagerAssembly: ?[*:0]align(1) const u16, wszAppDomainManagerType: ?[*:0]align(1) const u16, dwInitializeDomainFlags: EInitializeNewDomainFlags) callconv(.Inline) HRESULT {
            return @as(*const ICLRDomainManager.VTable, @ptrCast(self.vtable)).SetAppDomainManagerType(@as(*const ICLRDomainManager, @ptrCast(self)), wszAppDomainManagerAssembly, wszAppDomainManagerType, dwInitializeDomainFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDomainManager_SetPropertiesForDefaultAppDomain(self: *const T, nProperties: u32, pwszPropertyNames: ?*const ?PWSTR, pwszPropertyValues: ?*const ?PWSTR) callconv(.Inline) HRESULT {
            return @as(*const ICLRDomainManager.VTable, @ptrCast(self.vtable)).SetPropertiesForDefaultAppDomain(@as(*const ICLRDomainManager, @ptrCast(self)), nProperties, pwszPropertyNames, pwszPropertyValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeName_Value = Guid.initString("b81ff171-20f3-11d2-8dcc-00a0c9b00522");
pub const IID_ITypeName = &IID_ITypeName_Value;
pub const ITypeName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNameCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetNames: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                count: u32,
                rgbszNames: ?*?BSTR,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                count: u32,
                rgbszNames: ?*?BSTR,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeArgumentCount: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                count: u32,
                rgpArguments: ?*?*ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                count: u32,
                rgpArguments: ?*?*ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModifierLength: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetModifiers: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                count: u32,
                rgModifiers: ?*u32,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                count: u32,
                rgModifiers: ?*u32,
                pCount: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetAssemblyName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeName,
                rgbszAssemblyNames: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeName,
                rgbszAssemblyNames: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetNameCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetNameCount(@as(*const ITypeName, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetNames(self: *const T, count: u32, rgbszNames: ?*?BSTR, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetNames(@as(*const ITypeName, @ptrCast(self)), count, rgbszNames, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetTypeArgumentCount(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetTypeArgumentCount(@as(*const ITypeName, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetTypeArguments(self: *const T, count: u32, rgpArguments: ?*?*ITypeName, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetTypeArguments(@as(*const ITypeName, @ptrCast(self)), count, rgpArguments, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetModifierLength(self: *const T, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetModifierLength(@as(*const ITypeName, @ptrCast(self)), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetModifiers(self: *const T, count: u32, rgModifiers: ?*u32, pCount: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetModifiers(@as(*const ITypeName, @ptrCast(self)), count, rgModifiers, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeName_GetAssemblyName(self: *const T, rgbszAssemblyNames: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITypeName.VTable, @ptrCast(self.vtable)).GetAssemblyName(@as(*const ITypeName, @ptrCast(self)), rgbszAssemblyNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeNameBuilder_Value = Guid.initString("b81ff171-20f3-11d2-8dcc-00a0c9b00523");
pub const IID_ITypeNameBuilder = &IID_ITypeNameBuilder_Value;
pub const ITypeNameBuilder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenGenericArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseGenericArguments: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenGenericArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CloseGenericArgument: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
                szName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
                szName: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddPointer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddByRef: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddSzArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddArray: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
                rank: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
                rank: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        AddAssemblySpec: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
                szAssemblySpec: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
                szAssemblySpec: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ToString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
                pszStringRepresentation: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
                pszStringRepresentation: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        Clear: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_OpenGenericArguments(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).OpenGenericArguments(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_CloseGenericArguments(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).CloseGenericArguments(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_OpenGenericArgument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).OpenGenericArgument(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_CloseGenericArgument(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).CloseGenericArgument(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddName(self: *const T, szName: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddName(@as(*const ITypeNameBuilder, @ptrCast(self)), szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddPointer(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddPointer(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddByRef(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddByRef(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddSzArray(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddSzArray(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddArray(self: *const T, rank: u32) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddArray(@as(*const ITypeNameBuilder, @ptrCast(self)), rank);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_AddAssemblySpec(self: *const T, szAssemblySpec: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).AddAssemblySpec(@as(*const ITypeNameBuilder, @ptrCast(self)), szAssemblySpec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_ToString(self: *const T, pszStringRepresentation: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).ToString(@as(*const ITypeNameBuilder, @ptrCast(self)), pszStringRepresentation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameBuilder_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameBuilder.VTable, @ptrCast(self.vtable)).Clear(@as(*const ITypeNameBuilder, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITypeNameFactory_Value = Guid.initString("b81ff171-20f3-11d2-8dcc-00a0c9b00521");
pub const IID_ITypeNameFactory = &IID_ITypeNameFactory_Value;
pub const ITypeNameFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseTypeName: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameFactory,
                szName: ?[*:0]align(1) const u16,
                pError: ?*u32,
                ppTypeName: ?*?*ITypeName,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameFactory,
                szName: ?[*:0]align(1) const u16,
                pError: ?*u32,
                ppTypeName: ?*?*ITypeName,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetTypeNameBuilder: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ITypeNameFactory,
                ppTypeBuilder: ?*?*ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ITypeNameFactory,
                ppTypeBuilder: ?*?*ITypeNameBuilder,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameFactory_ParseTypeName(self: *const T, szName: ?[*:0]align(1) const u16, pError: ?*u32, ppTypeName: ?*?*ITypeName) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameFactory.VTable, @ptrCast(self.vtable)).ParseTypeName(@as(*const ITypeNameFactory, @ptrCast(self)), szName, pError, ppTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITypeNameFactory_GetTypeNameBuilder(self: *const T, ppTypeBuilder: ?*?*ITypeNameBuilder) callconv(.Inline) HRESULT {
            return @as(*const ITypeNameFactory.VTable, @ptrCast(self.vtable)).GetTypeNameBuilder(@as(*const ITypeNameFactory, @ptrCast(self)), ppTypeBuilder);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApartmentCallback_Value = Guid.initString("178e5337-1528-4591-b1c9-1c6e484686d8");
pub const IID_IApartmentCallback = &IID_IApartmentCallback_Value;
pub const IApartmentCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DoCallback: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IApartmentCallback,
                pFunc: usize,
                pData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IApartmentCallback,
                pFunc: usize,
                pData: usize,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApartmentCallback_DoCallback(self: *const T, pFunc: usize, pData: usize) callconv(.Inline) HRESULT {
            return @as(*const IApartmentCallback.VTable, @ptrCast(self.vtable)).DoCallback(@as(*const IApartmentCallback, @ptrCast(self)), pFunc, pData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IManagedObject_Value = Guid.initString("c3fcc19e-a970-11d2-8b5a-00a0c9b7c9c4");
pub const IID_IManagedObject = &IID_IManagedObject_Value;
pub const IManagedObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSerializedBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IManagedObject,
                pBSTR: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IManagedObject,
                pBSTR: ?*?BSTR,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetObjectIdentity: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IManagedObject,
                pBSTRGUID: ?*?BSTR,
                AppDomainID: ?*i32,
                pCCW: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IManagedObject,
                pBSTRGUID: ?*?BSTR,
                AppDomainID: ?*i32,
                pCCW: ?*i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManagedObject_GetSerializedBuffer(self: *const T, pBSTR: ?*?BSTR) callconv(.Inline) HRESULT {
            return @as(*const IManagedObject.VTable, @ptrCast(self.vtable)).GetSerializedBuffer(@as(*const IManagedObject, @ptrCast(self)), pBSTR);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManagedObject_GetObjectIdentity(self: *const T, pBSTRGUID: ?*?BSTR, AppDomainID: ?*i32, pCCW: ?*i32) callconv(.Inline) HRESULT {
            return @as(*const IManagedObject.VTable, @ptrCast(self.vtable)).GetObjectIdentity(@as(*const IManagedObject, @ptrCast(self)), pBSTRGUID, AppDomainID, pCCW);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICatalogServices_Value = Guid.initString("04c6be1e-1db1-4058-ab7a-700cccfbf254");
pub const IID_ICatalogServices = &IID_ICatalogServices_Value;
pub const ICatalogServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Autodone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICatalogServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICatalogServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        NotAutodone: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICatalogServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICatalogServices,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogServices_Autodone(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICatalogServices.VTable, @ptrCast(self.vtable)).Autodone(@as(*const ICatalogServices, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICatalogServices_NotAutodone(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICatalogServices.VTable, @ptrCast(self.vtable)).NotAutodone(@as(*const ICatalogServices, @ptrCast(self)));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_ComCallUnmarshal_Value = Guid.initString("3f281000-e95a-11d2-886b-00c04f869f04");
pub const CLSID_ComCallUnmarshal = &CLSID_ComCallUnmarshal_Value;

const CLSID_ComCallUnmarshalV4_Value = Guid.initString("45fb4600-e6e8-4928-b25e-50476ff79425");
pub const CLSID_ComCallUnmarshalV4 = &CLSID_ComCallUnmarshalV4_Value;

const CLSID_CorRuntimeHost_Value = Guid.initString("cb2f6723-ab3a-11d2-9c40-00c04fa30a3e");
pub const CLSID_CorRuntimeHost = &CLSID_CorRuntimeHost_Value;

const CLSID_CLRRuntimeHost_Value = Guid.initString("90f1a06e-7712-4762-86b5-7a5eba6bdb02");
pub const CLSID_CLRRuntimeHost = &CLSID_CLRRuntimeHost_Value;

const CLSID_TypeNameFactory_Value = Guid.initString("b81ff171-20f3-11d2-8dcc-00a0c9b00525");
pub const CLSID_TypeNameFactory = &CLSID_TypeNameFactory_Value;

pub const EContextType = enum(i32) {
    CurrentContext = 0,
    RestrictedContext = 1,
};
pub const eCurrentContext = EContextType.CurrentContext;
pub const eRestrictedContext = EContextType.RestrictedContext;

const IID_IHostSecurityContext_Value = Guid.initString("7e573ce4-0343-4423-98d7-6318348a1d3c");
pub const IID_IHostSecurityContext = &IID_IHostSecurityContext_Value;
pub const IHostSecurityContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Capture: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityContext,
                ppClonedContext: ?*?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityContext,
                ppClonedContext: ?*?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityContext_Capture(self: *const T, ppClonedContext: ?*?*IHostSecurityContext) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityContext.VTable, @ptrCast(self.vtable)).Capture(@as(*const IHostSecurityContext, @ptrCast(self)), ppClonedContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostSecurityManager_Value = Guid.initString("75ad2468-a349-4d02-a764-76a68aee0c4f");
pub const IID_IHostSecurityManager = &IID_IHostSecurityManager_Value;
pub const IHostSecurityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ImpersonateLoggedOnUser: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
                hToken: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
                hToken: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RevertToSelf: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        OpenThreadToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
                dwDesiredAccess: u32,
                bOpenAsSelf: BOOL,
                phThreadToken: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
                dwDesiredAccess: u32,
                bOpenAsSelf: BOOL,
                phThreadToken: ?*?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetThreadToken: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
                hToken: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
                hToken: ?HANDLE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetSecurityContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
                eContextType: EContextType,
                ppSecurityContext: ?*?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
                eContextType: EContextType,
                ppSecurityContext: ?*?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetSecurityContext: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const IHostSecurityManager,
                eContextType: EContextType,
                pSecurityContext: ?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const IHostSecurityManager,
                eContextType: EContextType,
                pSecurityContext: ?*IHostSecurityContext,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_ImpersonateLoggedOnUser(self: *const T, hToken: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).ImpersonateLoggedOnUser(@as(*const IHostSecurityManager, @ptrCast(self)), hToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_RevertToSelf(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).RevertToSelf(@as(*const IHostSecurityManager, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_OpenThreadToken(self: *const T, dwDesiredAccess: u32, bOpenAsSelf: BOOL, phThreadToken: ?*?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).OpenThreadToken(@as(*const IHostSecurityManager, @ptrCast(self)), dwDesiredAccess, bOpenAsSelf, phThreadToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_SetThreadToken(self: *const T, hToken: ?HANDLE) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).SetThreadToken(@as(*const IHostSecurityManager, @ptrCast(self)), hToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_GetSecurityContext(self: *const T, eContextType: EContextType, ppSecurityContext: ?*?*IHostSecurityContext) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).GetSecurityContext(@as(*const IHostSecurityManager, @ptrCast(self)), eContextType, ppSecurityContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostSecurityManager_SetSecurityContext(self: *const T, eContextType: EContextType, pSecurityContext: ?*IHostSecurityContext) callconv(.Inline) HRESULT {
            return @as(*const IHostSecurityManager.VTable, @ptrCast(self.vtable)).SetSecurityContext(@as(*const IHostSecurityManager, @ptrCast(self)), eContextType, pSecurityContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRAppDomainResourceMonitor_Value = Guid.initString("c62de18c-2e23-4aea-8423-b40c1fc59eae");
pub const IID_ICLRAppDomainResourceMonitor = &IID_ICLRAppDomainResourceMonitor_Value;
pub const ICLRAppDomainResourceMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentAllocated: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pBytesAllocated: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pBytesAllocated: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentSurvived: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pAppDomainBytesSurvived: ?*u64,
                pTotalBytesSurvived: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pAppDomainBytesSurvived: ?*u64,
                pTotalBytesSurvived: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetCurrentCpuTime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pMilliseconds: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRAppDomainResourceMonitor,
                dwAppDomainId: u32,
                pMilliseconds: ?*u64,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAppDomainResourceMonitor_GetCurrentAllocated(self: *const T, dwAppDomainId: u32, pBytesAllocated: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ICLRAppDomainResourceMonitor.VTable, @ptrCast(self.vtable)).GetCurrentAllocated(@as(*const ICLRAppDomainResourceMonitor, @ptrCast(self)), dwAppDomainId, pBytesAllocated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAppDomainResourceMonitor_GetCurrentSurvived(self: *const T, dwAppDomainId: u32, pAppDomainBytesSurvived: ?*u64, pTotalBytesSurvived: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ICLRAppDomainResourceMonitor.VTable, @ptrCast(self.vtable)).GetCurrentSurvived(@as(*const ICLRAppDomainResourceMonitor, @ptrCast(self)), dwAppDomainId, pAppDomainBytesSurvived, pTotalBytesSurvived);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRAppDomainResourceMonitor_GetCurrentCpuTime(self: *const T, dwAppDomainId: u32, pMilliseconds: ?*u64) callconv(.Inline) HRESULT {
            return @as(*const ICLRAppDomainResourceMonitor.VTable, @ptrCast(self.vtable)).GetCurrentCpuTime(@as(*const ICLRAppDomainResourceMonitor, @ptrCast(self)), dwAppDomainId, pMilliseconds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CLRCreateInstanceFnPtr = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        clsid: ?*const Guid,
        riid: ?*const Guid,
        ppInterface: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        clsid: ?*const Guid,
        riid: ?*const Guid,
        ppInterface: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const CreateInterfaceFnPtr = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        clsid: ?*const Guid,
        riid: ?*const Guid,
        ppInterface: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
        clsid: ?*const Guid,
        riid: ?*const Guid,
        ppInterface: ?*?*anyopaque,
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const CallbackThreadSetFnPtr = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const CallbackThreadUnsetFnPtr = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    else => *const fn(
    ) callconv(@import("std").os.windows.WINAPI) HRESULT,
} ;

pub const RuntimeLoadedCallbackFnPtr = switch (@import("builtin").zig_backend) {
    .stage1 => fn(
        pRuntimeInfo: ?*ICLRRuntimeInfo,
        pfnCallbackThreadSet: ?CallbackThreadSetFnPtr,
        pfnCallbackThreadUnset: ?CallbackThreadUnsetFnPtr,
    ) callconv(@import("std").os.windows.WINAPI) void,
    else => *const fn(
        pRuntimeInfo: ?*ICLRRuntimeInfo,
        pfnCallbackThreadSet: ?CallbackThreadSetFnPtr,
        pfnCallbackThreadUnset: ?CallbackThreadUnsetFnPtr,
    ) callconv(@import("std").os.windows.WINAPI) void,
} ;

const IID_ICLRMetaHost_Value = Guid.initString("d332db9e-b9b3-4125-8207-a14884f53216");
pub const IID_ICLRMetaHost = &IID_ICLRMetaHost_Value;
pub const ICLRMetaHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                pwzVersion: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppRuntime: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                pwzVersion: ?[*:0]align(1) const u16,
                riid: ?*const Guid,
                ppRuntime: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetVersionFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                pwzFilePath: ?[*:0]align(1) const u16,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                pwzFilePath: ?[*:0]align(1) const u16,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateInstalledRuntimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                ppEnumerator: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                ppEnumerator: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        EnumerateLoadedRuntimes: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                hndProcess: ?HANDLE,
                ppEnumerator: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                hndProcess: ?HANDLE,
                ppEnumerator: ?*?*IEnumUnknown,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        RequestRuntimeLoadedNotification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                pCallbackFunction: ?RuntimeLoadedCallbackFnPtr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                pCallbackFunction: ?RuntimeLoadedCallbackFnPtr,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        QueryLegacyV2RuntimeBinding: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        ExitProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHost,
                iExitCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHost,
                iExitCode: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_GetRuntime(self: *const T, pwzVersion: ?[*:0]align(1) const u16, riid: ?*const Guid, ppRuntime: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).GetRuntime(@as(*const ICLRMetaHost, @ptrCast(self)), pwzVersion, riid, ppRuntime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_GetVersionFromFile(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, pwzBuffer: [*:0]u16, pcchBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).GetVersionFromFile(@as(*const ICLRMetaHost, @ptrCast(self)), pwzFilePath, pwzBuffer, pcchBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_EnumerateInstalledRuntimes(self: *const T, ppEnumerator: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).EnumerateInstalledRuntimes(@as(*const ICLRMetaHost, @ptrCast(self)), ppEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_EnumerateLoadedRuntimes(self: *const T, hndProcess: ?HANDLE, ppEnumerator: ?*?*IEnumUnknown) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).EnumerateLoadedRuntimes(@as(*const ICLRMetaHost, @ptrCast(self)), hndProcess, ppEnumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_RequestRuntimeLoadedNotification(self: *const T, pCallbackFunction: ?RuntimeLoadedCallbackFnPtr) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).RequestRuntimeLoadedNotification(@as(*const ICLRMetaHost, @ptrCast(self)), pCallbackFunction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_QueryLegacyV2RuntimeBinding(self: *const T, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).QueryLegacyV2RuntimeBinding(@as(*const ICLRMetaHost, @ptrCast(self)), riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHost_ExitProcess(self: *const T, iExitCode: i32) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHost.VTable, @ptrCast(self.vtable)).ExitProcess(@as(*const ICLRMetaHost, @ptrCast(self)), iExitCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const METAHOST_POLICY_FLAGS = enum(i32) {
    HIGHCOMPAT = 0,
    APPLY_UPGRADE_POLICY = 8,
    EMULATE_EXE_LAUNCH = 16,
    SHOW_ERROR_DIALOG = 32,
    USE_PROCESS_IMAGE_PATH = 64,
    ENSURE_SKU_SUPPORTED = 128,
    IGNORE_ERROR_MODE = 4096,
};
pub const METAHOST_POLICY_HIGHCOMPAT = METAHOST_POLICY_FLAGS.HIGHCOMPAT;
pub const METAHOST_POLICY_APPLY_UPGRADE_POLICY = METAHOST_POLICY_FLAGS.APPLY_UPGRADE_POLICY;
pub const METAHOST_POLICY_EMULATE_EXE_LAUNCH = METAHOST_POLICY_FLAGS.EMULATE_EXE_LAUNCH;
pub const METAHOST_POLICY_SHOW_ERROR_DIALOG = METAHOST_POLICY_FLAGS.SHOW_ERROR_DIALOG;
pub const METAHOST_POLICY_USE_PROCESS_IMAGE_PATH = METAHOST_POLICY_FLAGS.USE_PROCESS_IMAGE_PATH;
pub const METAHOST_POLICY_ENSURE_SKU_SUPPORTED = METAHOST_POLICY_FLAGS.ENSURE_SKU_SUPPORTED;
pub const METAHOST_POLICY_IGNORE_ERROR_MODE = METAHOST_POLICY_FLAGS.IGNORE_ERROR_MODE;

pub const METAHOST_CONFIG_FLAGS = enum(i32) {
    UNSET = 0,
    TRUE = 1,
    FALSE = 2,
    MASK = 3,
};
pub const METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_UNSET = METAHOST_CONFIG_FLAGS.UNSET;
pub const METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_TRUE = METAHOST_CONFIG_FLAGS.TRUE;
pub const METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_FALSE = METAHOST_CONFIG_FLAGS.FALSE;
pub const METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_MASK = METAHOST_CONFIG_FLAGS.MASK;

const IID_ICLRMetaHostPolicy_Value = Guid.initString("e2190695-77b2-492e-8e14-c4b3a7fdd593");
pub const IID_ICLRMetaHostPolicy = &IID_ICLRMetaHostPolicy_Value;
pub const ICLRMetaHostPolicy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRequestedRuntime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRMetaHostPolicy,
                dwPolicyFlags: METAHOST_POLICY_FLAGS,
                pwzBinary: ?[*:0]align(1) const u16,
                pCfgStream: ?*IStream,
                pwzVersion: ?[*:0]u16,
                pcchVersion: ?*u32,
                pwzImageVersion: ?[*:0]u16,
                pcchImageVersion: ?*u32,
                pdwConfigFlags: ?*u32,
                riid: ?*const Guid,
                ppRuntime: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRMetaHostPolicy,
                dwPolicyFlags: METAHOST_POLICY_FLAGS,
                pwzBinary: ?[*:0]align(1) const u16,
                pCfgStream: ?*IStream,
                pwzVersion: ?[*:0]u16,
                pcchVersion: ?*u32,
                pwzImageVersion: ?[*:0]u16,
                pcchImageVersion: ?*u32,
                pdwConfigFlags: ?*u32,
                riid: ?*const Guid,
                ppRuntime: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRMetaHostPolicy_GetRequestedRuntime(self: *const T, dwPolicyFlags: METAHOST_POLICY_FLAGS, pwzBinary: ?[*:0]align(1) const u16, pCfgStream: ?*IStream, pwzVersion: ?[*:0]u16, pcchVersion: ?*u32, pwzImageVersion: ?[*:0]u16, pcchImageVersion: ?*u32, pdwConfigFlags: ?*u32, riid: ?*const Guid, ppRuntime: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRMetaHostPolicy.VTable, @ptrCast(self.vtable)).GetRequestedRuntime(@as(*const ICLRMetaHostPolicy, @ptrCast(self)), dwPolicyFlags, pwzBinary, pCfgStream, pwzVersion, pcchVersion, pwzImageVersion, pcchImageVersion, pdwConfigFlags, riid, ppRuntime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRProfiling_Value = Guid.initString("b349abe3-b56f-4689-bfcd-76bf39d888ea");
pub const IID_ICLRProfiling = &IID_ICLRProfiling_Value;
pub const ICLRProfiling = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachProfiler: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRProfiling,
                dwProfileeProcessID: u32,
                dwMillisecondsMax: u32,
                pClsidProfiler: ?*const Guid,
                wszProfilerPath: ?[*:0]align(1) const u16,
                pvClientData: [*]u8,
                cbClientData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRProfiling,
                dwProfileeProcessID: u32,
                dwMillisecondsMax: u32,
                pClsidProfiler: ?*const Guid,
                wszProfilerPath: ?[*:0]align(1) const u16,
                pvClientData: [*]u8,
                cbClientData: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRProfiling_AttachProfiler(self: *const T, dwProfileeProcessID: u32, dwMillisecondsMax: u32, pClsidProfiler: ?*const Guid, wszProfilerPath: ?[*:0]align(1) const u16, pvClientData: [*]u8, cbClientData: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRProfiling.VTable, @ptrCast(self.vtable)).AttachProfiler(@as(*const ICLRProfiling, @ptrCast(self)), dwProfileeProcessID, dwMillisecondsMax, pClsidProfiler, wszProfilerPath, pvClientData, cbClientData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CLR_DEBUGGING_VERSION = extern struct {
    wStructVersion: u16,
    wMajor: u16,
    wMinor: u16,
    wBuild: u16,
    wRevision: u16,
};

pub const CLR_DEBUGGING_PROCESS_FLAGS = enum(i32) {
    PENDING = 1,
    DEBUGGER_LAUNCH = 2,
};
pub const CLR_DEBUGGING_MANAGED_EVENT_PENDING = CLR_DEBUGGING_PROCESS_FLAGS.PENDING;
pub const CLR_DEBUGGING_MANAGED_EVENT_DEBUGGER_LAUNCH = CLR_DEBUGGING_PROCESS_FLAGS.DEBUGGER_LAUNCH;

const IID_ICLRDebuggingLibraryProvider_Value = Guid.initString("3151c08d-4d09-4f9b-8838-2880bf18fe51");
pub const IID_ICLRDebuggingLibraryProvider = &IID_ICLRDebuggingLibraryProvider_Value;
pub const ICLRDebuggingLibraryProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProvideLibrary: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebuggingLibraryProvider,
                pwszFileName: ?[*:0]align(1) const u16,
                dwTimestamp: u32,
                dwSizeOfImage: u32,
                phModule: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebuggingLibraryProvider,
                pwszFileName: ?[*:0]align(1) const u16,
                dwTimestamp: u32,
                dwSizeOfImage: u32,
                phModule: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebuggingLibraryProvider_ProvideLibrary(self: *const T, pwszFileName: ?[*:0]align(1) const u16, dwTimestamp: u32, dwSizeOfImage: u32, phModule: ?*HMODULE) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebuggingLibraryProvider.VTable, @ptrCast(self.vtable)).ProvideLibrary(@as(*const ICLRDebuggingLibraryProvider, @ptrCast(self)), pwszFileName, dwTimestamp, dwSizeOfImage, phModule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRDebugging_Value = Guid.initString("d28f3c5a-9634-4206-a509-477552eefb10");
pub const IID_ICLRDebugging = &IID_ICLRDebugging_Value;
pub const ICLRDebugging = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenVirtualProcess: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugging,
                moduleBaseAddress: u64,
                pDataTarget: ?*IUnknown,
                pLibraryProvider: ?*ICLRDebuggingLibraryProvider,
                pMaxDebuggerSupportedVersion: ?*CLR_DEBUGGING_VERSION,
                riidProcess: ?*const Guid,
                ppProcess: ?*?*IUnknown,
                pVersion: ?*CLR_DEBUGGING_VERSION,
                pdwFlags: ?*CLR_DEBUGGING_PROCESS_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugging,
                moduleBaseAddress: u64,
                pDataTarget: ?*IUnknown,
                pLibraryProvider: ?*ICLRDebuggingLibraryProvider,
                pMaxDebuggerSupportedVersion: ?*CLR_DEBUGGING_VERSION,
                riidProcess: ?*const Guid,
                ppProcess: ?*?*IUnknown,
                pVersion: ?*CLR_DEBUGGING_VERSION,
                pdwFlags: ?*CLR_DEBUGGING_PROCESS_FLAGS,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        CanUnloadNow: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRDebugging,
                hModule: HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRDebugging,
                hModule: HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugging_OpenVirtualProcess(self: *const T, moduleBaseAddress: u64, pDataTarget: ?*IUnknown, pLibraryProvider: ?*ICLRDebuggingLibraryProvider, pMaxDebuggerSupportedVersion: ?*CLR_DEBUGGING_VERSION, riidProcess: ?*const Guid, ppProcess: ?*?*IUnknown, pVersion: ?*CLR_DEBUGGING_VERSION, pdwFlags: ?*CLR_DEBUGGING_PROCESS_FLAGS) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugging.VTable, @ptrCast(self.vtable)).OpenVirtualProcess(@as(*const ICLRDebugging, @ptrCast(self)), moduleBaseAddress, pDataTarget, pLibraryProvider, pMaxDebuggerSupportedVersion, riidProcess, ppProcess, pVersion, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRDebugging_CanUnloadNow(self: *const T, hModule: HMODULE) callconv(.Inline) HRESULT {
            return @as(*const ICLRDebugging.VTable, @ptrCast(self.vtable)).CanUnloadNow(@as(*const ICLRDebugging, @ptrCast(self)), hModule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRRuntimeInfo_Value = Guid.initString("bd39d1d2-ba2f-486a-89b0-b4b0cb466891");
pub const IID_ICLRRuntimeInfo = &IID_ICLRRuntimeInfo_Value;
pub const ICLRRuntimeInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVersionString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pwzBuffer: ?[*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pwzBuffer: ?[*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetRuntimeDirectory: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLoaded: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                hndProcess: ?HANDLE,
                pbLoaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                hndProcess: ?HANDLE,
                pbLoaded: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadErrorString: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                iResourceID: u32,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
                iLocaleID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                iResourceID: u32,
                pwzBuffer: [*:0]u16,
                pcchBuffer: ?*u32,
                iLocaleID: i32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        LoadLibraryA: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pwzDllName: ?[*:0]align(1) const u16,
                phndModule: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pwzDllName: ?[*:0]align(1) const u16,
                phndModule: ?*HMODULE,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetProcAddress: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pszProcName: ?[*:0]align(1) const u8,
                ppProc: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pszProcName: ?[*:0]align(1) const u8,
                ppProc: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetInterface: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                rclsid: ?*const Guid,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                rclsid: ?*const Guid,
                riid: ?*const Guid,
                ppUnk: ?*?*anyopaque,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsLoadable: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pbLoadable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pbLoadable: ?*BOOL,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        SetDefaultStartupFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                dwStartupFlags: u32,
                pwzHostConfigFile: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                dwStartupFlags: u32,
                pwzHostConfigFile: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetDefaultStartupFlags: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pdwStartupFlags: ?*u32,
                pwzHostConfigFile: ?[*:0]u16,
                pcchHostConfigFile: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pdwStartupFlags: ?*u32,
                pwzHostConfigFile: ?[*:0]u16,
                pcchHostConfigFile: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        BindAsLegacyV2Runtime: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        IsStarted: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRRuntimeInfo,
                pbStarted: ?*BOOL,
                pdwStartupFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRRuntimeInfo,
                pbStarted: ?*BOOL,
                pdwStartupFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_GetVersionString(self: *const T, pwzBuffer: ?[*:0]u16, pcchBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).GetVersionString(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pwzBuffer, pcchBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_GetRuntimeDirectory(self: *const T, pwzBuffer: [*:0]u16, pcchBuffer: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).GetRuntimeDirectory(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pwzBuffer, pcchBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_IsLoaded(self: *const T, hndProcess: ?HANDLE, pbLoaded: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).IsLoaded(@as(*const ICLRRuntimeInfo, @ptrCast(self)), hndProcess, pbLoaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_LoadErrorString(self: *const T, iResourceID: u32, pwzBuffer: [*:0]u16, pcchBuffer: ?*u32, iLocaleID: i32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).LoadErrorString(@as(*const ICLRRuntimeInfo, @ptrCast(self)), iResourceID, pwzBuffer, pcchBuffer, iLocaleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_LoadLibraryA(self: *const T, pwzDllName: ?[*:0]align(1) const u16, phndModule: ?*HMODULE) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).LoadLibraryA(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pwzDllName, phndModule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_GetProcAddress(self: *const T, pszProcName: ?[*:0]align(1) const u8, ppProc: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).GetProcAddress(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pszProcName, ppProc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_GetInterface(self: *const T, rclsid: ?*const Guid, riid: ?*const Guid, ppUnk: ?*?*anyopaque) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).GetInterface(@as(*const ICLRRuntimeInfo, @ptrCast(self)), rclsid, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_IsLoadable(self: *const T, pbLoadable: ?*BOOL) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).IsLoadable(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pbLoadable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_SetDefaultStartupFlags(self: *const T, dwStartupFlags: u32, pwzHostConfigFile: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).SetDefaultStartupFlags(@as(*const ICLRRuntimeInfo, @ptrCast(self)), dwStartupFlags, pwzHostConfigFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_GetDefaultStartupFlags(self: *const T, pdwStartupFlags: ?*u32, pwzHostConfigFile: ?[*:0]u16, pcchHostConfigFile: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).GetDefaultStartupFlags(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pdwStartupFlags, pwzHostConfigFile, pcchHostConfigFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_BindAsLegacyV2Runtime(self: *const T) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).BindAsLegacyV2Runtime(@as(*const ICLRRuntimeInfo, @ptrCast(self)));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRRuntimeInfo_IsStarted(self: *const T, pbStarted: ?*BOOL, pdwStartupFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRRuntimeInfo.VTable, @ptrCast(self.vtable)).IsStarted(@as(*const ICLRRuntimeInfo, @ptrCast(self)), pbStarted, pdwStartupFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRStrongName_Value = Guid.initString("9fd93ccf-3280-4391-b3a9-96e1cde77c8d");
pub const IID_ICLRStrongName = &IID_ICLRStrongName_Value;
pub const ICLRStrongName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHashFromAssemblyFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pszFilePath: ?[*:0]align(1) const u8,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pszFilePath: ?[*:0]align(1) const u8,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashFromAssemblyFileW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashFromBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbBlob: ?*u8,
                cchBlob: u32,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbBlob: ?*u8,
                cchBlob: u32,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashFromFile: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pszFilePath: ?[*:0]align(1) const u8,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pszFilePath: ?[*:0]align(1) const u8,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashFromFileW: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        GetHashFromHandle: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                hFile: ?HANDLE,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                hFile: ?HANDLE,
                piHashAlg: ?*u32,
                pbHash: [*:0]u8,
                cchHash: u32,
                pchHash: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameCompareAssemblies: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzAssembly1: ?[*:0]align(1) const u16,
                pwzAssembly2: ?[*:0]align(1) const u16,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzAssembly1: ?[*:0]align(1) const u16,
                pwzAssembly2: ?[*:0]align(1) const u16,
                pdwResult: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameFreeBuffer: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbMemory: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbMemory: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameGetBlob: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                pbBlob: [*:0]u8,
                pcbBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                pbBlob: [*:0]u8,
                pcbBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameGetBlobFromImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbBase: [*:0]u8,
                dwLength: u32,
                pbBlob: [*:0]u8,
                pcbBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbBase: [*:0]u8,
                dwLength: u32,
                pbBlob: [*:0]u8,
                pcbBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameGetPublicKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameHashSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                ulHashAlg: u32,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                ulHashAlg: u32,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameKeyDelete: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameKeyGen: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppbKeyBlob: ?*?*u8,
                pcbKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                dwFlags: u32,
                ppbKeyBlob: ?*?*u8,
                pcbKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameKeyGenEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                dwFlags: u32,
                dwKeySize: u32,
                ppbKeyBlob: ?*?*u8,
                pcbKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                dwFlags: u32,
                dwKeySize: u32,
                ppbKeyBlob: ?*?*u8,
                pcbKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameKeyInstall: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureGeneration: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureGenerationEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                wszFilePath: ?[*:0]align(1) const u16,
                wszKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                wszFilePath: ?[*:0]align(1) const u16,
                wszKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureSize: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbPublicKeyBlob: ?*u8,
                cbPublicKeyBlob: u32,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbPublicKeyBlob: ?*u8,
                cbPublicKeyBlob: u32,
                pcbSize: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureVerification: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwInFlags: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                dwInFlags: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureVerificationEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                fForceVerification: BOOLEAN,
                pfWasVerified: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                fForceVerification: BOOLEAN,
                pfWasVerified: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureVerificationFromImage: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbBase: ?*u8,
                dwLength: u32,
                dwInFlags: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbBase: ?*u8,
                dwLength: u32,
                dwInFlags: u32,
                pdwOutFlags: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameTokenFromAssembly: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameTokenFromAssemblyEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pwzFilePath: ?[*:0]align(1) const u16,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameTokenFromPublicKey: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName,
                pbPublicKeyBlob: ?*u8,
                cbPublicKeyBlob: u32,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName,
                pbPublicKeyBlob: ?*u8,
                cbPublicKeyBlob: u32,
                ppbStrongNameToken: ?*?*u8,
                pcbStrongNameToken: ?*u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromAssemblyFile(self: *const T, pszFilePath: ?[*:0]align(1) const u8, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromAssemblyFile(@as(*const ICLRStrongName, @ptrCast(self)), pszFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromAssemblyFileW(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromAssemblyFileW(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromBlob(self: *const T, pbBlob: ?*u8, cchBlob: u32, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromBlob(@as(*const ICLRStrongName, @ptrCast(self)), pbBlob, cchBlob, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromFile(self: *const T, pszFilePath: ?[*:0]align(1) const u8, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromFile(@as(*const ICLRStrongName, @ptrCast(self)), pszFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromFileW(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromFileW(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_GetHashFromHandle(self: *const T, hFile: ?HANDLE, piHashAlg: ?*u32, pbHash: [*:0]u8, cchHash: u32, pchHash: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).GetHashFromHandle(@as(*const ICLRStrongName, @ptrCast(self)), hFile, piHashAlg, pbHash, cchHash, pchHash);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameCompareAssemblies(self: *const T, pwzAssembly1: ?[*:0]align(1) const u16, pwzAssembly2: ?[*:0]align(1) const u16, pdwResult: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameCompareAssemblies(@as(*const ICLRStrongName, @ptrCast(self)), pwzAssembly1, pwzAssembly2, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameFreeBuffer(self: *const T, pbMemory: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameFreeBuffer(@as(*const ICLRStrongName, @ptrCast(self)), pbMemory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameGetBlob(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, pbBlob: [*:0]u8, pcbBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameGetBlob(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, pbBlob, pcbBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameGetBlobFromImage(self: *const T, pbBase: [*:0]u8, dwLength: u32, pbBlob: [*:0]u8, pcbBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameGetBlobFromImage(@as(*const ICLRStrongName, @ptrCast(self)), pbBase, dwLength, pbBlob, pcbBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameGetPublicKey(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: ?*u8, cbKeyBlob: u32, ppbPublicKeyBlob: ?*?*u8, pcbPublicKeyBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameGetPublicKey(@as(*const ICLRStrongName, @ptrCast(self)), pwzKeyContainer, pbKeyBlob, cbKeyBlob, ppbPublicKeyBlob, pcbPublicKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameHashSize(self: *const T, ulHashAlg: u32, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameHashSize(@as(*const ICLRStrongName, @ptrCast(self)), ulHashAlg, pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameKeyDelete(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameKeyDelete(@as(*const ICLRStrongName, @ptrCast(self)), pwzKeyContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameKeyGen(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16, dwFlags: u32, ppbKeyBlob: ?*?*u8, pcbKeyBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameKeyGen(@as(*const ICLRStrongName, @ptrCast(self)), pwzKeyContainer, dwFlags, ppbKeyBlob, pcbKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameKeyGenEx(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16, dwFlags: u32, dwKeySize: u32, ppbKeyBlob: ?*?*u8, pcbKeyBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameKeyGenEx(@as(*const ICLRStrongName, @ptrCast(self)), pwzKeyContainer, dwFlags, dwKeySize, ppbKeyBlob, pcbKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameKeyInstall(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: ?*u8, cbKeyBlob: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameKeyInstall(@as(*const ICLRStrongName, @ptrCast(self)), pwzKeyContainer, pbKeyBlob, cbKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureGeneration(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, pwzKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: ?*u8, cbKeyBlob: u32, ppbSignatureBlob: ?*?*u8, pcbSignatureBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureGeneration(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, pwzKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, pcbSignatureBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureGenerationEx(self: *const T, wszFilePath: ?[*:0]align(1) const u16, wszKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: ?*u8, cbKeyBlob: u32, ppbSignatureBlob: ?*?*u8, pcbSignatureBlob: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureGenerationEx(@as(*const ICLRStrongName, @ptrCast(self)), wszFilePath, wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, pcbSignatureBlob, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureSize(self: *const T, pbPublicKeyBlob: ?*u8, cbPublicKeyBlob: u32, pcbSize: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureSize(@as(*const ICLRStrongName, @ptrCast(self)), pbPublicKeyBlob, cbPublicKeyBlob, pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureVerification(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, dwInFlags: u32, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureVerification(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, dwInFlags, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureVerificationEx(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, fForceVerification: BOOLEAN, pfWasVerified: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureVerificationEx(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, fForceVerification, pfWasVerified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameSignatureVerificationFromImage(self: *const T, pbBase: ?*u8, dwLength: u32, dwInFlags: u32, pdwOutFlags: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameSignatureVerificationFromImage(@as(*const ICLRStrongName, @ptrCast(self)), pbBase, dwLength, dwInFlags, pdwOutFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameTokenFromAssembly(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, ppbStrongNameToken: ?*?*u8, pcbStrongNameToken: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameTokenFromAssembly(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, ppbStrongNameToken, pcbStrongNameToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameTokenFromAssemblyEx(self: *const T, pwzFilePath: ?[*:0]align(1) const u16, ppbStrongNameToken: ?*?*u8, pcbStrongNameToken: ?*u32, ppbPublicKeyBlob: ?*?*u8, pcbPublicKeyBlob: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameTokenFromAssemblyEx(@as(*const ICLRStrongName, @ptrCast(self)), pwzFilePath, ppbStrongNameToken, pcbStrongNameToken, ppbPublicKeyBlob, pcbPublicKeyBlob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName_StrongNameTokenFromPublicKey(self: *const T, pbPublicKeyBlob: ?*u8, cbPublicKeyBlob: u32, ppbStrongNameToken: ?*?*u8, pcbStrongNameToken: ?*u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName.VTable, @ptrCast(self.vtable)).StrongNameTokenFromPublicKey(@as(*const ICLRStrongName, @ptrCast(self)), pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRStrongName2_Value = Guid.initString("c22ed5c5-4b59-4975-90eb-85ea55c0069b");
pub const IID_ICLRStrongName2 = &IID_ICLRStrongName2_Value;
pub const ICLRStrongName2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrongNameGetPublicKeyEx: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName2,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
                uHashAlgId: u32,
                uReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName2,
                pwzKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: ?*u8,
                cbKeyBlob: u32,
                ppbPublicKeyBlob: ?*?*u8,
                pcbPublicKeyBlob: ?*u32,
                uHashAlgId: u32,
                uReserved: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameSignatureVerificationEx2: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName2,
                wszFilePath: ?[*:0]align(1) const u16,
                fForceVerification: BOOLEAN,
                pbEcmaPublicKey: ?*u8,
                cbEcmaPublicKey: u32,
                pfWasVerified: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName2,
                wszFilePath: ?[*:0]align(1) const u16,
                fForceVerification: BOOLEAN,
                pbEcmaPublicKey: ?*u8,
                cbEcmaPublicKey: u32,
                pfWasVerified: ?*u8,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName2_StrongNameGetPublicKeyEx(self: *const T, pwzKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: ?*u8, cbKeyBlob: u32, ppbPublicKeyBlob: ?*?*u8, pcbPublicKeyBlob: ?*u32, uHashAlgId: u32, uReserved: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName2.VTable, @ptrCast(self.vtable)).StrongNameGetPublicKeyEx(@as(*const ICLRStrongName2, @ptrCast(self)), pwzKeyContainer, pbKeyBlob, cbKeyBlob, ppbPublicKeyBlob, pcbPublicKeyBlob, uHashAlgId, uReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName2_StrongNameSignatureVerificationEx2(self: *const T, wszFilePath: ?[*:0]align(1) const u16, fForceVerification: BOOLEAN, pbEcmaPublicKey: ?*u8, cbEcmaPublicKey: u32, pfWasVerified: ?*u8) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName2.VTable, @ptrCast(self.vtable)).StrongNameSignatureVerificationEx2(@as(*const ICLRStrongName2, @ptrCast(self)), wszFilePath, fForceVerification, pbEcmaPublicKey, cbEcmaPublicKey, pfWasVerified);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICLRStrongName3_Value = Guid.initString("22c7089b-bbd3-414a-b698-210f263f1fed");
pub const IID_ICLRStrongName3 = &IID_ICLRStrongName3_Value;
pub const ICLRStrongName3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrongNameDigestGenerate: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName3,
                wszFilePath: ?[*:0]align(1) const u16,
                ppbDigestBlob: ?*?*u8,
                pcbDigestBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName3,
                wszFilePath: ?[*:0]align(1) const u16,
                ppbDigestBlob: ?*?*u8,
                pcbDigestBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameDigestSign: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName3,
                wszKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: [*:0]u8,
                cbKeyBlob: u32,
                pbDigestBlob: [*:0]u8,
                cbDigestBlob: u32,
                hashAlgId: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName3,
                wszKeyContainer: ?[*:0]align(1) const u16,
                pbKeyBlob: [*:0]u8,
                cbKeyBlob: u32,
                pbDigestBlob: [*:0]u8,
                cbDigestBlob: u32,
                hashAlgId: u32,
                ppbSignatureBlob: ?*?*u8,
                pcbSignatureBlob: ?*u32,
                dwFlags: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
        StrongNameDigestEmbed: switch (@import("builtin").zig_backend) {
            .stage1 => fn(
                self: *const ICLRStrongName3,
                wszFilePath: ?[*:0]align(1) const u16,
                pbSignatureBlob: [*:0]u8,
                cbSignatureBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
            else => *const fn(
                self: *const ICLRStrongName3,
                wszFilePath: ?[*:0]align(1) const u16,
                pbSignatureBlob: [*:0]u8,
                cbSignatureBlob: u32,
            ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        },
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName3_StrongNameDigestGenerate(self: *const T, wszFilePath: ?[*:0]align(1) const u16, ppbDigestBlob: ?*?*u8, pcbDigestBlob: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName3.VTable, @ptrCast(self.vtable)).StrongNameDigestGenerate(@as(*const ICLRStrongName3, @ptrCast(self)), wszFilePath, ppbDigestBlob, pcbDigestBlob, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName3_StrongNameDigestSign(self: *const T, wszKeyContainer: ?[*:0]align(1) const u16, pbKeyBlob: [*:0]u8, cbKeyBlob: u32, pbDigestBlob: [*:0]u8, cbDigestBlob: u32, hashAlgId: u32, ppbSignatureBlob: ?*?*u8, pcbSignatureBlob: ?*u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName3.VTable, @ptrCast(self.vtable)).StrongNameDigestSign(@as(*const ICLRStrongName3, @ptrCast(self)), wszKeyContainer, pbKeyBlob, cbKeyBlob, pbDigestBlob, cbDigestBlob, hashAlgId, ppbSignatureBlob, pcbSignatureBlob, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICLRStrongName3_StrongNameDigestEmbed(self: *const T, wszFilePath: ?[*:0]align(1) const u16, pbSignatureBlob: [*:0]u8, cbSignatureBlob: u32) callconv(.Inline) HRESULT {
            return @as(*const ICLRStrongName3.VTable, @ptrCast(self.vtable)).StrongNameDigestEmbed(@as(*const ICLRStrongName3, @ptrCast(self)), wszFilePath, pbSignatureBlob, cbSignatureBlob);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (27)
//--------------------------------------------------------------------------------
// this function is obselete
pub extern "mscoree" fn GetCORSystemDirectory(
    pbuffer: [*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetCORVersion(
    pbBuffer: [*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetFileVersion(
    szFilename: ?[*:0]align(1) const u16,
    szBuffer: ?[*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetCORRequiredVersion(
    pbuffer: [*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetRequestedRuntimeInfo(
    pExe: ?[*:0]align(1) const u16,
    pwszVersion: ?[*:0]align(1) const u16,
    pConfigurationFile: ?[*:0]align(1) const u16,
    startupFlags: u32,
    runtimeInfoFlags: u32,
    pDirectory: ?[*:0]u16,
    dwDirectory: u32,
    dwDirectoryLength: ?*u32,
    pVersion: ?[*:0]u16,
    cchBuffer: u32,
    dwlength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetRequestedRuntimeVersion(
    pExe: ?PWSTR,
    pVersion: [*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorBindToRuntimeHost(
    pwszVersion: ?[*:0]align(1) const u16,
    pwszBuildFlavor: ?[*:0]align(1) const u16,
    pwszHostConfigFile: ?[*:0]align(1) const u16,
    pReserved: ?*anyopaque,
    startupFlags: u32,
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorBindToRuntimeEx(
    pwszVersion: ?[*:0]align(1) const u16,
    pwszBuildFlavor: ?[*:0]align(1) const u16,
    startupFlags: u32,
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorBindToRuntimeByCfg(
    pCfgStream: ?*IStream,
    reserved: u32,
    startupFlags: u32,
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorBindToRuntime(
    pwszVersion: ?[*:0]align(1) const u16,
    pwszBuildFlavor: ?[*:0]align(1) const u16,
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorBindToCurrentRuntime(
    pwszFileName: ?[*:0]align(1) const u16,
    rclsid: ?*const Guid,
    riid: ?*const Guid,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn ClrCreateManagedInstance(
    pTypeName: ?[*:0]align(1) const u16,
    riid: ?*const Guid,
    ppObject: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorMarkThreadInThreadPool(
) callconv(@import("std").os.windows.WINAPI) void;

// this function is obselete
pub extern "mscoree" fn RunDll32ShimW(
    hwnd: ?HWND,
    hinst: ?HINSTANCE,
    lpszCmdLine: ?[*:0]align(1) const u16,
    nCmdShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn LoadLibraryShim(
    szDllName: ?[*:0]align(1) const u16,
    szVersion: ?[*:0]align(1) const u16,
    pvReserved: ?*anyopaque,
    phModDll: ?*HMODULE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CallFunctionShim(
    szDllName: ?[*:0]align(1) const u16,
    szFunctionName: ?[*:0]align(1) const u8,
    lpvArgument1: ?*anyopaque,
    lpvArgument2: ?*anyopaque,
    szVersion: ?[*:0]align(1) const u16,
    pvReserved: ?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetRealProcAddress(
    pwszProcName: ?[*:0]align(1) const u8,
    ppv: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CorExitProcess(
    exitCode: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// this function is obselete
pub extern "mscoree" fn LoadStringRC(
    iResouceID: u32,
    szBuffer: [*:0]u16,
    iMax: i32,
    bQuiet: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn LoadStringRCEx(
    lcid: u32,
    iResouceID: u32,
    szBuffer: [*:0]u16,
    iMax: i32,
    bQuiet: i32,
    pcwchUsed: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn LockClrVersion(
    hostCallback: ?FLockClrVersionCallback,
    pBeginHostSetup: ?*?FLockClrVersionCallback,
    pEndHostSetup: ?*?FLockClrVersionCallback,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn CreateDebuggingInterfaceFromVersion(
    iDebuggerVersion: i32,
    szDebuggeeVersion: ?[*:0]align(1) const u16,
    ppCordb: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// this function is obselete
pub extern "mscoree" fn GetVersionFromProcess(
    hProcess: ?HANDLE,
    pVersion: [*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mscoree" fn CorLaunchApplication(
    dwClickOnceHost: HOST_TYPE,
    pwzAppFullName: ?[*:0]align(1) const u16,
    dwManifestPaths: u32,
    ppwzManifestPaths: ?*const ?PWSTR,
    dwActivationData: u32,
    ppwzActivationData: ?*const ?PWSTR,
    lpProcessInformation: ?*PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mscoree" fn GetRequestedRuntimeVersionForCLSID(
    rclsid: ?*const Guid,
    pVersion: ?[*:0]u16,
    cchBuffer: u32,
    dwLength: ?*u32,
    dwResolutionFlags: CLSID_RESOLUTION_FLAGS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mscoree" fn GetCLRIdentityManager(
    riid: ?*const Guid,
    ppManager: ?*?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mscoree" fn CLRCreateInstance(
    clsid: ?*const Guid,
    riid: ?*const Guid,
    ppInterface: ?*?*anyopaque,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (21)
//--------------------------------------------------------------------------------
const Guid = @import("../../../zig.zig").Guid;
const ACL = @import("../../../windows/win32/security.zig").ACL;
const BOOL = @import("../../../windows/win32/foundation.zig").BOOL;
const BOOLEAN = @import("../../../windows/win32/foundation.zig").BOOLEAN;
const BSTR = @import("../../../windows/win32/foundation.zig").BSTR;
const EXCEPTION_POINTERS = @import("../../../windows/win32/system/diagnostics/debug.zig").EXCEPTION_POINTERS;
const HANDLE = @import("../../../windows/win32/foundation.zig").HANDLE;
const HINSTANCE = @import("../../../windows/win32/foundation.zig").HINSTANCE;
const HMODULE = @import("../../../windows/win32/foundation.zig").HMODULE;
const HRESULT = @import("../../../windows/win32/foundation.zig").HRESULT;
const HWND = @import("../../../windows/win32/foundation.zig").HWND;
const IEnumUnknown = @import("../../../windows/win32/system/com.zig").IEnumUnknown;
const IStream = @import("../../../windows/win32/system/com.zig").IStream;
const IUnknown = @import("../../../windows/win32/system/com.zig").IUnknown;
const LPOVERLAPPED_COMPLETION_ROUTINE = @import("../../../windows/win32/system/io.zig").LPOVERLAPPED_COMPLETION_ROUTINE;
const LPTHREAD_START_ROUTINE = @import("../../../windows/win32/system/threading.zig").LPTHREAD_START_ROUTINE;
const PROCESS_INFORMATION = @import("../../../windows/win32/system/threading.zig").PROCESS_INFORMATION;
const PSTR = @import("../../../windows/win32/foundation.zig").PSTR;
const PWSTR = @import("../../../windows/win32/foundation.zig").PWSTR;
const VARIANT = @import("../../../windows/win32/system/variant.zig").VARIANT;
const WAITORTIMERCALLBACK = @import("../../../windows/win32/system/threading.zig").WAITORTIMERCALLBACK;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "FLockClrVersionCallback")) { _ = FLockClrVersionCallback; }
    if (@hasDecl(@This(), "FExecuteInAppDomainCallback")) { _ = FExecuteInAppDomainCallback; }
    if (@hasDecl(@This(), "PTLS_CALLBACK_FUNCTION")) { _ = PTLS_CALLBACK_FUNCTION; }
    if (@hasDecl(@This(), "CLRCreateInstanceFnPtr")) { _ = CLRCreateInstanceFnPtr; }
    if (@hasDecl(@This(), "CreateInterfaceFnPtr")) { _ = CreateInterfaceFnPtr; }
    if (@hasDecl(@This(), "CallbackThreadSetFnPtr")) { _ = CallbackThreadSetFnPtr; }
    if (@hasDecl(@This(), "CallbackThreadUnsetFnPtr")) { _ = CallbackThreadUnsetFnPtr; }
    if (@hasDecl(@This(), "RuntimeLoadedCallbackFnPtr")) { _ = RuntimeLoadedCallbackFnPtr; }

    @setEvalBranchQuota(
        comptime @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (comptime @import("std").meta.declarations(@This())) |decl| {
        _ = @field(@This(), decl.name);
    }
}
